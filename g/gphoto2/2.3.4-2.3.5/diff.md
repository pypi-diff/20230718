# Comparing `tmp/gphoto2-2.3.4.tar.gz` & `tmp/gphoto2-2.3.5.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "dist/gphoto2-2.3.4.tar", last modified: Wed Jul  6 07:44:35 2022, max compression
+gzip compressed data, was "/home/jim/Documents/projects/python-gphoto2/master/dist/tmpb4emoa77/gphoto2-2.3.5.tar", last modified: Sat Jul  8 13:48:49 2023, max compression
```

## Comparing `gphoto2-2.3.4.tar` & `gphoto2-2.3.5.tar`

### file list

```diff
@@ -1,89 +1,68 @@
-drwxr-xr-x   0 jim       (1026) users      (100)        0 2022-07-06 07:44:35.000000 gphoto2-2.3.4/
--rw-r--r--   0 jim       (1026) users      (100)    35120 2014-03-25 11:35:22.000000 gphoto2-2.3.4/LICENSE.txt
--rw-r--r--   0 jim       (1026) users      (100)      118 2022-01-03 13:44:56.000000 gphoto2-2.3.4/MANIFEST.in
--rw-r--r--   0 jim       (1026) users      (100)    22994 2022-07-06 07:44:35.000000 gphoto2-2.3.4/PKG-INFO
--rw-r--r--   0 jim       (1026) users      (100)    22051 2022-07-06 07:13:45.000000 gphoto2-2.3.4/README.rst
-drwxr-xr-x   0 jim       (1026) users      (100)        0 2022-07-06 07:44:35.000000 gphoto2-2.3.4/developer/
--rw-r--r--   0 jim       (1026) users      (100)   106562 2021-11-20 10:36:33.000000 gphoto2-2.3.4/developer/Doxyfile
--rw-r--r--   0 jim       (1026) users      (100)     3822 2022-07-06 07:13:18.000000 gphoto2-2.3.4/developer/README.txt
--rw-r--r--   0 jim       (1026) users      (100)     3608 2022-04-21 09:31:30.000000 gphoto2-2.3.4/developer/build_doc.py
--rw-r--r--   0 jim       (1026) users      (100)     4710 2022-05-21 10:51:18.000000 gphoto2-2.3.4/developer/build_swig.py
--rw-r--r--   0 jim       (1026) users      (100)     2095 2021-09-27 11:18:13.000000 gphoto2-2.3.4/developer/compare_versions.py
--rw-r--r--   0 jim       (1026) users      (100)     1650 2021-08-05 13:44:56.000000 gphoto2-2.3.4/developer/tag_release.py
-drwxr-xr-x   0 jim       (1026) users      (100)        0 2022-07-06 07:44:35.000000 gphoto2-2.3.4/examples/
--rw-r--r--   0 jim       (1026) users      (100)      365 2019-08-13 10:17:38.000000 gphoto2-2.3.4/examples/README.rst
--rw-r--r--   0 jim       (1026) users      (100)    55276 2022-05-20 14:34:24.000000 gphoto2-2.3.4/examples/cam-conf-view-gui.py
--rw-r--r--   0 jim       (1026) users      (100)    10661 2022-05-20 14:41:12.000000 gphoto2-2.3.4/examples/camera-config-gui.py
--rwxr-xr-x   0 jim       (1026) users      (100)     1566 2022-05-21 10:28:31.000000 gphoto2-2.3.4/examples/camera-summary.py
--rwxr-xr-x   0 jim       (1026) users      (100)     1679 2022-05-20 14:40:44.000000 gphoto2-2.3.4/examples/capture-image.py
--rwxr-xr-x   0 jim       (1026) users      (100)     3080 2022-05-20 14:32:58.000000 gphoto2-2.3.4/examples/choose-camera.py
--rwxr-xr-x   0 jim       (1026) users      (100)     3809 2022-05-20 14:40:19.000000 gphoto2-2.3.4/examples/clear-space.py
--rwxr-xr-x   0 jim       (1026) users      (100)     4176 2022-05-20 14:32:32.000000 gphoto2-2.3.4/examples/context_with_callbacks.py
--rwxr-xr-x   0 jim       (1026) users      (100)     2695 2022-05-20 14:39:54.000000 gphoto2-2.3.4/examples/copy-chunks.py
--rwxr-xr-x   0 jim       (1026) users      (100)     2999 2022-05-20 14:31:58.000000 gphoto2-2.3.4/examples/copy-data.py
--rwxr-xr-x   0 jim       (1026) users      (100)     3576 2022-05-20 14:39:27.000000 gphoto2-2.3.4/examples/copy-files.py
--rwxr-xr-x   0 jim       (1026) users      (100)     2356 2022-05-20 14:31:14.000000 gphoto2-2.3.4/examples/error_handling.py
--rwxr-xr-x   0 jim       (1026) users      (100)    14384 2022-05-20 14:30:44.000000 gphoto2-2.3.4/examples/focus-gui.py
--rwxr-xr-x   0 jim       (1026) users      (100)     2759 2022-05-20 14:29:41.000000 gphoto2-2.3.4/examples/get-camera-clock.py
--rwxr-xr-x   0 jim       (1026) users      (100)     1974 2022-05-20 14:38:54.000000 gphoto2-2.3.4/examples/get-capture-target.py
--rw-r--r--   0 jim       (1026) users      (100)     1206 2020-12-15 12:17:10.000000 gphoto2-2.3.4/examples/gphoto2_version.py
--rwxr-xr-x   0 jim       (1026) users      (100)     1424 2022-05-20 14:38:29.000000 gphoto2-2.3.4/examples/list-cameras.py
--rwxr-xr-x   0 jim       (1026) users      (100)     2368 2022-05-20 14:28:49.000000 gphoto2-2.3.4/examples/list-files.py
--rwxr-xr-x   0 jim       (1026) users      (100)     1686 2022-05-20 14:38:02.000000 gphoto2-2.3.4/examples/log_events.py
--rwxr-xr-x   0 jim       (1026) users      (100)     2920 2022-05-20 14:37:40.000000 gphoto2-2.3.4/examples/preview-image.py
--rwxr-xr-x   0 jim       (1026) users      (100)     3791 2022-05-20 14:37:20.000000 gphoto2-2.3.4/examples/read-exif-exifread.py
--rwxr-xr-x   0 jim       (1026) users      (100)     3824 2022-05-20 14:36:53.000000 gphoto2-2.3.4/examples/read-exif-gexiv2.py
--rwxr-xr-x   0 jim       (1026) users      (100)     2490 2022-05-20 14:36:27.000000 gphoto2-2.3.4/examples/set-camera-clock.py
--rw-r--r--   0 jim       (1026) users      (100)     2279 2022-05-20 14:36:00.000000 gphoto2-2.3.4/examples/set-capture-target.py
--rwxr-xr-x   0 jim       (1026) users      (100)     3668 2022-05-20 14:35:38.000000 gphoto2-2.3.4/examples/time_lapse.py
--rw-r--r--   0 jim       (1026) users      (100)     2022 2022-05-20 14:34:48.000000 gphoto2-2.3.4/examples/wait-for-event.py
-drwxr-xr-x   0 jim       (1026) users      (100)        0 2022-07-06 07:44:35.000000 gphoto2-2.3.4/gphoto2.egg-info/
--rw-r--r--   0 jim       (1026) users      (100)    22994 2022-07-06 07:44:34.000000 gphoto2-2.3.4/gphoto2.egg-info/PKG-INFO
--rw-r--r--   0 jim       (1026) users      (100)     2114 2022-07-06 07:44:34.000000 gphoto2-2.3.4/gphoto2.egg-info/SOURCES.txt
--rw-r--r--   0 jim       (1026) users      (100)        1 2022-07-06 07:44:34.000000 gphoto2-2.3.4/gphoto2.egg-info/dependency_links.txt
--rw-r--r--   0 jim       (1026) users      (100)        1 2022-07-06 07:44:34.000000 gphoto2-2.3.4/gphoto2.egg-info/not-zip-safe
--rw-r--r--   0 jim       (1026) users      (100)      113 2022-07-06 07:44:34.000000 gphoto2-2.3.4/gphoto2.egg-info/top_level.txt
--rw-r--r--   0 jim       (1026) users      (100)       38 2022-07-06 07:44:35.000000 gphoto2-2.3.4/setup.cfg
--rw-r--r--   0 jim       (1026) users      (100)     7303 2022-05-20 13:56:43.000000 gphoto2-2.3.4/setup.py
-drwxr-xr-x   0 jim       (1026) users      (100)        0 2022-07-06 07:44:35.000000 gphoto2-2.3.4/src/
-drwxr-xr-x   0 jim       (1026) users      (100)        0 2022-07-06 07:44:35.000000 gphoto2-2.3.4/src/gphoto2/
--rw-r--r--   0 jim       (1026) users      (100)     1238 2021-11-24 08:55:59.000000 gphoto2-2.3.4/src/gphoto2/__main__.py
--rw-r--r--   0 jim       (1026) users      (100)     4413 2022-07-06 07:23:19.000000 gphoto2-2.3.4/src/gphoto2/abilities_list.i
--rw-r--r--   0 jim       (1026) users      (100)    13000 2022-05-21 10:37:42.000000 gphoto2-2.3.4/src/gphoto2/camera.i
-drwxr-xr-x   0 jim       (1026) users      (100)        0 2022-07-06 07:44:35.000000 gphoto2-2.3.4/src/gphoto2/common/
--rw-r--r--   0 jim       (1026) users      (100)     3674 2021-04-20 14:01:19.000000 gphoto2-2.3.4/src/gphoto2/common/macros.i
--rw-r--r--   0 jim       (1026) users      (100)     2313 2021-08-05 07:20:25.000000 gphoto2-2.3.4/src/gphoto2/common/preamble.i
--rw-r--r--   0 jim       (1026) users      (100)    11062 2021-09-29 08:42:26.000000 gphoto2-2.3.4/src/gphoto2/context.i
--rw-r--r--   0 jim       (1026) users      (100)     9211 2021-08-05 10:54:50.000000 gphoto2-2.3.4/src/gphoto2/file.i
--rw-r--r--   0 jim       (1026) users      (100)     2144 2022-01-03 13:21:00.000000 gphoto2-2.3.4/src/gphoto2/filesys.i
--rw-r--r--   0 jim       (1026) users      (100)     3967 2021-04-20 14:02:41.000000 gphoto2-2.3.4/src/gphoto2/list.i
--rw-r--r--   0 jim       (1026) users      (100)     4337 2022-07-06 07:22:17.000000 gphoto2-2.3.4/src/gphoto2/port_info_list.i
--rw-r--r--   0 jim       (1026) users      (100)     6032 2021-09-29 09:40:50.000000 gphoto2-2.3.4/src/gphoto2/port_log.i
--rw-r--r--   0 jim       (1026) users      (100)     2266 2021-04-20 11:53:39.000000 gphoto2-2.3.4/src/gphoto2/result.i
--rw-r--r--   0 jim       (1026) users      (100)     1445 2020-02-05 12:11:17.000000 gphoto2-2.3.4/src/gphoto2/version.i
--rw-r--r--   0 jim       (1026) users      (100)    13382 2021-04-27 09:43:27.000000 gphoto2-2.3.4/src/gphoto2/widget.i
-drwxr-xr-x   0 jim       (1026) users      (100)        0 2022-07-06 07:44:35.000000 gphoto2-2.3.4/src/swig-gp2.5.30/
--rw-r--r--   0 jim       (1026) users      (100)     1140 2022-07-06 07:20:14.000000 gphoto2-2.3.4/src/swig-gp2.5.30/__init__.py
--rw-r--r--   0 jim       (1026) users      (100)     1238 2021-11-24 08:55:59.000000 gphoto2-2.3.4/src/swig-gp2.5.30/__main__.py
--rw-r--r--   0 jim       (1026) users      (100)     2355 2022-07-06 07:20:11.000000 gphoto2-2.3.4/src/swig-gp2.5.30/abilities_list.py
--rw-r--r--   0 jim       (1026) users      (100)   260922 2022-07-06 07:20:11.000000 gphoto2-2.3.4/src/swig-gp2.5.30/abilities_list_wrap.c
--rw-r--r--   0 jim       (1026) users      (100)     2348 2022-07-06 07:20:12.000000 gphoto2-2.3.4/src/swig-gp2.5.30/camera.py
--rw-r--r--   0 jim       (1026) users      (100)   426586 2022-07-06 07:20:12.000000 gphoto2-2.3.4/src/swig-gp2.5.30/camera_wrap.c
--rw-r--r--   0 jim       (1026) users      (100)     2348 2022-07-06 07:20:12.000000 gphoto2-2.3.4/src/swig-gp2.5.30/context.py
--rw-r--r--   0 jim       (1026) users      (100)   237907 2022-07-06 07:20:12.000000 gphoto2-2.3.4/src/swig-gp2.5.30/context_wrap.c
--rw-r--r--   0 jim       (1026) users      (100)     2344 2022-07-06 07:20:12.000000 gphoto2-2.3.4/src/swig-gp2.5.30/file.py
--rw-r--r--   0 jim       (1026) users      (100)   250721 2022-07-06 07:20:12.000000 gphoto2-2.3.4/src/swig-gp2.5.30/file_wrap.c
--rw-r--r--   0 jim       (1026) users      (100)     2353 2022-07-06 07:20:12.000000 gphoto2-2.3.4/src/swig-gp2.5.30/filesys.py
--rw-r--r--   0 jim       (1026) users      (100)   401700 2022-07-06 07:20:12.000000 gphoto2-2.3.4/src/swig-gp2.5.30/filesys_wrap.c
--rw-r--r--   0 jim       (1026) users      (100)     2344 2022-07-06 07:20:13.000000 gphoto2-2.3.4/src/swig-gp2.5.30/list.py
--rw-r--r--   0 jim       (1026) users      (100)   220593 2022-07-06 07:20:13.000000 gphoto2-2.3.4/src/swig-gp2.5.30/list_wrap.c
--rw-r--r--   0 jim       (1026) users      (100)     2355 2022-07-06 07:20:13.000000 gphoto2-2.3.4/src/swig-gp2.5.30/port_info_list.py
--rw-r--r--   0 jim       (1026) users      (100)   236814 2022-07-06 07:20:13.000000 gphoto2-2.3.4/src/swig-gp2.5.30/port_info_list_wrap.c
--rw-r--r--   0 jim       (1026) users      (100)     3960 2022-07-06 07:20:13.000000 gphoto2-2.3.4/src/swig-gp2.5.30/port_log.py
--rw-r--r--   0 jim       (1026) users      (100)   179390 2022-07-06 07:20:13.000000 gphoto2-2.3.4/src/swig-gp2.5.30/port_log_wrap.c
--rw-r--r--   0 jim       (1026) users      (100)     3578 2022-07-06 07:20:13.000000 gphoto2-2.3.4/src/swig-gp2.5.30/result.py
--rw-r--r--   0 jim       (1026) users      (100)   162932 2022-07-06 07:20:13.000000 gphoto2-2.3.4/src/swig-gp2.5.30/result_wrap.c
--rw-r--r--   0 jim       (1026) users      (100)     2346 2022-07-06 07:20:13.000000 gphoto2-2.3.4/src/swig-gp2.5.30/version.py
--rw-r--r--   0 jim       (1026) users      (100)   157251 2022-07-06 07:20:13.000000 gphoto2-2.3.4/src/swig-gp2.5.30/version_wrap.c
--rw-r--r--   0 jim       (1026) users      (100)     2348 2022-07-06 07:20:14.000000 gphoto2-2.3.4/src/swig-gp2.5.30/widget.py
--rw-r--r--   0 jim       (1026) users      (100)   337915 2022-07-06 07:20:14.000000 gphoto2-2.3.4/src/swig-gp2.5.30/widget_wrap.c
+drwxr-xr-x   0 jim       (1026) users      (100)        0 2023-07-08 13:48:49.000000 gphoto2-2.3.5/
+-rw-r--r--   0 jim       (1026) users      (100)     8695 2023-07-08 12:32:38.000000 gphoto2-2.3.5/INSTALL.rst
+-rw-r--r--   0 jim       (1026) users      (100)    35120 2014-03-25 11:35:22.000000 gphoto2-2.3.5/LICENSE.txt
+-rw-r--r--   0 jim       (1026) users      (100)      149 2023-07-07 14:38:47.000000 gphoto2-2.3.5/MANIFEST.in
+-rw-r--r--   0 jim       (1026) users      (100)    17069 2023-07-08 13:48:49.000000 gphoto2-2.3.5/PKG-INFO
+-rw-r--r--   0 jim       (1026) users      (100)    16126 2023-04-24 10:02:00.000000 gphoto2-2.3.5/README.rst
+drwxr-xr-x   0 jim       (1026) users      (100)        0 2023-07-08 13:48:49.000000 gphoto2-2.3.5/examples/
+-rw-r--r--   0 jim       (1026) users      (100)      365 2019-08-13 10:17:38.000000 gphoto2-2.3.5/examples/README.rst
+-rw-r--r--   0 jim       (1026) users      (100)    55276 2022-05-20 14:34:24.000000 gphoto2-2.3.5/examples/cam-conf-view-gui.py
+-rw-r--r--   0 jim       (1026) users      (100)    10661 2022-05-20 14:41:12.000000 gphoto2-2.3.5/examples/camera-config-gui.py
+-rwxr-xr-x   0 jim       (1026) users      (100)     1566 2022-05-21 10:28:31.000000 gphoto2-2.3.5/examples/camera-summary.py
+-rwxr-xr-x   0 jim       (1026) users      (100)     1679 2022-05-20 14:40:44.000000 gphoto2-2.3.5/examples/capture-image.py
+-rwxr-xr-x   0 jim       (1026) users      (100)     3080 2022-05-20 14:32:58.000000 gphoto2-2.3.5/examples/choose-camera.py
+-rwxr-xr-x   0 jim       (1026) users      (100)     3809 2022-05-20 14:40:19.000000 gphoto2-2.3.5/examples/clear-space.py
+-rwxr-xr-x   0 jim       (1026) users      (100)     4176 2022-05-20 14:32:32.000000 gphoto2-2.3.5/examples/context_with_callbacks.py
+-rwxr-xr-x   0 jim       (1026) users      (100)     2695 2022-05-20 14:39:54.000000 gphoto2-2.3.5/examples/copy-chunks.py
+-rwxr-xr-x   0 jim       (1026) users      (100)     2999 2022-05-20 14:31:58.000000 gphoto2-2.3.5/examples/copy-data.py
+-rwxr-xr-x   0 jim       (1026) users      (100)     3576 2022-05-20 14:39:27.000000 gphoto2-2.3.5/examples/copy-files.py
+-rwxr-xr-x   0 jim       (1026) users      (100)     2356 2022-05-20 14:31:14.000000 gphoto2-2.3.5/examples/error_handling.py
+-rwxr-xr-x   0 jim       (1026) users      (100)    14384 2022-05-20 14:30:44.000000 gphoto2-2.3.5/examples/focus-gui.py
+-rwxr-xr-x   0 jim       (1026) users      (100)     2759 2022-05-20 14:29:41.000000 gphoto2-2.3.5/examples/get-camera-clock.py
+-rwxr-xr-x   0 jim       (1026) users      (100)     1974 2022-05-20 14:38:54.000000 gphoto2-2.3.5/examples/get-capture-target.py
+-rw-r--r--   0 jim       (1026) users      (100)     1206 2020-12-15 12:17:10.000000 gphoto2-2.3.5/examples/gphoto2_version.py
+-rwxr-xr-x   0 jim       (1026) users      (100)     1424 2022-05-20 14:38:29.000000 gphoto2-2.3.5/examples/list-cameras.py
+-rwxr-xr-x   0 jim       (1026) users      (100)     2368 2022-05-20 14:28:49.000000 gphoto2-2.3.5/examples/list-files.py
+-rwxr-xr-x   0 jim       (1026) users      (100)     1686 2022-05-20 14:38:02.000000 gphoto2-2.3.5/examples/log_events.py
+-rwxr-xr-x   0 jim       (1026) users      (100)     2920 2022-05-20 14:37:40.000000 gphoto2-2.3.5/examples/preview-image.py
+-rwxr-xr-x   0 jim       (1026) users      (100)     3791 2022-05-20 14:37:20.000000 gphoto2-2.3.5/examples/read-exif-exifread.py
+-rwxr-xr-x   0 jim       (1026) users      (100)     3824 2022-05-20 14:36:53.000000 gphoto2-2.3.5/examples/read-exif-gexiv2.py
+-rwxr-xr-x   0 jim       (1026) users      (100)     2490 2022-05-20 14:36:27.000000 gphoto2-2.3.5/examples/set-camera-clock.py
+-rw-r--r--   0 jim       (1026) users      (100)     2279 2022-05-20 14:36:00.000000 gphoto2-2.3.5/examples/set-capture-target.py
+-rwxr-xr-x   0 jim       (1026) users      (100)     3668 2022-05-20 14:35:38.000000 gphoto2-2.3.5/examples/time_lapse.py
+-rw-r--r--   0 jim       (1026) users      (100)     2263 2022-08-29 13:56:01.000000 gphoto2-2.3.5/examples/wait-for-event.py
+drwxr-xr-x   0 jim       (1026) users      (100)        0 2023-07-08 13:48:49.000000 gphoto2-2.3.5/gphoto2.egg-info/
+-rw-r--r--   0 jim       (1026) users      (100)    17069 2023-07-08 13:48:49.000000 gphoto2-2.3.5/gphoto2.egg-info/PKG-INFO
+-rw-r--r--   0 jim       (1026) users      (100)     1669 2023-07-08 13:48:49.000000 gphoto2-2.3.5/gphoto2.egg-info/SOURCES.txt
+-rw-r--r--   0 jim       (1026) users      (100)        1 2023-07-08 13:48:49.000000 gphoto2-2.3.5/gphoto2.egg-info/dependency_links.txt
+-rw-r--r--   0 jim       (1026) users      (100)        1 2023-07-08 13:48:49.000000 gphoto2-2.3.5/gphoto2.egg-info/not-zip-safe
+-rw-r--r--   0 jim       (1026) users      (100)      113 2023-07-08 13:48:49.000000 gphoto2-2.3.5/gphoto2.egg-info/top_level.txt
+-rw-r--r--   0 jim       (1026) users      (100)     2142 2023-07-06 15:34:26.000000 gphoto2-2.3.5/pyproject.toml
+-rw-r--r--   0 jim       (1026) users      (100)       38 2023-07-08 13:48:49.000000 gphoto2-2.3.5/setup.cfg
+-rw-r--r--   0 jim       (1026) users      (100)     7525 2023-07-08 10:53:46.000000 gphoto2-2.3.5/setup.py
+drwxr-xr-x   0 jim       (1026) users      (100)        0 2023-07-08 13:48:49.000000 gphoto2-2.3.5/src/
+drwxr-xr-x   0 jim       (1026) users      (100)        0 2023-07-08 13:48:49.000000 gphoto2-2.3.5/src/swig-gp2_5_30/
+-rw-r--r--   0 jim       (1026) users      (100)     1140 2023-07-08 10:59:39.000000 gphoto2-2.3.5/src/swig-gp2_5_30/__init__.py
+-rw-r--r--   0 jim       (1026) users      (100)     1273 2023-04-22 10:26:41.000000 gphoto2-2.3.5/src/swig-gp2_5_30/__main__.py
+-rw-r--r--   0 jim       (1026) users      (100)      664 2023-07-08 10:59:37.000000 gphoto2-2.3.5/src/swig-gp2_5_30/abilities_list.py
+-rw-r--r--   0 jim       (1026) users      (100)   255424 2023-07-08 10:59:37.000000 gphoto2-2.3.5/src/swig-gp2_5_30/abilities_list_wrap.c
+-rw-r--r--   0 jim       (1026) users      (100)      656 2023-07-08 10:59:37.000000 gphoto2-2.3.5/src/swig-gp2_5_30/camera.py
+-rw-r--r--   0 jim       (1026) users      (100)   399081 2023-07-08 10:59:37.000000 gphoto2-2.3.5/src/swig-gp2_5_30/camera_wrap.c
+-rw-r--r--   0 jim       (1026) users      (100)      657 2023-07-08 10:59:37.000000 gphoto2-2.3.5/src/swig-gp2_5_30/context.py
+-rw-r--r--   0 jim       (1026) users      (100)   236771 2023-07-08 10:59:37.000000 gphoto2-2.3.5/src/swig-gp2_5_30/context_wrap.c
+-rw-r--r--   0 jim       (1026) users      (100)      654 2023-07-08 10:59:37.000000 gphoto2-2.3.5/src/swig-gp2_5_30/file.py
+-rw-r--r--   0 jim       (1026) users      (100)   238048 2023-07-08 10:59:37.000000 gphoto2-2.3.5/src/swig-gp2_5_30/file_wrap.c
+-rw-r--r--   0 jim       (1026) users      (100)      657 2023-07-08 10:59:38.000000 gphoto2-2.3.5/src/swig-gp2_5_30/filesys.py
+-rw-r--r--   0 jim       (1026) users      (100)   387488 2023-07-08 10:59:38.000000 gphoto2-2.3.5/src/swig-gp2_5_30/filesys_wrap.c
+-rw-r--r--   0 jim       (1026) users      (100)      654 2023-07-08 10:59:38.000000 gphoto2-2.3.5/src/swig-gp2_5_30/list.py
+-rw-r--r--   0 jim       (1026) users      (100)   215552 2023-07-08 10:59:38.000000 gphoto2-2.3.5/src/swig-gp2_5_30/list_wrap.c
+-rw-r--r--   0 jim       (1026) users      (100)      664 2023-07-08 10:59:38.000000 gphoto2-2.3.5/src/swig-gp2_5_30/port_info_list.py
+-rw-r--r--   0 jim       (1026) users      (100)   229687 2023-07-08 10:59:38.000000 gphoto2-2.3.5/src/swig-gp2_5_30/port_info_list_wrap.c
+-rw-r--r--   0 jim       (1026) users      (100)     2272 2023-07-08 10:59:38.000000 gphoto2-2.3.5/src/swig-gp2_5_30/port_log.py
+-rw-r--r--   0 jim       (1026) users      (100)   178458 2023-07-08 10:59:38.000000 gphoto2-2.3.5/src/swig-gp2_5_30/port_log_wrap.c
+-rw-r--r--   0 jim       (1026) users      (100)     1891 2023-07-08 10:59:39.000000 gphoto2-2.3.5/src/swig-gp2_5_30/result.py
+-rw-r--r--   0 jim       (1026) users      (100)   161853 2023-07-08 10:59:39.000000 gphoto2-2.3.5/src/swig-gp2_5_30/result_wrap.c
+-rw-r--r--   0 jim       (1026) users      (100)      657 2023-07-08 10:59:39.000000 gphoto2-2.3.5/src/swig-gp2_5_30/version.py
+-rw-r--r--   0 jim       (1026) users      (100)   156906 2023-07-08 10:59:39.000000 gphoto2-2.3.5/src/swig-gp2_5_30/version_wrap.c
+-rw-r--r--   0 jim       (1026) users      (100)      656 2023-07-08 10:59:39.000000 gphoto2-2.3.5/src/swig-gp2_5_30/widget.py
+-rw-r--r--   0 jim       (1026) users      (100)   323914 2023-07-08 10:59:39.000000 gphoto2-2.3.5/src/swig-gp2_5_30/widget_wrap.c
```

### Comparing `gphoto2-2.3.4/LICENSE.txt` & `gphoto2-2.3.5/LICENSE.txt`

 * *Files identical despite different names*

### Comparing `gphoto2-2.3.4/PKG-INFO` & `gphoto2-2.3.5/PKG-INFO`

 * *Files 15% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: gphoto2
-Version: 2.3.4
+Version: 2.3.5
 Summary: Python interface to libgphoto2
 Home-page: https://github.com/jim-easterbrook/python-gphoto2
 Author: Jim Easterbrook
 Author-email: jim@jim-easterbrook.me.uk
 License: GNU GPL
 Platform: POSIX
 Platform: MacOS
@@ -19,152 +19,50 @@
 Classifier: Operating System :: POSIX :: Linux
 Classifier: Programming Language :: Python :: 3
 Classifier: Topic :: Multimedia
 Classifier: Topic :: Multimedia :: Graphics
 Classifier: Topic :: Multimedia :: Graphics :: Capture
 License-File: LICENSE.txt
 
-python-gphoto2 v\ 2.3.4
+python-gphoto2 v\ 2.3.5
 =======================
 
 python-gphoto2 is a comprehensive Python interface (or binding) to libgphoto2_.
 It is built using SWIG_ to automatically generate the interface code.
 This gives direct access to nearly all the libgphoto2 functions_, but sometimes in a rather un-Pythonic manner.
 
 Other Python bindings to libgphoto2_ are available:
 piggyphoto_ uses ctypes_ (included in standard Python installations) to interface to the library.
 The gphoto2 source tree includes some `Python bindings`_ which also use ctypes_.
 `gphoto2-cffi`_ uses cffi_.
 
 .. contents::
    :backlinks: top
 
-Installation (binary wheel)
----------------------------
+Installation
+------------
 
 Since python-gphoto2 version 2.3.1 "binary wheels" are provided for many Linux and MacOS computers.
 These include a recent version of the libgphoto2_ libraries, and pre-built Python interface modules, which makes installation quick and easy.
 Use pip_'s ``--only-binary`` option to install one of these wheels::
 
-    sudo pip3 install gphoto2 --only-binary :all:
+    $ pip3 install gphoto2 --user --only-binary :all:
 
 If this fails it is most likely because none of the available wheels is compatible with your computer.
-In this case you *must* install the dependencies listed below before installing python-gphoto2.
-The installation process compiles and links the bindings with the libgphoto2_ installed on your computer.
+In this case you *must* install some dependencies before installing python-gphoto2.
+See `<INSTALL.rst>`_ for more details.
 
 Raspberry Pi
 ^^^^^^^^^^^^
 
 Binary wheels for the Raspberry Pi are available from piwheels_.
-You still need to install some system packages to use these::
-
-    sudo apt install libexif12 libgphoto2-6 libgphoto2-port12 libltdl7
-    sudo pip3 install gphoto2
-
-Dependencies
-------------
-
-*   Python: http://python.org/ version 3.5 or greater
-*   libgphoto2: http://www.gphoto.org/proj/libgphoto2/ version 2.5.0 or greater
-*   build tools: pkg-config, C compiler & linker
-
-In most cases you should use your operating system's package manager to install these.
-Note that you need the "development headers" for libgphoto2_ and Python.
-On some systems these are included in the base package, but on others they need to be installed separately.
-Look for ``libgphoto2-dev`` or ``libgphoto2-devel`` or something similar.
-Test your installation with the command ``pkg-config --cflags --libs libgphoto2 python3``.
-
-Installation (source)
----------------------
-
-There are several ways to install python-gphoto2, with varying levels of control over the installation process.
-By far the easiest is to use your operating system's package manager, if you're lucky enough to be using a system that has python-gphoto2 available.
-Note that this may not install the latest version.
-
-Otherwise you can install it with pip_, or by downloading an archive, or by getting the source from GitHub_.
-Make sure that you install the dependencies_ first.
-
-Install with pip_
-^^^^^^^^^^^^^^^^^
-
-The easiest installation method is to use the pip_ command.
-Note the use of ``--no-binary`` to prevent installation from a binary wheel::
-
-    sudo pip3 install -v gphoto2 --no-binary :all:
-
-This installation may take longer than you expect as the package's modules are compiled during installation.
-The ``-v`` option increases pip_'s verbosity so you can see that it's doing something.
-
-Install a downloaded archive
-^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-
-Visit PyPI_ and download one of the zip or tar.gz files, then extract it and change to the new directory.
-For example::
-
-    tar xf gphoto2-2.3.0.tar.gz
-    cd gphoto2-2.3.0
-
-Python's setuptools_ are used to build and install python-gphoto2::
-
-    pip3 wheel . -v
-    sudo pip3 install gphoto2-*.whl
-
-Install from GitHub_ (SWIG_ required)
-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-
-SWIG (http://swig.org/) should be installable via your operating system's package manager.
-Note that this may be an older version of SWIG than the one used to generate the files on PyPI_.
-
-To install the current development version, use git_ to "clone" the GitHub_ repository, then change to the new directory::
-
-    git clone https://github.com/jim-easterbrook/python-gphoto2.git
-    cd python-gphoto2
-
-As before, Python's setuptools_ are used to build and install python-gphoto2, but now you have to run SWIG_ first to generate the files to be compiled.
-The ``developer`` directory includes a script to run SWIG::
+You need to install some system packages to use these::
 
-    python3 developer/build_swig.py system
-    pip3 wheel . -v
-    sudo pip3 install gphoto2-*.whl
-
-See "`running SWIG`_" below for more detail.
-
-Testing
--------
-
-Since version 2.3.1 you can test your installation of python-gphoto2 by running it with the ``python3 -m gphoto2`` command::
-
-    python3 -m gphoto2
-    python-gphoto2 version: 2.3.1
-    libgphoto2 version: ['2.5.27', 'standard camlibs (SKIPPING docupen)', 'gcc', 'ltdl', 'EXIF']
-    libgphoto2_port version: ['0.12.0', 'iolibs: disk ptpip serial usb1 usbdiskdirect usbscsi vusb', 'gcc', 'ltdl', 'EXIF', 'USB', 'serial without locking']
-    python-gphoto2 examples: /usr/lib64/python3.6/site-packages/gphoto2/examples
-
-This shows the python-gphoto2 and libgphoto2 version numbers, and where the example programs have been installed.
-Connect a digital camera to your computer, switch it on, and try one of the example programs::
-
-    python3 /usr/lib64/python3.6/site-packages/gphoto2/examples/camera-summary.py
-
-If this works then you're ready to start using python-gphoto2.
-
-Reinstalling
-^^^^^^^^^^^^
-
-If you update or move your installation of libgphoto2_ the Python gphoto2 package may fail to import one of the libgphoto2 shared object files.
-If this happens you need to rebuild and reinstall the Python gphoto2 package::
-
-    sudo pip3 install -v -U --force-reinstall gphoto2
-
-if you installed with pip_, or ::
-
-    rm -rf build
-    pip3 wheel . -v
-    sudo pip3 install --force-reinstall gphoto2-*.whl
-
-if you installed from source.
+    $ sudo apt install libexif12 libgphoto2-6 libgphoto2-port12 libltdl7
+    $ pip3 install gphoto2 --user
 
 Using python-gphoto2
 --------------------
 
 The Python interface to libgphoto2_ should allow you to do anything you could do in a C program.
 However, there are still bits missing and functions that cannot be called from Python.
 Let me know if you run into any problems.
@@ -177,15 +75,15 @@
 
 These functions are as similar as possible to their libgphoto2_ equivalents.
 Most of them return an error code which you must check.
 
 Using SWIG_ to generate the Python interfaces automatically means that every function in libgphoto2_ *should* be available to Python.
 You can show the documentation of a function with the ``pydoc`` command (or ``python -m pydoc`` if you installed gphoto2 with pip inside a virtual environment)::
 
-   jim@firefly ~$ pydoc3 gphoto2.gp_camera_folder_list_files
+   $ pydoc3 gphoto2.gp_camera_folder_list_files
    Help on built-in function gp_camera_folder_list_files in gphoto2:
 
    gphoto2.gp_camera_folder_list_files = gp_camera_folder_list_files(...)
        gp_camera_folder_list_files(camera, folder, context) -> int
 
        Parameters
        ----------
@@ -208,15 +106,14 @@
            a GPContext
 
        Returns
        -------
        a gphoto2 error code
 
        See also gphoto2.Camera.folder_list_files
-   jim@firefly ~$
 
 The first part of this text is the function signature and parameter list generated by SWIG.
 (Note that ``context`` is optional - it's only needed if you need the callback functions that can be  associated with a context.)
 The rest of the text is copied from the "doxygen" format documentation in the C source code.
 (The online `API documentation`_ shows how it is intended to look.)
 Note that this includes a ``list`` parameter that is not in the function signature.
 In C this is an "output" parameter, a concept that doesn't really exist in Python.
@@ -464,45 +361,20 @@
 gp_camera_wait_for_event / Camera.wait_for_event
 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
 These functions return both the event type and the event data.
 The data you get depends on the type.
 ``GP_EVENT_FILE_ADDED`` and ``GP_EVENT_FOLDER_ADDED`` events return a ``CameraFilePath``, others return ``None`` or a text string.
 
-Running SWIG_
--------------
-
-SWIG_ is used to convert the ``.i`` interface definition files in ``src/gphoto2`` to ``.py`` and ``.c`` files.
-These are then compiled to build the Python interface to libgphoto2_.
-The files downloaded from PyPI_ include the SWIG_ generated files, but you may wish to regenerate them by running SWIG_ again (e.g. to test a new version of SWIG_ or of libgphoto2_).
-You will also need to run SWIG_ if you have downloaded the python-gphoto2 sources from GitHub_ instead of using PyPI_.
-
-The ``developer`` directory includes a script to run SWIG_.
-It requires one parameter: the version to be swigged.
-This can be ``system`` or a number triplet, e.g. ``2.5.27``::
-
-    python3 developer/build_swig.py system
-
-This builds the interface for the version of libgphoto2_ installed on your computer.
-The interface files are created in directories with names like ``src/swig-gp2.5.18``.
-This naming scheme allows for different versions of libgphoto2_.
-The most appropriate version is chosen when the interface is built.
-
-To build interfaces for multiple versions of libgphoto2_ (e.g. v2.5.10 as well as v2.5.0) you need to put those versions' source files in your working directory and then run ``python developer/build_swig.py`` again, specifying the version::
-
-    python3 developer/build_swig.py 2.5.10
-
-More information about this is in the file ``developer/README.txt``.
-
 Licence
 -------
 
 | python-gphoto2 - Python interface to libgphoto2
 | http://github.com/jim-easterbrook/python-gphoto2
-| Copyright (C) 2014-22  Jim Easterbrook  jim@jim-easterbrook.me.uk
+| Copyright (C) 2014-23  Jim Easterbrook  jim@jim-easterbrook.me.uk
 
 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
@@ -516,27 +388,23 @@
 .. _API documentation: http://www.gphoto.org/doc/api/
 .. _buffer protocol:   https://docs.python.org/2/c-api/buffer.html
 .. _bytearray:         https://docs.python.org/2/library/functions.html#bytearray
 .. _bytes-like object: https://docs.python.org/3/glossary.html#term-bytes-like-object
 .. _cffi:              http://cffi.readthedocs.org/
 .. _ctypes:            https://docs.python.org/2/library/ctypes.html
 .. _functions:         http://www.gphoto.org/doc/api/
-.. _git:               http://git-scm.com/
 .. _GitHub:            https://github.com/jim-easterbrook/python-gphoto2
 .. _gphoto2-cffi:      https://github.com/jbaiter/gphoto2-cffi
 .. _gphoto2 command line program:
                        http://gphoto.org/doc/manual/using-gphoto2.html
 .. _gphoto-user mailing list:
                        http://gphoto.org/mailinglists/
 .. _libgphoto2:        http://www.gphoto.org/proj/libgphoto2/
 .. _memoryview:        https://docs.python.org/2/library/stdtypes.html#memoryview
 .. _Python bindings:
    http://sourceforge.net/p/gphoto/code/HEAD/tree/trunk/bindings/libgphoto2-python/
 .. _piggyphoto:        https://github.com/alexdu/piggyphoto
 .. _pip:               https://pip.pypa.io/
 .. _piwheels:          https://www.piwheels.org/project/gphoto2/
-.. _PyPI:              https://pypi.python.org/pypi/gphoto2/
-.. _setuptools:        https://pypi.org/project/setuptools/
 .. _SWIG:              http://swig.org/
-.. _SWIG -builtin:     http://www.swig.org/Doc3.0/Python.html#Python_builtin_types
```

### Comparing `gphoto2-2.3.4/README.rst` & `gphoto2-2.3.5/README.rst`

 * *Files 16% similar despite different names*

```diff
@@ -1,145 +1,43 @@
-python-gphoto2 v\ 2.3.4
+python-gphoto2 v\ 2.3.5
 =======================
 
 python-gphoto2 is a comprehensive Python interface (or binding) to libgphoto2_.
 It is built using SWIG_ to automatically generate the interface code.
 This gives direct access to nearly all the libgphoto2 functions_, but sometimes in a rather un-Pythonic manner.
 
 Other Python bindings to libgphoto2_ are available:
 piggyphoto_ uses ctypes_ (included in standard Python installations) to interface to the library.
 The gphoto2 source tree includes some `Python bindings`_ which also use ctypes_.
 `gphoto2-cffi`_ uses cffi_.
 
 .. contents::
    :backlinks: top
 
-Installation (binary wheel)
----------------------------
+Installation
+------------
 
 Since python-gphoto2 version 2.3.1 "binary wheels" are provided for many Linux and MacOS computers.
 These include a recent version of the libgphoto2_ libraries, and pre-built Python interface modules, which makes installation quick and easy.
 Use pip_'s ``--only-binary`` option to install one of these wheels::
 
-    sudo pip3 install gphoto2 --only-binary :all:
+    $ pip3 install gphoto2 --user --only-binary :all:
 
 If this fails it is most likely because none of the available wheels is compatible with your computer.
-In this case you *must* install the dependencies listed below before installing python-gphoto2.
-The installation process compiles and links the bindings with the libgphoto2_ installed on your computer.
+In this case you *must* install some dependencies before installing python-gphoto2.
+See `<INSTALL.rst>`_ for more details.
 
 Raspberry Pi
 ^^^^^^^^^^^^
 
 Binary wheels for the Raspberry Pi are available from piwheels_.
-You still need to install some system packages to use these::
-
-    sudo apt install libexif12 libgphoto2-6 libgphoto2-port12 libltdl7
-    sudo pip3 install gphoto2
-
-Dependencies
-------------
-
-*   Python: http://python.org/ version 3.5 or greater
-*   libgphoto2: http://www.gphoto.org/proj/libgphoto2/ version 2.5.0 or greater
-*   build tools: pkg-config, C compiler & linker
-
-In most cases you should use your operating system's package manager to install these.
-Note that you need the "development headers" for libgphoto2_ and Python.
-On some systems these are included in the base package, but on others they need to be installed separately.
-Look for ``libgphoto2-dev`` or ``libgphoto2-devel`` or something similar.
-Test your installation with the command ``pkg-config --cflags --libs libgphoto2 python3``.
-
-Installation (source)
----------------------
-
-There are several ways to install python-gphoto2, with varying levels of control over the installation process.
-By far the easiest is to use your operating system's package manager, if you're lucky enough to be using a system that has python-gphoto2 available.
-Note that this may not install the latest version.
-
-Otherwise you can install it with pip_, or by downloading an archive, or by getting the source from GitHub_.
-Make sure that you install the dependencies_ first.
-
-Install with pip_
-^^^^^^^^^^^^^^^^^
-
-The easiest installation method is to use the pip_ command.
-Note the use of ``--no-binary`` to prevent installation from a binary wheel::
-
-    sudo pip3 install -v gphoto2 --no-binary :all:
-
-This installation may take longer than you expect as the package's modules are compiled during installation.
-The ``-v`` option increases pip_'s verbosity so you can see that it's doing something.
-
-Install a downloaded archive
-^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-
-Visit PyPI_ and download one of the zip or tar.gz files, then extract it and change to the new directory.
-For example::
-
-    tar xf gphoto2-2.3.0.tar.gz
-    cd gphoto2-2.3.0
-
-Python's setuptools_ are used to build and install python-gphoto2::
-
-    pip3 wheel . -v
-    sudo pip3 install gphoto2-*.whl
-
-Install from GitHub_ (SWIG_ required)
-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-
-SWIG (http://swig.org/) should be installable via your operating system's package manager.
-Note that this may be an older version of SWIG than the one used to generate the files on PyPI_.
-
-To install the current development version, use git_ to "clone" the GitHub_ repository, then change to the new directory::
-
-    git clone https://github.com/jim-easterbrook/python-gphoto2.git
-    cd python-gphoto2
-
-As before, Python's setuptools_ are used to build and install python-gphoto2, but now you have to run SWIG_ first to generate the files to be compiled.
-The ``developer`` directory includes a script to run SWIG::
+You need to install some system packages to use these::
 
-    python3 developer/build_swig.py system
-    pip3 wheel . -v
-    sudo pip3 install gphoto2-*.whl
-
-See "`running SWIG`_" below for more detail.
-
-Testing
--------
-
-Since version 2.3.1 you can test your installation of python-gphoto2 by running it with the ``python3 -m gphoto2`` command::
-
-    python3 -m gphoto2
-    python-gphoto2 version: 2.3.1
-    libgphoto2 version: ['2.5.27', 'standard camlibs (SKIPPING docupen)', 'gcc', 'ltdl', 'EXIF']
-    libgphoto2_port version: ['0.12.0', 'iolibs: disk ptpip serial usb1 usbdiskdirect usbscsi vusb', 'gcc', 'ltdl', 'EXIF', 'USB', 'serial without locking']
-    python-gphoto2 examples: /usr/lib64/python3.6/site-packages/gphoto2/examples
-
-This shows the python-gphoto2 and libgphoto2 version numbers, and where the example programs have been installed.
-Connect a digital camera to your computer, switch it on, and try one of the example programs::
-
-    python3 /usr/lib64/python3.6/site-packages/gphoto2/examples/camera-summary.py
-
-If this works then you're ready to start using python-gphoto2.
-
-Reinstalling
-^^^^^^^^^^^^
-
-If you update or move your installation of libgphoto2_ the Python gphoto2 package may fail to import one of the libgphoto2 shared object files.
-If this happens you need to rebuild and reinstall the Python gphoto2 package::
-
-    sudo pip3 install -v -U --force-reinstall gphoto2
-
-if you installed with pip_, or ::
-
-    rm -rf build
-    pip3 wheel . -v
-    sudo pip3 install --force-reinstall gphoto2-*.whl
-
-if you installed from source.
+    $ sudo apt install libexif12 libgphoto2-6 libgphoto2-port12 libltdl7
+    $ pip3 install gphoto2 --user
 
 Using python-gphoto2
 --------------------
 
 The Python interface to libgphoto2_ should allow you to do anything you could do in a C program.
 However, there are still bits missing and functions that cannot be called from Python.
 Let me know if you run into any problems.
@@ -152,15 +50,15 @@
 
 These functions are as similar as possible to their libgphoto2_ equivalents.
 Most of them return an error code which you must check.
 
 Using SWIG_ to generate the Python interfaces automatically means that every function in libgphoto2_ *should* be available to Python.
 You can show the documentation of a function with the ``pydoc`` command (or ``python -m pydoc`` if you installed gphoto2 with pip inside a virtual environment)::
 
-   jim@firefly ~$ pydoc3 gphoto2.gp_camera_folder_list_files
+   $ pydoc3 gphoto2.gp_camera_folder_list_files
    Help on built-in function gp_camera_folder_list_files in gphoto2:
 
    gphoto2.gp_camera_folder_list_files = gp_camera_folder_list_files(...)
        gp_camera_folder_list_files(camera, folder, context) -> int
 
        Parameters
        ----------
@@ -183,15 +81,14 @@
            a GPContext
 
        Returns
        -------
        a gphoto2 error code
 
        See also gphoto2.Camera.folder_list_files
-   jim@firefly ~$
 
 The first part of this text is the function signature and parameter list generated by SWIG.
 (Note that ``context`` is optional - it's only needed if you need the callback functions that can be  associated with a context.)
 The rest of the text is copied from the "doxygen" format documentation in the C source code.
 (The online `API documentation`_ shows how it is intended to look.)
 Note that this includes a ``list`` parameter that is not in the function signature.
 In C this is an "output" parameter, a concept that doesn't really exist in Python.
@@ -439,45 +336,20 @@
 gp_camera_wait_for_event / Camera.wait_for_event
 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
 These functions return both the event type and the event data.
 The data you get depends on the type.
 ``GP_EVENT_FILE_ADDED`` and ``GP_EVENT_FOLDER_ADDED`` events return a ``CameraFilePath``, others return ``None`` or a text string.
 
-Running SWIG_
--------------
-
-SWIG_ is used to convert the ``.i`` interface definition files in ``src/gphoto2`` to ``.py`` and ``.c`` files.
-These are then compiled to build the Python interface to libgphoto2_.
-The files downloaded from PyPI_ include the SWIG_ generated files, but you may wish to regenerate them by running SWIG_ again (e.g. to test a new version of SWIG_ or of libgphoto2_).
-You will also need to run SWIG_ if you have downloaded the python-gphoto2 sources from GitHub_ instead of using PyPI_.
-
-The ``developer`` directory includes a script to run SWIG_.
-It requires one parameter: the version to be swigged.
-This can be ``system`` or a number triplet, e.g. ``2.5.27``::
-
-    python3 developer/build_swig.py system
-
-This builds the interface for the version of libgphoto2_ installed on your computer.
-The interface files are created in directories with names like ``src/swig-gp2.5.18``.
-This naming scheme allows for different versions of libgphoto2_.
-The most appropriate version is chosen when the interface is built.
-
-To build interfaces for multiple versions of libgphoto2_ (e.g. v2.5.10 as well as v2.5.0) you need to put those versions' source files in your working directory and then run ``python developer/build_swig.py`` again, specifying the version::
-
-    python3 developer/build_swig.py 2.5.10
-
-More information about this is in the file ``developer/README.txt``.
-
 Licence
 -------
 
 | python-gphoto2 - Python interface to libgphoto2
 | http://github.com/jim-easterbrook/python-gphoto2
-| Copyright (C) 2014-22  Jim Easterbrook  jim@jim-easterbrook.me.uk
+| Copyright (C) 2014-23  Jim Easterbrook  jim@jim-easterbrook.me.uk
 
 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
@@ -491,25 +363,21 @@
 .. _API documentation: http://www.gphoto.org/doc/api/
 .. _buffer protocol:   https://docs.python.org/2/c-api/buffer.html
 .. _bytearray:         https://docs.python.org/2/library/functions.html#bytearray
 .. _bytes-like object: https://docs.python.org/3/glossary.html#term-bytes-like-object
 .. _cffi:              http://cffi.readthedocs.org/
 .. _ctypes:            https://docs.python.org/2/library/ctypes.html
 .. _functions:         http://www.gphoto.org/doc/api/
-.. _git:               http://git-scm.com/
 .. _GitHub:            https://github.com/jim-easterbrook/python-gphoto2
 .. _gphoto2-cffi:      https://github.com/jbaiter/gphoto2-cffi
 .. _gphoto2 command line program:
                        http://gphoto.org/doc/manual/using-gphoto2.html
 .. _gphoto-user mailing list:
                        http://gphoto.org/mailinglists/
 .. _libgphoto2:        http://www.gphoto.org/proj/libgphoto2/
 .. _memoryview:        https://docs.python.org/2/library/stdtypes.html#memoryview
 .. _Python bindings:
    http://sourceforge.net/p/gphoto/code/HEAD/tree/trunk/bindings/libgphoto2-python/
 .. _piggyphoto:        https://github.com/alexdu/piggyphoto
 .. _pip:               https://pip.pypa.io/
 .. _piwheels:          https://www.piwheels.org/project/gphoto2/
-.. _PyPI:              https://pypi.python.org/pypi/gphoto2/
-.. _setuptools:        https://pypi.org/project/setuptools/
 .. _SWIG:              http://swig.org/
-.. _SWIG -builtin:     http://www.swig.org/Doc3.0/Python.html#Python_builtin_types
```

### Comparing `gphoto2-2.3.4/developer/compare_versions.py` & `gphoto2-2.3.5/examples/capture-image.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,53 +1,48 @@
 #!/usr/bin/env python
 
 # python-gphoto2 - Python interface to libgphoto2
 # http://github.com/jim-easterbrook/python-gphoto2
-# Copyright (C) 2017  Jim Easterbrook  jim@jim-easterbrook.me.uk
+# Copyright (C) 2015-22  Jim Easterbrook  jim@jim-easterbrook.me.uk
 #
 # This program is free software: you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation, either version 3 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-import difflib
+import logging
+import locale
 import os
+import subprocess
 import sys
-import time
+
+import gphoto2 as gp
 
 def main():
-    if len(sys.argv) != 3:
-        print('Two arguments required')
-        return 1
-    root_1 = os.path.join('src', 'swig-gp' + sys.argv[1])
-    root_2 = os.path.join('src', 'swig-gp' + sys.argv[2])
-    print('Comparing {} and {}'.format(root_1, root_2))
-    for root, dirs, files in os.walk(root_1):
-        for name in files:
-            this = os.path.join(root, name)
-            that = os.path.join(root.replace(root_1, root_2), name)
-            if not os.path.exists(that):
-                print('File {} does not exist'.format(that))
-            else:
-                this_date = time.ctime(os.stat(this).st_mtime)
-                that_date = time.ctime(os.stat(that).st_mtime)
-                diff = difflib.unified_diff(
-                    open(this).readlines(), open(that).readlines(),
-                    this, that, this_date, that_date, n=4)
-                sys.stdout.writelines(diff)
-    for root, dirs, files in os.walk(root_2):
-        for name in files:
-            that = os.path.join(root.replace(root_1, root_2), name)
-            if not os.path.exists(that):
-                print('File {} does not exist'.format(that))
+    locale.setlocale(locale.LC_ALL, '')
+    logging.basicConfig(
+        format='%(levelname)s: %(name)s: %(message)s', level=logging.WARNING)
+    callback_obj = gp.check_result(gp.use_python_logging())
+    camera = gp.Camera()
+    camera.init()
+    print('Capturing image')
+    file_path = camera.capture(gp.GP_CAPTURE_IMAGE)
+    print('Camera file path: {0}/{1}'.format(file_path.folder, file_path.name))
+    target = os.path.join('/tmp', file_path.name)
+    print('Copying image to', target)
+    camera_file = camera.file_get(
+        file_path.folder, file_path.name, gp.GP_FILE_TYPE_NORMAL)
+    camera_file.save(target)
+    subprocess.call(['xdg-open', target])
+    camera.exit()
     return 0
 
-if __name__ == '__main__':
+if __name__ == "__main__":
     sys.exit(main())
```

### Comparing `gphoto2-2.3.4/examples/cam-conf-view-gui.py` & `gphoto2-2.3.5/examples/cam-conf-view-gui.py`

 * *Files identical despite different names*

### Comparing `gphoto2-2.3.4/examples/camera-config-gui.py` & `gphoto2-2.3.5/examples/camera-config-gui.py`

 * *Files identical despite different names*

### Comparing `gphoto2-2.3.4/examples/camera-summary.py` & `gphoto2-2.3.5/examples/camera-summary.py`

 * *Files identical despite different names*

### Comparing `gphoto2-2.3.4/examples/capture-image.py` & `gphoto2-2.3.5/examples/list-cameras.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,48 +1,43 @@
 #!/usr/bin/env python
 
 # python-gphoto2 - Python interface to libgphoto2
 # http://github.com/jim-easterbrook/python-gphoto2
-# Copyright (C) 2015-22  Jim Easterbrook  jim@jim-easterbrook.me.uk
+# Copyright (C) 2014-22  Jim Easterbrook  jim@jim-easterbrook.me.uk
 #
 # This program is free software: you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation, either version 3 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-import logging
+# "object oriented" version of list-cameras.py
+
 import locale
-import os
-import subprocess
+import logging
 import sys
 
 import gphoto2 as gp
 
 def main():
     locale.setlocale(locale.LC_ALL, '')
     logging.basicConfig(
         format='%(levelname)s: %(name)s: %(message)s', level=logging.WARNING)
     callback_obj = gp.check_result(gp.use_python_logging())
-    camera = gp.Camera()
-    camera.init()
-    print('Capturing image')
-    file_path = camera.capture(gp.GP_CAPTURE_IMAGE)
-    print('Camera file path: {0}/{1}'.format(file_path.folder, file_path.name))
-    target = os.path.join('/tmp', file_path.name)
-    print('Copying image to', target)
-    camera_file = camera.file_get(
-        file_path.folder, file_path.name, gp.GP_FILE_TYPE_NORMAL)
-    camera_file.save(target)
-    subprocess.call(['xdg-open', target])
-    camera.exit()
+    cameras = gp.Camera.autodetect()
+    for n, (name, value) in enumerate(cameras):
+        print('camera number', n)
+        print('===============')
+        print(name)
+        print(value)
+        print
     return 0
 
 if __name__ == "__main__":
     sys.exit(main())
```

### Comparing `gphoto2-2.3.4/examples/choose-camera.py` & `gphoto2-2.3.5/examples/choose-camera.py`

 * *Files identical despite different names*

### Comparing `gphoto2-2.3.4/examples/clear-space.py` & `gphoto2-2.3.5/examples/clear-space.py`

 * *Files identical despite different names*

### Comparing `gphoto2-2.3.4/examples/context_with_callbacks.py` & `gphoto2-2.3.5/examples/context_with_callbacks.py`

 * *Files identical despite different names*

### Comparing `gphoto2-2.3.4/examples/copy-chunks.py` & `gphoto2-2.3.5/examples/copy-chunks.py`

 * *Files identical despite different names*

### Comparing `gphoto2-2.3.4/examples/copy-data.py` & `gphoto2-2.3.5/examples/copy-data.py`

 * *Files identical despite different names*

### Comparing `gphoto2-2.3.4/examples/copy-files.py` & `gphoto2-2.3.5/examples/copy-files.py`

 * *Files identical despite different names*

### Comparing `gphoto2-2.3.4/examples/error_handling.py` & `gphoto2-2.3.5/examples/error_handling.py`

 * *Files identical despite different names*

### Comparing `gphoto2-2.3.4/examples/focus-gui.py` & `gphoto2-2.3.5/examples/focus-gui.py`

 * *Files identical despite different names*

### Comparing `gphoto2-2.3.4/examples/get-camera-clock.py` & `gphoto2-2.3.5/examples/get-camera-clock.py`

 * *Files identical despite different names*

### Comparing `gphoto2-2.3.4/examples/get-capture-target.py` & `gphoto2-2.3.5/examples/get-capture-target.py`

 * *Files identical despite different names*

### Comparing `gphoto2-2.3.4/examples/gphoto2_version.py` & `gphoto2-2.3.5/examples/gphoto2_version.py`

 * *Files identical despite different names*

### Comparing `gphoto2-2.3.4/examples/list-cameras.py` & `gphoto2-2.3.5/examples/log_events.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,43 +1,49 @@
 #!/usr/bin/env python
 
 # python-gphoto2 - Python interface to libgphoto2
 # http://github.com/jim-easterbrook/python-gphoto2
-# Copyright (C) 2014-22  Jim Easterbrook  jim@jim-easterbrook.me.uk
+# Copyright (C) 2018-22  Jim Easterbrook  jim@jim-easterbrook.me.uk
 #
 # This program is free software: you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation, either version 3 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-# "object oriented" version of list-cameras.py
+# print events as they are received from a camera
 
 import locale
-import logging
 import sys
+from datetime import datetime
 
 import gphoto2 as gp
 
 def main():
     locale.setlocale(locale.LC_ALL, '')
-    logging.basicConfig(
-        format='%(levelname)s: %(name)s: %(message)s', level=logging.WARNING)
-    callback_obj = gp.check_result(gp.use_python_logging())
-    cameras = gp.Camera.autodetect()
-    for n, (name, value) in enumerate(cameras):
-        print('camera number', n)
-        print('===============')
-        print(name)
-        print(value)
-        print
+    # create event name lookup table (not essential but helps readability)
+    ev_name = {}
+    for name in ('GP_EVENT_UNKNOWN', 'GP_EVENT_TIMEOUT', 'GP_EVENT_FILE_ADDED',
+                 'GP_EVENT_FOLDER_ADDED', 'GP_EVENT_CAPTURE_COMPLETE'):
+        ev_name[getattr(gp, name)] = name
+    camera = gp.Camera()
+    camera.init()
+    while True:
+        try:
+            ev_type, ev_data = camera.wait_for_event(2000)
+        except KeyboardInterrupt:
+            break
+        if not ev_data:
+            ev_data = ''
+        print(datetime.now().strftime('%H:%M:%S'), ev_name[ev_type], ev_data)
+    camera.exit()
     return 0
 
 if __name__ == "__main__":
     sys.exit(main())
```

### Comparing `gphoto2-2.3.4/examples/list-files.py` & `gphoto2-2.3.5/examples/list-files.py`

 * *Files identical despite different names*

### Comparing `gphoto2-2.3.4/examples/log_events.py` & `gphoto2-2.3.5/examples/set-capture-target.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,49 +1,64 @@
 #!/usr/bin/env python
 
 # python-gphoto2 - Python interface to libgphoto2
 # http://github.com/jim-easterbrook/python-gphoto2
-# Copyright (C) 2018-22  Jim Easterbrook  jim@jim-easterbrook.me.uk
+# Copyright (C) 2015-22  Jim Easterbrook  jim@jim-easterbrook.me.uk
 #
 # This program is free software: you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation, either version 3 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-# print events as they are received from a camera
-
 import locale
+import logging
 import sys
-from datetime import datetime
 
 import gphoto2 as gp
 
 def main():
     locale.setlocale(locale.LC_ALL, '')
-    # create event name lookup table (not essential but helps readability)
-    ev_name = {}
-    for name in ('GP_EVENT_UNKNOWN', 'GP_EVENT_TIMEOUT', 'GP_EVENT_FILE_ADDED',
-                 'GP_EVENT_FOLDER_ADDED', 'GP_EVENT_CAPTURE_COMPLETE'):
-        ev_name[getattr(gp, name)] = name
-    camera = gp.Camera()
-    camera.init()
-    while True:
-        try:
-            ev_type, ev_data = camera.wait_for_event(2000)
-        except KeyboardInterrupt:
-            break
-        if not ev_data:
-            ev_data = ''
-        print(datetime.now().strftime('%H:%M:%S'), ev_name[ev_type], ev_data)
-    camera.exit()
+    # use Python logging
+    logging.basicConfig(
+        format='%(levelname)s: %(name)s: %(message)s', level=logging.WARNING)
+    callback_obj = gp.check_result(gp.use_python_logging())
+    # get user value
+    if len(sys.argv) != 2:
+        print('One command line parameter required')
+        return 1
+    try:
+        value = int(sys.argv[1])
+    except:
+        print('Integer parameter required')
+        return 1
+    # open camera connection
+    camera = gp.check_result(gp.gp_camera_new())
+    gp.check_result(gp.gp_camera_init(camera))
+    # get configuration tree
+    config = gp.check_result(gp.gp_camera_get_config(camera))
+    # find the capture target config item
+    capture_target = gp.check_result(
+        gp.gp_widget_get_child_by_name(config, 'capturetarget'))
+    # check value in range
+    count = gp.check_result(gp.gp_widget_count_choices(capture_target))
+    if value < 0 or value >= count:
+        print('Parameter out of range')
+        return 1
+    # set value
+    value = gp.check_result(gp.gp_widget_get_choice(capture_target, value))
+    gp.check_result(gp.gp_widget_set_value(capture_target, value))
+    # set config
+    gp.check_result(gp.gp_camera_set_config(camera, config))
+    # clean up
+    gp.check_result(gp.gp_camera_exit(camera))
     return 0
 
 if __name__ == "__main__":
     sys.exit(main())
```

### Comparing `gphoto2-2.3.4/examples/preview-image.py` & `gphoto2-2.3.5/examples/preview-image.py`

 * *Files identical despite different names*

### Comparing `gphoto2-2.3.4/examples/read-exif-exifread.py` & `gphoto2-2.3.5/examples/read-exif-exifread.py`

 * *Files identical despite different names*

### Comparing `gphoto2-2.3.4/examples/read-exif-gexiv2.py` & `gphoto2-2.3.5/examples/read-exif-gexiv2.py`

 * *Files identical despite different names*

### Comparing `gphoto2-2.3.4/examples/set-camera-clock.py` & `gphoto2-2.3.5/examples/set-camera-clock.py`

 * *Files identical despite different names*

### Comparing `gphoto2-2.3.4/examples/time_lapse.py` & `gphoto2-2.3.5/examples/time_lapse.py`

 * *Files identical despite different names*

### Comparing `gphoto2-2.3.4/examples/wait-for-event.py` & `gphoto2-2.3.5/examples/wait-for-event.py`

 * *Files 14% similar despite different names*

```diff
@@ -13,29 +13,33 @@
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License
 
 # *******************************************************
-# gp.camera_wait_for_event() function waits for
-# a capture trigger to arrive. When it does, it downloads
+# camera.wait_for_event() function waits for a capture trigger
+# to arrive and returns the folder and name of the new file.
+# When it does, camera.file_get() is used to download
 # the image directly from the camera, without using SD
 # card
 #
-# gp_camera_trigger_capture() or Trigger Button on the
+# camera.trigger_capture() or Trigger Button on the
 # camera can be used to start capturing.
 #
 # gp_capture_image_and_download() method takes about 2 seconds
 # to process since it saves the image to SD CARD
 # first then downloads it, which takes a lot of time.
-#
-# "object oriented" version of wait-for-event.py
 # *******************************************************
 
+# Additional comment by Jim Easterbrook: My cameras save to SD card or
+# RAM according to the capture target setting. Use of
+# camera.wait_for_event() or camera.capture() makes no difference to
+# where the image is saved.
+
 import locale
 import os
 import sys
 
 import gphoto2 as gp
```

### Comparing `gphoto2-2.3.4/gphoto2.egg-info/PKG-INFO` & `gphoto2-2.3.5/gphoto2.egg-info/PKG-INFO`

 * *Files 15% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: gphoto2
-Version: 2.3.4
+Version: 2.3.5
 Summary: Python interface to libgphoto2
 Home-page: https://github.com/jim-easterbrook/python-gphoto2
 Author: Jim Easterbrook
 Author-email: jim@jim-easterbrook.me.uk
 License: GNU GPL
 Platform: POSIX
 Platform: MacOS
@@ -19,152 +19,50 @@
 Classifier: Operating System :: POSIX :: Linux
 Classifier: Programming Language :: Python :: 3
 Classifier: Topic :: Multimedia
 Classifier: Topic :: Multimedia :: Graphics
 Classifier: Topic :: Multimedia :: Graphics :: Capture
 License-File: LICENSE.txt
 
-python-gphoto2 v\ 2.3.4
+python-gphoto2 v\ 2.3.5
 =======================
 
 python-gphoto2 is a comprehensive Python interface (or binding) to libgphoto2_.
 It is built using SWIG_ to automatically generate the interface code.
 This gives direct access to nearly all the libgphoto2 functions_, but sometimes in a rather un-Pythonic manner.
 
 Other Python bindings to libgphoto2_ are available:
 piggyphoto_ uses ctypes_ (included in standard Python installations) to interface to the library.
 The gphoto2 source tree includes some `Python bindings`_ which also use ctypes_.
 `gphoto2-cffi`_ uses cffi_.
 
 .. contents::
    :backlinks: top
 
-Installation (binary wheel)
----------------------------
+Installation
+------------
 
 Since python-gphoto2 version 2.3.1 "binary wheels" are provided for many Linux and MacOS computers.
 These include a recent version of the libgphoto2_ libraries, and pre-built Python interface modules, which makes installation quick and easy.
 Use pip_'s ``--only-binary`` option to install one of these wheels::
 
-    sudo pip3 install gphoto2 --only-binary :all:
+    $ pip3 install gphoto2 --user --only-binary :all:
 
 If this fails it is most likely because none of the available wheels is compatible with your computer.
-In this case you *must* install the dependencies listed below before installing python-gphoto2.
-The installation process compiles and links the bindings with the libgphoto2_ installed on your computer.
+In this case you *must* install some dependencies before installing python-gphoto2.
+See `<INSTALL.rst>`_ for more details.
 
 Raspberry Pi
 ^^^^^^^^^^^^
 
 Binary wheels for the Raspberry Pi are available from piwheels_.
-You still need to install some system packages to use these::
-
-    sudo apt install libexif12 libgphoto2-6 libgphoto2-port12 libltdl7
-    sudo pip3 install gphoto2
-
-Dependencies
-------------
-
-*   Python: http://python.org/ version 3.5 or greater
-*   libgphoto2: http://www.gphoto.org/proj/libgphoto2/ version 2.5.0 or greater
-*   build tools: pkg-config, C compiler & linker
-
-In most cases you should use your operating system's package manager to install these.
-Note that you need the "development headers" for libgphoto2_ and Python.
-On some systems these are included in the base package, but on others they need to be installed separately.
-Look for ``libgphoto2-dev`` or ``libgphoto2-devel`` or something similar.
-Test your installation with the command ``pkg-config --cflags --libs libgphoto2 python3``.
-
-Installation (source)
----------------------
-
-There are several ways to install python-gphoto2, with varying levels of control over the installation process.
-By far the easiest is to use your operating system's package manager, if you're lucky enough to be using a system that has python-gphoto2 available.
-Note that this may not install the latest version.
-
-Otherwise you can install it with pip_, or by downloading an archive, or by getting the source from GitHub_.
-Make sure that you install the dependencies_ first.
-
-Install with pip_
-^^^^^^^^^^^^^^^^^
-
-The easiest installation method is to use the pip_ command.
-Note the use of ``--no-binary`` to prevent installation from a binary wheel::
-
-    sudo pip3 install -v gphoto2 --no-binary :all:
-
-This installation may take longer than you expect as the package's modules are compiled during installation.
-The ``-v`` option increases pip_'s verbosity so you can see that it's doing something.
-
-Install a downloaded archive
-^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-
-Visit PyPI_ and download one of the zip or tar.gz files, then extract it and change to the new directory.
-For example::
-
-    tar xf gphoto2-2.3.0.tar.gz
-    cd gphoto2-2.3.0
-
-Python's setuptools_ are used to build and install python-gphoto2::
-
-    pip3 wheel . -v
-    sudo pip3 install gphoto2-*.whl
-
-Install from GitHub_ (SWIG_ required)
-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-
-SWIG (http://swig.org/) should be installable via your operating system's package manager.
-Note that this may be an older version of SWIG than the one used to generate the files on PyPI_.
-
-To install the current development version, use git_ to "clone" the GitHub_ repository, then change to the new directory::
-
-    git clone https://github.com/jim-easterbrook/python-gphoto2.git
-    cd python-gphoto2
-
-As before, Python's setuptools_ are used to build and install python-gphoto2, but now you have to run SWIG_ first to generate the files to be compiled.
-The ``developer`` directory includes a script to run SWIG::
+You need to install some system packages to use these::
 
-    python3 developer/build_swig.py system
-    pip3 wheel . -v
-    sudo pip3 install gphoto2-*.whl
-
-See "`running SWIG`_" below for more detail.
-
-Testing
--------
-
-Since version 2.3.1 you can test your installation of python-gphoto2 by running it with the ``python3 -m gphoto2`` command::
-
-    python3 -m gphoto2
-    python-gphoto2 version: 2.3.1
-    libgphoto2 version: ['2.5.27', 'standard camlibs (SKIPPING docupen)', 'gcc', 'ltdl', 'EXIF']
-    libgphoto2_port version: ['0.12.0', 'iolibs: disk ptpip serial usb1 usbdiskdirect usbscsi vusb', 'gcc', 'ltdl', 'EXIF', 'USB', 'serial without locking']
-    python-gphoto2 examples: /usr/lib64/python3.6/site-packages/gphoto2/examples
-
-This shows the python-gphoto2 and libgphoto2 version numbers, and where the example programs have been installed.
-Connect a digital camera to your computer, switch it on, and try one of the example programs::
-
-    python3 /usr/lib64/python3.6/site-packages/gphoto2/examples/camera-summary.py
-
-If this works then you're ready to start using python-gphoto2.
-
-Reinstalling
-^^^^^^^^^^^^
-
-If you update or move your installation of libgphoto2_ the Python gphoto2 package may fail to import one of the libgphoto2 shared object files.
-If this happens you need to rebuild and reinstall the Python gphoto2 package::
-
-    sudo pip3 install -v -U --force-reinstall gphoto2
-
-if you installed with pip_, or ::
-
-    rm -rf build
-    pip3 wheel . -v
-    sudo pip3 install --force-reinstall gphoto2-*.whl
-
-if you installed from source.
+    $ sudo apt install libexif12 libgphoto2-6 libgphoto2-port12 libltdl7
+    $ pip3 install gphoto2 --user
 
 Using python-gphoto2
 --------------------
 
 The Python interface to libgphoto2_ should allow you to do anything you could do in a C program.
 However, there are still bits missing and functions that cannot be called from Python.
 Let me know if you run into any problems.
@@ -177,15 +75,15 @@
 
 These functions are as similar as possible to their libgphoto2_ equivalents.
 Most of them return an error code which you must check.
 
 Using SWIG_ to generate the Python interfaces automatically means that every function in libgphoto2_ *should* be available to Python.
 You can show the documentation of a function with the ``pydoc`` command (or ``python -m pydoc`` if you installed gphoto2 with pip inside a virtual environment)::
 
-   jim@firefly ~$ pydoc3 gphoto2.gp_camera_folder_list_files
+   $ pydoc3 gphoto2.gp_camera_folder_list_files
    Help on built-in function gp_camera_folder_list_files in gphoto2:
 
    gphoto2.gp_camera_folder_list_files = gp_camera_folder_list_files(...)
        gp_camera_folder_list_files(camera, folder, context) -> int
 
        Parameters
        ----------
@@ -208,15 +106,14 @@
            a GPContext
 
        Returns
        -------
        a gphoto2 error code
 
        See also gphoto2.Camera.folder_list_files
-   jim@firefly ~$
 
 The first part of this text is the function signature and parameter list generated by SWIG.
 (Note that ``context`` is optional - it's only needed if you need the callback functions that can be  associated with a context.)
 The rest of the text is copied from the "doxygen" format documentation in the C source code.
 (The online `API documentation`_ shows how it is intended to look.)
 Note that this includes a ``list`` parameter that is not in the function signature.
 In C this is an "output" parameter, a concept that doesn't really exist in Python.
@@ -464,45 +361,20 @@
 gp_camera_wait_for_event / Camera.wait_for_event
 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
 These functions return both the event type and the event data.
 The data you get depends on the type.
 ``GP_EVENT_FILE_ADDED`` and ``GP_EVENT_FOLDER_ADDED`` events return a ``CameraFilePath``, others return ``None`` or a text string.
 
-Running SWIG_
--------------
-
-SWIG_ is used to convert the ``.i`` interface definition files in ``src/gphoto2`` to ``.py`` and ``.c`` files.
-These are then compiled to build the Python interface to libgphoto2_.
-The files downloaded from PyPI_ include the SWIG_ generated files, but you may wish to regenerate them by running SWIG_ again (e.g. to test a new version of SWIG_ or of libgphoto2_).
-You will also need to run SWIG_ if you have downloaded the python-gphoto2 sources from GitHub_ instead of using PyPI_.
-
-The ``developer`` directory includes a script to run SWIG_.
-It requires one parameter: the version to be swigged.
-This can be ``system`` or a number triplet, e.g. ``2.5.27``::
-
-    python3 developer/build_swig.py system
-
-This builds the interface for the version of libgphoto2_ installed on your computer.
-The interface files are created in directories with names like ``src/swig-gp2.5.18``.
-This naming scheme allows for different versions of libgphoto2_.
-The most appropriate version is chosen when the interface is built.
-
-To build interfaces for multiple versions of libgphoto2_ (e.g. v2.5.10 as well as v2.5.0) you need to put those versions' source files in your working directory and then run ``python developer/build_swig.py`` again, specifying the version::
-
-    python3 developer/build_swig.py 2.5.10
-
-More information about this is in the file ``developer/README.txt``.
-
 Licence
 -------
 
 | python-gphoto2 - Python interface to libgphoto2
 | http://github.com/jim-easterbrook/python-gphoto2
-| Copyright (C) 2014-22  Jim Easterbrook  jim@jim-easterbrook.me.uk
+| Copyright (C) 2014-23  Jim Easterbrook  jim@jim-easterbrook.me.uk
 
 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
@@ -516,27 +388,23 @@
 .. _API documentation: http://www.gphoto.org/doc/api/
 .. _buffer protocol:   https://docs.python.org/2/c-api/buffer.html
 .. _bytearray:         https://docs.python.org/2/library/functions.html#bytearray
 .. _bytes-like object: https://docs.python.org/3/glossary.html#term-bytes-like-object
 .. _cffi:              http://cffi.readthedocs.org/
 .. _ctypes:            https://docs.python.org/2/library/ctypes.html
 .. _functions:         http://www.gphoto.org/doc/api/
-.. _git:               http://git-scm.com/
 .. _GitHub:            https://github.com/jim-easterbrook/python-gphoto2
 .. _gphoto2-cffi:      https://github.com/jbaiter/gphoto2-cffi
 .. _gphoto2 command line program:
                        http://gphoto.org/doc/manual/using-gphoto2.html
 .. _gphoto-user mailing list:
                        http://gphoto.org/mailinglists/
 .. _libgphoto2:        http://www.gphoto.org/proj/libgphoto2/
 .. _memoryview:        https://docs.python.org/2/library/stdtypes.html#memoryview
 .. _Python bindings:
    http://sourceforge.net/p/gphoto/code/HEAD/tree/trunk/bindings/libgphoto2-python/
 .. _piggyphoto:        https://github.com/alexdu/piggyphoto
 .. _pip:               https://pip.pypa.io/
 .. _piwheels:          https://www.piwheels.org/project/gphoto2/
-.. _PyPI:              https://pypi.python.org/pypi/gphoto2/
-.. _setuptools:        https://pypi.org/project/setuptools/
 .. _SWIG:              http://swig.org/
-.. _SWIG -builtin:     http://www.swig.org/Doc3.0/Python.html#Python_builtin_types
```

### Comparing `gphoto2-2.3.4/setup.py` & `gphoto2-2.3.5/setup.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # python-gphoto2 - Python interface to libgphoto2
 # http://github.com/jim-easterbrook/python-gphoto2
-# Copyright (C) 2014-22  Jim Easterbrook  jim@jim-easterbrook.me.uk
+# Copyright (C) 2014-23  Jim Easterbrook  jim@jim-easterbrook.me.uk
 #
 # This program is free software: you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation, either version 3 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful,
@@ -13,173 +13,174 @@
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 from collections import defaultdict
 from setuptools import setup, Extension
+from setuptools import __version__ as setuptools_version
 import os
 import subprocess
 import sys
 
-# python-gphoto2 version
-with open('README.rst') as rst:
-    version = rst.readline().split()[-1]
-
 packages = ['gphoto2', 'gphoto2.examples']
 package_dir = {'gphoto2.examples': 'examples'}
 package_data = {'gphoto2.examples': ['*']}
+exclude_package_data = {'': ['*.c']}
+extra_link_args = []
 
-if 'GPHOTO2_VERSION' in os.environ:
+if 'GPHOTO2_ROOT' in os.environ:
     # using a local build of libgphoto2
-    gphoto2_version_str = os.environ['GPHOTO2_VERSION']
-    print('Using local libgphoto2 v{}'.format(gphoto2_version_str))
-    gphoto2_dir = os.path.join(
-        'libgphoto2-' + gphoto2_version_str, 'local_install')
-    inc_dir = os.path.join(gphoto2_dir, 'include')
-    if not os.path.isdir(inc_dir):
-        raise RuntimeError('Include directory not found')
-    lib_dir = None
-    for name in os.listdir(gphoto2_dir):
-        if name.startswith('lib'):
-            lib_dir = os.path.join(gphoto2_dir, name)
+    gphoto2_dir = os.environ['GPHOTO2_ROOT']
+    gphoto2_dir = os.path.expanduser(gphoto2_dir)
+    if not os.path.isabs(gphoto2_dir):
+        raise RuntimeError('GPHOTO2_ROOT is not an absolute path')
+    print('Using libgphoto2 from {}'.format(gphoto2_dir))
+    for root, dirs, files in os.walk(gphoto2_dir):
+        if 'libgphoto2.pc' in files:
+            os.environ['PKG_CONFIG_PATH'] = root
             break
-    if not lib_dir:
-        raise RuntimeError('Library directory not found')
+    else:
+        raise RuntimeError('No package config file found')
+    # get gphoto2 libs
+    lib_dir = subprocess.check_output(
+        ['pkg-config', '--variable=libdir', 'libgphoto2'],
+        universal_newlines=True).strip()
     packages.append('gphoto2.libs')
-    package_dir['gphoto2.libs'] = lib_dir
+    package_dir['gphoto2.libs'] = os.path.relpath(lib_dir)
     package_data['gphoto2.libs'] = []
     # choose the libx.so.n versions of all the .so files and links
     for name in os.listdir(lib_dir):
-        if '.so.' in name and len(name.split('.')) == 3:
+        if (name.startswith('libgphoto') and '.so.' in name
+                and len(name.split('.')) == 3):
             package_data['gphoto2.libs'].append(name)
-    # get cam libs and io libs
+    # get cam libs
     packages.append('gphoto2.camlibs')
-    package_dir['gphoto2.camlibs'] = os.path.join(
-        lib_dir, 'libgphoto2', gphoto2_version_str)
+    lib_dir = subprocess.check_output(
+        ['pkg-config', '--variable=driverdir', 'libgphoto2'],
+        universal_newlines=True).strip()
+    package_dir['gphoto2.camlibs'] = os.path.relpath(lib_dir)
     package_data['gphoto2.camlibs'] = ['*.so']
-    iolibs = os.listdir(os.path.join(lib_dir, 'libgphoto2_port'))
-    iolibs.sort()
+    # get io libs
     packages.append('gphoto2.iolibs')
-    package_dir['gphoto2.iolibs'] = os.path.join(
-        lib_dir, 'libgphoto2_port', iolibs[-1])
+    lib_dir = subprocess.check_output(
+        ['pkg-config', '--variable=driverdir', 'libgphoto2_port'],
+        universal_newlines=True).strip()
+    package_dir['gphoto2.iolibs'] = os.path.relpath(lib_dir)
     package_data['gphoto2.iolibs'] = ['*.so']
-    # add localisation files
-    locale_dir = os.path.join(gphoto2_dir, 'share', 'locale')
+    # get localisation files
+    prefix = subprocess.check_output(
+        ['pkg-config', '--variable=prefix', 'libgphoto2'],
+        universal_newlines=True).strip()
+    locale_dir = os.path.join(prefix, 'share', 'locale')
     if os.path.isdir(locale_dir):
         packages.append('gphoto2.locale')
-        package_dir['gphoto2.locale'] = locale_dir
+        package_dir['gphoto2.locale'] = os.path.relpath(locale_dir)
         package_data['gphoto2.locale'] = ['*/LC_MESSAGES/libgphoto2*.mo']
+        for name in os.listdir(locale_dir):
+            packages.append('gphoto2.locale.' + name + '.LC_MESSAGES')
     # module compile options
-    libraries = ['gphoto2', 'gphoto2_port', 'm']
-    library_dirs = [lib_dir]
-    include_dirs = [inc_dir]
     extra_link_args = ['-Wl,-rpath,$ORIGIN/libs']
-else:
-    # using system installed libgphoto2
-    cmd = ['pkg-config', '--modversion', 'libgphoto2']
-    FNULL = open(os.devnull, 'w')
-    try:
-        gphoto2_version_str = subprocess.check_output(
-            cmd, stderr=FNULL, universal_newlines=True).strip()
-    except Exception:
-        raise RuntimeError('ERROR: command "%s" failed' % ' '.join(cmd))
-    print('Using installed libgphoto2 v{}'.format(gphoto2_version_str))
-    gphoto2_flags = defaultdict(list)
-    for flag in subprocess.check_output(
-            ['pkg-config', '--cflags', '--libs', 'libgphoto2'],
-            universal_newlines=True).split():
-        gphoto2_flags[flag[:2]].append(flag)
-    gphoto2_include  = gphoto2_flags['-I']
-    for n in range(len(gphoto2_include)):
-        if gphoto2_include[n].endswith('/gphoto2'):
-            gphoto2_include[n] = gphoto2_include[n][:-len('/gphoto2')]
-    libraries = [x.replace('-l', '') for x in gphoto2_flags['-l']]
-    library_dirs = [x.replace('-L', '') for x in gphoto2_flags['-L']]
-    include_dirs = [x.replace('-I', '') for x in gphoto2_include]
-    extra_link_args = []
+
+cmd = ['pkg-config', '--modversion', 'libgphoto2']
+FNULL = open(os.devnull, 'w')
+try:
+    gphoto2_version_str = subprocess.check_output(
+        cmd, stderr=FNULL, universal_newlines=True).strip()
+except Exception:
+    raise RuntimeError('ERROR: command "%s" failed' % ' '.join(cmd))
+print('Using libgphoto2 v{}'.format(gphoto2_version_str))
+# get libgphoto2 config
+gphoto2_flags = defaultdict(list)
+for flag in subprocess.check_output(
+        ['pkg-config', '--cflags', '--libs', 'libgphoto2'],
+        universal_newlines=True).split():
+    gphoto2_flags[flag[:2]].append(flag)
+gphoto2_include  = gphoto2_flags['-I']
+for n in range(len(gphoto2_include)):
+    if gphoto2_include[n].endswith('/gphoto2'):
+        gphoto2_include[n] = gphoto2_include[n][:-len('/gphoto2')]
+libraries = [x.replace('-l', '') for x in gphoto2_flags['-l']]
+library_dirs = [x.replace('-L', '') for x in gphoto2_flags['-L']]
+include_dirs = [x.replace('-I', '') for x in gphoto2_include]
 
 # get list of available swigged versions
 swigged_versions = []
 for name in os.listdir('src'):
     if not name.startswith('swig-gp'):
         continue
-    swigged_version = name.replace('swig-gp','').split('.')
+    swigged_version = name.replace('swig-gp', '').split('_')
     swigged_versions.append(tuple(map(int, swigged_version)))
 swigged_versions.sort()
 
 # choose best match from swigged versions
 gphoto2_version = tuple(map(int, gphoto2_version_str.split('.')))
+if gphoto2_version < (2, 5, 10):
+    raise RuntimeError('libgphoto2 version 2.5.10 or later is required')
 while len(swigged_versions) > 1 and swigged_versions[0] < gphoto2_version:
     swigged_versions = swigged_versions[1:]
 swigged_version = swigged_versions[0]
 
 # create extension modules list
 ext_modules = []
-mod_src_dir = 'swig-gp' + '.'.join(map(str, swigged_version))
+mod_src_dir = 'swig-gp' + '_'.join(map(str, swigged_version))
 mod_src_dir = os.path.join('src', mod_src_dir)
 package_dir['gphoto2'] = mod_src_dir
 
 extra_compile_args = [
     '-O3', '-Wno-unused-variable', '-Wno-unused-but-set-variable',
-    '-Wno-unused-label', '-Wno-strict-prototypes',
-    '-DGPHOTO2_VERSION=' + '0x{:02x}{:02x}{:02x}{:02x}'.format(
-        *gphoto2_version, 0, 0)]
+    '-Wno-unused-label', '-Wno-strict-prototypes']
 if 'PYTHON_GPHOTO2_STRICT' in os.environ:
     extra_compile_args.append('-Werror')
+define_macros = [('GPHOTO2_VERSION',
+                  '0x{:02x}{:02x}{:02x}{:02x}'.format(*gphoto2_version, 0, 0)),
+                 ('SWIG_TYPE_TABLE', 'gphoto2')]
 for file_name in os.listdir(mod_src_dir):
     if file_name[-7:] != '_wrap.c':
         continue
     ext_name = file_name[:-7]
     ext_modules.append(Extension(
         '_' + ext_name,
         sources = [os.path.join(mod_src_dir, file_name)],
         libraries = libraries,
         library_dirs = library_dirs,
         runtime_library_dirs = library_dirs,
         include_dirs = include_dirs,
         extra_compile_args = extra_compile_args,
+        define_macros = define_macros,
         extra_link_args = extra_link_args,
         ))
 
-command_options = {}
-
-# set options for building distributions
-command_options['sdist'] = {
-    'formats' : ('setup.py', 'gztar'),
+setup_kwds = {
+    'ext_package': 'gphoto2',
+    'ext_modules': ext_modules,
+    'packages': packages,
+    'package_dir': package_dir,
+    'package_data': package_data,
+    'exclude_package_data': exclude_package_data,
     }
 
-with open('README.rst') as ldf:
-    long_description = ldf.read()
+if tuple(map(int, setuptools_version.split('.'))) < (61, 0):
+    # get metadata from pyproject.toml
+    import toml
+    metadata = toml.load('pyproject.toml')
+
+    with open(metadata['project']['readme']) as ldf:
+        long_description = ldf.read()
+        # python-gphoto2 version
+        version = long_description.split('\n')[0].split()[-1]
+
+    setup_kwds.update(
+        name = metadata['project']['name'],
+        version = version,
+        description = metadata['project']['description'],
+        long_description = long_description,
+        author = metadata['project']['authors'][0]['name'],
+        author_email = metadata['project']['authors'][0]['email'],
+        url = metadata['project']['urls']['homepage'],
+        classifiers = metadata['project']['classifiers'],
+        platforms = metadata['tool']['setuptools']['platforms'],
+        license = metadata['project']['license']['text'],
+        zip_safe = metadata['tool']['setuptools']['zip-safe'],
+        )
 
-setup(name = 'gphoto2',
-      version = version,
-      description = 'Python interface to libgphoto2',
-      long_description = long_description,
-      author = 'Jim Easterbrook',
-      author_email = 'jim@jim-easterbrook.me.uk',
-      url = 'https://github.com/jim-easterbrook/python-gphoto2',
-      classifiers = [
-          'Development Status :: 5 - Production/Stable',
-          'Intended Audience :: Developers',
-          'License :: OSI Approved :: GNU General Public License v3 or later (GPLv3+)',
-          'Operating System :: MacOS',
-          'Operating System :: MacOS :: MacOS X',
-          'Operating System :: POSIX',
-          'Operating System :: POSIX :: BSD :: FreeBSD',
-          'Operating System :: POSIX :: BSD :: NetBSD',
-          'Operating System :: POSIX :: Linux',
-          'Programming Language :: Python :: 3',
-          'Topic :: Multimedia',
-          'Topic :: Multimedia :: Graphics',
-          'Topic :: Multimedia :: Graphics :: Capture',
-          ],
-      platforms = ['POSIX', 'MacOS'],
-      license = 'GNU GPL',
-      command_options = command_options,
-      ext_package = 'gphoto2',
-      ext_modules = ext_modules,
-      packages = packages,
-      package_dir = package_dir,
-      package_data = package_data,
-      zip_safe = False,
-      )
+setup(**setup_kwds)
```

### Comparing `gphoto2-2.3.4/src/gphoto2/__main__.py` & `gphoto2-2.3.5/src/swig-gp2_5_30/__main__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # python-gphoto2 - Python interface to libgphoto2
 # http://github.com/jim-easterbrook/python-gphoto2
-# Copyright (C) 2021  Jim Easterbrook  jim@jim-easterbrook.me.uk
+# Copyright (C) 2021-23  Jim Easterbrook  jim@jim-easterbrook.me.uk
 #
 # This program is free software: you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation, either version 3 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful,
@@ -19,16 +19,17 @@
 import sys
 
 import gphoto2 as gp
 
 
 def main():
     print('python-gphoto2 version:', gp.__version__)
-    print('libgphoto2 version:', gp.gp_library_version(gp.GP_VERSION_SHORT))
+    print('libgphoto2 version:',
+          ', '.join(gp.gp_library_version(gp.GP_VERSION_SHORT)))
     print('libgphoto2_port version:',
-          gp.gp_port_library_version(gp.GP_VERSION_SHORT))
+          ', '.join(gp.gp_port_library_version(gp.GP_VERSION_SHORT)))
     print('python-gphoto2 examples:',
           os.path.join(os.path.dirname(__file__), 'examples'))
 
 
 if __name__ == "__main__":
     sys.exit(main())
```

### Comparing `gphoto2-2.3.4/src/swig-gp2.5.30/__init__.py` & `gphoto2-2.3.5/src/swig-gp2_5_30/__init__.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-__version__ = "2.3.4"
+__version__ = "2.3.5"
 
 
 import os
 
 _dir = os.path.dirname(__file__)
 _camlibs = os.path.join(_dir, 'camlibs')
 if os.path.isdir(_camlibs):
```

### Comparing `gphoto2-2.3.4/src/swig-gp2.5.30/abilities_list_wrap.c` & `gphoto2-2.3.5/src/swig-gp2_5_30/abilities_list_wrap.c`

 * *Files 3% similar despite different names*

```diff
@@ -1,24 +1,21 @@
 /* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 4.0.2
+ * This file was automatically generated by SWIG (https://www.swig.org).
+ * Version 4.1.1
  *
- * This file is not intended to be easily readable and contains a number of
- * coding conventions designed to improve portability and efficiency. Do not make
- * changes to this file unless you know what you are doing--modify the SWIG
- * interface file instead.
+ * Do not make changes to this file unless you know what you are doing - modify
+ * the SWIG interface file instead.
  * ----------------------------------------------------------------------------- */
 
 
-#ifndef SWIGPYTHON
+#define SWIG_VERSION 0x040101
 #define SWIGPYTHON
-#endif
-
 #define SWIG_PYTHON_DIRECTOR_NO_VTABLE
 #define SWIGPYTHON_BUILTIN
+#define SWIGPYTHON_FASTPROXY
 
 /* -----------------------------------------------------------------------------
  *  This section contains generic SWIG labels for method/variable
  *  declarations/attributes, and other compiler dependent labels.
  * ----------------------------------------------------------------------------- */
 
 /* template workaround for compilers that cannot correctly implement the C++ standard */
@@ -142,23 +139,45 @@
 
 
 #if defined(__GNUC__) && defined(_WIN32) && !defined(SWIG_PYTHON_NO_HYPOT_WORKAROUND)
 /* Workaround for '::hypot' has not been declared', see https://bugs.python.org/issue11566 */
 # include <math.h>
 #endif
 
+#if !defined(PY_SSIZE_T_CLEAN) && !defined(SWIG_NO_PY_SSIZE_T_CLEAN)
+#define PY_SSIZE_T_CLEAN
+#endif
+
+#if __GNUC__ >= 7
+#pragma GCC diagnostic push
+#if defined(__cplusplus) && __cplusplus >=201703L
+#pragma GCC diagnostic ignored "-Wregister" /* For python-2.7 headers that use register */
+#endif
+#endif
+
 #if defined(_DEBUG) && defined(SWIG_PYTHON_INTERPRETER_NO_DEBUG)
 /* Use debug wrappers with the Python release dll */
+
+#if defined(_MSC_VER) && _MSC_VER >= 1929
+/* Workaround compilation errors when redefining _DEBUG in MSVC 2019 version 16.10 and later
+ * See https://github.com/swig/swig/issues/2090 */
+# include <corecrt.h>
+#endif
+
 # undef _DEBUG
 # include <Python.h>
 # define _DEBUG 1
 #else
 # include <Python.h>
 #endif
 
+#if __GNUC__ >= 7
+#pragma GCC diagnostic pop
+#endif
+
 /* -----------------------------------------------------------------------------
  * swigrun.swg
  *
  * This file contains generic C API SWIG runtime support for pointer
  * type checking.
  * ----------------------------------------------------------------------------- */
 
@@ -197,14 +216,16 @@
 # define SWIG_BUFFER_SIZE 1024
 #endif
 
 /* Flags for pointer conversions */
 #define SWIG_POINTER_DISOWN        0x1
 #define SWIG_CAST_NEW_MEMORY       0x2
 #define SWIG_POINTER_NO_NULL       0x4
+#define SWIG_POINTER_CLEAR         0x8
+#define SWIG_POINTER_RELEASE       (SWIG_POINTER_CLEAR | SWIG_POINTER_DISOWN)
 
 /* Flags for new pointer objects */
 #define SWIG_POINTER_OWN           0x1
 
 
 /*
    Flags/methods for returning states.
@@ -268,44 +289,50 @@
       }
 
    Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
    more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
    SWIG errors code.
 
    Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
-   allows to return the 'cast rank', for example, if you have this
+   allows returning the 'cast rank', for example, if you have this
 
        int food(double)
        int fooi(int);
 
    and you call
 
       food(1)   // cast rank '1'  (1 -> 1.0)
       fooi(1)   // cast rank '0'
 
    just use the SWIG_AddCast()/SWIG_CheckState()
 */
 
 #define SWIG_OK                    (0)
+/* Runtime errors are < 0 */
 #define SWIG_ERROR                 (-1)
+/* Errors in range -1 to -99 are in swigerrors.swg (errors for all languages including those not using the runtime) */
+/* Errors in range -100 to -199 are language specific errors defined in *errors.swg */
+/* Errors < -200 are generic runtime specific errors */
+#define SWIG_ERROR_RELEASE_NOT_OWNED (-200)
+
 #define SWIG_IsOK(r)               (r >= 0)
 #define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)
 
 /* The CastRankLimit says how many bits are used for the cast rank */
 #define SWIG_CASTRANKLIMIT         (1 << 8)
 /* The NewMask denotes the object was created (using new/malloc) */
 #define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
 /* The TmpMask is for in/out typemaps that use temporal objects */
 #define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
 /* Simple returning values */
 #define SWIG_BADOBJ                (SWIG_ERROR)
 #define SWIG_OLDOBJ                (SWIG_OK)
 #define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
 #define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
-/* Check, add and del mask methods */
+/* Check, add and del object mask methods */
 #define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
 #define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
 #define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
 #define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
 #define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
 #define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))
 
@@ -443,15 +470,15 @@
   return 0;
 }
 
 /*
   Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
 */
 SWIGRUNTIME swig_cast_info *
-SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty) {
+SWIG_TypeCheckStruct(const swig_type_info *from, swig_type_info *ty) {
   if (ty) {
     swig_cast_info *iter = ty->cast;
     while (iter) {
       if (iter->type == from) {
         if (iter == ty->cast)
           return iter;
         /* Move iter to the top of the linked list */
@@ -503,17 +530,17 @@
 /*
   Return the pretty name associated with this type,
   that is an unmangled type name in a form presentable to the user.
 */
 SWIGRUNTIME const char *
 SWIG_TypePrettyName(const swig_type_info *type) {
   /* The "str" field contains the equivalent pretty names of the
-     type, separated by vertical-bar characters.  We choose
-     to print the last name, as it is often (?) the most
-     specific. */
+     type, separated by vertical-bar characters.  Choose the last
+     name. It should be the most specific; a fully resolved name
+     but not necessarily with default template parameters expanded. */
   if (!type) return NULL;
   if (type->str != NULL) {
     const char *last_name = type->str;
     const char *s;
     for (s = type->str; *s; s++)
       if (*s == '|') last_name = s+1;
     return last_name;
@@ -725,15 +752,15 @@
   return SWIG_UnpackData(++c,ptr,sz);
 }
 
 #ifdef __cplusplus
 }
 #endif
 
-/*  Errors in SWIG */
+/* SWIG Errors applicable to all language modules, values are reserved from -1 to -99 */
 #define  SWIG_UnknownError    	   -1
 #define  SWIG_IOError        	   -2
 #define  SWIG_RuntimeError   	   -3
 #define  SWIG_IndexError     	   -4
 #define  SWIG_TypeError      	   -5
 #define  SWIG_DivisionByZero 	   -6
 #define  SWIG_OverflowError  	   -7
@@ -741,15 +768,14 @@
 #define  SWIG_ValueError     	   -9
 #define  SWIG_SystemError    	   -10
 #define  SWIG_AttributeError 	   -11
 #define  SWIG_MemoryError    	   -12
 #define  SWIG_NullReferenceError   -13
 
 
-
 /* Compatibility macros for Python 3 */
 #if PY_VERSION_HEX >= 0x03000000
 
 #define PyClass_Check(obj) PyObject_IsInstance(obj, (PyObject *)&PyType_Type)
 #define PyInt_Check(x) PyLong_Check(x)
 #define PyInt_AsLong(x) PyLong_AsLong(x)
 #define PyInt_FromLong(x) PyLong_FromLong(x)
@@ -757,15 +783,14 @@
 #define PyString_Check(name) PyBytes_Check(name)
 #define PyString_FromString(x) PyUnicode_FromString(x)
 #define PyString_Format(fmt, args)  PyUnicode_Format(fmt, args)
 #define PyString_AsString(str) PyBytes_AsString(str)
 #define PyString_Size(str) PyBytes_Size(str)	
 #define PyString_InternFromString(key) PyUnicode_InternFromString(key)
 #define Py_TPFLAGS_HAVE_CLASS Py_TPFLAGS_BASETYPE
-#define PyString_AS_STRING(x) PyUnicode_AS_STRING(x)
 #define _PyLong_FromSsize_t(x) PyLong_FromSsize_t(x)
 
 #endif
 
 #ifndef Py_TYPE
 #  define Py_TYPE(op) ((op)->ob_type)
 #endif
@@ -775,46 +800,27 @@
 #if PY_VERSION_HEX >= 0x03000000
 #  define SWIG_Python_str_FromFormat PyUnicode_FromFormat
 #else
 #  define SWIG_Python_str_FromFormat PyString_FromFormat
 #endif
 
 
-/* Warning: This function will allocate a new string in Python 3,
- * so please call SWIG_Python_str_DelForPy3(x) to free the space.
- */
 SWIGINTERN char*
 SWIG_Python_str_AsChar(PyObject *str)
 {
 #if PY_VERSION_HEX >= 0x03030000
   return (char *)PyUnicode_AsUTF8(str);
-#elif PY_VERSION_HEX >= 0x03000000
-  char *newstr = 0;
-  str = PyUnicode_AsUTF8String(str);
-  if (str) {
-    char *cstr;
-    Py_ssize_t len;
-    if (PyBytes_AsStringAndSize(str, &cstr, &len) != -1) {
-      newstr = (char *) malloc(len+1);
-      if (newstr)
-        memcpy(newstr, cstr, len+1);
-    }
-    Py_XDECREF(str);
-  }
-  return newstr;
 #else
   return PyString_AsString(str);
 #endif
 }
 
-#if PY_VERSION_HEX >= 0x03030000 || PY_VERSION_HEX < 0x03000000
-#  define SWIG_Python_str_DelForPy3(x)
-#else
-#  define SWIG_Python_str_DelForPy3(x) free( (void*) (x) )
-#endif
+/* Was useful for Python 3.0.x-3.2.x - now provided only for compatibility
+ * with any uses in user interface files. */
+#define SWIG_Python_str_DelForPy3(x)
 
 
 SWIGINTERN PyObject*
 SWIG_Python_str_FromChar(const char *c)
 {
 #if PY_VERSION_HEX >= 0x03000000
   return PyUnicode_FromString(c); 
@@ -823,18 +829,22 @@
 #endif
 }
 
 #ifndef PyObject_DEL
 # define PyObject_DEL PyObject_Del
 #endif
 
-// SWIGPY_USE_CAPSULE is no longer used within SWIG itself, but some user
-// interface files check for it.
+/* SWIGPY_USE_CAPSULE is no longer used within SWIG itself, but some user interface files check for it. */
 # define SWIGPY_USE_CAPSULE
-# define SWIGPY_CAPSULE_NAME ("swig_runtime_data" SWIG_RUNTIME_VERSION ".type_pointer_capsule" SWIG_TYPE_TABLE_NAME)
+#ifdef SWIGPYTHON_BUILTIN
+# define SWIGPY_CAPSULE_ATTR_NAME "type_pointer_capsule_builtin" SWIG_TYPE_TABLE_NAME
+#else
+# define SWIGPY_CAPSULE_ATTR_NAME "type_pointer_capsule" SWIG_TYPE_TABLE_NAME
+#endif
+# define SWIGPY_CAPSULE_NAME ("swig_runtime_data" SWIG_RUNTIME_VERSION "." SWIGPY_CAPSULE_ATTR_NAME)
 
 #if PY_VERSION_HEX < 0x03020000
 #define PyDescr_TYPE(x) (((PyDescrObject *)(x))->d_type)
 #define PyDescr_NAME(x) (((PyDescrObject *)(x))->d_name)
 #define Py_hash_t long
 #endif
 
@@ -900,15 +910,14 @@
     const char *tmp = SWIG_Python_str_AsChar(old_str);
     PyErr_Clear();
     Py_XINCREF(type);
     if (tmp)
       PyErr_Format(type, "%s %s", tmp, mesg);
     else
       PyErr_Format(type, "%s", mesg);
-    SWIG_Python_str_DelForPy3(tmp);
     Py_DECREF(old_str);
     Py_DECREF(value);
   } else {
     PyErr_SetString(PyExc_RuntimeError, mesg);
   }
 }
 
@@ -931,16 +940,20 @@
     PyObject *type = NULL, *value = NULL, *traceback = NULL;
     PyErr_Fetch(&type, &value, &traceback);
 #if PY_VERSION_HEX >= 0x03000000
     newvalue = PyUnicode_FromFormat("%S\nAdditional information:\n%s", value, message);
 #else
     newvalue = PyString_FromFormat("%s\nAdditional information:\n%s", PyString_AsString(value), message);
 #endif
-    Py_XDECREF(value);
-    PyErr_Restore(type, newvalue, traceback);
+    if (newvalue) {
+      Py_XDECREF(value);
+      PyErr_Restore(type, newvalue, traceback);
+    } else {
+      PyErr_Restore(type, value, traceback);
+    }
   } else {
     /* Raise TypeError using given message */
     PyErr_SetString(PyExc_TypeError, message);
   }
 }
 
 #if defined(SWIG_PYTHON_NO_THREADS)
@@ -949,16 +962,20 @@
 #  endif
 #endif
 #if defined(SWIG_PYTHON_THREADS) /* Threading support is enabled */
 #  if !defined(SWIG_PYTHON_USE_GIL) && !defined(SWIG_PYTHON_NO_USE_GIL)
 #    define SWIG_PYTHON_USE_GIL
 #  endif
 #  if defined(SWIG_PYTHON_USE_GIL) /* Use PyGILState threads calls */
-#    ifndef SWIG_PYTHON_INITIALIZE_THREADS
-#     define SWIG_PYTHON_INITIALIZE_THREADS  PyEval_InitThreads() 
+#    if !defined(SWIG_PYTHON_INITIALIZE_THREADS)
+#      if PY_VERSION_HEX < 0x03070000
+#        define SWIG_PYTHON_INITIALIZE_THREADS PyEval_InitThreads()
+#      else
+#        define SWIG_PYTHON_INITIALIZE_THREADS
+#      endif
 #    endif
 #    ifdef __cplusplus /* C++ code */
        class SWIG_Python_Thread_Block {
          bool status;
          PyGILState_STATE state;
        public:
          void end() { if (status) { PyGILState_Release(state); status = false;} }
@@ -1048,16 +1065,16 @@
  *
  * ----------------------------------------------------------------------------- */
 
 #if PY_VERSION_HEX < 0x02070000 /* 2.7.0 */
 # error "This version of SWIG only supports Python >= 2.7"
 #endif
 
-#if PY_VERSION_HEX >= 0x03000000 && PY_VERSION_HEX < 0x03020000
-# error "This version of SWIG only supports Python 3 >= 3.2"
+#if PY_VERSION_HEX >= 0x03000000 && PY_VERSION_HEX < 0x03030000
+# error "This version of SWIG only supports Python 3 >= 3.3"
 #endif
 
 /* Common SWIG API */
 
 /* for raw pointers */
 #define SWIG_Python_ConvertPtr(obj, pptr, type, flags)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, 0)
 #define SWIG_ConvertPtr(obj, pptr, type, flags)         SWIG_Python_ConvertPtr(obj, pptr, type, flags)
@@ -1164,15 +1181,20 @@
   } else if (result == Py_None) {
     Py_DECREF(result);
     result = obj;
   } else {
     if (!PyList_Check(result)) {
       PyObject *o2 = result;
       result = PyList_New(1);
-      PyList_SetItem(result, 0, o2);
+      if (result) {
+        PyList_SET_ITEM(result, 0, o2);
+      } else {
+        Py_DECREF(obj);
+        return o2;
+      }
     }
     PyList_Append(result,obj);
     Py_DECREF(obj);
   }
   return result;
 }
 
@@ -1246,14 +1268,246 @@
 */
 #ifdef __cplusplus
 #define SWIG_STATIC_POINTER(var)  var
 #else
 #define SWIG_STATIC_POINTER(var)  var = 0; if (!var) var
 #endif
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Python-specific SWIG API */
+#define SWIG_newvarlink()                             SWIG_Python_newvarlink()
+#define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
+#define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)
+ 
+/* -----------------------------------------------------------------------------
+ * global variable support code.
+ * ----------------------------------------------------------------------------- */
+ 
+typedef struct swig_globalvar {   
+  char       *name;                  /* Name of global variable */
+  PyObject *(*get_attr)(void);       /* Return the current value */
+  int       (*set_attr)(PyObject *); /* Set the value */
+  struct swig_globalvar *next;
+} swig_globalvar;
+
+typedef struct swig_varlinkobject {
+  PyObject_HEAD
+  swig_globalvar *vars;
+} swig_varlinkobject;
+
+SWIGINTERN PyObject *
+swig_varlink_repr(PyObject *SWIGUNUSEDPARM(v)) {
+#if PY_VERSION_HEX >= 0x03000000
+  return PyUnicode_InternFromString("<Swig global variables>");
+#else
+  return PyString_FromString("<Swig global variables>");
+#endif
+}
+
+SWIGINTERN PyObject *
+swig_varlink_str(PyObject *o) {
+  swig_varlinkobject *v = (swig_varlinkobject *) o;
+#if PY_VERSION_HEX >= 0x03000000
+  PyObject *str = PyUnicode_InternFromString("(");
+  PyObject *tail;
+  PyObject *joined;
+  swig_globalvar *var;
+  for (var = v->vars; var; var=var->next) {
+    tail = PyUnicode_FromString(var->name);
+    joined = PyUnicode_Concat(str, tail);
+    Py_DecRef(str);
+    Py_DecRef(tail);
+    str = joined;
+    if (var->next) {
+        tail = PyUnicode_InternFromString(", ");
+        joined = PyUnicode_Concat(str, tail);
+        Py_DecRef(str);
+        Py_DecRef(tail);
+        str = joined;
+    }
+  }
+  tail = PyUnicode_InternFromString(")");
+  joined = PyUnicode_Concat(str, tail);
+  Py_DecRef(str);
+  Py_DecRef(tail);
+  str = joined;
+#else
+  PyObject *str = PyString_FromString("(");
+  swig_globalvar *var;
+  for (var = v->vars; var; var=var->next) {
+    PyString_ConcatAndDel(&str,PyString_FromString(var->name));
+    if (var->next) PyString_ConcatAndDel(&str,PyString_FromString(", "));
+  }
+  PyString_ConcatAndDel(&str,PyString_FromString(")"));
+#endif
+  return str;
+}
+
+SWIGINTERN void
+swig_varlink_dealloc(PyObject *o) {
+  swig_varlinkobject *v = (swig_varlinkobject *) o;
+  swig_globalvar *var = v->vars;
+  while (var) {
+    swig_globalvar *n = var->next;
+    free(var->name);
+    free(var);
+    var = n;
+  }
+}
+
+SWIGINTERN PyObject *
+swig_varlink_getattr(PyObject *o, char *n) {
+  swig_varlinkobject *v = (swig_varlinkobject *) o;
+  PyObject *res = NULL;
+  swig_globalvar *var = v->vars;
+  while (var) {
+    if (strcmp(var->name,n) == 0) {
+      res = (*var->get_attr)();
+      break;
+    }
+    var = var->next;
+  }
+  if (res == NULL && !PyErr_Occurred()) {
+    PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
+  }
+  return res;
+}
+
+SWIGINTERN int
+swig_varlink_setattr(PyObject *o, char *n, PyObject *p) {
+  swig_varlinkobject *v = (swig_varlinkobject *) o;
+  int res = 1;
+  swig_globalvar *var = v->vars;
+  while (var) {
+    if (strcmp(var->name,n) == 0) {
+      res = (*var->set_attr)(p);
+      break;
+    }
+    var = var->next;
+  }
+  if (res == 1 && !PyErr_Occurred()) {
+    PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
+  }
+  return res;
+}
+
+SWIGINTERN PyTypeObject*
+swig_varlink_type(void) {
+  static char varlink__doc__[] = "Swig var link object";
+  static PyTypeObject varlink_type;
+  static int type_init = 0;
+  if (!type_init) {
+    const PyTypeObject tmp = {
+#if PY_VERSION_HEX >= 0x03000000
+      PyVarObject_HEAD_INIT(NULL, 0)
+#else
+      PyObject_HEAD_INIT(NULL)
+      0,                                  /* ob_size */
+#endif
+      "swigvarlink",                      /* tp_name */
+      sizeof(swig_varlinkobject),         /* tp_basicsize */
+      0,                                  /* tp_itemsize */
+      (destructor) swig_varlink_dealloc,  /* tp_dealloc */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                       /*tp_print*/
+#else
+      (Py_ssize_t)0,                      /*tp_vectorcall_offset*/
+#endif
+      (getattrfunc) swig_varlink_getattr, /* tp_getattr */
+      (setattrfunc) swig_varlink_setattr, /* tp_setattr */
+      0,                                  /* tp_compare */
+      (reprfunc) swig_varlink_repr,       /* tp_repr */
+      0,                                  /* tp_as_number */
+      0,                                  /* tp_as_sequence */
+      0,                                  /* tp_as_mapping */
+      0,                                  /* tp_hash */
+      0,                                  /* tp_call */
+      (reprfunc) swig_varlink_str,        /* tp_str */
+      0,                                  /* tp_getattro */
+      0,                                  /* tp_setattro */
+      0,                                  /* tp_as_buffer */
+      0,                                  /* tp_flags */
+      varlink__doc__,                     /* tp_doc */
+      0,                                  /* tp_traverse */
+      0,                                  /* tp_clear */
+      0,                                  /* tp_richcompare */
+      0,                                  /* tp_weaklistoffset */
+      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
+      0,                                  /* tp_del */
+      0,                                  /* tp_version_tag */
+#if PY_VERSION_HEX >= 0x03040000
+      0,                                  /* tp_finalize */
+#endif
+#if PY_VERSION_HEX >= 0x03080000
+      0,                                  /* tp_vectorcall */
+#endif
+#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
+      0,                                  /* tp_print */
+#endif
+#ifdef COUNT_ALLOCS
+      0,                                  /* tp_allocs */
+      0,                                  /* tp_frees */
+      0,                                  /* tp_maxalloc */
+      0,                                  /* tp_prev */
+      0                                   /* tp_next */
+#endif
+    };
+    varlink_type = tmp;
+    type_init = 1;
+    if (PyType_Ready(&varlink_type) < 0)
+      return NULL;
+  }
+  return &varlink_type;
+}
+
+/* Create a variable linking object for use later */
+SWIGINTERN PyObject *
+SWIG_Python_newvarlink(void) {
+  swig_varlinkobject *result = PyObject_NEW(swig_varlinkobject, swig_varlink_type());
+  if (result) {
+    result->vars = 0;
+  }
+  return ((PyObject*) result);
+}
+
+SWIGINTERN void 
+SWIG_Python_addvarlink(PyObject *p, const char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
+  swig_varlinkobject *v = (swig_varlinkobject *) p;
+  swig_globalvar *gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
+  if (gv) {
+    size_t size = strlen(name)+1;
+    gv->name = (char *)malloc(size);
+    if (gv->name) {
+      memcpy(gv->name, name, size);
+      gv->get_attr = get_attr;
+      gv->set_attr = set_attr;
+      gv->next = v->vars;
+    }
+  }
+  v->vars = gv;
+}
+
+
+static PyObject *Swig_Globals_global = NULL;
+  
+SWIGINTERN PyObject *
+SWIG_globals(void) {
+  if (Swig_Globals_global == NULL) {
+    Swig_Globals_global = SWIG_newvarlink();
+  }
+  return Swig_Globals_global;
+}
+
+#ifdef __cplusplus
+}
+#endif
+
 /* -----------------------------------------------------------------------------
  * Pointer declarations
  * ----------------------------------------------------------------------------- */
 
 /* Flags for new pointer objects */
 #define SWIG_POINTER_NOSHADOW       (SWIG_POINTER_OWN      << 1)
 #define SWIG_POINTER_NEW            (SWIG_POINTER_NOSHADOW | SWIG_POINTER_OWN)
@@ -1316,52 +1570,59 @@
     SwigPyClientData *data = (SwigPyClientData *)malloc(sizeof(SwigPyClientData));
     /* the klass element */
     data->klass = obj;
     Py_INCREF(data->klass);
     /* the newraw method and newargs arguments used to create a new raw instance */
     if (PyClass_Check(obj)) {
       data->newraw = 0;
-      data->newargs = obj;
       Py_INCREF(obj);
+      data->newargs = obj;
     } else {
       data->newraw = PyObject_GetAttrString(data->klass, "__new__");
       if (data->newraw) {
-	Py_INCREF(data->newraw);
-	data->newargs = PyTuple_New(1);
-	PyTuple_SetItem(data->newargs, 0, obj);
+        data->newargs = PyTuple_New(1);
+        if (data->newargs) {
+          Py_INCREF(obj);
+          PyTuple_SET_ITEM(data->newargs, 0, obj);
+        } else {
+          Py_DECREF(data->newraw);
+          Py_DECREF(data->klass);
+          free(data);
+          return 0;
+        }
       } else {
-	data->newargs = obj;
+        Py_INCREF(obj);
+        data->newargs = obj;
       }
-      Py_INCREF(data->newargs);
     }
     /* the destroy method, aka as the C++ delete method */
     data->destroy = PyObject_GetAttrString(data->klass, "__swig_destroy__");
     if (PyErr_Occurred()) {
       PyErr_Clear();
       data->destroy = 0;
     }
     if (data->destroy) {
-      int flags;
-      Py_INCREF(data->destroy);
-      flags = PyCFunction_GET_FLAGS(data->destroy);
-      data->delargs = !(flags & (METH_O));
+      data->delargs = !(PyCFunction_GET_FLAGS(data->destroy) & METH_O);
     } else {
       data->delargs = 0;
     }
     data->implicitconv = 0;
     data->pytype = 0;
     return data;
   }
 }
 
 SWIGRUNTIME void 
-SwigPyClientData_Del(SwigPyClientData *data) {
+SwigPyClientData_Del(SwigPyClientData *data)
+{
+  Py_XDECREF(data->klass);
   Py_XDECREF(data->newraw);
   Py_XDECREF(data->newargs);
   Py_XDECREF(data->destroy);
+  free(data);
 }
 
 /* =============== SwigPyObject =====================*/
 
 typedef struct {
   PyObject_HEAD
   void *ptr;
@@ -1380,15 +1641,15 @@
 SwigPyObject_get___dict__(PyObject *v, PyObject *SWIGUNUSEDPARM(args))
 {
   SwigPyObject *sobj = (SwigPyObject *)v;
 
   if (!sobj->dict)
     sobj->dict = PyDict_New();
 
-  Py_INCREF(sobj->dict);
+  Py_XINCREF(sobj->dict);
   return sobj->dict;
 }
 
 #endif
 
 SWIGRUNTIME PyObject *
 SwigPyObject_long(SwigPyObject *v)
@@ -1398,26 +1659,29 @@
 
 SWIGRUNTIME PyObject *
 SwigPyObject_format(const char* fmt, SwigPyObject *v)
 {
   PyObject *res = NULL;
   PyObject *args = PyTuple_New(1);
   if (args) {
-    if (PyTuple_SetItem(args, 0, SwigPyObject_long(v)) == 0) {
-      PyObject *ofmt = SWIG_Python_str_FromChar(fmt);
+    PyObject *val = SwigPyObject_long(v);
+    if (val) {
+      PyObject *ofmt;
+      PyTuple_SET_ITEM(args, 0, val);
+      ofmt = SWIG_Python_str_FromChar(fmt);
       if (ofmt) {
 #if PY_VERSION_HEX >= 0x03000000
-	res = PyUnicode_Format(ofmt,args);
+        res = PyUnicode_Format(ofmt,args);
 #else
-	res = PyString_Format(ofmt,args);
+        res = PyString_Format(ofmt,args);
 #endif
-	Py_DECREF(ofmt);
+        Py_DECREF(ofmt);
       }
-      Py_DECREF(args);
     }
+    Py_DECREF(args);
   }
   return res;
 }
 
 SWIGRUNTIME PyObject *
 SwigPyObject_oct(SwigPyObject *v)
 {
@@ -1431,26 +1695,31 @@
 }
 
 SWIGRUNTIME PyObject *
 SwigPyObject_repr(SwigPyObject *v)
 {
   const char *name = SWIG_TypePrettyName(v->ty);
   PyObject *repr = SWIG_Python_str_FromFormat("<Swig Object of type '%s' at %p>", (name ? name : "unknown"), (void *)v);
-  if (v->next) {
+  if (repr && v->next) {
     PyObject *nrep = SwigPyObject_repr((SwigPyObject *)v->next);
+    if (nrep) {
 # if PY_VERSION_HEX >= 0x03000000
-    PyObject *joined = PyUnicode_Concat(repr, nrep);
-    Py_DecRef(repr);
-    Py_DecRef(nrep);
-    repr = joined;
+      PyObject *joined = PyUnicode_Concat(repr, nrep);
+      Py_DecRef(repr);
+      Py_DecRef(nrep);
+      repr = joined;
 # else
-    PyString_ConcatAndDel(&repr,nrep);
+      PyString_ConcatAndDel(&repr,nrep);
 # endif
+    } else {
+      Py_DecRef(repr);
+      repr = NULL;
+    }
   }
-  return repr;  
+  return repr;
 }
 
 /* We need a version taking two PyObject* parameters so it's a valid
  * PyCFunction to use in swigobject_methods[]. */
 SWIGRUNTIME PyObject *
 SwigPyObject_repr2(PyObject *v, PyObject *SWIGUNUSEDPARM(args))
 {
@@ -1512,14 +1781,16 @@
     || (strcmp(Py_TYPE(op)->tp_name,"SwigPyObject") == 0);
 #endif
 }
 
 SWIGRUNTIME PyObject *
 SwigPyObject_New(void *ptr, swig_type_info *ty, int own);
 
+static PyObject* Swig_Capsule_global = NULL;
+
 SWIGRUNTIME void
 SwigPyObject_dealloc(PyObject *v)
 {
   SwigPyObject *sobj = (SwigPyObject *) v;
   PyObject *next = sobj->next;
   if (sobj->own == SWIG_POINTER_OWN) {
     swig_type_info *ty = sobj->ty;
@@ -1538,16 +1809,20 @@
       
       PyObject *type = NULL, *value = NULL, *traceback = NULL;
       PyErr_Fetch(&type, &value, &traceback);
 
       if (data->delargs) {
         /* we need to create a temporary object to carry the destroy operation */
         PyObject *tmp = SwigPyObject_New(sobj->ptr, ty, 0);
-        res = SWIG_Python_CallFunctor(destroy, tmp);
-        Py_DECREF(tmp);
+        if (tmp) {
+          res = SWIG_Python_CallFunctor(destroy, tmp);
+        } else {
+          res = 0;
+        }
+        Py_XDECREF(tmp);
       } else {
         PyCFunction meth = PyCFunction_GET_FUNCTION(destroy);
         PyObject *mself = PyCFunction_GET_SELF(destroy);
         res = ((*meth)(mself, v));
       }
       if (!res)
         PyErr_WriteUnraisable(destroy);
@@ -1558,27 +1833,32 @@
     } 
 #if !defined(SWIG_PYTHON_SILENT_MEMLEAK)
     else {
       const char *name = SWIG_TypePrettyName(ty);
       printf("swig/python detected a memory leak of type '%s', no destructor found.\n", (name ? name : "unknown"));
     }
 #endif
-  } 
+    Py_XDECREF(Swig_Capsule_global);
+  }
   Py_XDECREF(next);
+#ifdef SWIGPYTHON_BUILTIN
+  Py_XDECREF(sobj->dict);
+#endif
   PyObject_DEL(v);
 }
 
 SWIGRUNTIME PyObject* 
 SwigPyObject_append(PyObject* v, PyObject* next)
 {
   SwigPyObject *sobj = (SwigPyObject *) v;
   if (!SwigPyObject_Check(next)) {
     PyErr_SetString(PyExc_TypeError, "Attempt to append a non SwigPyObject");
     return NULL;
   }
+  ((SwigPyObject *)next)->next = sobj->next;
   sobj->next = next;
   Py_INCREF(next);
   return SWIG_Py_Void();
 }
 
 SWIGRUNTIME PyObject* 
 SwigPyObject_next(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
@@ -1615,17 +1895,17 @@
   if (!PyArg_UnpackTuple(args, "own", 0, 1, &val)) {
     return NULL;
   } else {
     SwigPyObject *sobj = (SwigPyObject *)v;
     PyObject *obj = PyBool_FromLong(sobj->own);
     if (val) {
       if (PyObject_IsTrue(val)) {
-        SwigPyObject_acquire(v,args);
+        Py_DECREF(SwigPyObject_acquire(v,args));
       } else {
-        SwigPyObject_disown(v,args);
+        Py_DECREF(SwigPyObject_disown(v,args));
       }
     } 
     return obj;
   }
 }
 
 static PyMethodDef
@@ -1697,15 +1977,19 @@
       PyObject_HEAD_INIT(NULL)
       0,                                    /* ob_size */
 #endif
       "SwigPyObject",                       /* tp_name */
       sizeof(SwigPyObject),                 /* tp_basicsize */
       0,                                    /* tp_itemsize */
       (destructor)SwigPyObject_dealloc,     /* tp_dealloc */
-      0,                                    /* tp_print */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                         /*tp_print*/
+#else
+      (Py_ssize_t)0,                        /*tp_vectorcall_offset*/
+#endif
       (getattrfunc)0,                       /* tp_getattr */
       (setattrfunc)0,                       /* tp_setattr */
 #if PY_VERSION_HEX >= 0x03000000
       0, /* tp_reserved in 3.0.1, tp_compare in 3.0.0 but not used */
 #else
       (cmpfunc)SwigPyObject_compare,        /* tp_compare */
 #endif
@@ -1762,29 +2046,38 @@
       0,                                    /* tp_maxalloc */
       0,                                    /* tp_prev */
       0                                     /* tp_next */
 #endif
     };
     swigpyobject_type = tmp;
     type_init = 1;
-    if (PyType_Ready(&swigpyobject_type) < 0)
+    if (PyType_Ready(&swigpyobject_type) != 0)
       return NULL;
   }
   return &swigpyobject_type;
 }
 
 SWIGRUNTIME PyObject *
 SwigPyObject_New(void *ptr, swig_type_info *ty, int own)
 {
   SwigPyObject *sobj = PyObject_NEW(SwigPyObject, SwigPyObject_type());
   if (sobj) {
     sobj->ptr  = ptr;
     sobj->ty   = ty;
     sobj->own  = own;
     sobj->next = 0;
+#ifdef SWIGPYTHON_BUILTIN
+    sobj->dict = 0;
+#endif
+    if (own == SWIG_POINTER_OWN) {
+      /* Obtain a reference to the Python capsule wrapping the module information, so that the
+       * module information is correctly destroyed after all SWIG python objects have been freed
+       * by the GC (and corresponding destructors invoked) */
+      Py_XINCREF(Swig_Capsule_global);
+    }
   }
   return (PyObject *)sobj;
 }
 
 /* -----------------------------------------------------------------------------
  * Implements a simple Swig Packed type, and use it instead of string
  * ----------------------------------------------------------------------------- */
@@ -1864,15 +2157,19 @@
       PyObject_HEAD_INIT(NULL)
       0,                                    /* ob_size */
 #endif
       "SwigPyPacked",                       /* tp_name */
       sizeof(SwigPyPacked),                 /* tp_basicsize */
       0,                                    /* tp_itemsize */
       (destructor)SwigPyPacked_dealloc,     /* tp_dealloc */
-      0,                                    /* tp_print */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                         /*tp_print*/
+#else
+      (Py_ssize_t)0,                        /*tp_vectorcall_offset*/
+#endif
       (getattrfunc)0,                       /* tp_getattr */
       (setattrfunc)0,                       /* tp_setattr */
 #if PY_VERSION_HEX>=0x03000000
       0, /* tp_reserved in 3.0.1 */
 #else
       (cmpfunc)SwigPyPacked_compare,        /* tp_compare */
 #endif
@@ -1929,15 +2226,15 @@
       0,                                    /* tp_maxalloc */
       0,                                    /* tp_prev */
       0                                     /* tp_next */
 #endif
     };
     swigpypacked_type = tmp;
     type_init = 1;
-    if (PyType_Ready(&swigpypacked_type) < 0)
+    if (PyType_Ready(&swigpypacked_type) != 0)
       return NULL;
   }
   return &swigpypacked_type;
 }
 
 SWIGRUNTIME PyObject *
 SwigPyPacked_New(void *ptr, size_t size, swig_type_info *ty)
@@ -2119,20 +2416,27 @@
       }
     } else {
       if (ptr) *ptr = vptr;
       break;
     }
   }
   if (sobj) {
-    if (own)
-      *own = *own | sobj->own;
-    if (flags & SWIG_POINTER_DISOWN) {
-      sobj->own = 0;
+    if (((flags & SWIG_POINTER_RELEASE) == SWIG_POINTER_RELEASE) && !sobj->own) {
+      res = SWIG_ERROR_RELEASE_NOT_OWNED;
+    } else {
+      if (own)
+        *own = *own | sobj->own;
+      if (flags & SWIG_POINTER_DISOWN) {
+        sobj->own = 0;
+      }
+      if (flags & SWIG_POINTER_CLEAR) {
+        sobj->ptr = 0;
+      }
+      res = SWIG_OK;
     }
-    res = SWIG_OK;
   } else {
     if (implicit_conv) {
       SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
       if (data && !data->implicitconv) {
         PyObject *klass = data->klass;
         if (klass) {
           PyObject *impconv;
@@ -2237,20 +2541,25 @@
   PyObject *newraw = data->newraw;
   if (newraw) {
     inst = PyObject_Call(newraw, data->newargs, NULL);
     if (inst) {
 #if !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
       PyObject **dictptr = _PyObject_GetDictPtr(inst);
       if (dictptr != NULL) {
-	PyObject *dict = *dictptr;
-	if (dict == NULL) {
-	  dict = PyDict_New();
-	  *dictptr = dict;
-	  PyDict_SetItem(dict, SWIG_This(), swig_this);
-	}
+        PyObject *dict = *dictptr;
+        if (dict == NULL) {
+          dict = PyDict_New();
+          *dictptr = dict;
+        }
+        if (dict) {
+          PyDict_SetItem(dict, SWIG_This(), swig_this);
+        } else{
+          Py_DECREF(inst);
+          inst = 0;
+        }
       }
 #else
       if (PyObject_SetAttr(inst, SWIG_This(), swig_this) == -1) {
         Py_DECREF(inst);
         inst = 0;
       }
 #endif
@@ -2264,15 +2573,15 @@
         inst = ((PyTypeObject *)data->newargs)->tp_new((PyTypeObject *)data->newargs, empty_args, empty_kwargs);
         Py_DECREF(empty_kwargs);
         if (inst) {
           if (PyObject_SetAttr(inst, SWIG_This(), swig_this) == -1) {
             Py_DECREF(inst);
             inst = 0;
           } else {
-            Py_TYPE(inst)->tp_flags &= ~Py_TPFLAGS_VALID_VERSION_TAG;
+            PyType_Modified(Py_TYPE(inst));
           }
         }
       }
       Py_DECREF(empty_args);
     }
 #else
     PyObject *dict = PyDict_New();
@@ -2293,30 +2602,34 @@
   PyObject **dictptr = _PyObject_GetDictPtr(inst);
   if (dictptr != NULL) {
     PyObject *dict = *dictptr;
     if (dict == NULL) {
       dict = PyDict_New();
       *dictptr = dict;
     }
-    return PyDict_SetItem(dict, SWIG_This(), swig_this);
+    if (dict) {
+      return PyDict_SetItem(dict, SWIG_This(), swig_this);
+    } else{
+      return -1;
+    }
   }
 #endif
   return PyObject_SetAttr(inst, SWIG_This(), swig_this);
 } 
 
 
 SWIGINTERN PyObject *
 SWIG_Python_InitShadowInstance(PyObject *args) {
   PyObject *obj[2];
   if (!SWIG_Python_UnpackTuple(args, "swiginit", 2, 2, obj)) {
     return NULL;
   } else {
     SwigPyObject *sthis = SWIG_Python_GetSwigThis(obj[0]);
     if (sthis) {
-      SwigPyObject_append((PyObject*) sthis, obj[1]);
+      Py_DECREF(SwigPyObject_append((PyObject*) sthis, obj[1]));
     } else {
       if (SWIG_Python_SetSwigThis(obj[0], obj[1]) != 0)
         return NULL;
     }
     return SWIG_Py_Void();
   }
 }
@@ -2347,15 +2660,17 @@
 #ifdef SWIGPYTHON_BUILTIN
         newobj->dict = 0;
 #endif
       }
     } else {
       newobj = PyObject_New(SwigPyObject, clientdata->pytype);
 #ifdef SWIGPYTHON_BUILTIN
-      newobj->dict = 0;
+      if (newobj) {
+        newobj->dict = 0;
+      }
 #endif
     }
     if (newobj) {
       newobj->ptr = ptr;
       newobj->ty = type;
       newobj->own = own;
       newobj->next = 0;
@@ -2386,89 +2701,111 @@
  *  Get type list 
  * -----------------------------------------------------------------------------*/
 
 #ifdef SWIG_LINK_RUNTIME
 void *SWIG_ReturnGlobalTypeList(void *);
 #endif
 
+static PyObject *Swig_TypeCache_global = NULL;
+
+/* The python cached type query */
+SWIGRUNTIME PyObject *
+SWIG_Python_TypeCache(void) {
+  if (Swig_TypeCache_global == NULL) {
+    Swig_TypeCache_global = PyDict_New();
+  }
+  return Swig_TypeCache_global;
+}
+
 SWIGRUNTIME swig_module_info *
 SWIG_Python_GetModule(void *SWIGUNUSEDPARM(clientdata)) {
+#ifdef SWIG_LINK_RUNTIME
   static void *type_pointer = (void *)0;
   /* first check if module already created */
   if (!type_pointer) {
-#ifdef SWIG_LINK_RUNTIME
     type_pointer = SWIG_ReturnGlobalTypeList((void *)0);
+  }
 #else
-    type_pointer = PyCapsule_Import(SWIGPY_CAPSULE_NAME, 0);
-    if (PyErr_Occurred()) {
-      PyErr_Clear();
-      type_pointer = (void *)0;
-    }
-#endif
+  void *type_pointer = PyCapsule_Import(SWIGPY_CAPSULE_NAME, 0);
+  if (PyErr_Occurred()) {
+    PyErr_Clear();
+    type_pointer = (void *)0;
   }
+#endif
   return (swig_module_info *) type_pointer;
 }
 
+
+static int interpreter_counter = 0; // how many (sub-)interpreters are using swig_module's types
+
 SWIGRUNTIME void
 SWIG_Python_DestroyModule(PyObject *obj)
 {
   swig_module_info *swig_module = (swig_module_info *) PyCapsule_GetPointer(obj, SWIGPY_CAPSULE_NAME);
   swig_type_info **types = swig_module->types;
   size_t i;
+  if (--interpreter_counter != 0) // another sub-interpreter may still be using the swig_module's types
+    return;
   for (i =0; i < swig_module->size; ++i) {
     swig_type_info *ty = types[i];
     if (ty->owndata) {
       SwigPyClientData *data = (SwigPyClientData *) ty->clientdata;
+      ty->clientdata = 0;
       if (data) SwigPyClientData_Del(data);
     }
   }
   Py_DECREF(SWIG_This());
   Swig_This_global = NULL;
+  Py_DECREF(SWIG_globals());
+  Swig_Globals_global = NULL;
+  Py_DECREF(SWIG_Python_TypeCache());
+  Swig_TypeCache_global = NULL;
+  Swig_Capsule_global = NULL;
 }
 
 SWIGRUNTIME void
 SWIG_Python_SetModule(swig_module_info *swig_module) {
 #if PY_VERSION_HEX >= 0x03000000
  /* Add a dummy module object into sys.modules */
   PyObject *module = PyImport_AddModule("swig_runtime_data" SWIG_RUNTIME_VERSION);
 #else
   static PyMethodDef swig_empty_runtime_method_table[] = { {NULL, NULL, 0, NULL} }; /* Sentinel */
   PyObject *module = Py_InitModule("swig_runtime_data" SWIG_RUNTIME_VERSION, swig_empty_runtime_method_table);
 #endif
   PyObject *pointer = PyCapsule_New((void *) swig_module, SWIGPY_CAPSULE_NAME, SWIG_Python_DestroyModule);
   if (pointer && module) {
-    PyModule_AddObject(module, "type_pointer_capsule" SWIG_TYPE_TABLE_NAME, pointer);
+    if (PyModule_AddObject(module, SWIGPY_CAPSULE_ATTR_NAME, pointer) == 0) {
+      ++interpreter_counter;
+      Swig_Capsule_global = pointer;
+    } else {
+      Py_DECREF(pointer);
+    }
   } else {
     Py_XDECREF(pointer);
   }
 }
 
-/* The python cached type query */
-SWIGRUNTIME PyObject *
-SWIG_Python_TypeCache(void) {
-  static PyObject *SWIG_STATIC_POINTER(cache) = PyDict_New();
-  return cache;
-}
-
 SWIGRUNTIME swig_type_info *
 SWIG_Python_TypeQuery(const char *type)
 {
   PyObject *cache = SWIG_Python_TypeCache();
   PyObject *key = SWIG_Python_str_FromChar(type); 
   PyObject *obj = PyDict_GetItem(cache, key);
   swig_type_info *descriptor;
   if (obj) {
     descriptor = (swig_type_info *) PyCapsule_GetPointer(obj, NULL);
   } else {
     swig_module_info *swig_module = SWIG_GetModule(0);
     descriptor = SWIG_TypeQueryModule(swig_module, swig_module, type);
     if (descriptor) {
       obj = PyCapsule_New((void*) descriptor, NULL, NULL);
-      PyDict_SetItem(cache, key, obj);
-      Py_DECREF(obj);
+      if (obj) {
+        PyDict_SetItem(cache, key, obj);
+        Py_DECREF(obj);
+      }
     }
   }
   Py_DECREF(key);
   return descriptor;
 }
 
 /* 
@@ -2493,15 +2830,14 @@
       Py_XINCREF(type);
       PyErr_Clear();
       if (infront) {
 	PyErr_Format(type, "%s %s", mesg, errmesg);
       } else {
 	PyErr_Format(type, "%s %s", errmesg, mesg);
       }
-      SWIG_Python_str_DelForPy3(tmp);
       Py_DECREF(old_str);
     }
     return 1;
   } else {
     return 0;
   }
 }
@@ -2545,15 +2881,14 @@
       const char *otype = (obj ? obj->ob_type->tp_name : 0); 
       if (otype) {
 	PyObject *str = PyObject_Str(obj);
 	const char *cstr = str ? SWIG_Python_str_AsChar(str) : 0;
 	if (cstr) {
 	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s(%s)' is received",
 		       type, otype, cstr);
-          SWIG_Python_str_DelForPy3(cstr);
 	} else {
 	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s' is received",
 		       type, otype);
 	}
 	Py_XDECREF(str);
 	return;
       }
@@ -2567,20 +2902,14 @@
 
 /* Convert a pointer value, signal an exception on a type mismatch */
 SWIGRUNTIME void *
 SWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int SWIGUNUSEDPARM(argnum), int flags) {
   void *result;
   if (SWIG_Python_ConvertPtr(obj, &result, ty, flags) == -1) {
     PyErr_Clear();
-#if SWIG_POINTER_EXCEPTION
-    if (flags) {
-      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);
-      SWIG_Python_ArgFail(argnum);
-    }
-#endif
   }
   return result;
 }
 
 #ifdef SWIGPYTHON_BUILTIN
 SWIGRUNTIME int
 SWIG_Python_NonDynamicSetAttr(PyObject *obj, PyObject *name, PyObject *value) {
@@ -2603,30 +2932,30 @@
     PyErr_Format(PyExc_TypeError, "attribute name must be string, not '%.200s'", name->ob_type->tp_name);
     return -1;
   } else {
     Py_INCREF(name);
   }
 
   if (!tp->tp_dict) {
-    if (PyType_Ready(tp) < 0)
+    if (PyType_Ready(tp) != 0)
       goto done;
   }
 
   descr = _PyType_Lookup(tp, name);
   f = NULL;
   if (descr != NULL)
     f = descr->ob_type->tp_descr_set;
   if (!f) {
     if (PyString_Check(name)) {
       encoded_name = name;
       Py_INCREF(name);
     } else {
       encoded_name = PyUnicode_AsUTF8String(name);
       if (!encoded_name)
-        return -1;
+        goto done;
     }
     PyErr_Format(PyExc_AttributeError, "'%.100s' object has no attribute '%.200s'", tp->tp_name, PyString_AsString(encoded_name));
     Py_DECREF(encoded_name);
   } else {
     res = f(descr, obj, value);
   }
   
@@ -2645,15 +2974,19 @@
 extern "C" {
 #endif
 
 SWIGINTERN Py_hash_t
 SwigPyObject_hash(PyObject *obj) {
   SwigPyObject *sobj = (SwigPyObject *)obj;
   void *ptr = sobj->ptr;
+#if PY_VERSION_HEX < 0x03020000
+  return (Py_hash_t)(Py_ssize_t)ptr;
+#else
   return (Py_hash_t)ptr;
+#endif
 }
 
 SWIGINTERN Py_hash_t
 SWIG_PyNumber_AsPyHash(PyObject *obj) {
   Py_hash_t result = -1;
 #if PY_VERSION_HEX < 0x03020000
   if (PyInt_Check(obj))
@@ -2850,15 +3183,19 @@
       PyObject_HEAD_INIT(&PyType_Type)
       0,                                        /* ob_size */
 #endif
       "swig_static_var_getset_descriptor",      /* tp_name */
       sizeof(PyGetSetDescrObject),              /* tp_basicsize */
       0,                                        /* tp_itemsize */
       (destructor)SwigPyStaticVar_dealloc,      /* tp_dealloc */
-      0,                                        /* tp_print */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                             /* tp_print */
+#else
+      (Py_ssize_t)0,                            /* tp_vectorcall_offset */
+#endif
       0,                                        /* tp_getattr */
       0,                                        /* tp_setattr */
       0,                                        /* tp_compare */
       (reprfunc)SwigPyStaticVar_repr,           /* tp_repr */
       0,                                        /* tp_as_number */
       0,                                        /* tp_as_sequence */
       0,                                        /* tp_as_mapping */
@@ -2934,15 +3271,19 @@
       PyObject_HEAD_INIT(&PyType_Type)
       0,                                        /* ob_size */
 #endif
       "SwigPyObjectType",                       /* tp_name */
       PyType_Type.tp_basicsize,                 /* tp_basicsize */
       0,                                        /* tp_itemsize */
       0,                                        /* tp_dealloc */
-      0,                                        /* tp_print */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                             /* tp_print */
+#else
+      (Py_ssize_t)0,                            /* tp_vectorcall_offset */
+#endif
       0,                                        /* tp_getattr */
       0,                                        /* tp_setattr */
       0,                                        /* tp_compare */
       0,                                        /* tp_repr */
       0,                                        /* tp_as_number */
       0,                                        /* tp_as_sequence */
       0,                                        /* tp_as_mapping */
@@ -3053,18 +3394,18 @@
   Py_XINCREF(result);
   return result;
 }
 
 SWIGINTERN void
 SwigPyBuiltin_SetMetaType (PyTypeObject *type, PyTypeObject *metatype)
 {
-#if PY_VERSION_HEX >= 0x03000000
-    type->ob_base.ob_base.ob_type = metatype;
+#if PY_VERSION_HEX >= 0x030900a4
+    Py_SET_TYPE(type, metatype);
 #else
-    type->ob_type = metatype;
+    Py_TYPE(type) = metatype;
 #endif
 }
 
 
 /* Start of callback function macros for use in PyTypeObject */
 
 typedef PyObject *(*SwigPyWrapperFunction)(PyObject *, PyObject *);
@@ -3394,32 +3735,17 @@
 #endif
 
 
 
 
 #define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 
 
-#define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 
-
+#define SWIG_contract_assert(expr, msg) do { if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } } while (0) 
 
 
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* Method creation and docstring support functions */
-
-SWIGINTERN PyMethodDef *SWIG_PythonGetProxyDoc(const char *name);
-SWIGINTERN PyObject *SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func);
-SWIGINTERN PyObject *SWIG_PyStaticMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func);
-
-#ifdef __cplusplus
-}
-#endif
-
 
 /* -------- TYPES TABLE (BEGIN) -------- */
 
 #define SWIGTYPE_p_CameraAbilities swig_types[0]
 #define SWIGTYPE_p_CameraCaptureType swig_types[1]
 #define SWIGTYPE_p_CameraDriverStatus swig_types[2]
 #define SWIGTYPE_p_CameraEventType swig_types[3]
@@ -3494,18 +3820,14 @@
 
 #else
 #  define SWIG_init    init_abilities_list
 
 #endif
 #define SWIG_name    "_abilities_list"
 
-#define SWIGVERSION 0x040002 
-#define SWIG_VERSION SWIGVERSION
-
-
 #define SWIG_as_voidptr(a) (void *)((const void *)(a)) 
 #define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),(void**)(a)) 
 
 
 #include <stddef.h>
 
 
@@ -3959,16 +4281,16 @@
 PyErr_SetObject(PyExc_GPhoto2Error, PyInt_FromLong(result));
 /*@SWIG@*/
 
 
 
   }
 
-#if GPHOTO2_VERSION < 0x02051d01
-int gp_init_localedir(const char *localedir) {
+#if GPHOTO2_VERSION < 0x02051e00
+static int gp_init_localedir(const char *localedir) {
     return GP_ERROR_NOT_SUPPORTED;
 }
 #endif
 
 
 SWIGINTERNINLINE PyObject *
 SWIG_FromCharPtrAndSize(const char* carray, size_t size)
@@ -4014,14 +4336,15 @@
 #ifdef __cplusplus
 extern "C" {
 #endif
 SWIGINTERN int _wrap_new_CameraAbilitiesList(PyObject *self, PyObject *args, PyObject *kwargs) {
   PyObject *resultobj = 0;
   struct _CameraAbilitiesList *result = 0 ;
   
+  (void)self;
   if (!SWIG_Python_CheckNoKeywords(kwargs, "new_CameraAbilitiesList")) SWIG_fail;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "new_CameraAbilitiesList takes no arguments");
   {
     result = (struct _CameraAbilitiesList *)new__CameraAbilitiesList();
     if (PyErr_Occurred()) SWIG_fail;
   }
   resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p__CameraAbilitiesList, SWIG_BUILTIN_INIT |  0 );
@@ -4033,14 +4356,15 @@
 
 SWIGINTERN PyObject *_wrap_delete_CameraAbilitiesList(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraAbilitiesList *arg1 = (struct _CameraAbilitiesList *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_CameraAbilitiesList takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraAbilitiesList, SWIG_POINTER_DISOWN |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CameraAbilitiesList" "', argument " "1"" of type '" "struct _CameraAbilitiesList *""'"); 
   }
   arg1 = (struct _CameraAbilitiesList *)(argp1);
   {
@@ -4057,14 +4381,15 @@
 SWIGINTERN PyObject *_wrap_CameraAbilitiesList___len__(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraAbilitiesList *arg1 = (struct _CameraAbilitiesList *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   int result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraAbilitiesList___len__ takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraAbilitiesList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraAbilitiesList___len__" "', argument " "1"" of type '" "struct _CameraAbilitiesList *""'"); 
   }
   arg1 = (struct _CameraAbilitiesList *)(argp1);
   {
@@ -4092,14 +4417,15 @@
   {
     arg3 = (CameraAbilities *)calloc(1, sizeof(CameraAbilities));
     if (arg3 == NULL) {
       PyErr_SetString(PyExc_MemoryError, "Cannot allocate " "CameraAbilities");
       SWIG_fail;
     }
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "CameraAbilitiesList___getitem__", 1, 1, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraAbilitiesList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraAbilitiesList___getitem__" "', argument " "1"" of type '" "struct _CameraAbilitiesList *""'"); 
   }
   arg1 = (struct _CameraAbilitiesList *)(argp1);
   ecode2 = SWIG_AsVal_int(obj1, &val2);
@@ -4138,14 +4464,15 @@
   void *argp2 = 0 ;
   int res2 = 0 ;
   PyObject * obj1 = 0 ;
   
   {
     arg2 = NULL;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "CameraAbilitiesList_load", 0, 1, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraAbilitiesList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraAbilitiesList_load" "', argument " "1"" of type '" "struct _CameraAbilitiesList *""'"); 
   }
   arg1 = (struct _CameraAbilitiesList *)(argp1);
   if (obj1) {
@@ -4180,14 +4507,15 @@
   int res3 = 0 ;
   PyObject * obj1 = 0 ;
   PyObject * obj2 = 0 ;
   
   {
     arg3 = NULL;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "CameraAbilitiesList_load_dir", 1, 2, &obj1, &obj2)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraAbilitiesList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraAbilitiesList_load_dir" "', argument " "1"" of type '" "struct _CameraAbilitiesList *""'"); 
   }
   arg1 = (struct _CameraAbilitiesList *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -4217,14 +4545,15 @@
 
 SWIGINTERN PyObject *_wrap_CameraAbilitiesList_reset(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraAbilitiesList *arg1 = (struct _CameraAbilitiesList *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraAbilitiesList_reset takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraAbilitiesList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraAbilitiesList_reset" "', argument " "1"" of type '" "struct _CameraAbilitiesList *""'"); 
   }
   arg1 = (struct _CameraAbilitiesList *)(argp1);
   {
@@ -4262,14 +4591,15 @@
       arg3 = NULL;
       /*@SWIG:src/gphoto2/common/macros.i,25,GPHOTO2_ERROR@*/
       PyErr_SetObject(PyExc_GPhoto2Error, PyInt_FromLong(error));
       /*@SWIG@*/
       SWIG_fail;
     }
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "CameraAbilitiesList_detect", 1, 2, &obj1, &obj2)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraAbilitiesList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraAbilitiesList_detect" "', argument " "1"" of type '" "struct _CameraAbilitiesList *""'"); 
   }
   arg1 = (struct _CameraAbilitiesList *)(argp1);
   res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p__GPPortInfoList, 0 |  0 );
@@ -4316,14 +4646,15 @@
   CameraAbilities arg2 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   void *argp2 ;
   int res2 = 0 ;
   PyObject * obj1 = 0 ;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "CameraAbilitiesList_append", 1, 1, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraAbilitiesList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraAbilitiesList_append" "', argument " "1"" of type '" "struct _CameraAbilitiesList *""'"); 
   }
   arg1 = (struct _CameraAbilitiesList *)(argp1);
   {
@@ -4351,14 +4682,15 @@
 SWIGINTERN PyObject *_wrap_CameraAbilitiesList_count(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraAbilitiesList *arg1 = (struct _CameraAbilitiesList *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   int result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraAbilitiesList_count takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraAbilitiesList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraAbilitiesList_count" "', argument " "1"" of type '" "struct _CameraAbilitiesList *""'"); 
   }
   arg1 = (struct _CameraAbilitiesList *)(argp1);
   {
@@ -4380,14 +4712,15 @@
   int res1 = 0 ;
   int res2 ;
   char *buf2 = 0 ;
   int alloc2 = 0 ;
   PyObject * obj1 = 0 ;
   int result;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "CameraAbilitiesList_lookup_model", 1, 1, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraAbilitiesList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraAbilitiesList_lookup_model" "', argument " "1"" of type '" "struct _CameraAbilitiesList *""'"); 
   }
   arg1 = (struct _CameraAbilitiesList *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -4422,14 +4755,15 @@
   {
     arg3 = (CameraAbilities *)calloc(1, sizeof(CameraAbilities));
     if (arg3 == NULL) {
       PyErr_SetString(PyExc_MemoryError, "Cannot allocate " "CameraAbilities");
       SWIG_fail;
     }
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "CameraAbilitiesList_get_abilities", 1, 1, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraAbilitiesList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraAbilitiesList_get_abilities" "', argument " "1"" of type '" "struct _CameraAbilitiesList *""'"); 
   }
   arg1 = (struct _CameraAbilitiesList *)(argp1);
   ecode2 = SWIG_AsVal_int(obj1, &val2);
@@ -4468,14 +4802,15 @@
 SWIGINTERN PyObject *_wrap_CameraAbilities_model_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   CameraAbilities *arg1 = (CameraAbilities *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   char *result = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraAbilities_model_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CameraAbilities, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraAbilities_model_get" "', argument " "1"" of type '" "CameraAbilities *""'"); 
   }
   arg1 = (CameraAbilities *)(argp1);
   result = (char *)(char *) ((arg1)->model);
@@ -4495,14 +4830,15 @@
 SWIGINTERN PyObject *_wrap_CameraAbilities_status_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   CameraAbilities *arg1 = (CameraAbilities *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   CameraDriverStatus result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraAbilities_status_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CameraAbilities, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraAbilities_status_get" "', argument " "1"" of type '" "CameraAbilities *""'"); 
   }
   arg1 = (CameraAbilities *)(argp1);
   result = (CameraDriverStatus) ((arg1)->status);
@@ -4516,14 +4852,15 @@
 SWIGINTERN PyObject *_wrap_CameraAbilities_port_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   CameraAbilities *arg1 = (CameraAbilities *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   GPPortType result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraAbilities_port_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CameraAbilities, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraAbilities_port_get" "', argument " "1"" of type '" "CameraAbilities *""'"); 
   }
   arg1 = (CameraAbilities *)(argp1);
   result = (GPPortType) ((arg1)->port);
@@ -4537,14 +4874,15 @@
 SWIGINTERN PyObject *_wrap_CameraAbilities_speed_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   CameraAbilities *arg1 = (CameraAbilities *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   int *result = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraAbilities_speed_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CameraAbilities, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraAbilities_speed_get" "', argument " "1"" of type '" "CameraAbilities *""'"); 
   }
   arg1 = (CameraAbilities *)(argp1);
   result = (int *)(int *) ((arg1)->speed);
@@ -4567,14 +4905,15 @@
 SWIGINTERN PyObject *_wrap_CameraAbilities_operations_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   CameraAbilities *arg1 = (CameraAbilities *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   CameraOperation result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraAbilities_operations_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CameraAbilities, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraAbilities_operations_get" "', argument " "1"" of type '" "CameraAbilities *""'"); 
   }
   arg1 = (CameraAbilities *)(argp1);
   result = (CameraOperation) ((arg1)->operations);
@@ -4588,14 +4927,15 @@
 SWIGINTERN PyObject *_wrap_CameraAbilities_file_operations_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   CameraAbilities *arg1 = (CameraAbilities *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   CameraFileOperation result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraAbilities_file_operations_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CameraAbilities, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraAbilities_file_operations_get" "', argument " "1"" of type '" "CameraAbilities *""'"); 
   }
   arg1 = (CameraAbilities *)(argp1);
   result = (CameraFileOperation) ((arg1)->file_operations);
@@ -4609,14 +4949,15 @@
 SWIGINTERN PyObject *_wrap_CameraAbilities_folder_operations_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   CameraAbilities *arg1 = (CameraAbilities *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   CameraFolderOperation result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraAbilities_folder_operations_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CameraAbilities, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraAbilities_folder_operations_get" "', argument " "1"" of type '" "CameraAbilities *""'"); 
   }
   arg1 = (CameraAbilities *)(argp1);
   result = (CameraFolderOperation) ((arg1)->folder_operations);
@@ -4630,14 +4971,15 @@
 SWIGINTERN PyObject *_wrap_CameraAbilities_usb_vendor_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   CameraAbilities *arg1 = (CameraAbilities *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   int result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraAbilities_usb_vendor_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CameraAbilities, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraAbilities_usb_vendor_get" "', argument " "1"" of type '" "CameraAbilities *""'"); 
   }
   arg1 = (CameraAbilities *)(argp1);
   result = (int) ((arg1)->usb_vendor);
@@ -4651,14 +4993,15 @@
 SWIGINTERN PyObject *_wrap_CameraAbilities_usb_product_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   CameraAbilities *arg1 = (CameraAbilities *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   int result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraAbilities_usb_product_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CameraAbilities, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraAbilities_usb_product_get" "', argument " "1"" of type '" "CameraAbilities *""'"); 
   }
   arg1 = (CameraAbilities *)(argp1);
   result = (int) ((arg1)->usb_product);
@@ -4672,14 +5015,15 @@
 SWIGINTERN PyObject *_wrap_CameraAbilities_usb_class_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   CameraAbilities *arg1 = (CameraAbilities *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   int result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraAbilities_usb_class_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CameraAbilities, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraAbilities_usb_class_get" "', argument " "1"" of type '" "CameraAbilities *""'"); 
   }
   arg1 = (CameraAbilities *)(argp1);
   result = (int) ((arg1)->usb_class);
@@ -4693,14 +5037,15 @@
 SWIGINTERN PyObject *_wrap_CameraAbilities_usb_subclass_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   CameraAbilities *arg1 = (CameraAbilities *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   int result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraAbilities_usb_subclass_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CameraAbilities, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraAbilities_usb_subclass_get" "', argument " "1"" of type '" "CameraAbilities *""'"); 
   }
   arg1 = (CameraAbilities *)(argp1);
   result = (int) ((arg1)->usb_subclass);
@@ -4714,14 +5059,15 @@
 SWIGINTERN PyObject *_wrap_CameraAbilities_usb_protocol_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   CameraAbilities *arg1 = (CameraAbilities *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   int result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraAbilities_usb_protocol_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CameraAbilities, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraAbilities_usb_protocol_get" "', argument " "1"" of type '" "CameraAbilities *""'"); 
   }
   arg1 = (CameraAbilities *)(argp1);
   result = (int) ((arg1)->usb_protocol);
@@ -4735,14 +5081,15 @@
 SWIGINTERN PyObject *_wrap_CameraAbilities_library_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   CameraAbilities *arg1 = (CameraAbilities *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   char *result = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraAbilities_library_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CameraAbilities, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraAbilities_library_get" "', argument " "1"" of type '" "CameraAbilities *""'"); 
   }
   arg1 = (CameraAbilities *)(argp1);
   result = (char *)(char *) ((arg1)->library);
@@ -4762,14 +5109,15 @@
 SWIGINTERN PyObject *_wrap_CameraAbilities_id_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   CameraAbilities *arg1 = (CameraAbilities *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   char *result = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraAbilities_id_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CameraAbilities, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraAbilities_id_get" "', argument " "1"" of type '" "CameraAbilities *""'"); 
   }
   arg1 = (CameraAbilities *)(argp1);
   result = (char *)(char *) ((arg1)->id);
@@ -4789,14 +5137,15 @@
 SWIGINTERN PyObject *_wrap_CameraAbilities_device_type_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   CameraAbilities *arg1 = (CameraAbilities *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   GphotoDeviceType result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraAbilities_device_type_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CameraAbilities, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraAbilities_device_type_get" "', argument " "1"" of type '" "CameraAbilities *""'"); 
   }
   arg1 = (CameraAbilities *)(argp1);
   result = (GphotoDeviceType) ((arg1)->device_type);
@@ -4810,14 +5159,15 @@
 SWIGINTERN PyObject *_wrap_CameraAbilities_reserved2_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   CameraAbilities *arg1 = (CameraAbilities *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   int result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraAbilities_reserved2_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CameraAbilities, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraAbilities_reserved2_get" "', argument " "1"" of type '" "CameraAbilities *""'"); 
   }
   arg1 = (CameraAbilities *)(argp1);
   result = (int) ((arg1)->reserved2);
@@ -4831,14 +5181,15 @@
 SWIGINTERN PyObject *_wrap_CameraAbilities_reserved3_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   CameraAbilities *arg1 = (CameraAbilities *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   int result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraAbilities_reserved3_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CameraAbilities, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraAbilities_reserved3_get" "', argument " "1"" of type '" "CameraAbilities *""'"); 
   }
   arg1 = (CameraAbilities *)(argp1);
   result = (int) ((arg1)->reserved3);
@@ -4852,14 +5203,15 @@
 SWIGINTERN PyObject *_wrap_CameraAbilities_reserved4_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   CameraAbilities *arg1 = (CameraAbilities *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   int result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraAbilities_reserved4_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CameraAbilities, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraAbilities_reserved4_get" "', argument " "1"" of type '" "CameraAbilities *""'"); 
   }
   arg1 = (CameraAbilities *)(argp1);
   result = (int) ((arg1)->reserved4);
@@ -4873,14 +5225,15 @@
 SWIGINTERN PyObject *_wrap_CameraAbilities_reserved5_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   CameraAbilities *arg1 = (CameraAbilities *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   int result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraAbilities_reserved5_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CameraAbilities, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraAbilities_reserved5_get" "', argument " "1"" of type '" "CameraAbilities *""'"); 
   }
   arg1 = (CameraAbilities *)(argp1);
   result = (int) ((arg1)->reserved5);
@@ -4894,14 +5247,15 @@
 SWIGINTERN PyObject *_wrap_CameraAbilities_reserved6_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   CameraAbilities *arg1 = (CameraAbilities *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   int result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraAbilities_reserved6_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CameraAbilities, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraAbilities_reserved6_get" "', argument " "1"" of type '" "CameraAbilities *""'"); 
   }
   arg1 = (CameraAbilities *)(argp1);
   result = (int) ((arg1)->reserved6);
@@ -4915,14 +5269,15 @@
 SWIGINTERN PyObject *_wrap_CameraAbilities_reserved7_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   CameraAbilities *arg1 = (CameraAbilities *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   int result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraAbilities_reserved7_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CameraAbilities, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraAbilities_reserved7_get" "', argument " "1"" of type '" "CameraAbilities *""'"); 
   }
   arg1 = (CameraAbilities *)(argp1);
   result = (int) ((arg1)->reserved7);
@@ -4936,14 +5291,15 @@
 SWIGINTERN PyObject *_wrap_CameraAbilities_reserved8_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   CameraAbilities *arg1 = (CameraAbilities *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   int result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraAbilities_reserved8_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CameraAbilities, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraAbilities_reserved8_get" "', argument " "1"" of type '" "CameraAbilities *""'"); 
   }
   arg1 = (CameraAbilities *)(argp1);
   result = (int) ((arg1)->reserved8);
@@ -4956,14 +5312,15 @@
 
 SWIGINTERN PyObject *_wrap_delete_CameraAbilities(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   CameraAbilities *arg1 = (CameraAbilities *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_CameraAbilities takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CameraAbilities, SWIG_POINTER_DISOWN |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CameraAbilities" "', argument " "1"" of type '" "CameraAbilities *""'"); 
   }
   arg1 = (CameraAbilities *)(argp1);
   free((char *) arg1);
@@ -4982,14 +5339,15 @@
   CameraAbilitiesList *temp1 ;
   int result;
   
   {
     temp1 = NULL;
     arg1 = &temp1;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_abilities_list_new", 0, 0)) SWIG_fail;
   result = (int)gp_abilities_list_new(arg1);
   resultobj = SWIG_From_int((int)(result));
   {
     resultobj = SWIG_Python_AppendOutput(
       resultobj, SWIG_NewPointerObj(*arg1, SWIGTYPE_p__CameraAbilitiesList, SWIG_POINTER_OWN));
   }
@@ -5010,14 +5368,15 @@
   PyObject * obj0 = 0 ;
   PyObject * obj1 = 0 ;
   int result;
   
   {
     arg2 = NULL;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_abilities_list_load", 1, 2, &obj0, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraAbilitiesList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_abilities_list_load" "', argument " "1"" of type '" "CameraAbilitiesList *""'"); 
   }
   arg1 = (CameraAbilitiesList *)(argp1);
   if (obj1) {
@@ -5051,14 +5410,15 @@
   PyObject * obj1 = 0 ;
   PyObject * obj2 = 0 ;
   int result;
   
   {
     arg3 = NULL;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_abilities_list_load_dir", 2, 3, &obj0, &obj1, &obj2)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraAbilitiesList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_abilities_list_load_dir" "', argument " "1"" of type '" "CameraAbilitiesList *""'"); 
   }
   arg1 = (CameraAbilitiesList *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -5087,14 +5447,15 @@
   PyObject *resultobj = 0;
   CameraAbilitiesList *arg1 = (CameraAbilitiesList *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   PyObject * obj0 = 0 ;
   int result;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_abilities_list_reset", 1, 1, &obj0)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraAbilitiesList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_abilities_list_reset" "', argument " "1"" of type '" "CameraAbilitiesList *""'"); 
   }
   arg1 = (CameraAbilitiesList *)(argp1);
   result = (int)gp_abilities_list_reset(arg1);
@@ -5131,14 +5492,15 @@
       arg3 = NULL;
       /*@SWIG:src/gphoto2/common/macros.i,25,GPHOTO2_ERROR@*/
       PyErr_SetObject(PyExc_GPhoto2Error, PyInt_FromLong(error));
       /*@SWIG@*/
       SWIG_fail;
     }
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_abilities_list_detect", 2, 3, &obj0, &obj1, &obj2)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraAbilitiesList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_abilities_list_detect" "', argument " "1"" of type '" "CameraAbilitiesList *""'"); 
   }
   arg1 = (CameraAbilitiesList *)(argp1);
   res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p__GPPortInfoList, 0 |  0 );
@@ -5184,14 +5546,15 @@
   int res1 = 0 ;
   void *argp2 ;
   int res2 = 0 ;
   PyObject * obj0 = 0 ;
   PyObject * obj1 = 0 ;
   int result;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_abilities_list_append", 2, 2, &obj0, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraAbilitiesList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_abilities_list_append" "', argument " "1"" of type '" "CameraAbilitiesList *""'"); 
   }
   arg1 = (CameraAbilitiesList *)(argp1);
   {
@@ -5217,14 +5580,15 @@
   PyObject *resultobj = 0;
   CameraAbilitiesList *arg1 = (CameraAbilitiesList *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   PyObject * obj0 = 0 ;
   int result;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_abilities_list_count", 1, 1, &obj0)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraAbilitiesList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_abilities_list_count" "', argument " "1"" of type '" "CameraAbilitiesList *""'"); 
   }
   arg1 = (CameraAbilitiesList *)(argp1);
   result = (int)gp_abilities_list_count(arg1);
@@ -5244,14 +5608,15 @@
   int res2 ;
   char *buf2 = 0 ;
   int alloc2 = 0 ;
   PyObject * obj0 = 0 ;
   PyObject * obj1 = 0 ;
   int result;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_abilities_list_lookup_model", 2, 2, &obj0, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraAbilitiesList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_abilities_list_lookup_model" "', argument " "1"" of type '" "CameraAbilitiesList *""'"); 
   }
   arg1 = (CameraAbilitiesList *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -5285,14 +5650,15 @@
   {
     arg3 = (CameraAbilities *)calloc(1, sizeof(CameraAbilities));
     if (arg3 == NULL) {
       PyErr_SetString(PyExc_MemoryError, "Cannot allocate " "CameraAbilities");
       SWIG_fail;
     }
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_abilities_list_get_abilities", 2, 2, &obj0, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraAbilitiesList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_abilities_list_get_abilities" "', argument " "1"" of type '" "CameraAbilitiesList *""'"); 
   }
   arg1 = (CameraAbilitiesList *)(argp1);
   ecode2 = SWIG_AsVal_int(obj1, &val2);
@@ -5324,14 +5690,15 @@
   char *arg1 = (char *) 0 ;
   int res1 ;
   char *buf1 = 0 ;
   int alloc1 = 0 ;
   PyObject * obj0 = 0 ;
   char *result = 0 ;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_message_codeset", 1, 1, &obj0)) SWIG_fail;
   res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_message_codeset" "', argument " "1"" of type '" "char const *""'");
   }
   arg1 = (char *)(buf1);
   result = (char *)gp_message_codeset((char const *)arg1);
@@ -5349,14 +5716,15 @@
   char *arg1 = (char *) 0 ;
   int res1 ;
   char *buf1 = 0 ;
   int alloc1 = 0 ;
   PyObject * obj0 = 0 ;
   int result;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_init_localedir", 1, 1, &obj0)) SWIG_fail;
   res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_init_localedir" "', argument " "1"" of type '" "char const *""'");
   }
   arg1 = (char *)(buf1);
   result = (int)gp_init_localedir((char const *)arg1);
@@ -5366,276 +5734,14 @@
 fail:
   if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
   return NULL;
 }
 
 
 static PyMethodDef SwigMethods[] = {
-	 { "SWIG_PyInstanceMethod_New", SWIG_PyInstanceMethod_New, METH_O, NULL},
-	 { "SWIG_PyStaticMethod_New", SWIG_PyStaticMethod_New, METH_O, NULL},
-	 { "gp_abilities_list_new", _wrap_gp_abilities_list_new, METH_VARARGS, "\n"
-		"gp_abilities_list_new() -> int\n"
-		"Allocate the memory for a new abilities list.  \n"
-		"\n"
-		"Function to allocate the memory for a new abilities list.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `list` :  \n"
-		"    CameraAbilitiesList object to initialize  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"gphoto2 error code  \n"
-		"\n"
-		"You would then call gp_abilities_list_load() in order to populate it.\n"
-		"\n"
-		"See also gphoto2.CameraAbilitiesList\n"
-		""},
-	 { "gp_abilities_list_load", _wrap_gp_abilities_list_load, METH_VARARGS, "\n"
-		"gp_abilities_list_load(list, context) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"list: gphoto2.CameraAbilitiesList\n"
-		"context: gphoto2.Context (default=None)\n"
-		"\n"
-		"Scans the system for camera drivers.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `list` :  \n"
-		"    a CameraAbilitiesList  \n"
-		"* `context` :  \n"
-		"    a GPContext  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code  \n"
-		"\n"
-		"All supported camera models will then be added to the list.\n"
-		"\n"
-		"See also gphoto2.CameraAbilitiesList.load\n"
-		""},
-	 { "gp_abilities_list_load_dir", _wrap_gp_abilities_list_load_dir, METH_VARARGS, "\n"
-		"gp_abilities_list_load_dir(list, dir, context) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"list: gphoto2.CameraAbilitiesList\n"
-		"dir: str\n"
-		"context: gphoto2.Context (default=None)\n"
-		"\n"
-		""},
-	 { "gp_abilities_list_reset", _wrap_gp_abilities_list_reset, METH_VARARGS, "\n"
-		"gp_abilities_list_reset(list) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"list: gphoto2.CameraAbilitiesList\n"
-		"\n"
-		"Reset the list.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `list` :  \n"
-		"    a CameraAbilitiesList  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code\n"
-		"\n"
-		"See also gphoto2.CameraAbilitiesList.reset\n"
-		""},
-	 { "gp_abilities_list_detect", _wrap_gp_abilities_list_detect, METH_VARARGS, "\n"
-		"gp_abilities_list_detect(list, info_list, context) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"list: gphoto2.CameraAbilitiesList\n"
-		"info_list: gphoto2.GPPortInfoList\n"
-		"context: gphoto2.Context (default=None)\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `list` :  \n"
-		"    a CameraAbilitiesList  \n"
-		"* `info_list` :  \n"
-		"    the GPPortInfoList of ports to use for detection  \n"
-		"* `l` :  \n"
-		"    a CameraList that contains the autodetected cameras after the call  \n"
-		"* `context` :  \n"
-		"    a GPContext  \n"
-		"\n"
-		"Tries to detect any camera connected to the computer using the supplied\n"
-		"list of supported cameras and the supplied info_list of ports.  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code\n"
-		"\n"
-		"See also gphoto2.CameraAbilitiesList.detect\n"
-		""},
-	 { "gp_abilities_list_append", _wrap_gp_abilities_list_append, METH_VARARGS, "\n"
-		"gp_abilities_list_append(list, abilities) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"list: gphoto2.CameraAbilitiesList\n"
-		"abilities: gphoto2.CameraAbilities\n"
-		"\n"
-		"Append the abilities to the list.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `list` :  \n"
-		"    CameraAbilitiesList  \n"
-		"* `abilities` :  \n"
-		"    CameraAbilities  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code  \n"
-		"\n"
-		"This function is called by a camera library on camera_abilities() in\n"
-		"order to inform libgphoto2 about a supported camera model.\n"
-		"\n"
-		"See also gphoto2.CameraAbilitiesList.append\n"
-		""},
-	 { "gp_abilities_list_count", _wrap_gp_abilities_list_count, METH_VARARGS, "\n"
-		"gp_abilities_list_count(list) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"list: gphoto2.CameraAbilitiesList\n"
-		"\n"
-		"Count the entries in the supplied list.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `list` :  \n"
-		"    a CameraAbilitiesList  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"The number of entries or a gphoto2 error code\n"
-		"\n"
-		"See also gphoto2.CameraAbilitiesList.count\n"
-		""},
-	 { "gp_abilities_list_lookup_model", _wrap_gp_abilities_list_lookup_model, METH_VARARGS, "\n"
-		"gp_abilities_list_lookup_model(list, model) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"list: gphoto2.CameraAbilitiesList\n"
-		"model: str\n"
-		"\n"
-		"Search the list for an entry of given model name.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `list` :  \n"
-		"    a CameraAbilitiesList  \n"
-		"* `model` :  \n"
-		"    a camera model name  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"Index of entry or gphoto2 error code\n"
-		"\n"
-		"See also gphoto2.CameraAbilitiesList.lookup_model\n"
-		""},
-	 { "gp_abilities_list_get_abilities", _wrap_gp_abilities_list_get_abilities, METH_VARARGS, "\n"
-		"gp_abilities_list_get_abilities(list, index) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"list: gphoto2.CameraAbilitiesList\n"
-		"index: int\n"
-		"\n"
-		"Retrieve the camera abilities of entry with supplied index number.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `list` :  \n"
-		"    a CameraAbilitiesList  \n"
-		"* `index` :  \n"
-		"    index  \n"
-		"* `abilities` :  \n"
-		"    pointer to CameraAbilities for returned data.  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code  \n"
-		"\n"
-		"Retrieves the camera abilities of entry with supplied index number.\n"
-		"Typically, you would call gp_camera_set_abilities() afterwards in order\n"
-		"to prepare the initialization of a camera.\n"
-		"\n"
-		"See also gphoto2.CameraAbilitiesList.get_abilities\n"
-		""},
-	 { "gp_message_codeset", _wrap_gp_message_codeset, METH_VARARGS, "\n"
-		"gp_message_codeset(arg1) -> char const *\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"arg1: str\n"
-		"\n"
-		"Set the current character codeset libgphoto2 is operating in.  \n"
-		"\n"
-		"Set the codeset for all messages returned by libgphoto2.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `codeset` :  \n"
-		"    New codeset for the messages. For instance \"utf-8\".  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"old codeset as returned from bind_textdomain_codeset().\n"
-		""},
-	 { "gp_init_localedir", _wrap_gp_init_localedir, METH_VARARGS, "\n"
-		"gp_init_localedir(localedir) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"localedir: str\n"
-		"\n"
-		"Initialize the localedir directory for the libgphoto2 gettext domain.  \n"
-		"\n"
-		"Override the localedir directory libgphoto2 uses for its message\n"
-		"translations.  \n"
-		"\n"
-		"You only need to call this if you have a non-standard installation where\n"
-		"the locale files are at a location which differs from the compiled in\n"
-		"default location.  \n"
-		"\n"
-		"If you do need to call this function, call it before calling any non-\n"
-		"initialization function.  \n"
-		"\n"
-		"Internally, this will make sure bindtextdomain() is called for the\n"
-		"relevant gettext text domain(s).  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `localedir` :  \n"
-		"    Root directory of libgphoto2's localization files. If NULL, use the\n"
-		"    compiled in default value, which will be something like\n"
-		"    \"/usr/share/locale\".  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"gphoto2 error code.\n"
-		""},
-	 { NULL, NULL, 0, NULL }
-};
-
-static PyMethodDef SwigMethods_proxydocs[] = {
-	 { "SWIG_PyInstanceMethod_New", SWIG_PyInstanceMethod_New, METH_O, NULL},
-	 { "SWIG_PyStaticMethod_New", SWIG_PyStaticMethod_New, METH_O, NULL},
 	 { "gp_abilities_list_new", _wrap_gp_abilities_list_new, METH_VARARGS, "\n"
 		"gp_abilities_list_new() -> int\n"
 		"Allocate the memory for a new abilities list.  \n"
 		"\n"
 		"Function to allocate the memory for a new abilities list.  \n"
 		"\n"
 		"Parameters\n"
@@ -6101,15 +6207,19 @@
     PyObject_HEAD_INIT(NULL)
     0,                                        /* ob_size */
 #endif
     "gphoto2.abilities_list.CameraAbilitiesList",                 /* tp_name */
     sizeof(SwigPyObject),                     /* tp_basicsize */
     0,                                        /* tp_itemsize */
     _wrap_delete_CameraAbilitiesList_destructor_closure,          /* tp_dealloc */
+#if PY_VERSION_HEX < 0x030800b4
     (printfunc) 0,                            /* tp_print */
+#else
+    (Py_ssize_t) 0,                           /* tp_vectorcall_offset */
+#endif
     (getattrfunc) 0,                          /* tp_getattr */
     (setattrfunc) 0,                          /* tp_setattr */
 #if PY_VERSION_HEX >= 0x03000000
     0,                                        /* tp_compare */
 #else
     (cmpfunc) 0,                              /* tp_compare */
 #endif
@@ -6173,14 +6283,17 @@
 #endif
   },
 #if PY_VERSION_HEX >= 0x03050000
   {
     (unaryfunc) 0,                            /* am_await */
     (unaryfunc) 0,                            /* am_aiter */
     (unaryfunc) 0,                            /* am_anext */
+# if PY_VERSION_HEX >= 0x030a0000
+    (sendfunc) 0,                             /* am_send */
+# endif
   },
 #endif
   {
     (binaryfunc) 0,                           /* nb_add */
     (binaryfunc) 0,                           /* nb_subtract */
     (binaryfunc) 0,                           /* nb_multiply */
 #if PY_VERSION_HEX < 0x03000000
@@ -6273,65 +6386,74 @@
   },
     (PyObject *) 0,                           /* ht_name */
     (PyObject *) 0,                           /* ht_slots */
 #if PY_VERSION_HEX >= 0x03030000
     (PyObject *) 0,                           /* ht_qualname */
     0,                                        /* ht_cached_keys */
 #endif
+#if PY_VERSION_HEX >= 0x03090000
+    (PyObject *) 0,                           /* ht_module */
+#endif
+#if PY_VERSION_HEX >= 0x030b0000
+    (char *) 0,                               /* _ht_tpname */
+  {
+    (PyObject *) 0,                           /* getitem */
+  }
+#endif
 };
 
 SWIGINTERN SwigPyClientData SwigPyBuiltin___CameraAbilitiesList_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin___CameraAbilitiesList_type};
 
-static SwigPyGetSet CameraAbilities_usb_product_getset = { _wrap_CameraAbilities_usb_product_get, 0 };
-static SwigPyGetSet CameraAbilities_usb_protocol_getset = { _wrap_CameraAbilities_usb_protocol_get, 0 };
-static SwigPyGetSet CameraAbilities_usb_class_getset = { _wrap_CameraAbilities_usb_class_get, 0 };
-static SwigPyGetSet CameraAbilities_usb_vendor_getset = { _wrap_CameraAbilities_usb_vendor_get, 0 };
-static SwigPyGetSet CameraAbilities_speed_getset = { _wrap_CameraAbilities_speed_get, 0 };
-static SwigPyGetSet CameraAbilities_reserved2_getset = { _wrap_CameraAbilities_reserved2_get, 0 };
-static SwigPyGetSet CameraAbilities_model_getset = { _wrap_CameraAbilities_model_get, 0 };
+static SwigPyGetSet CameraAbilities_folder_operations_getset = { _wrap_CameraAbilities_folder_operations_get, 0 };
+static SwigPyGetSet CameraAbilities_status_getset = { _wrap_CameraAbilities_status_get, 0 };
+static SwigPyGetSet CameraAbilities_device_type_getset = { _wrap_CameraAbilities_device_type_get, 0 };
 static SwigPyGetSet CameraAbilities_reserved3_getset = { _wrap_CameraAbilities_reserved3_get, 0 };
-static SwigPyGetSet CameraAbilities___dict___getset = { SwigPyObject_get___dict__, 0 };
+static SwigPyGetSet CameraAbilities_port_getset = { _wrap_CameraAbilities_port_get, 0 };
+static SwigPyGetSet CameraAbilities_speed_getset = { _wrap_CameraAbilities_speed_get, 0 };
 static SwigPyGetSet CameraAbilities_reserved4_getset = { _wrap_CameraAbilities_reserved4_get, 0 };
+static SwigPyGetSet CameraAbilities___dict___getset = { SwigPyObject_get___dict__, 0 };
 static SwigPyGetSet CameraAbilities_reserved5_getset = { _wrap_CameraAbilities_reserved5_get, 0 };
-static SwigPyGetSet CameraAbilities_id_getset = { _wrap_CameraAbilities_id_get, 0 };
+static SwigPyGetSet CameraAbilities_model_getset = { _wrap_CameraAbilities_model_get, 0 };
 static SwigPyGetSet CameraAbilities_reserved6_getset = { _wrap_CameraAbilities_reserved6_get, 0 };
-static SwigPyGetSet CameraAbilities_folder_operations_getset = { _wrap_CameraAbilities_folder_operations_get, 0 };
-static SwigPyGetSet CameraAbilities_file_operations_getset = { _wrap_CameraAbilities_file_operations_get, 0 };
-static SwigPyGetSet CameraAbilities_operations_getset = { _wrap_CameraAbilities_operations_get, 0 };
 static SwigPyGetSet CameraAbilities_reserved7_getset = { _wrap_CameraAbilities_reserved7_get, 0 };
-static SwigPyGetSet CameraAbilities_usb_subclass_getset = { _wrap_CameraAbilities_usb_subclass_get, 0 };
-static SwigPyGetSet CameraAbilities_device_type_getset = { _wrap_CameraAbilities_device_type_get, 0 };
+static SwigPyGetSet CameraAbilities_operations_getset = { _wrap_CameraAbilities_operations_get, 0 };
 static SwigPyGetSet CameraAbilities_reserved8_getset = { _wrap_CameraAbilities_reserved8_get, 0 };
-static SwigPyGetSet CameraAbilities_port_getset = { _wrap_CameraAbilities_port_get, 0 };
-static SwigPyGetSet CameraAbilities_status_getset = { _wrap_CameraAbilities_status_get, 0 };
+static SwigPyGetSet CameraAbilities_usb_vendor_getset = { _wrap_CameraAbilities_usb_vendor_get, 0 };
+static SwigPyGetSet CameraAbilities_usb_class_getset = { _wrap_CameraAbilities_usb_class_get, 0 };
 static SwigPyGetSet CameraAbilities_library_getset = { _wrap_CameraAbilities_library_get, 0 };
+static SwigPyGetSet CameraAbilities_usb_subclass_getset = { _wrap_CameraAbilities_usb_subclass_get, 0 };
+static SwigPyGetSet CameraAbilities_file_operations_getset = { _wrap_CameraAbilities_file_operations_get, 0 };
+static SwigPyGetSet CameraAbilities_usb_product_getset = { _wrap_CameraAbilities_usb_product_get, 0 };
+static SwigPyGetSet CameraAbilities_id_getset = { _wrap_CameraAbilities_id_get, 0 };
+static SwigPyGetSet CameraAbilities_usb_protocol_getset = { _wrap_CameraAbilities_usb_protocol_get, 0 };
+static SwigPyGetSet CameraAbilities_reserved2_getset = { _wrap_CameraAbilities_reserved2_get, 0 };
 SWIGINTERN PyGetSetDef SwigPyBuiltin__CameraAbilities_getset[] = {
-    { (char *)"usb_product", SwigPyBuiltin_GetterClosure, 0, (char *)"usb_product", &CameraAbilities_usb_product_getset },
-    { (char *)"usb_protocol", SwigPyBuiltin_GetterClosure, 0, (char *)"usb_protocol", &CameraAbilities_usb_protocol_getset },
-    { (char *)"usb_class", SwigPyBuiltin_GetterClosure, 0, (char *)"usb_class", &CameraAbilities_usb_class_getset },
-    { (char *)"usb_vendor", SwigPyBuiltin_GetterClosure, 0, (char *)"usb_vendor", &CameraAbilities_usb_vendor_getset },
-    { (char *)"speed", SwigPyBuiltin_GetterClosure, 0, (char *)"speed", &CameraAbilities_speed_getset },
-    { (char *)"reserved2", SwigPyBuiltin_GetterClosure, 0, (char *)"reserved2", &CameraAbilities_reserved2_getset },
-    { (char *)"model", SwigPyBuiltin_GetterClosure, 0, (char *)"model", &CameraAbilities_model_getset },
+    { (char *)"folder_operations", SwigPyBuiltin_GetterClosure, 0, (char *)"folder_operations", &CameraAbilities_folder_operations_getset },
+    { (char *)"status", SwigPyBuiltin_GetterClosure, 0, (char *)"status", &CameraAbilities_status_getset },
+    { (char *)"device_type", SwigPyBuiltin_GetterClosure, 0, (char *)"device_type", &CameraAbilities_device_type_getset },
     { (char *)"reserved3", SwigPyBuiltin_GetterClosure, 0, (char *)"reserved3", &CameraAbilities_reserved3_getset },
-    { (char *)"__dict__", SwigPyBuiltin_GetterClosure, 0, (char *)"model", &CameraAbilities___dict___getset },
+    { (char *)"port", SwigPyBuiltin_GetterClosure, 0, (char *)"port", &CameraAbilities_port_getset },
+    { (char *)"speed", SwigPyBuiltin_GetterClosure, 0, (char *)"speed", &CameraAbilities_speed_getset },
     { (char *)"reserved4", SwigPyBuiltin_GetterClosure, 0, (char *)"reserved4", &CameraAbilities_reserved4_getset },
+    { (char *)"__dict__", SwigPyBuiltin_GetterClosure, 0, (char *)"model", &CameraAbilities___dict___getset },
     { (char *)"reserved5", SwigPyBuiltin_GetterClosure, 0, (char *)"reserved5", &CameraAbilities_reserved5_getset },
-    { (char *)"id", SwigPyBuiltin_GetterClosure, 0, (char *)"id", &CameraAbilities_id_getset },
+    { (char *)"model", SwigPyBuiltin_GetterClosure, 0, (char *)"model", &CameraAbilities_model_getset },
     { (char *)"reserved6", SwigPyBuiltin_GetterClosure, 0, (char *)"reserved6", &CameraAbilities_reserved6_getset },
-    { (char *)"folder_operations", SwigPyBuiltin_GetterClosure, 0, (char *)"folder_operations", &CameraAbilities_folder_operations_getset },
-    { (char *)"file_operations", SwigPyBuiltin_GetterClosure, 0, (char *)"file_operations", &CameraAbilities_file_operations_getset },
-    { (char *)"operations", SwigPyBuiltin_GetterClosure, 0, (char *)"operations", &CameraAbilities_operations_getset },
     { (char *)"reserved7", SwigPyBuiltin_GetterClosure, 0, (char *)"reserved7", &CameraAbilities_reserved7_getset },
-    { (char *)"usb_subclass", SwigPyBuiltin_GetterClosure, 0, (char *)"usb_subclass", &CameraAbilities_usb_subclass_getset },
-    { (char *)"device_type", SwigPyBuiltin_GetterClosure, 0, (char *)"device_type", &CameraAbilities_device_type_getset },
+    { (char *)"operations", SwigPyBuiltin_GetterClosure, 0, (char *)"operations", &CameraAbilities_operations_getset },
     { (char *)"reserved8", SwigPyBuiltin_GetterClosure, 0, (char *)"reserved8", &CameraAbilities_reserved8_getset },
-    { (char *)"port", SwigPyBuiltin_GetterClosure, 0, (char *)"port", &CameraAbilities_port_getset },
-    { (char *)"status", SwigPyBuiltin_GetterClosure, 0, (char *)"status", &CameraAbilities_status_getset },
+    { (char *)"usb_vendor", SwigPyBuiltin_GetterClosure, 0, (char *)"usb_vendor", &CameraAbilities_usb_vendor_getset },
+    { (char *)"usb_class", SwigPyBuiltin_GetterClosure, 0, (char *)"usb_class", &CameraAbilities_usb_class_getset },
     { (char *)"library", SwigPyBuiltin_GetterClosure, 0, (char *)"library", &CameraAbilities_library_getset },
+    { (char *)"usb_subclass", SwigPyBuiltin_GetterClosure, 0, (char *)"usb_subclass", &CameraAbilities_usb_subclass_getset },
+    { (char *)"file_operations", SwigPyBuiltin_GetterClosure, 0, (char *)"file_operations", &CameraAbilities_file_operations_getset },
+    { (char *)"usb_product", SwigPyBuiltin_GetterClosure, 0, (char *)"usb_product", &CameraAbilities_usb_product_getset },
+    { (char *)"id", SwigPyBuiltin_GetterClosure, 0, (char *)"id", &CameraAbilities_id_getset },
+    { (char *)"usb_protocol", SwigPyBuiltin_GetterClosure, 0, (char *)"usb_protocol", &CameraAbilities_usb_protocol_getset },
+    { (char *)"reserved2", SwigPyBuiltin_GetterClosure, 0, (char *)"reserved2", &CameraAbilities_reserved2_getset },
     { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
 };
 
 SWIGINTERN PyObject *
 SwigPyBuiltin__CameraAbilities_richcompare(PyObject *self, PyObject *other, int op) {
   PyObject *result = NULL;
   PyObject *tuple = PyTuple_New(1);
@@ -6362,15 +6484,19 @@
     PyObject_HEAD_INIT(NULL)
     0,                                        /* ob_size */
 #endif
     "gphoto2.abilities_list.CameraAbilities", /* tp_name */
     sizeof(SwigPyObject),                     /* tp_basicsize */
     0,                                        /* tp_itemsize */
     _wrap_delete_CameraAbilities_destructor_closure,              /* tp_dealloc */
+#if PY_VERSION_HEX < 0x030800b4
     (printfunc) 0,                            /* tp_print */
+#else
+    (Py_ssize_t) 0,                           /* tp_vectorcall_offset */
+#endif
     (getattrfunc) 0,                          /* tp_getattr */
     (setattrfunc) 0,                          /* tp_setattr */
 #if PY_VERSION_HEX >= 0x03000000
     0,                                        /* tp_compare */
 #else
     (cmpfunc) 0,                              /* tp_compare */
 #endif
@@ -6441,14 +6567,17 @@
 #endif
   },
 #if PY_VERSION_HEX >= 0x03050000
   {
     (unaryfunc) 0,                            /* am_await */
     (unaryfunc) 0,                            /* am_aiter */
     (unaryfunc) 0,                            /* am_anext */
+# if PY_VERSION_HEX >= 0x030a0000
+    (sendfunc) 0,                             /* am_send */
+# endif
   },
 #endif
   {
     (binaryfunc) 0,                           /* nb_add */
     (binaryfunc) 0,                           /* nb_subtract */
     (binaryfunc) 0,                           /* nb_multiply */
 #if PY_VERSION_HEX < 0x03000000
@@ -6541,76 +6670,85 @@
   },
     (PyObject *) 0,                           /* ht_name */
     (PyObject *) 0,                           /* ht_slots */
 #if PY_VERSION_HEX >= 0x03030000
     (PyObject *) 0,                           /* ht_qualname */
     0,                                        /* ht_cached_keys */
 #endif
+#if PY_VERSION_HEX >= 0x03090000
+    (PyObject *) 0,                           /* ht_module */
+#endif
+#if PY_VERSION_HEX >= 0x030b0000
+    (char *) 0,                               /* _ht_tpname */
+  {
+    (PyObject *) 0,                           /* getitem */
+  }
+#endif
 };
 
 SWIGINTERN SwigPyClientData SwigPyBuiltin__CameraAbilities_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__CameraAbilities_type};
 
 
 /* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */
 
 static swig_type_info _swigt__p_CameraAbilities = {"_p_CameraAbilities", "CameraAbilities *", 0, 0, (void*)&SwigPyBuiltin__CameraAbilities_clientdata, 0};
-static swig_type_info _swigt__p_CameraCaptureType = {"_p_CameraCaptureType", "enum CameraCaptureType *|CameraCaptureType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraDriverStatus = {"_p_CameraDriverStatus", "enum CameraDriverStatus *|CameraDriverStatus *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraEventType = {"_p_CameraEventType", "enum CameraEventType *|CameraEventType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileAccessType = {"_p_CameraFileAccessType", "enum CameraFileAccessType *|CameraFileAccessType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileInfoFields = {"_p_CameraFileInfoFields", "enum CameraFileInfoFields *|CameraFileInfoFields *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileOperation = {"_p_CameraFileOperation", "enum CameraFileOperation *|CameraFileOperation *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraCaptureType = {"_p_CameraCaptureType", "CameraCaptureType *|enum CameraCaptureType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraDriverStatus = {"_p_CameraDriverStatus", "CameraDriverStatus *|enum CameraDriverStatus *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraEventType = {"_p_CameraEventType", "CameraEventType *|enum CameraEventType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileAccessType = {"_p_CameraFileAccessType", "CameraFileAccessType *|enum CameraFileAccessType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileInfoFields = {"_p_CameraFileInfoFields", "CameraFileInfoFields *|enum CameraFileInfoFields *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileOperation = {"_p_CameraFileOperation", "CameraFileOperation *|enum CameraFileOperation *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_CameraFilePath = {"_p_CameraFilePath", "CameraFilePath *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFilePermissions = {"_p_CameraFilePermissions", "enum CameraFilePermissions *|CameraFilePermissions *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileStatus = {"_p_CameraFileStatus", "enum CameraFileStatus *|CameraFileStatus *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileType = {"_p_CameraFileType", "enum CameraFileType *|CameraFileType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFolderOperation = {"_p_CameraFolderOperation", "enum CameraFolderOperation *|CameraFolderOperation *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraOperation = {"_p_CameraOperation", "enum CameraOperation *|CameraOperation *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraStorageAccessType = {"_p_CameraStorageAccessType", "enum CameraStorageAccessType *|CameraStorageAccessType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraStorageFilesystemType = {"_p_CameraStorageFilesystemType", "enum CameraStorageFilesystemType *|CameraStorageFilesystemType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraStorageInfoFields = {"_p_CameraStorageInfoFields", "enum CameraStorageInfoFields *|CameraStorageInfoFields *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraStorageType = {"_p_CameraStorageType", "enum CameraStorageType *|CameraStorageType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFilePermissions = {"_p_CameraFilePermissions", "CameraFilePermissions *|enum CameraFilePermissions *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileStatus = {"_p_CameraFileStatus", "CameraFileStatus *|enum CameraFileStatus *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileType = {"_p_CameraFileType", "CameraFileType *|enum CameraFileType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFolderOperation = {"_p_CameraFolderOperation", "CameraFolderOperation *|enum CameraFolderOperation *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraOperation = {"_p_CameraOperation", "CameraOperation *|enum CameraOperation *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraStorageAccessType = {"_p_CameraStorageAccessType", "CameraStorageAccessType *|enum CameraStorageAccessType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraStorageFilesystemType = {"_p_CameraStorageFilesystemType", "CameraStorageFilesystemType *|enum CameraStorageFilesystemType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraStorageInfoFields = {"_p_CameraStorageInfoFields", "CameraStorageInfoFields *|enum CameraStorageInfoFields *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraStorageType = {"_p_CameraStorageType", "CameraStorageType *|enum CameraStorageType *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_CameraText = {"_p_CameraText", "CameraText *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraWidgetType = {"_p_CameraWidgetType", "enum CameraWidgetType *|CameraWidgetType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_GPLogLevel = {"_p_GPLogLevel", "enum GPLogLevel *|GPLogLevel *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_GPPortType = {"_p_GPPortType", "enum GPPortType *|GPPortType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_GPVersionVerbosity = {"_p_GPVersionVerbosity", "enum GPVersionVerbosity *|GPVersionVerbosity *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_GphotoDeviceType = {"_p_GphotoDeviceType", "enum GphotoDeviceType *|GphotoDeviceType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraWidgetType = {"_p_CameraWidgetType", "CameraWidgetType *|enum CameraWidgetType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GPLogLevel = {"_p_GPLogLevel", "GPLogLevel *|enum GPLogLevel *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GPPortType = {"_p_GPPortType", "GPPortType *|enum GPPortType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GPVersionVerbosity = {"_p_GPVersionVerbosity", "GPVersionVerbosity *|enum GPVersionVerbosity *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GphotoDeviceType = {"_p_GphotoDeviceType", "GphotoDeviceType *|enum GphotoDeviceType *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_SwigPyObject = {"_p_SwigPyObject", "SwigPyObject *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__Camera = {"_p__Camera", "struct _Camera *|Camera *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraAbilitiesList = {"_p__CameraAbilitiesList", "struct _CameraAbilitiesList *|_CameraAbilitiesList *|CameraAbilitiesList *", 0, 0, (void*)&SwigPyBuiltin___CameraAbilitiesList_clientdata, 0};
-static swig_type_info _swigt__p__CameraFile = {"_p__CameraFile", "struct _CameraFile *|CameraFile *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFileHandler = {"_p__CameraFileHandler", "struct _CameraFileHandler *|CameraFileHandler *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFileInfo = {"_p__CameraFileInfo", "struct _CameraFileInfo *|CameraFileInfo *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFileInfoAudio = {"_p__CameraFileInfoAudio", "struct _CameraFileInfoAudio *|CameraFileInfoAudio *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFileInfoFile = {"_p__CameraFileInfoFile", "struct _CameraFileInfoFile *|CameraFileInfoFile *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFileInfoPreview = {"_p__CameraFileInfoPreview", "struct _CameraFileInfoPreview *|CameraFileInfoPreview *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFilesystem = {"_p__CameraFilesystem", "struct _CameraFilesystem *|CameraFilesystem *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFilesystemFuncs = {"_p__CameraFilesystemFuncs", "struct _CameraFilesystemFuncs *|CameraFilesystemFuncs *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFunctions = {"_p__CameraFunctions", "struct _CameraFunctions *|CameraFunctions *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraList = {"_p__CameraList", "struct _CameraList *|CameraList *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraPrivateCore = {"_p__CameraPrivateCore", "struct _CameraPrivateCore *|CameraPrivateCore *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraPrivateLibrary = {"_p__CameraPrivateLibrary", "struct _CameraPrivateLibrary *|CameraPrivateLibrary *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraStorageInformation = {"_p__CameraStorageInformation", "struct _CameraStorageInformation *|CameraStorageInformation *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraWidget = {"_p__CameraWidget", "struct _CameraWidget *|CameraWidget *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__GPContext = {"_p__GPContext", "struct _GPContext *|GPContext *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__GPContextFeedback = {"_p__GPContextFeedback", "enum _GPContextFeedback *|GPContextFeedback *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__Camera = {"_p__Camera", "Camera *|struct _Camera *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraAbilitiesList = {"_p__CameraAbilitiesList", "CameraAbilitiesList *|struct _CameraAbilitiesList *|_CameraAbilitiesList *", 0, 0, (void*)&SwigPyBuiltin___CameraAbilitiesList_clientdata, 0};
+static swig_type_info _swigt__p__CameraFile = {"_p__CameraFile", "CameraFile *|struct _CameraFile *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFileHandler = {"_p__CameraFileHandler", "CameraFileHandler *|struct _CameraFileHandler *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFileInfo = {"_p__CameraFileInfo", "CameraFileInfo *|struct _CameraFileInfo *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFileInfoAudio = {"_p__CameraFileInfoAudio", "CameraFileInfoAudio *|struct _CameraFileInfoAudio *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFileInfoFile = {"_p__CameraFileInfoFile", "CameraFileInfoFile *|struct _CameraFileInfoFile *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFileInfoPreview = {"_p__CameraFileInfoPreview", "CameraFileInfoPreview *|struct _CameraFileInfoPreview *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFilesystem = {"_p__CameraFilesystem", "CameraFilesystem *|struct _CameraFilesystem *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFilesystemFuncs = {"_p__CameraFilesystemFuncs", "CameraFilesystemFuncs *|struct _CameraFilesystemFuncs *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFunctions = {"_p__CameraFunctions", "CameraFunctions *|struct _CameraFunctions *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraList = {"_p__CameraList", "CameraList *|struct _CameraList *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraPrivateCore = {"_p__CameraPrivateCore", "CameraPrivateCore *|struct _CameraPrivateCore *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraPrivateLibrary = {"_p__CameraPrivateLibrary", "CameraPrivateLibrary *|struct _CameraPrivateLibrary *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraStorageInformation = {"_p__CameraStorageInformation", "CameraStorageInformation *|struct _CameraStorageInformation *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraWidget = {"_p__CameraWidget", "CameraWidget *|struct _CameraWidget *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__GPContext = {"_p__GPContext", "GPContext *|struct _GPContext *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__GPContextFeedback = {"_p__GPContextFeedback", "GPContextFeedback *|enum _GPContextFeedback *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p__GPPortInfo = {"_p__GPPortInfo", "_GPPortInfo *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__GPPortInfoList = {"_p__GPPortInfoList", "struct _GPPortInfoList *|GPPortInfoList *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__GPPortInfoList = {"_p__GPPortInfoList", "GPPortInfoList *|struct _GPPortInfoList *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_int = {"_p_int", "intptr_t *|int *|int_least32_t *|int_fast32_t *|int32_t *|int_fast16_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_long = {"_p_long", "long *|time_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_long_long = {"_p_long_long", "int_least64_t *|int_fast64_t *|int64_t *|long long *|intmax_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_p__CameraAbilitiesList = {"_p_p__CameraAbilitiesList", "struct _CameraAbilitiesList **|CameraAbilitiesList **", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_short = {"_p_short", "short *|int_least16_t *|int16_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_signed_char = {"_p_signed_char", "signed char *|int_least8_t *|int_fast8_t *|int8_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_unsigned_char = {"_p_unsigned_char", "unsigned char *|uint_least8_t *|uint_fast8_t *|uint8_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_unsigned_int = {"_p_unsigned_int", "uintptr_t *|uint_least32_t *|uint_fast32_t *|uint32_t *|unsigned int *|uint_fast16_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_unsigned_long_long = {"_p_unsigned_long_long", "uint_least64_t *|uint_fast64_t *|uint64_t *|unsigned long long *|uintmax_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_unsigned_short = {"_p_unsigned_short", "unsigned short *|uint_least16_t *|uint16_t *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_int = {"_p_int", "int32_t *|int_fast16_t *|int_fast32_t *|int_least32_t *|intptr_t *|int *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_long = {"_p_long", "time_t *|long *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_long_long = {"_p_long_long", "int64_t *|int_fast64_t *|int_least64_t *|intmax_t *|long long *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_p__CameraAbilitiesList = {"_p_p__CameraAbilitiesList", "CameraAbilitiesList **|struct _CameraAbilitiesList **", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_short = {"_p_short", "int16_t *|int_least16_t *|short *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_signed_char = {"_p_signed_char", "int8_t *|int_fast8_t *|int_least8_t *|signed char *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_unsigned_char = {"_p_unsigned_char", "uint8_t *|uint_fast8_t *|uint_least8_t *|unsigned char *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_unsigned_int = {"_p_unsigned_int", "uint32_t *|uint_fast16_t *|uint_fast32_t *|uint_least32_t *|uintptr_t *|unsigned int *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_unsigned_long_long = {"_p_unsigned_long_long", "uint64_t *|uint_fast64_t *|uint_least64_t *|uintmax_t *|unsigned long long *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_unsigned_short = {"_p_unsigned_short", "uint16_t *|uint_least16_t *|unsigned short *", 0, 0, (void*)0, 0};
 
 static swig_type_info *swig_type_initial[] = {
   &_swigt__p_CameraAbilities,
   &_swigt__p_CameraCaptureType,
   &_swigt__p_CameraDriverStatus,
   &_swigt__p_CameraEventType,
   &_swigt__p_CameraFileAccessType,
@@ -6839,17 +6977,20 @@
 #endif
 #endif
 
 #if 0
 #define SWIGRUNTIME_DEBUG
 #endif
 
+#ifndef SWIG_INIT_CLIENT_DATA_TYPE
+#define SWIG_INIT_CLIENT_DATA_TYPE void *
+#endif
 
 SWIGRUNTIME void
-SWIG_InitializeModule(void *clientdata) {
+SWIG_InitializeModule(SWIG_INIT_CLIENT_DATA_TYPE clientdata) {
   size_t i;
   swig_module_info *module_head, *iter;
   int init;
   
   /* check to see if the circular list has been setup, if not, set it up */
   if (swig_module.next==0) {
     /* Initialize the swig_module */
@@ -7024,228 +7165,14 @@
 
 
 
 #ifdef __cplusplus
 extern "C" {
 #endif
   
-  /* Python-specific SWIG API */
-#define SWIG_newvarlink()                             SWIG_Python_newvarlink()
-#define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
-#define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)
-  
-  /* -----------------------------------------------------------------------------
-   * global variable support code.
-   * ----------------------------------------------------------------------------- */
-  
-  typedef struct swig_globalvar {
-    char       *name;                  /* Name of global variable */
-    PyObject *(*get_attr)(void);       /* Return the current value */
-    int       (*set_attr)(PyObject *); /* Set the value */
-    struct swig_globalvar *next;
-  } swig_globalvar;
-  
-  typedef struct swig_varlinkobject {
-    PyObject_HEAD
-    swig_globalvar *vars;
-  } swig_varlinkobject;
-  
-  SWIGINTERN PyObject *
-  swig_varlink_repr(swig_varlinkobject *SWIGUNUSEDPARM(v)) {
-#if PY_VERSION_HEX >= 0x03000000
-    return PyUnicode_InternFromString("<Swig global variables>");
-#else
-    return PyString_FromString("<Swig global variables>");
-#endif
-  }
-  
-  SWIGINTERN PyObject *
-  swig_varlink_str(swig_varlinkobject *v) {
-#if PY_VERSION_HEX >= 0x03000000
-    PyObject *str = PyUnicode_InternFromString("(");
-    PyObject *tail;
-    PyObject *joined;
-    swig_globalvar *var;
-    for (var = v->vars; var; var=var->next) {
-      tail = PyUnicode_FromString(var->name);
-      joined = PyUnicode_Concat(str, tail);
-      Py_DecRef(str);
-      Py_DecRef(tail);
-      str = joined;
-      if (var->next) {
-        tail = PyUnicode_InternFromString(", ");
-        joined = PyUnicode_Concat(str, tail);
-        Py_DecRef(str);
-        Py_DecRef(tail);
-        str = joined;
-      }
-    }
-    tail = PyUnicode_InternFromString(")");
-    joined = PyUnicode_Concat(str, tail);
-    Py_DecRef(str);
-    Py_DecRef(tail);
-    str = joined;
-#else
-    PyObject *str = PyString_FromString("(");
-    swig_globalvar *var;
-    for (var = v->vars; var; var=var->next) {
-      PyString_ConcatAndDel(&str,PyString_FromString(var->name));
-      if (var->next) PyString_ConcatAndDel(&str,PyString_FromString(", "));
-    }
-    PyString_ConcatAndDel(&str,PyString_FromString(")"));
-#endif
-    return str;
-  }
-  
-  SWIGINTERN void
-  swig_varlink_dealloc(swig_varlinkobject *v) {
-    swig_globalvar *var = v->vars;
-    while (var) {
-      swig_globalvar *n = var->next;
-      free(var->name);
-      free(var);
-      var = n;
-    }
-  }
-  
-  SWIGINTERN PyObject *
-  swig_varlink_getattr(swig_varlinkobject *v, char *n) {
-    PyObject *res = NULL;
-    swig_globalvar *var = v->vars;
-    while (var) {
-      if (strcmp(var->name,n) == 0) {
-        res = (*var->get_attr)();
-        break;
-      }
-      var = var->next;
-    }
-    if (res == NULL && !PyErr_Occurred()) {
-      PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
-    }
-    return res;
-  }
-  
-  SWIGINTERN int
-  swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
-    int res = 1;
-    swig_globalvar *var = v->vars;
-    while (var) {
-      if (strcmp(var->name,n) == 0) {
-        res = (*var->set_attr)(p);
-        break;
-      }
-      var = var->next;
-    }
-    if (res == 1 && !PyErr_Occurred()) {
-      PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
-    }
-    return res;
-  }
-  
-  SWIGINTERN PyTypeObject*
-  swig_varlink_type(void) {
-    static char varlink__doc__[] = "Swig var link object";
-    static PyTypeObject varlink_type;
-    static int type_init = 0;
-    if (!type_init) {
-      const PyTypeObject tmp = {
-#if PY_VERSION_HEX >= 0x03000000
-        PyVarObject_HEAD_INIT(NULL, 0)
-#else
-        PyObject_HEAD_INIT(NULL)
-        0,                                  /* ob_size */
-#endif
-        "swigvarlink",                      /* tp_name */
-        sizeof(swig_varlinkobject),         /* tp_basicsize */
-        0,                                  /* tp_itemsize */
-        (destructor) swig_varlink_dealloc,  /* tp_dealloc */
-        0,                                  /* tp_print */
-        (getattrfunc) swig_varlink_getattr, /* tp_getattr */
-        (setattrfunc) swig_varlink_setattr, /* tp_setattr */
-        0,                                  /* tp_compare */
-        (reprfunc) swig_varlink_repr,       /* tp_repr */
-        0,                                  /* tp_as_number */
-        0,                                  /* tp_as_sequence */
-        0,                                  /* tp_as_mapping */
-        0,                                  /* tp_hash */
-        0,                                  /* tp_call */
-        (reprfunc) swig_varlink_str,        /* tp_str */
-        0,                                  /* tp_getattro */
-        0,                                  /* tp_setattro */
-        0,                                  /* tp_as_buffer */
-        0,                                  /* tp_flags */
-        varlink__doc__,                     /* tp_doc */
-        0,                                  /* tp_traverse */
-        0,                                  /* tp_clear */
-        0,                                  /* tp_richcompare */
-        0,                                  /* tp_weaklistoffset */
-        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
-        0,                                  /* tp_del */
-        0,                                  /* tp_version_tag */
-#if PY_VERSION_HEX >= 0x03040000
-        0,                                  /* tp_finalize */
-#endif
-#if PY_VERSION_HEX >= 0x03080000
-        0,                                  /* tp_vectorcall */
-#endif
-#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
-        0,                                  /* tp_print */
-#endif
-#ifdef COUNT_ALLOCS
-        0,                                  /* tp_allocs */
-        0,                                  /* tp_frees */
-        0,                                  /* tp_maxalloc */
-        0,                                  /* tp_prev */
-        0                                   /* tp_next */
-#endif
-      };
-      varlink_type = tmp;
-      type_init = 1;
-      if (PyType_Ready(&varlink_type) < 0)
-      return NULL;
-    }
-    return &varlink_type;
-  }
-  
-  /* Create a variable linking object for use later */
-  SWIGINTERN PyObject *
-  SWIG_Python_newvarlink(void) {
-    swig_varlinkobject *result = PyObject_NEW(swig_varlinkobject, swig_varlink_type());
-    if (result) {
-      result->vars = 0;
-    }
-    return ((PyObject*) result);
-  }
-  
-  SWIGINTERN void 
-  SWIG_Python_addvarlink(PyObject *p, const char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
-    swig_varlinkobject *v = (swig_varlinkobject *) p;
-    swig_globalvar *gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
-    if (gv) {
-      size_t size = strlen(name)+1;
-      gv->name = (char *)malloc(size);
-      if (gv->name) {
-        memcpy(gv->name, name, size);
-        gv->get_attr = get_attr;
-        gv->set_attr = set_attr;
-        gv->next = v->vars;
-      }
-    }
-    v->vars = gv;
-  }
-  
-  SWIGINTERN PyObject *
-  SWIG_globals(void) {
-    static PyObject *globals = 0;
-    if (!globals) {
-      globals = SWIG_newvarlink();
-    }
-    return globals;
-  }
-  
   /* -----------------------------------------------------------------------------
    * constants/methods manipulation
    * ----------------------------------------------------------------------------- */
   
   /* Install Constants */
   SWIGINTERN void
   SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
@@ -7266,31 +7193,28 @@
       if (obj) {
         PyDict_SetItemString(d, constants[i].name, obj);
         Py_DECREF(obj);
       }
     }
   }
   
-  /* -----------------------------------------------------------------------------*/
-  /* Fix SwigMethods to carry the callback ptrs when needed */
-  /* -----------------------------------------------------------------------------*/
+  /* -----------------------------------------------------------------------------
+   * Patch %callback methods' docstrings to hold the callback ptrs
+   * -----------------------------------------------------------------------------*/
   
   SWIGINTERN void
-  SWIG_Python_FixMethods(PyMethodDef *methods,
-    swig_const_info *const_table,
-    swig_type_info **types,
-    swig_type_info **types_initial) {
+  SWIG_Python_FixMethods(PyMethodDef *methods, const swig_const_info *const_table, swig_type_info **types, swig_type_info **types_initial) {
     size_t i;
     for (i = 0; methods[i].ml_name; ++i) {
       const char *c = methods[i].ml_doc;
       if (!c) continue;
       c = strstr(c, "swig_ptr: ");
       if (c) {
         int j;
-        swig_const_info *ci = 0;
+        const swig_const_info *ci = 0;
         const char *name = c + 10;
         for (j = 0; const_table[j].type; ++j) {
           if (strncmp(const_table[j].name, name, 
               strlen(const_table[j].name)) == 0) {
             ci = &(const_table[j]);
             break;
           }
@@ -7314,76 +7238,21 @@
             }
           }
         }
       }
     }
   } 
   
-  /* -----------------------------------------------------------------------------
-   * Method creation and docstring support functions
-   * ----------------------------------------------------------------------------- */
-  
-  /* -----------------------------------------------------------------------------
-   * Function to find the method definition with the correct docstring for the
-   * proxy module as opposed to the low-level API
-   * ----------------------------------------------------------------------------- */
-  
-  SWIGINTERN PyMethodDef *SWIG_PythonGetProxyDoc(const char *name) {
-    /* Find the function in the modified method table */
-    size_t offset = 0;
-    int found = 0;
-    while (SwigMethods_proxydocs[offset].ml_meth != NULL) {
-      if (strcmp(SwigMethods_proxydocs[offset].ml_name, name) == 0) {
-        found = 1;
-        break;
-      }
-      offset++;
-    }
-    /* Use the copy with the modified docstring if available */
-    return found ? &SwigMethods_proxydocs[offset] : NULL;
-  }
-  
-  /* -----------------------------------------------------------------------------
-   * Wrapper of PyInstanceMethod_New() used in Python 3
-   * It is exported to the generated module, used for -fastproxy
-   * ----------------------------------------------------------------------------- */
-  
-  SWIGINTERN PyObject *SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func) {
-    if (PyCFunction_Check(func)) {
-      PyCFunctionObject *funcobj = (PyCFunctionObject *)func;
-      PyMethodDef *ml = SWIG_PythonGetProxyDoc(funcobj->m_ml->ml_name);
-      if (ml)
-      func = PyCFunction_NewEx(ml, funcobj->m_self, funcobj->m_module);
-    }
-#if PY_VERSION_HEX >= 0x03000000
-    return PyInstanceMethod_New(func);
-#else
-    return PyMethod_New(func, NULL, NULL);
-#endif
-  }
-  
-  /* -----------------------------------------------------------------------------
-   * Wrapper of PyStaticMethod_New()
-   * It is exported to the generated module, used for -fastproxy
-   * ----------------------------------------------------------------------------- */
-  
-  SWIGINTERN PyObject *SWIG_PyStaticMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func) {
-    if (PyCFunction_Check(func)) {
-      PyCFunctionObject *funcobj = (PyCFunctionObject *)func;
-      PyMethodDef *ml = SWIG_PythonGetProxyDoc(funcobj->m_ml->ml_name);
-      if (ml)
-      func = PyCFunction_NewEx(ml, funcobj->m_self, funcobj->m_module);
-    }
-    return PyStaticMethod_New(func);
-  }
-  
 #ifdef __cplusplus
 }
 #endif
 
+
+
+
 /* -----------------------------------------------------------------------------*
  *  Partial Init method
  * -----------------------------------------------------------------------------*/
 
 #ifdef __cplusplus
 extern "C"
 #endif
```

### Comparing `gphoto2-2.3.4/src/swig-gp2.5.30/camera_wrap.c` & `gphoto2-2.3.5/src/swig-gp2_5_30/camera_wrap.c`

 * *Files 4% similar despite different names*

```diff
@@ -1,25 +1,22 @@
 /* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 4.0.2
+ * This file was automatically generated by SWIG (https://www.swig.org).
+ * Version 4.1.1
  *
- * This file is not intended to be easily readable and contains a number of
- * coding conventions designed to improve portability and efficiency. Do not make
- * changes to this file unless you know what you are doing--modify the SWIG
- * interface file instead.
+ * Do not make changes to this file unless you know what you are doing - modify
+ * the SWIG interface file instead.
  * ----------------------------------------------------------------------------- */
 
 
-#ifndef SWIGPYTHON
+#define SWIG_VERSION 0x040101
 #define SWIGPYTHON
-#endif
-
 #define SWIG_PYTHON_THREADS
 #define SWIG_PYTHON_DIRECTOR_NO_VTABLE
 #define SWIGPYTHON_BUILTIN
+#define SWIGPYTHON_FASTPROXY
 
 /* -----------------------------------------------------------------------------
  *  This section contains generic SWIG labels for method/variable
  *  declarations/attributes, and other compiler dependent labels.
  * ----------------------------------------------------------------------------- */
 
 /* template workaround for compilers that cannot correctly implement the C++ standard */
@@ -143,23 +140,45 @@
 
 
 #if defined(__GNUC__) && defined(_WIN32) && !defined(SWIG_PYTHON_NO_HYPOT_WORKAROUND)
 /* Workaround for '::hypot' has not been declared', see https://bugs.python.org/issue11566 */
 # include <math.h>
 #endif
 
+#if !defined(PY_SSIZE_T_CLEAN) && !defined(SWIG_NO_PY_SSIZE_T_CLEAN)
+#define PY_SSIZE_T_CLEAN
+#endif
+
+#if __GNUC__ >= 7
+#pragma GCC diagnostic push
+#if defined(__cplusplus) && __cplusplus >=201703L
+#pragma GCC diagnostic ignored "-Wregister" /* For python-2.7 headers that use register */
+#endif
+#endif
+
 #if defined(_DEBUG) && defined(SWIG_PYTHON_INTERPRETER_NO_DEBUG)
 /* Use debug wrappers with the Python release dll */
+
+#if defined(_MSC_VER) && _MSC_VER >= 1929
+/* Workaround compilation errors when redefining _DEBUG in MSVC 2019 version 16.10 and later
+ * See https://github.com/swig/swig/issues/2090 */
+# include <corecrt.h>
+#endif
+
 # undef _DEBUG
 # include <Python.h>
 # define _DEBUG 1
 #else
 # include <Python.h>
 #endif
 
+#if __GNUC__ >= 7
+#pragma GCC diagnostic pop
+#endif
+
 /* -----------------------------------------------------------------------------
  * swigrun.swg
  *
  * This file contains generic C API SWIG runtime support for pointer
  * type checking.
  * ----------------------------------------------------------------------------- */
 
@@ -198,14 +217,16 @@
 # define SWIG_BUFFER_SIZE 1024
 #endif
 
 /* Flags for pointer conversions */
 #define SWIG_POINTER_DISOWN        0x1
 #define SWIG_CAST_NEW_MEMORY       0x2
 #define SWIG_POINTER_NO_NULL       0x4
+#define SWIG_POINTER_CLEAR         0x8
+#define SWIG_POINTER_RELEASE       (SWIG_POINTER_CLEAR | SWIG_POINTER_DISOWN)
 
 /* Flags for new pointer objects */
 #define SWIG_POINTER_OWN           0x1
 
 
 /*
    Flags/methods for returning states.
@@ -269,44 +290,50 @@
       }
 
    Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
    more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
    SWIG errors code.
 
    Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
-   allows to return the 'cast rank', for example, if you have this
+   allows returning the 'cast rank', for example, if you have this
 
        int food(double)
        int fooi(int);
 
    and you call
 
       food(1)   // cast rank '1'  (1 -> 1.0)
       fooi(1)   // cast rank '0'
 
    just use the SWIG_AddCast()/SWIG_CheckState()
 */
 
 #define SWIG_OK                    (0)
+/* Runtime errors are < 0 */
 #define SWIG_ERROR                 (-1)
+/* Errors in range -1 to -99 are in swigerrors.swg (errors for all languages including those not using the runtime) */
+/* Errors in range -100 to -199 are language specific errors defined in *errors.swg */
+/* Errors < -200 are generic runtime specific errors */
+#define SWIG_ERROR_RELEASE_NOT_OWNED (-200)
+
 #define SWIG_IsOK(r)               (r >= 0)
 #define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)
 
 /* The CastRankLimit says how many bits are used for the cast rank */
 #define SWIG_CASTRANKLIMIT         (1 << 8)
 /* The NewMask denotes the object was created (using new/malloc) */
 #define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
 /* The TmpMask is for in/out typemaps that use temporal objects */
 #define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
 /* Simple returning values */
 #define SWIG_BADOBJ                (SWIG_ERROR)
 #define SWIG_OLDOBJ                (SWIG_OK)
 #define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
 #define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
-/* Check, add and del mask methods */
+/* Check, add and del object mask methods */
 #define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
 #define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
 #define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
 #define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
 #define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
 #define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))
 
@@ -444,15 +471,15 @@
   return 0;
 }
 
 /*
   Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
 */
 SWIGRUNTIME swig_cast_info *
-SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty) {
+SWIG_TypeCheckStruct(const swig_type_info *from, swig_type_info *ty) {
   if (ty) {
     swig_cast_info *iter = ty->cast;
     while (iter) {
       if (iter->type == from) {
         if (iter == ty->cast)
           return iter;
         /* Move iter to the top of the linked list */
@@ -504,17 +531,17 @@
 /*
   Return the pretty name associated with this type,
   that is an unmangled type name in a form presentable to the user.
 */
 SWIGRUNTIME const char *
 SWIG_TypePrettyName(const swig_type_info *type) {
   /* The "str" field contains the equivalent pretty names of the
-     type, separated by vertical-bar characters.  We choose
-     to print the last name, as it is often (?) the most
-     specific. */
+     type, separated by vertical-bar characters.  Choose the last
+     name. It should be the most specific; a fully resolved name
+     but not necessarily with default template parameters expanded. */
   if (!type) return NULL;
   if (type->str != NULL) {
     const char *last_name = type->str;
     const char *s;
     for (s = type->str; *s; s++)
       if (*s == '|') last_name = s+1;
     return last_name;
@@ -726,15 +753,15 @@
   return SWIG_UnpackData(++c,ptr,sz);
 }
 
 #ifdef __cplusplus
 }
 #endif
 
-/*  Errors in SWIG */
+/* SWIG Errors applicable to all language modules, values are reserved from -1 to -99 */
 #define  SWIG_UnknownError    	   -1
 #define  SWIG_IOError        	   -2
 #define  SWIG_RuntimeError   	   -3
 #define  SWIG_IndexError     	   -4
 #define  SWIG_TypeError      	   -5
 #define  SWIG_DivisionByZero 	   -6
 #define  SWIG_OverflowError  	   -7
@@ -742,15 +769,14 @@
 #define  SWIG_ValueError     	   -9
 #define  SWIG_SystemError    	   -10
 #define  SWIG_AttributeError 	   -11
 #define  SWIG_MemoryError    	   -12
 #define  SWIG_NullReferenceError   -13
 
 
-
 /* Compatibility macros for Python 3 */
 #if PY_VERSION_HEX >= 0x03000000
 
 #define PyClass_Check(obj) PyObject_IsInstance(obj, (PyObject *)&PyType_Type)
 #define PyInt_Check(x) PyLong_Check(x)
 #define PyInt_AsLong(x) PyLong_AsLong(x)
 #define PyInt_FromLong(x) PyLong_FromLong(x)
@@ -758,15 +784,14 @@
 #define PyString_Check(name) PyBytes_Check(name)
 #define PyString_FromString(x) PyUnicode_FromString(x)
 #define PyString_Format(fmt, args)  PyUnicode_Format(fmt, args)
 #define PyString_AsString(str) PyBytes_AsString(str)
 #define PyString_Size(str) PyBytes_Size(str)	
 #define PyString_InternFromString(key) PyUnicode_InternFromString(key)
 #define Py_TPFLAGS_HAVE_CLASS Py_TPFLAGS_BASETYPE
-#define PyString_AS_STRING(x) PyUnicode_AS_STRING(x)
 #define _PyLong_FromSsize_t(x) PyLong_FromSsize_t(x)
 
 #endif
 
 #ifndef Py_TYPE
 #  define Py_TYPE(op) ((op)->ob_type)
 #endif
@@ -776,46 +801,27 @@
 #if PY_VERSION_HEX >= 0x03000000
 #  define SWIG_Python_str_FromFormat PyUnicode_FromFormat
 #else
 #  define SWIG_Python_str_FromFormat PyString_FromFormat
 #endif
 
 
-/* Warning: This function will allocate a new string in Python 3,
- * so please call SWIG_Python_str_DelForPy3(x) to free the space.
- */
 SWIGINTERN char*
 SWIG_Python_str_AsChar(PyObject *str)
 {
 #if PY_VERSION_HEX >= 0x03030000
   return (char *)PyUnicode_AsUTF8(str);
-#elif PY_VERSION_HEX >= 0x03000000
-  char *newstr = 0;
-  str = PyUnicode_AsUTF8String(str);
-  if (str) {
-    char *cstr;
-    Py_ssize_t len;
-    if (PyBytes_AsStringAndSize(str, &cstr, &len) != -1) {
-      newstr = (char *) malloc(len+1);
-      if (newstr)
-        memcpy(newstr, cstr, len+1);
-    }
-    Py_XDECREF(str);
-  }
-  return newstr;
 #else
   return PyString_AsString(str);
 #endif
 }
 
-#if PY_VERSION_HEX >= 0x03030000 || PY_VERSION_HEX < 0x03000000
-#  define SWIG_Python_str_DelForPy3(x)
-#else
-#  define SWIG_Python_str_DelForPy3(x) free( (void*) (x) )
-#endif
+/* Was useful for Python 3.0.x-3.2.x - now provided only for compatibility
+ * with any uses in user interface files. */
+#define SWIG_Python_str_DelForPy3(x)
 
 
 SWIGINTERN PyObject*
 SWIG_Python_str_FromChar(const char *c)
 {
 #if PY_VERSION_HEX >= 0x03000000
   return PyUnicode_FromString(c); 
@@ -824,18 +830,22 @@
 #endif
 }
 
 #ifndef PyObject_DEL
 # define PyObject_DEL PyObject_Del
 #endif
 
-// SWIGPY_USE_CAPSULE is no longer used within SWIG itself, but some user
-// interface files check for it.
+/* SWIGPY_USE_CAPSULE is no longer used within SWIG itself, but some user interface files check for it. */
 # define SWIGPY_USE_CAPSULE
-# define SWIGPY_CAPSULE_NAME ("swig_runtime_data" SWIG_RUNTIME_VERSION ".type_pointer_capsule" SWIG_TYPE_TABLE_NAME)
+#ifdef SWIGPYTHON_BUILTIN
+# define SWIGPY_CAPSULE_ATTR_NAME "type_pointer_capsule_builtin" SWIG_TYPE_TABLE_NAME
+#else
+# define SWIGPY_CAPSULE_ATTR_NAME "type_pointer_capsule" SWIG_TYPE_TABLE_NAME
+#endif
+# define SWIGPY_CAPSULE_NAME ("swig_runtime_data" SWIG_RUNTIME_VERSION "." SWIGPY_CAPSULE_ATTR_NAME)
 
 #if PY_VERSION_HEX < 0x03020000
 #define PyDescr_TYPE(x) (((PyDescrObject *)(x))->d_type)
 #define PyDescr_NAME(x) (((PyDescrObject *)(x))->d_name)
 #define Py_hash_t long
 #endif
 
@@ -901,15 +911,14 @@
     const char *tmp = SWIG_Python_str_AsChar(old_str);
     PyErr_Clear();
     Py_XINCREF(type);
     if (tmp)
       PyErr_Format(type, "%s %s", tmp, mesg);
     else
       PyErr_Format(type, "%s", mesg);
-    SWIG_Python_str_DelForPy3(tmp);
     Py_DECREF(old_str);
     Py_DECREF(value);
   } else {
     PyErr_SetString(PyExc_RuntimeError, mesg);
   }
 }
 
@@ -932,16 +941,20 @@
     PyObject *type = NULL, *value = NULL, *traceback = NULL;
     PyErr_Fetch(&type, &value, &traceback);
 #if PY_VERSION_HEX >= 0x03000000
     newvalue = PyUnicode_FromFormat("%S\nAdditional information:\n%s", value, message);
 #else
     newvalue = PyString_FromFormat("%s\nAdditional information:\n%s", PyString_AsString(value), message);
 #endif
-    Py_XDECREF(value);
-    PyErr_Restore(type, newvalue, traceback);
+    if (newvalue) {
+      Py_XDECREF(value);
+      PyErr_Restore(type, newvalue, traceback);
+    } else {
+      PyErr_Restore(type, value, traceback);
+    }
   } else {
     /* Raise TypeError using given message */
     PyErr_SetString(PyExc_TypeError, message);
   }
 }
 
 #if defined(SWIG_PYTHON_NO_THREADS)
@@ -950,16 +963,20 @@
 #  endif
 #endif
 #if defined(SWIG_PYTHON_THREADS) /* Threading support is enabled */
 #  if !defined(SWIG_PYTHON_USE_GIL) && !defined(SWIG_PYTHON_NO_USE_GIL)
 #    define SWIG_PYTHON_USE_GIL
 #  endif
 #  if defined(SWIG_PYTHON_USE_GIL) /* Use PyGILState threads calls */
-#    ifndef SWIG_PYTHON_INITIALIZE_THREADS
-#     define SWIG_PYTHON_INITIALIZE_THREADS  PyEval_InitThreads() 
+#    if !defined(SWIG_PYTHON_INITIALIZE_THREADS)
+#      if PY_VERSION_HEX < 0x03070000
+#        define SWIG_PYTHON_INITIALIZE_THREADS PyEval_InitThreads()
+#      else
+#        define SWIG_PYTHON_INITIALIZE_THREADS
+#      endif
 #    endif
 #    ifdef __cplusplus /* C++ code */
        class SWIG_Python_Thread_Block {
          bool status;
          PyGILState_STATE state;
        public:
          void end() { if (status) { PyGILState_Release(state); status = false;} }
@@ -1049,16 +1066,16 @@
  *
  * ----------------------------------------------------------------------------- */
 
 #if PY_VERSION_HEX < 0x02070000 /* 2.7.0 */
 # error "This version of SWIG only supports Python >= 2.7"
 #endif
 
-#if PY_VERSION_HEX >= 0x03000000 && PY_VERSION_HEX < 0x03020000
-# error "This version of SWIG only supports Python 3 >= 3.2"
+#if PY_VERSION_HEX >= 0x03000000 && PY_VERSION_HEX < 0x03030000
+# error "This version of SWIG only supports Python 3 >= 3.3"
 #endif
 
 /* Common SWIG API */
 
 /* for raw pointers */
 #define SWIG_Python_ConvertPtr(obj, pptr, type, flags)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, 0)
 #define SWIG_ConvertPtr(obj, pptr, type, flags)         SWIG_Python_ConvertPtr(obj, pptr, type, flags)
@@ -1165,15 +1182,20 @@
   } else if (result == Py_None) {
     Py_DECREF(result);
     result = obj;
   } else {
     if (!PyList_Check(result)) {
       PyObject *o2 = result;
       result = PyList_New(1);
-      PyList_SetItem(result, 0, o2);
+      if (result) {
+        PyList_SET_ITEM(result, 0, o2);
+      } else {
+        Py_DECREF(obj);
+        return o2;
+      }
     }
     PyList_Append(result,obj);
     Py_DECREF(obj);
   }
   return result;
 }
 
@@ -1247,14 +1269,246 @@
 */
 #ifdef __cplusplus
 #define SWIG_STATIC_POINTER(var)  var
 #else
 #define SWIG_STATIC_POINTER(var)  var = 0; if (!var) var
 #endif
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Python-specific SWIG API */
+#define SWIG_newvarlink()                             SWIG_Python_newvarlink()
+#define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
+#define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)
+ 
+/* -----------------------------------------------------------------------------
+ * global variable support code.
+ * ----------------------------------------------------------------------------- */
+ 
+typedef struct swig_globalvar {   
+  char       *name;                  /* Name of global variable */
+  PyObject *(*get_attr)(void);       /* Return the current value */
+  int       (*set_attr)(PyObject *); /* Set the value */
+  struct swig_globalvar *next;
+} swig_globalvar;
+
+typedef struct swig_varlinkobject {
+  PyObject_HEAD
+  swig_globalvar *vars;
+} swig_varlinkobject;
+
+SWIGINTERN PyObject *
+swig_varlink_repr(PyObject *SWIGUNUSEDPARM(v)) {
+#if PY_VERSION_HEX >= 0x03000000
+  return PyUnicode_InternFromString("<Swig global variables>");
+#else
+  return PyString_FromString("<Swig global variables>");
+#endif
+}
+
+SWIGINTERN PyObject *
+swig_varlink_str(PyObject *o) {
+  swig_varlinkobject *v = (swig_varlinkobject *) o;
+#if PY_VERSION_HEX >= 0x03000000
+  PyObject *str = PyUnicode_InternFromString("(");
+  PyObject *tail;
+  PyObject *joined;
+  swig_globalvar *var;
+  for (var = v->vars; var; var=var->next) {
+    tail = PyUnicode_FromString(var->name);
+    joined = PyUnicode_Concat(str, tail);
+    Py_DecRef(str);
+    Py_DecRef(tail);
+    str = joined;
+    if (var->next) {
+        tail = PyUnicode_InternFromString(", ");
+        joined = PyUnicode_Concat(str, tail);
+        Py_DecRef(str);
+        Py_DecRef(tail);
+        str = joined;
+    }
+  }
+  tail = PyUnicode_InternFromString(")");
+  joined = PyUnicode_Concat(str, tail);
+  Py_DecRef(str);
+  Py_DecRef(tail);
+  str = joined;
+#else
+  PyObject *str = PyString_FromString("(");
+  swig_globalvar *var;
+  for (var = v->vars; var; var=var->next) {
+    PyString_ConcatAndDel(&str,PyString_FromString(var->name));
+    if (var->next) PyString_ConcatAndDel(&str,PyString_FromString(", "));
+  }
+  PyString_ConcatAndDel(&str,PyString_FromString(")"));
+#endif
+  return str;
+}
+
+SWIGINTERN void
+swig_varlink_dealloc(PyObject *o) {
+  swig_varlinkobject *v = (swig_varlinkobject *) o;
+  swig_globalvar *var = v->vars;
+  while (var) {
+    swig_globalvar *n = var->next;
+    free(var->name);
+    free(var);
+    var = n;
+  }
+}
+
+SWIGINTERN PyObject *
+swig_varlink_getattr(PyObject *o, char *n) {
+  swig_varlinkobject *v = (swig_varlinkobject *) o;
+  PyObject *res = NULL;
+  swig_globalvar *var = v->vars;
+  while (var) {
+    if (strcmp(var->name,n) == 0) {
+      res = (*var->get_attr)();
+      break;
+    }
+    var = var->next;
+  }
+  if (res == NULL && !PyErr_Occurred()) {
+    PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
+  }
+  return res;
+}
+
+SWIGINTERN int
+swig_varlink_setattr(PyObject *o, char *n, PyObject *p) {
+  swig_varlinkobject *v = (swig_varlinkobject *) o;
+  int res = 1;
+  swig_globalvar *var = v->vars;
+  while (var) {
+    if (strcmp(var->name,n) == 0) {
+      res = (*var->set_attr)(p);
+      break;
+    }
+    var = var->next;
+  }
+  if (res == 1 && !PyErr_Occurred()) {
+    PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
+  }
+  return res;
+}
+
+SWIGINTERN PyTypeObject*
+swig_varlink_type(void) {
+  static char varlink__doc__[] = "Swig var link object";
+  static PyTypeObject varlink_type;
+  static int type_init = 0;
+  if (!type_init) {
+    const PyTypeObject tmp = {
+#if PY_VERSION_HEX >= 0x03000000
+      PyVarObject_HEAD_INIT(NULL, 0)
+#else
+      PyObject_HEAD_INIT(NULL)
+      0,                                  /* ob_size */
+#endif
+      "swigvarlink",                      /* tp_name */
+      sizeof(swig_varlinkobject),         /* tp_basicsize */
+      0,                                  /* tp_itemsize */
+      (destructor) swig_varlink_dealloc,  /* tp_dealloc */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                       /*tp_print*/
+#else
+      (Py_ssize_t)0,                      /*tp_vectorcall_offset*/
+#endif
+      (getattrfunc) swig_varlink_getattr, /* tp_getattr */
+      (setattrfunc) swig_varlink_setattr, /* tp_setattr */
+      0,                                  /* tp_compare */
+      (reprfunc) swig_varlink_repr,       /* tp_repr */
+      0,                                  /* tp_as_number */
+      0,                                  /* tp_as_sequence */
+      0,                                  /* tp_as_mapping */
+      0,                                  /* tp_hash */
+      0,                                  /* tp_call */
+      (reprfunc) swig_varlink_str,        /* tp_str */
+      0,                                  /* tp_getattro */
+      0,                                  /* tp_setattro */
+      0,                                  /* tp_as_buffer */
+      0,                                  /* tp_flags */
+      varlink__doc__,                     /* tp_doc */
+      0,                                  /* tp_traverse */
+      0,                                  /* tp_clear */
+      0,                                  /* tp_richcompare */
+      0,                                  /* tp_weaklistoffset */
+      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
+      0,                                  /* tp_del */
+      0,                                  /* tp_version_tag */
+#if PY_VERSION_HEX >= 0x03040000
+      0,                                  /* tp_finalize */
+#endif
+#if PY_VERSION_HEX >= 0x03080000
+      0,                                  /* tp_vectorcall */
+#endif
+#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
+      0,                                  /* tp_print */
+#endif
+#ifdef COUNT_ALLOCS
+      0,                                  /* tp_allocs */
+      0,                                  /* tp_frees */
+      0,                                  /* tp_maxalloc */
+      0,                                  /* tp_prev */
+      0                                   /* tp_next */
+#endif
+    };
+    varlink_type = tmp;
+    type_init = 1;
+    if (PyType_Ready(&varlink_type) < 0)
+      return NULL;
+  }
+  return &varlink_type;
+}
+
+/* Create a variable linking object for use later */
+SWIGINTERN PyObject *
+SWIG_Python_newvarlink(void) {
+  swig_varlinkobject *result = PyObject_NEW(swig_varlinkobject, swig_varlink_type());
+  if (result) {
+    result->vars = 0;
+  }
+  return ((PyObject*) result);
+}
+
+SWIGINTERN void 
+SWIG_Python_addvarlink(PyObject *p, const char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
+  swig_varlinkobject *v = (swig_varlinkobject *) p;
+  swig_globalvar *gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
+  if (gv) {
+    size_t size = strlen(name)+1;
+    gv->name = (char *)malloc(size);
+    if (gv->name) {
+      memcpy(gv->name, name, size);
+      gv->get_attr = get_attr;
+      gv->set_attr = set_attr;
+      gv->next = v->vars;
+    }
+  }
+  v->vars = gv;
+}
+
+
+static PyObject *Swig_Globals_global = NULL;
+  
+SWIGINTERN PyObject *
+SWIG_globals(void) {
+  if (Swig_Globals_global == NULL) {
+    Swig_Globals_global = SWIG_newvarlink();
+  }
+  return Swig_Globals_global;
+}
+
+#ifdef __cplusplus
+}
+#endif
+
 /* -----------------------------------------------------------------------------
  * Pointer declarations
  * ----------------------------------------------------------------------------- */
 
 /* Flags for new pointer objects */
 #define SWIG_POINTER_NOSHADOW       (SWIG_POINTER_OWN      << 1)
 #define SWIG_POINTER_NEW            (SWIG_POINTER_NOSHADOW | SWIG_POINTER_OWN)
@@ -1317,52 +1571,59 @@
     SwigPyClientData *data = (SwigPyClientData *)malloc(sizeof(SwigPyClientData));
     /* the klass element */
     data->klass = obj;
     Py_INCREF(data->klass);
     /* the newraw method and newargs arguments used to create a new raw instance */
     if (PyClass_Check(obj)) {
       data->newraw = 0;
-      data->newargs = obj;
       Py_INCREF(obj);
+      data->newargs = obj;
     } else {
       data->newraw = PyObject_GetAttrString(data->klass, "__new__");
       if (data->newraw) {
-	Py_INCREF(data->newraw);
-	data->newargs = PyTuple_New(1);
-	PyTuple_SetItem(data->newargs, 0, obj);
+        data->newargs = PyTuple_New(1);
+        if (data->newargs) {
+          Py_INCREF(obj);
+          PyTuple_SET_ITEM(data->newargs, 0, obj);
+        } else {
+          Py_DECREF(data->newraw);
+          Py_DECREF(data->klass);
+          free(data);
+          return 0;
+        }
       } else {
-	data->newargs = obj;
+        Py_INCREF(obj);
+        data->newargs = obj;
       }
-      Py_INCREF(data->newargs);
     }
     /* the destroy method, aka as the C++ delete method */
     data->destroy = PyObject_GetAttrString(data->klass, "__swig_destroy__");
     if (PyErr_Occurred()) {
       PyErr_Clear();
       data->destroy = 0;
     }
     if (data->destroy) {
-      int flags;
-      Py_INCREF(data->destroy);
-      flags = PyCFunction_GET_FLAGS(data->destroy);
-      data->delargs = !(flags & (METH_O));
+      data->delargs = !(PyCFunction_GET_FLAGS(data->destroy) & METH_O);
     } else {
       data->delargs = 0;
     }
     data->implicitconv = 0;
     data->pytype = 0;
     return data;
   }
 }
 
 SWIGRUNTIME void 
-SwigPyClientData_Del(SwigPyClientData *data) {
+SwigPyClientData_Del(SwigPyClientData *data)
+{
+  Py_XDECREF(data->klass);
   Py_XDECREF(data->newraw);
   Py_XDECREF(data->newargs);
   Py_XDECREF(data->destroy);
+  free(data);
 }
 
 /* =============== SwigPyObject =====================*/
 
 typedef struct {
   PyObject_HEAD
   void *ptr;
@@ -1381,15 +1642,15 @@
 SwigPyObject_get___dict__(PyObject *v, PyObject *SWIGUNUSEDPARM(args))
 {
   SwigPyObject *sobj = (SwigPyObject *)v;
 
   if (!sobj->dict)
     sobj->dict = PyDict_New();
 
-  Py_INCREF(sobj->dict);
+  Py_XINCREF(sobj->dict);
   return sobj->dict;
 }
 
 #endif
 
 SWIGRUNTIME PyObject *
 SwigPyObject_long(SwigPyObject *v)
@@ -1399,26 +1660,29 @@
 
 SWIGRUNTIME PyObject *
 SwigPyObject_format(const char* fmt, SwigPyObject *v)
 {
   PyObject *res = NULL;
   PyObject *args = PyTuple_New(1);
   if (args) {
-    if (PyTuple_SetItem(args, 0, SwigPyObject_long(v)) == 0) {
-      PyObject *ofmt = SWIG_Python_str_FromChar(fmt);
+    PyObject *val = SwigPyObject_long(v);
+    if (val) {
+      PyObject *ofmt;
+      PyTuple_SET_ITEM(args, 0, val);
+      ofmt = SWIG_Python_str_FromChar(fmt);
       if (ofmt) {
 #if PY_VERSION_HEX >= 0x03000000
-	res = PyUnicode_Format(ofmt,args);
+        res = PyUnicode_Format(ofmt,args);
 #else
-	res = PyString_Format(ofmt,args);
+        res = PyString_Format(ofmt,args);
 #endif
-	Py_DECREF(ofmt);
+        Py_DECREF(ofmt);
       }
-      Py_DECREF(args);
     }
+    Py_DECREF(args);
   }
   return res;
 }
 
 SWIGRUNTIME PyObject *
 SwigPyObject_oct(SwigPyObject *v)
 {
@@ -1432,26 +1696,31 @@
 }
 
 SWIGRUNTIME PyObject *
 SwigPyObject_repr(SwigPyObject *v)
 {
   const char *name = SWIG_TypePrettyName(v->ty);
   PyObject *repr = SWIG_Python_str_FromFormat("<Swig Object of type '%s' at %p>", (name ? name : "unknown"), (void *)v);
-  if (v->next) {
+  if (repr && v->next) {
     PyObject *nrep = SwigPyObject_repr((SwigPyObject *)v->next);
+    if (nrep) {
 # if PY_VERSION_HEX >= 0x03000000
-    PyObject *joined = PyUnicode_Concat(repr, nrep);
-    Py_DecRef(repr);
-    Py_DecRef(nrep);
-    repr = joined;
+      PyObject *joined = PyUnicode_Concat(repr, nrep);
+      Py_DecRef(repr);
+      Py_DecRef(nrep);
+      repr = joined;
 # else
-    PyString_ConcatAndDel(&repr,nrep);
+      PyString_ConcatAndDel(&repr,nrep);
 # endif
+    } else {
+      Py_DecRef(repr);
+      repr = NULL;
+    }
   }
-  return repr;  
+  return repr;
 }
 
 /* We need a version taking two PyObject* parameters so it's a valid
  * PyCFunction to use in swigobject_methods[]. */
 SWIGRUNTIME PyObject *
 SwigPyObject_repr2(PyObject *v, PyObject *SWIGUNUSEDPARM(args))
 {
@@ -1513,14 +1782,16 @@
     || (strcmp(Py_TYPE(op)->tp_name,"SwigPyObject") == 0);
 #endif
 }
 
 SWIGRUNTIME PyObject *
 SwigPyObject_New(void *ptr, swig_type_info *ty, int own);
 
+static PyObject* Swig_Capsule_global = NULL;
+
 SWIGRUNTIME void
 SwigPyObject_dealloc(PyObject *v)
 {
   SwigPyObject *sobj = (SwigPyObject *) v;
   PyObject *next = sobj->next;
   if (sobj->own == SWIG_POINTER_OWN) {
     swig_type_info *ty = sobj->ty;
@@ -1539,16 +1810,20 @@
       
       PyObject *type = NULL, *value = NULL, *traceback = NULL;
       PyErr_Fetch(&type, &value, &traceback);
 
       if (data->delargs) {
         /* we need to create a temporary object to carry the destroy operation */
         PyObject *tmp = SwigPyObject_New(sobj->ptr, ty, 0);
-        res = SWIG_Python_CallFunctor(destroy, tmp);
-        Py_DECREF(tmp);
+        if (tmp) {
+          res = SWIG_Python_CallFunctor(destroy, tmp);
+        } else {
+          res = 0;
+        }
+        Py_XDECREF(tmp);
       } else {
         PyCFunction meth = PyCFunction_GET_FUNCTION(destroy);
         PyObject *mself = PyCFunction_GET_SELF(destroy);
         res = ((*meth)(mself, v));
       }
       if (!res)
         PyErr_WriteUnraisable(destroy);
@@ -1559,27 +1834,32 @@
     } 
 #if !defined(SWIG_PYTHON_SILENT_MEMLEAK)
     else {
       const char *name = SWIG_TypePrettyName(ty);
       printf("swig/python detected a memory leak of type '%s', no destructor found.\n", (name ? name : "unknown"));
     }
 #endif
-  } 
+    Py_XDECREF(Swig_Capsule_global);
+  }
   Py_XDECREF(next);
+#ifdef SWIGPYTHON_BUILTIN
+  Py_XDECREF(sobj->dict);
+#endif
   PyObject_DEL(v);
 }
 
 SWIGRUNTIME PyObject* 
 SwigPyObject_append(PyObject* v, PyObject* next)
 {
   SwigPyObject *sobj = (SwigPyObject *) v;
   if (!SwigPyObject_Check(next)) {
     PyErr_SetString(PyExc_TypeError, "Attempt to append a non SwigPyObject");
     return NULL;
   }
+  ((SwigPyObject *)next)->next = sobj->next;
   sobj->next = next;
   Py_INCREF(next);
   return SWIG_Py_Void();
 }
 
 SWIGRUNTIME PyObject* 
 SwigPyObject_next(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
@@ -1616,17 +1896,17 @@
   if (!PyArg_UnpackTuple(args, "own", 0, 1, &val)) {
     return NULL;
   } else {
     SwigPyObject *sobj = (SwigPyObject *)v;
     PyObject *obj = PyBool_FromLong(sobj->own);
     if (val) {
       if (PyObject_IsTrue(val)) {
-        SwigPyObject_acquire(v,args);
+        Py_DECREF(SwigPyObject_acquire(v,args));
       } else {
-        SwigPyObject_disown(v,args);
+        Py_DECREF(SwigPyObject_disown(v,args));
       }
     } 
     return obj;
   }
 }
 
 static PyMethodDef
@@ -1698,15 +1978,19 @@
       PyObject_HEAD_INIT(NULL)
       0,                                    /* ob_size */
 #endif
       "SwigPyObject",                       /* tp_name */
       sizeof(SwigPyObject),                 /* tp_basicsize */
       0,                                    /* tp_itemsize */
       (destructor)SwigPyObject_dealloc,     /* tp_dealloc */
-      0,                                    /* tp_print */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                         /*tp_print*/
+#else
+      (Py_ssize_t)0,                        /*tp_vectorcall_offset*/
+#endif
       (getattrfunc)0,                       /* tp_getattr */
       (setattrfunc)0,                       /* tp_setattr */
 #if PY_VERSION_HEX >= 0x03000000
       0, /* tp_reserved in 3.0.1, tp_compare in 3.0.0 but not used */
 #else
       (cmpfunc)SwigPyObject_compare,        /* tp_compare */
 #endif
@@ -1763,29 +2047,38 @@
       0,                                    /* tp_maxalloc */
       0,                                    /* tp_prev */
       0                                     /* tp_next */
 #endif
     };
     swigpyobject_type = tmp;
     type_init = 1;
-    if (PyType_Ready(&swigpyobject_type) < 0)
+    if (PyType_Ready(&swigpyobject_type) != 0)
       return NULL;
   }
   return &swigpyobject_type;
 }
 
 SWIGRUNTIME PyObject *
 SwigPyObject_New(void *ptr, swig_type_info *ty, int own)
 {
   SwigPyObject *sobj = PyObject_NEW(SwigPyObject, SwigPyObject_type());
   if (sobj) {
     sobj->ptr  = ptr;
     sobj->ty   = ty;
     sobj->own  = own;
     sobj->next = 0;
+#ifdef SWIGPYTHON_BUILTIN
+    sobj->dict = 0;
+#endif
+    if (own == SWIG_POINTER_OWN) {
+      /* Obtain a reference to the Python capsule wrapping the module information, so that the
+       * module information is correctly destroyed after all SWIG python objects have been freed
+       * by the GC (and corresponding destructors invoked) */
+      Py_XINCREF(Swig_Capsule_global);
+    }
   }
   return (PyObject *)sobj;
 }
 
 /* -----------------------------------------------------------------------------
  * Implements a simple Swig Packed type, and use it instead of string
  * ----------------------------------------------------------------------------- */
@@ -1865,15 +2158,19 @@
       PyObject_HEAD_INIT(NULL)
       0,                                    /* ob_size */
 #endif
       "SwigPyPacked",                       /* tp_name */
       sizeof(SwigPyPacked),                 /* tp_basicsize */
       0,                                    /* tp_itemsize */
       (destructor)SwigPyPacked_dealloc,     /* tp_dealloc */
-      0,                                    /* tp_print */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                         /*tp_print*/
+#else
+      (Py_ssize_t)0,                        /*tp_vectorcall_offset*/
+#endif
       (getattrfunc)0,                       /* tp_getattr */
       (setattrfunc)0,                       /* tp_setattr */
 #if PY_VERSION_HEX>=0x03000000
       0, /* tp_reserved in 3.0.1 */
 #else
       (cmpfunc)SwigPyPacked_compare,        /* tp_compare */
 #endif
@@ -1930,15 +2227,15 @@
       0,                                    /* tp_maxalloc */
       0,                                    /* tp_prev */
       0                                     /* tp_next */
 #endif
     };
     swigpypacked_type = tmp;
     type_init = 1;
-    if (PyType_Ready(&swigpypacked_type) < 0)
+    if (PyType_Ready(&swigpypacked_type) != 0)
       return NULL;
   }
   return &swigpypacked_type;
 }
 
 SWIGRUNTIME PyObject *
 SwigPyPacked_New(void *ptr, size_t size, swig_type_info *ty)
@@ -2120,20 +2417,27 @@
       }
     } else {
       if (ptr) *ptr = vptr;
       break;
     }
   }
   if (sobj) {
-    if (own)
-      *own = *own | sobj->own;
-    if (flags & SWIG_POINTER_DISOWN) {
-      sobj->own = 0;
+    if (((flags & SWIG_POINTER_RELEASE) == SWIG_POINTER_RELEASE) && !sobj->own) {
+      res = SWIG_ERROR_RELEASE_NOT_OWNED;
+    } else {
+      if (own)
+        *own = *own | sobj->own;
+      if (flags & SWIG_POINTER_DISOWN) {
+        sobj->own = 0;
+      }
+      if (flags & SWIG_POINTER_CLEAR) {
+        sobj->ptr = 0;
+      }
+      res = SWIG_OK;
     }
-    res = SWIG_OK;
   } else {
     if (implicit_conv) {
       SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
       if (data && !data->implicitconv) {
         PyObject *klass = data->klass;
         if (klass) {
           PyObject *impconv;
@@ -2238,20 +2542,25 @@
   PyObject *newraw = data->newraw;
   if (newraw) {
     inst = PyObject_Call(newraw, data->newargs, NULL);
     if (inst) {
 #if !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
       PyObject **dictptr = _PyObject_GetDictPtr(inst);
       if (dictptr != NULL) {
-	PyObject *dict = *dictptr;
-	if (dict == NULL) {
-	  dict = PyDict_New();
-	  *dictptr = dict;
-	  PyDict_SetItem(dict, SWIG_This(), swig_this);
-	}
+        PyObject *dict = *dictptr;
+        if (dict == NULL) {
+          dict = PyDict_New();
+          *dictptr = dict;
+        }
+        if (dict) {
+          PyDict_SetItem(dict, SWIG_This(), swig_this);
+        } else{
+          Py_DECREF(inst);
+          inst = 0;
+        }
       }
 #else
       if (PyObject_SetAttr(inst, SWIG_This(), swig_this) == -1) {
         Py_DECREF(inst);
         inst = 0;
       }
 #endif
@@ -2265,15 +2574,15 @@
         inst = ((PyTypeObject *)data->newargs)->tp_new((PyTypeObject *)data->newargs, empty_args, empty_kwargs);
         Py_DECREF(empty_kwargs);
         if (inst) {
           if (PyObject_SetAttr(inst, SWIG_This(), swig_this) == -1) {
             Py_DECREF(inst);
             inst = 0;
           } else {
-            Py_TYPE(inst)->tp_flags &= ~Py_TPFLAGS_VALID_VERSION_TAG;
+            PyType_Modified(Py_TYPE(inst));
           }
         }
       }
       Py_DECREF(empty_args);
     }
 #else
     PyObject *dict = PyDict_New();
@@ -2294,30 +2603,34 @@
   PyObject **dictptr = _PyObject_GetDictPtr(inst);
   if (dictptr != NULL) {
     PyObject *dict = *dictptr;
     if (dict == NULL) {
       dict = PyDict_New();
       *dictptr = dict;
     }
-    return PyDict_SetItem(dict, SWIG_This(), swig_this);
+    if (dict) {
+      return PyDict_SetItem(dict, SWIG_This(), swig_this);
+    } else{
+      return -1;
+    }
   }
 #endif
   return PyObject_SetAttr(inst, SWIG_This(), swig_this);
 } 
 
 
 SWIGINTERN PyObject *
 SWIG_Python_InitShadowInstance(PyObject *args) {
   PyObject *obj[2];
   if (!SWIG_Python_UnpackTuple(args, "swiginit", 2, 2, obj)) {
     return NULL;
   } else {
     SwigPyObject *sthis = SWIG_Python_GetSwigThis(obj[0]);
     if (sthis) {
-      SwigPyObject_append((PyObject*) sthis, obj[1]);
+      Py_DECREF(SwigPyObject_append((PyObject*) sthis, obj[1]));
     } else {
       if (SWIG_Python_SetSwigThis(obj[0], obj[1]) != 0)
         return NULL;
     }
     return SWIG_Py_Void();
   }
 }
@@ -2348,15 +2661,17 @@
 #ifdef SWIGPYTHON_BUILTIN
         newobj->dict = 0;
 #endif
       }
     } else {
       newobj = PyObject_New(SwigPyObject, clientdata->pytype);
 #ifdef SWIGPYTHON_BUILTIN
-      newobj->dict = 0;
+      if (newobj) {
+        newobj->dict = 0;
+      }
 #endif
     }
     if (newobj) {
       newobj->ptr = ptr;
       newobj->ty = type;
       newobj->own = own;
       newobj->next = 0;
@@ -2387,89 +2702,111 @@
  *  Get type list 
  * -----------------------------------------------------------------------------*/
 
 #ifdef SWIG_LINK_RUNTIME
 void *SWIG_ReturnGlobalTypeList(void *);
 #endif
 
+static PyObject *Swig_TypeCache_global = NULL;
+
+/* The python cached type query */
+SWIGRUNTIME PyObject *
+SWIG_Python_TypeCache(void) {
+  if (Swig_TypeCache_global == NULL) {
+    Swig_TypeCache_global = PyDict_New();
+  }
+  return Swig_TypeCache_global;
+}
+
 SWIGRUNTIME swig_module_info *
 SWIG_Python_GetModule(void *SWIGUNUSEDPARM(clientdata)) {
+#ifdef SWIG_LINK_RUNTIME
   static void *type_pointer = (void *)0;
   /* first check if module already created */
   if (!type_pointer) {
-#ifdef SWIG_LINK_RUNTIME
     type_pointer = SWIG_ReturnGlobalTypeList((void *)0);
+  }
 #else
-    type_pointer = PyCapsule_Import(SWIGPY_CAPSULE_NAME, 0);
-    if (PyErr_Occurred()) {
-      PyErr_Clear();
-      type_pointer = (void *)0;
-    }
-#endif
+  void *type_pointer = PyCapsule_Import(SWIGPY_CAPSULE_NAME, 0);
+  if (PyErr_Occurred()) {
+    PyErr_Clear();
+    type_pointer = (void *)0;
   }
+#endif
   return (swig_module_info *) type_pointer;
 }
 
+
+static int interpreter_counter = 0; // how many (sub-)interpreters are using swig_module's types
+
 SWIGRUNTIME void
 SWIG_Python_DestroyModule(PyObject *obj)
 {
   swig_module_info *swig_module = (swig_module_info *) PyCapsule_GetPointer(obj, SWIGPY_CAPSULE_NAME);
   swig_type_info **types = swig_module->types;
   size_t i;
+  if (--interpreter_counter != 0) // another sub-interpreter may still be using the swig_module's types
+    return;
   for (i =0; i < swig_module->size; ++i) {
     swig_type_info *ty = types[i];
     if (ty->owndata) {
       SwigPyClientData *data = (SwigPyClientData *) ty->clientdata;
+      ty->clientdata = 0;
       if (data) SwigPyClientData_Del(data);
     }
   }
   Py_DECREF(SWIG_This());
   Swig_This_global = NULL;
+  Py_DECREF(SWIG_globals());
+  Swig_Globals_global = NULL;
+  Py_DECREF(SWIG_Python_TypeCache());
+  Swig_TypeCache_global = NULL;
+  Swig_Capsule_global = NULL;
 }
 
 SWIGRUNTIME void
 SWIG_Python_SetModule(swig_module_info *swig_module) {
 #if PY_VERSION_HEX >= 0x03000000
  /* Add a dummy module object into sys.modules */
   PyObject *module = PyImport_AddModule("swig_runtime_data" SWIG_RUNTIME_VERSION);
 #else
   static PyMethodDef swig_empty_runtime_method_table[] = { {NULL, NULL, 0, NULL} }; /* Sentinel */
   PyObject *module = Py_InitModule("swig_runtime_data" SWIG_RUNTIME_VERSION, swig_empty_runtime_method_table);
 #endif
   PyObject *pointer = PyCapsule_New((void *) swig_module, SWIGPY_CAPSULE_NAME, SWIG_Python_DestroyModule);
   if (pointer && module) {
-    PyModule_AddObject(module, "type_pointer_capsule" SWIG_TYPE_TABLE_NAME, pointer);
+    if (PyModule_AddObject(module, SWIGPY_CAPSULE_ATTR_NAME, pointer) == 0) {
+      ++interpreter_counter;
+      Swig_Capsule_global = pointer;
+    } else {
+      Py_DECREF(pointer);
+    }
   } else {
     Py_XDECREF(pointer);
   }
 }
 
-/* The python cached type query */
-SWIGRUNTIME PyObject *
-SWIG_Python_TypeCache(void) {
-  static PyObject *SWIG_STATIC_POINTER(cache) = PyDict_New();
-  return cache;
-}
-
 SWIGRUNTIME swig_type_info *
 SWIG_Python_TypeQuery(const char *type)
 {
   PyObject *cache = SWIG_Python_TypeCache();
   PyObject *key = SWIG_Python_str_FromChar(type); 
   PyObject *obj = PyDict_GetItem(cache, key);
   swig_type_info *descriptor;
   if (obj) {
     descriptor = (swig_type_info *) PyCapsule_GetPointer(obj, NULL);
   } else {
     swig_module_info *swig_module = SWIG_GetModule(0);
     descriptor = SWIG_TypeQueryModule(swig_module, swig_module, type);
     if (descriptor) {
       obj = PyCapsule_New((void*) descriptor, NULL, NULL);
-      PyDict_SetItem(cache, key, obj);
-      Py_DECREF(obj);
+      if (obj) {
+        PyDict_SetItem(cache, key, obj);
+        Py_DECREF(obj);
+      }
     }
   }
   Py_DECREF(key);
   return descriptor;
 }
 
 /* 
@@ -2494,15 +2831,14 @@
       Py_XINCREF(type);
       PyErr_Clear();
       if (infront) {
 	PyErr_Format(type, "%s %s", mesg, errmesg);
       } else {
 	PyErr_Format(type, "%s %s", errmesg, mesg);
       }
-      SWIG_Python_str_DelForPy3(tmp);
       Py_DECREF(old_str);
     }
     return 1;
   } else {
     return 0;
   }
 }
@@ -2546,15 +2882,14 @@
       const char *otype = (obj ? obj->ob_type->tp_name : 0); 
       if (otype) {
 	PyObject *str = PyObject_Str(obj);
 	const char *cstr = str ? SWIG_Python_str_AsChar(str) : 0;
 	if (cstr) {
 	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s(%s)' is received",
 		       type, otype, cstr);
-          SWIG_Python_str_DelForPy3(cstr);
 	} else {
 	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s' is received",
 		       type, otype);
 	}
 	Py_XDECREF(str);
 	return;
       }
@@ -2568,20 +2903,14 @@
 
 /* Convert a pointer value, signal an exception on a type mismatch */
 SWIGRUNTIME void *
 SWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int SWIGUNUSEDPARM(argnum), int flags) {
   void *result;
   if (SWIG_Python_ConvertPtr(obj, &result, ty, flags) == -1) {
     PyErr_Clear();
-#if SWIG_POINTER_EXCEPTION
-    if (flags) {
-      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);
-      SWIG_Python_ArgFail(argnum);
-    }
-#endif
   }
   return result;
 }
 
 #ifdef SWIGPYTHON_BUILTIN
 SWIGRUNTIME int
 SWIG_Python_NonDynamicSetAttr(PyObject *obj, PyObject *name, PyObject *value) {
@@ -2604,30 +2933,30 @@
     PyErr_Format(PyExc_TypeError, "attribute name must be string, not '%.200s'", name->ob_type->tp_name);
     return -1;
   } else {
     Py_INCREF(name);
   }
 
   if (!tp->tp_dict) {
-    if (PyType_Ready(tp) < 0)
+    if (PyType_Ready(tp) != 0)
       goto done;
   }
 
   descr = _PyType_Lookup(tp, name);
   f = NULL;
   if (descr != NULL)
     f = descr->ob_type->tp_descr_set;
   if (!f) {
     if (PyString_Check(name)) {
       encoded_name = name;
       Py_INCREF(name);
     } else {
       encoded_name = PyUnicode_AsUTF8String(name);
       if (!encoded_name)
-        return -1;
+        goto done;
     }
     PyErr_Format(PyExc_AttributeError, "'%.100s' object has no attribute '%.200s'", tp->tp_name, PyString_AsString(encoded_name));
     Py_DECREF(encoded_name);
   } else {
     res = f(descr, obj, value);
   }
   
@@ -2646,15 +2975,19 @@
 extern "C" {
 #endif
 
 SWIGINTERN Py_hash_t
 SwigPyObject_hash(PyObject *obj) {
   SwigPyObject *sobj = (SwigPyObject *)obj;
   void *ptr = sobj->ptr;
+#if PY_VERSION_HEX < 0x03020000
+  return (Py_hash_t)(Py_ssize_t)ptr;
+#else
   return (Py_hash_t)ptr;
+#endif
 }
 
 SWIGINTERN Py_hash_t
 SWIG_PyNumber_AsPyHash(PyObject *obj) {
   Py_hash_t result = -1;
 #if PY_VERSION_HEX < 0x03020000
   if (PyInt_Check(obj))
@@ -2851,15 +3184,19 @@
       PyObject_HEAD_INIT(&PyType_Type)
       0,                                        /* ob_size */
 #endif
       "swig_static_var_getset_descriptor",      /* tp_name */
       sizeof(PyGetSetDescrObject),              /* tp_basicsize */
       0,                                        /* tp_itemsize */
       (destructor)SwigPyStaticVar_dealloc,      /* tp_dealloc */
-      0,                                        /* tp_print */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                             /* tp_print */
+#else
+      (Py_ssize_t)0,                            /* tp_vectorcall_offset */
+#endif
       0,                                        /* tp_getattr */
       0,                                        /* tp_setattr */
       0,                                        /* tp_compare */
       (reprfunc)SwigPyStaticVar_repr,           /* tp_repr */
       0,                                        /* tp_as_number */
       0,                                        /* tp_as_sequence */
       0,                                        /* tp_as_mapping */
@@ -2935,15 +3272,19 @@
       PyObject_HEAD_INIT(&PyType_Type)
       0,                                        /* ob_size */
 #endif
       "SwigPyObjectType",                       /* tp_name */
       PyType_Type.tp_basicsize,                 /* tp_basicsize */
       0,                                        /* tp_itemsize */
       0,                                        /* tp_dealloc */
-      0,                                        /* tp_print */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                             /* tp_print */
+#else
+      (Py_ssize_t)0,                            /* tp_vectorcall_offset */
+#endif
       0,                                        /* tp_getattr */
       0,                                        /* tp_setattr */
       0,                                        /* tp_compare */
       0,                                        /* tp_repr */
       0,                                        /* tp_as_number */
       0,                                        /* tp_as_sequence */
       0,                                        /* tp_as_mapping */
@@ -3054,18 +3395,18 @@
   Py_XINCREF(result);
   return result;
 }
 
 SWIGINTERN void
 SwigPyBuiltin_SetMetaType (PyTypeObject *type, PyTypeObject *metatype)
 {
-#if PY_VERSION_HEX >= 0x03000000
-    type->ob_base.ob_base.ob_type = metatype;
+#if PY_VERSION_HEX >= 0x030900a4
+    Py_SET_TYPE(type, metatype);
 #else
-    type->ob_type = metatype;
+    Py_TYPE(type) = metatype;
 #endif
 }
 
 
 /* Start of callback function macros for use in PyTypeObject */
 
 typedef PyObject *(*SwigPyWrapperFunction)(PyObject *, PyObject *);
@@ -3395,31 +3736,16 @@
 #endif
 
 
 
 
 #define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 
 
-#define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 
-
-
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* Method creation and docstring support functions */
-
-SWIGINTERN PyMethodDef *SWIG_PythonGetProxyDoc(const char *name);
-SWIGINTERN PyObject *SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func);
-SWIGINTERN PyObject *SWIG_PyStaticMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func);
+#define SWIG_contract_assert(expr, msg) do { if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } } while (0) 
 
-#ifdef __cplusplus
-}
-#endif
 
 
 /* -------- TYPES TABLE (BEGIN) -------- */
 
 #define SWIGTYPE_p_CameraAbilities swig_types[0]
 #define SWIGTYPE_p_CameraCaptureType swig_types[1]
 #define SWIGTYPE_p_CameraDriverStatus swig_types[2]
@@ -3502,18 +3828,14 @@
 
 #else
 #  define SWIG_init    init_camera
 
 #endif
 #define SWIG_name    "_camera"
 
-#define SWIGVERSION 0x040002 
-#define SWIG_VERSION SWIGVERSION
-
-
 #define SWIG_as_voidptr(a) (void *)((const void *)(a)) 
 #define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),(void**)(a)) 
 
 
 #include <stddef.h>
 
 
@@ -3529,27 +3851,14 @@
 SWIGINTERNINLINE PyObject*
   SWIG_From_int  (int value)
 {
   return PyInt_FromLong((long) value);
 }
 
 
-#if GPHOTO2_VERSION < 0x02050a00
-int gp_camera_list_config(Camera *camera, CameraList *list, GPContext *context) {
-    return GP_ERROR_NOT_SUPPORTED;
-}
-int gp_camera_get_single_config(Camera *camera, const char *name,
-                                CameraWidget **widget, GPContext *context) {
-    return GP_ERROR_NOT_SUPPORTED;
-}
-int gp_camera_set_single_config(Camera *camera, const char *name,
-                                CameraWidget *widget, GPContext *context) {
-    return GP_ERROR_NOT_SUPPORTED;
-}
-#endif
 #if GPHOTO2_VERSION < 0x02051100
   unsigned int GP_EVENT_FILE_CHANGED = GP_EVENT_CAPTURE_COMPLETE + 1;
 #endif
 
 SWIGINTERN char *CameraText___str__(CameraText *self){
     return self->text;
   }
@@ -4516,14 +4825,15 @@
       arg2 = NULL;
       /*@SWIG:src/gphoto2/common/macros.i,25,GPHOTO2_ERROR@*/
       PyErr_SetObject(PyExc_GPhoto2Error, PyInt_FromLong(error));
       /*@SWIG@*/
       SWIG_fail;
     }
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_camera_capture_preview", 1, 2, &obj0, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_camera_capture_preview" "', argument " "1"" of type '" "Camera *""'"); 
   }
   arg1 = (Camera *)(argp1);
   if (obj1) {
@@ -4563,14 +4873,15 @@
 SWIGINTERN PyObject *_wrap_CameraText___str__(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   CameraText *arg1 = (CameraText *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   char *result = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraText___str__ takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CameraText, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraText___str__" "', argument " "1"" of type '" "CameraText *""'"); 
   }
   arg1 = (CameraText *)(argp1);
   result = (char *)CameraText___str__(arg1);
@@ -4584,14 +4895,15 @@
 SWIGINTERN PyObject *_wrap_CameraText_text_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   CameraText *arg1 = (CameraText *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   char *result = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraText_text_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CameraText, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraText_text_get" "', argument " "1"" of type '" "CameraText *""'"); 
   }
   arg1 = (CameraText *)(argp1);
   result = (char *)(char *) ((arg1)->text);
@@ -4610,14 +4922,15 @@
 
 SWIGINTERN PyObject *_wrap_delete_CameraText(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   CameraText *arg1 = (CameraText *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_CameraText takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CameraText, SWIG_POINTER_DISOWN |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CameraText" "', argument " "1"" of type '" "CameraText *""'"); 
   }
   arg1 = (CameraText *)(argp1);
   free((char *) arg1);
@@ -4635,14 +4948,15 @@
 SWIGINTERN PyObject *_wrap_CameraFilePath_name_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   CameraFilePath *arg1 = (CameraFilePath *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   char *result = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraFilePath_name_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CameraFilePath, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraFilePath_name_get" "', argument " "1"" of type '" "CameraFilePath *""'"); 
   }
   arg1 = (CameraFilePath *)(argp1);
   result = (char *)(char *) ((arg1)->name);
@@ -4662,14 +4976,15 @@
 SWIGINTERN PyObject *_wrap_CameraFilePath_folder_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   CameraFilePath *arg1 = (CameraFilePath *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   char *result = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraFilePath_folder_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CameraFilePath, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraFilePath_folder_get" "', argument " "1"" of type '" "CameraFilePath *""'"); 
   }
   arg1 = (CameraFilePath *)(argp1);
   result = (char *)(char *) ((arg1)->folder);
@@ -4688,14 +5003,15 @@
 
 SWIGINTERN PyObject *_wrap_delete_CameraFilePath(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   CameraFilePath *arg1 = (CameraFilePath *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_CameraFilePath takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CameraFilePath, SWIG_POINTER_DISOWN |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CameraFilePath" "', argument " "1"" of type '" "CameraFilePath *""'"); 
   }
   arg1 = (CameraFilePath *)(argp1);
   free((char *) arg1);
@@ -4708,14 +5024,15 @@
 
 SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_CameraFilePath) /* defines _wrap_delete_CameraFilePath_destructor_closure */
 
 SWIGINTERN int _wrap_new_Camera(PyObject *self, PyObject *args, PyObject *kwargs) {
   PyObject *resultobj = 0;
   struct _Camera *result = 0 ;
   
+  (void)self;
   if (!SWIG_Python_CheckNoKeywords(kwargs, "new_Camera")) SWIG_fail;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "new_Camera takes no arguments");
   {
     result = (struct _Camera *)new__Camera();
     if (PyErr_Occurred()) SWIG_fail;
   }
   resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p__Camera, SWIG_BUILTIN_INIT |  0 );
@@ -4727,14 +5044,15 @@
 
 SWIGINTERN PyObject *_wrap_delete_Camera(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _Camera *arg1 = (struct _Camera *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_Camera takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__Camera, SWIG_POINTER_DISOWN |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Camera" "', argument " "1"" of type '" "struct _Camera *""'"); 
   }
   arg1 = (struct _Camera *)(argp1);
   {
@@ -4765,14 +5083,15 @@
       arg1 = NULL;
       /*@SWIG:src/gphoto2/common/macros.i,25,GPHOTO2_ERROR@*/
       PyErr_SetObject(PyExc_GPhoto2Error, PyInt_FromLong(error));
       /*@SWIG@*/
       SWIG_fail;
     }
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "Camera_autodetect", 0, 1, &obj0)) SWIG_fail;
   if (obj0) {
     res2 = SWIG_ConvertPtr(obj0, &argp2,SWIGTYPE_p__GPContext, 0 |  0 );
     if (!SWIG_IsOK(res2)) {
       SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Camera_autodetect" "', argument " "2"" of type '" "GPContext *""'"); 
     }
     arg2 = (GPContext *)(argp2);
@@ -4809,14 +5128,15 @@
   CameraAbilities arg2 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   void *argp2 ;
   int res2 = 0 ;
   PyObject * obj1 = 0 ;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "Camera_set_abilities", 1, 1, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Camera_set_abilities" "', argument " "1"" of type '" "struct _Camera *""'"); 
   }
   arg1 = (struct _Camera *)(argp1);
   {
@@ -4851,14 +5171,15 @@
   {
     arg2 = (CameraAbilities *)calloc(1, sizeof(CameraAbilities));
     if (arg2 == NULL) {
       PyErr_SetString(PyExc_MemoryError, "Cannot allocate " "CameraAbilities");
       SWIG_fail;
     }
   }
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Camera_get_abilities takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Camera_get_abilities" "', argument " "1"" of type '" "struct _Camera *""'"); 
   }
   arg1 = (struct _Camera *)(argp1);
   {
@@ -4889,14 +5210,15 @@
   GPPortInfo arg2 = (GPPortInfo) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   void *argp2 = 0 ;
   int res2 = 0 ;
   PyObject * obj1 = 0 ;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "Camera_set_port_info", 1, 1, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Camera_set_port_info" "', argument " "1"" of type '" "struct _Camera *""'"); 
   }
   arg1 = (struct _Camera *)(argp1);
   res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p__GPPortInfo, 0 |  0 );
@@ -4923,14 +5245,15 @@
   int res1 = 0 ;
   GPPortInfo temp2 ;
   
   {
     temp2 = NULL;
     arg2 = &temp2;
   }
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Camera_get_port_info takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Camera_get_port_info" "', argument " "1"" of type '" "struct _Camera *""'"); 
   }
   arg1 = (struct _Camera *)(argp1);
   {
@@ -4954,14 +5277,15 @@
   int arg2 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   int val2 ;
   int ecode2 = 0 ;
   PyObject * obj1 = 0 ;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "Camera_set_port_speed", 1, 1, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Camera_set_port_speed" "', argument " "1"" of type '" "struct _Camera *""'"); 
   }
   arg1 = (struct _Camera *)(argp1);
   ecode2 = SWIG_AsVal_int(obj1, &val2);
@@ -4983,14 +5307,15 @@
 SWIGINTERN PyObject *_wrap_Camera_get_port_speed(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _Camera *arg1 = (struct _Camera *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   int result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Camera_get_port_speed takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Camera_get_port_speed" "', argument " "1"" of type '" "struct _Camera *""'"); 
   }
   arg1 = (struct _Camera *)(argp1);
   {
@@ -5013,14 +5338,15 @@
   void *argp2 = 0 ;
   int res2 = 0 ;
   PyObject * obj1 = 0 ;
   
   {
     arg2 = NULL;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "Camera_init", 0, 1, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Camera_init" "', argument " "1"" of type '" "struct _Camera *""'"); 
   }
   arg1 = (struct _Camera *)(argp1);
   if (obj1) {
@@ -5050,14 +5376,15 @@
   void *argp2 = 0 ;
   int res2 = 0 ;
   PyObject * obj1 = 0 ;
   
   {
     arg2 = NULL;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "Camera_exit", 0, 1, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Camera_exit" "', argument " "1"" of type '" "struct _Camera *""'"); 
   }
   arg1 = (struct _Camera *)(argp1);
   if (obj1) {
@@ -5093,14 +5420,15 @@
   {
     arg3 = NULL;
   }
   {
     temp2 = NULL;
     arg2 = &temp2;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "Camera_get_config", 0, 1, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Camera_get_config" "', argument " "1"" of type '" "struct _Camera *""'"); 
   }
   arg1 = (struct _Camera *)(argp1);
   if (obj1) {
@@ -5146,14 +5474,15 @@
       arg2 = NULL;
       /*@SWIG:src/gphoto2/common/macros.i,25,GPHOTO2_ERROR@*/
       PyErr_SetObject(PyExc_GPhoto2Error, PyInt_FromLong(error));
       /*@SWIG@*/
       SWIG_fail;
     }
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "Camera_list_config", 0, 1, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Camera_list_config" "', argument " "1"" of type '" "struct _Camera *""'"); 
   }
   arg1 = (struct _Camera *)(argp1);
   if (obj1) {
@@ -5209,14 +5538,15 @@
   {
     arg4 = NULL;
   }
   {
     temp3 = NULL;
     arg3 = &temp3;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "Camera_get_single_config", 1, 2, &obj1, &obj2)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Camera_get_single_config" "', argument " "1"" of type '" "struct _Camera *""'"); 
   }
   arg1 = (struct _Camera *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -5262,14 +5592,15 @@
   int res3 = 0 ;
   PyObject * obj1 = 0 ;
   PyObject * obj2 = 0 ;
   
   {
     arg3 = NULL;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "Camera_set_config", 1, 2, &obj1, &obj2)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Camera_set_config" "', argument " "1"" of type '" "struct _Camera *""'"); 
   }
   arg1 = (struct _Camera *)(argp1);
   res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p__CameraWidget, 0 |  0 );
@@ -5313,14 +5644,15 @@
   PyObject * obj1 = 0 ;
   PyObject * obj2 = 0 ;
   PyObject * obj3 = 0 ;
   
   {
     arg4 = NULL;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "Camera_set_single_config", 2, 3, &obj1, &obj2, &obj3)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Camera_set_single_config" "', argument " "1"" of type '" "struct _Camera *""'"); 
   }
   arg1 = (struct _Camera *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -5370,14 +5702,15 @@
   {
     arg2 = (CameraText *)calloc(1, sizeof(CameraText));
     if (arg2 == NULL) {
       PyErr_SetString(PyExc_MemoryError, "Cannot allocate " "CameraText");
       SWIG_fail;
     }
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "Camera_get_summary", 0, 1, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Camera_get_summary" "', argument " "1"" of type '" "struct _Camera *""'"); 
   }
   arg1 = (struct _Camera *)(argp1);
   if (obj1) {
@@ -5426,14 +5759,15 @@
   {
     arg2 = (CameraText *)calloc(1, sizeof(CameraText));
     if (arg2 == NULL) {
       PyErr_SetString(PyExc_MemoryError, "Cannot allocate " "CameraText");
       SWIG_fail;
     }
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "Camera_get_manual", 0, 1, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Camera_get_manual" "', argument " "1"" of type '" "struct _Camera *""'"); 
   }
   arg1 = (struct _Camera *)(argp1);
   if (obj1) {
@@ -5482,14 +5816,15 @@
   {
     arg2 = (CameraText *)calloc(1, sizeof(CameraText));
     if (arg2 == NULL) {
       PyErr_SetString(PyExc_MemoryError, "Cannot allocate " "CameraText");
       SWIG_fail;
     }
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "Camera_get_about", 0, 1, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Camera_get_about" "', argument " "1"" of type '" "struct _Camera *""'"); 
   }
   arg1 = (struct _Camera *)(argp1);
   if (obj1) {
@@ -5542,14 +5877,15 @@
   {
     arg3 = (CameraFilePath *)calloc(1, sizeof(CameraFilePath));
     if (arg3 == NULL) {
       PyErr_SetString(PyExc_MemoryError, "Cannot allocate " "CameraFilePath");
       SWIG_fail;
     }
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "Camera_capture", 1, 2, &obj1, &obj2)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Camera_capture" "', argument " "1"" of type '" "struct _Camera *""'"); 
   }
   arg1 = (struct _Camera *)(argp1);
   ecode2 = SWIG_AsVal_int(obj1, &val2);
@@ -5595,14 +5931,15 @@
   void *argp2 = 0 ;
   int res2 = 0 ;
   PyObject * obj1 = 0 ;
   
   {
     arg2 = NULL;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "Camera_trigger_capture", 0, 1, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Camera_trigger_capture" "', argument " "1"" of type '" "struct _Camera *""'"); 
   }
   arg1 = (struct _Camera *)(argp1);
   if (obj1) {
@@ -5643,14 +5980,15 @@
       arg2 = NULL;
       /*@SWIG:src/gphoto2/common/macros.i,25,GPHOTO2_ERROR@*/
       PyErr_SetObject(PyExc_GPhoto2Error, PyInt_FromLong(error));
       /*@SWIG@*/
       SWIG_fail;
     }
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "Camera_capture_preview", 0, 1, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Camera_capture_preview" "', argument " "1"" of type '" "struct _Camera *""'"); 
   }
   arg1 = (struct _Camera *)(argp1);
   if (obj1) {
@@ -5709,14 +6047,15 @@
   }
   {
     temp_type3 = -1;
     temp_data3 = NULL;
     arg3 = &temp_type3;
     arg4 = &temp_data3;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "Camera_wait_for_event", 1, 2, &obj1, &obj2)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Camera_wait_for_event" "', argument " "1"" of type '" "struct _Camera *""'"); 
   }
   arg1 = (struct _Camera *)(argp1);
   ecode2 = SWIG_AsVal_int(obj1, &val2);
@@ -5779,14 +6118,15 @@
   }
   {
     temp_ptr2 = NULL;
     temp_cnt2 = 0;
     arg2 = &temp_ptr2;
     arg3 = &temp_cnt2;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "Camera_get_storageinfo", 0, 1, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Camera_get_storageinfo" "', argument " "1"" of type '" "struct _Camera *""'"); 
   }
   arg1 = (struct _Camera *)(argp1);
   if (obj1) {
@@ -5856,14 +6196,15 @@
       arg3 = NULL;
       /*@SWIG:src/gphoto2/common/macros.i,25,GPHOTO2_ERROR@*/
       PyErr_SetObject(PyExc_GPhoto2Error, PyInt_FromLong(error));
       /*@SWIG@*/
       SWIG_fail;
     }
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "Camera_folder_list_files", 1, 2, &obj1, &obj2)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Camera_folder_list_files" "', argument " "1"" of type '" "struct _Camera *""'"); 
   }
   arg1 = (struct _Camera *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -5931,14 +6272,15 @@
       arg3 = NULL;
       /*@SWIG:src/gphoto2/common/macros.i,25,GPHOTO2_ERROR@*/
       PyErr_SetObject(PyExc_GPhoto2Error, PyInt_FromLong(error));
       /*@SWIG@*/
       SWIG_fail;
     }
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "Camera_folder_list_folders", 1, 2, &obj1, &obj2)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Camera_folder_list_folders" "', argument " "1"" of type '" "struct _Camera *""'"); 
   }
   arg1 = (struct _Camera *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -5995,14 +6337,15 @@
   int res3 = 0 ;
   PyObject * obj1 = 0 ;
   PyObject * obj2 = 0 ;
   
   {
     arg3 = NULL;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "Camera_folder_delete_all", 1, 2, &obj1, &obj2)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Camera_folder_delete_all" "', argument " "1"" of type '" "struct _Camera *""'"); 
   }
   arg1 = (struct _Camera *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -6057,14 +6400,15 @@
   PyObject * obj3 = 0 ;
   PyObject * obj4 = 0 ;
   PyObject * obj5 = 0 ;
   
   {
     arg6 = NULL;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "Camera_folder_put_file", 4, 5, &obj1, &obj2, &obj3, &obj4, &obj5)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Camera_folder_put_file" "', argument " "1"" of type '" "struct _Camera *""'"); 
   }
   arg1 = (struct _Camera *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -6128,14 +6472,15 @@
   PyObject * obj1 = 0 ;
   PyObject * obj2 = 0 ;
   PyObject * obj3 = 0 ;
   
   {
     arg4 = NULL;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "Camera_folder_make_dir", 2, 3, &obj1, &obj2, &obj3)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Camera_folder_make_dir" "', argument " "1"" of type '" "struct _Camera *""'"); 
   }
   arg1 = (struct _Camera *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -6189,14 +6534,15 @@
   PyObject * obj1 = 0 ;
   PyObject * obj2 = 0 ;
   PyObject * obj3 = 0 ;
   
   {
     arg4 = NULL;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "Camera_folder_remove_dir", 2, 3, &obj1, &obj2, &obj3)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Camera_folder_remove_dir" "', argument " "1"" of type '" "struct _Camera *""'"); 
   }
   arg1 = (struct _Camera *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -6258,14 +6604,15 @@
   {
     arg4 = (CameraFileInfo *)calloc(1, sizeof(CameraFileInfo));
     if (arg4 == NULL) {
       PyErr_SetString(PyExc_MemoryError, "Cannot allocate " "CameraFileInfo");
       SWIG_fail;
     }
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "Camera_file_get_info", 2, 3, &obj1, &obj2, &obj3)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Camera_file_get_info" "', argument " "1"" of type '" "struct _Camera *""'"); 
   }
   arg1 = (struct _Camera *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -6334,14 +6681,15 @@
   PyObject * obj2 = 0 ;
   PyObject * obj3 = 0 ;
   PyObject * obj4 = 0 ;
   
   {
     arg5 = NULL;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "Camera_file_set_info", 3, 4, &obj1, &obj2, &obj3, &obj4)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Camera_file_set_info" "', argument " "1"" of type '" "struct _Camera *""'"); 
   }
   arg1 = (struct _Camera *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -6421,14 +6769,15 @@
       arg5 = NULL;
       /*@SWIG:src/gphoto2/common/macros.i,25,GPHOTO2_ERROR@*/
       PyErr_SetObject(PyExc_GPhoto2Error, PyInt_FromLong(error));
       /*@SWIG@*/
       SWIG_fail;
     }
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "Camera_file_get", 3, 4, &obj1, &obj2, &obj3, &obj4)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Camera_file_get" "', argument " "1"" of type '" "struct _Camera *""'"); 
   }
   arg1 = (struct _Camera *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -6514,14 +6863,15 @@
   PyObject * obj4 = 0 ;
   PyObject * obj5 = 0 ;
   PyObject * obj6 = 0 ;
   
   {
     arg8 = NULL;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "Camera_file_read", 5, 6, &obj1, &obj2, &obj3, &obj4, &obj5, &obj6)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Camera_file_read" "', argument " "1"" of type '" "struct _Camera *""'"); 
   }
   arg1 = (struct _Camera *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -6607,14 +6957,15 @@
   PyObject * obj1 = 0 ;
   PyObject * obj2 = 0 ;
   PyObject * obj3 = 0 ;
   
   {
     arg4 = NULL;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "Camera_file_delete", 2, 3, &obj1, &obj2, &obj3)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Camera_file_delete" "', argument " "1"" of type '" "struct _Camera *""'"); 
   }
   arg1 = (struct _Camera *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -6657,14 +7008,15 @@
   Camera *temp1 ;
   int result;
   
   {
     temp1 = NULL;
     arg1 = &temp1;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_camera_new", 0, 0)) SWIG_fail;
   result = (int)gp_camera_new(arg1);
   resultobj = SWIG_From_int((int)(result));
   {
     resultobj = SWIG_Python_AppendOutput(
       resultobj, SWIG_NewPointerObj(*arg1, SWIGTYPE_p__Camera, SWIG_POINTER_OWN));
   }
@@ -6682,14 +7034,15 @@
   int res1 = 0 ;
   void *argp2 ;
   int res2 = 0 ;
   PyObject * obj0 = 0 ;
   PyObject * obj1 = 0 ;
   int result;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_camera_set_abilities", 2, 2, &obj0, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_camera_set_abilities" "', argument " "1"" of type '" "Camera *""'"); 
   }
   arg1 = (Camera *)(argp1);
   {
@@ -6723,14 +7076,15 @@
   {
     arg2 = (CameraAbilities *)calloc(1, sizeof(CameraAbilities));
     if (arg2 == NULL) {
       PyErr_SetString(PyExc_MemoryError, "Cannot allocate " "CameraAbilities");
       SWIG_fail;
     }
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_camera_get_abilities", 1, 1, &obj0)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_camera_get_abilities" "', argument " "1"" of type '" "Camera *""'"); 
   }
   arg1 = (Camera *)(argp1);
   result = (int)gp_camera_get_abilities(arg1,arg2);
@@ -6760,14 +7114,15 @@
   int res1 = 0 ;
   void *argp2 = 0 ;
   int res2 = 0 ;
   PyObject * obj0 = 0 ;
   PyObject * obj1 = 0 ;
   int result;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_camera_set_port_info", 2, 2, &obj0, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_camera_set_port_info" "', argument " "1"" of type '" "Camera *""'"); 
   }
   arg1 = (Camera *)(argp1);
   res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p__GPPortInfo, 0 |  0 );
@@ -6793,14 +7148,15 @@
   PyObject * obj0 = 0 ;
   int result;
   
   {
     temp2 = NULL;
     arg2 = &temp2;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_camera_get_port_info", 1, 1, &obj0)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_camera_get_port_info" "', argument " "1"" of type '" "Camera *""'"); 
   }
   arg1 = (Camera *)(argp1);
   result = (int)gp_camera_get_port_info(arg1,arg2);
@@ -6823,14 +7179,15 @@
   int res1 = 0 ;
   int val2 ;
   int ecode2 = 0 ;
   PyObject * obj0 = 0 ;
   PyObject * obj1 = 0 ;
   int result;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_camera_set_port_speed", 2, 2, &obj0, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_camera_set_port_speed" "', argument " "1"" of type '" "Camera *""'"); 
   }
   arg1 = (Camera *)(argp1);
   ecode2 = SWIG_AsVal_int(obj1, &val2);
@@ -6850,14 +7207,15 @@
   PyObject *resultobj = 0;
   Camera *arg1 = (Camera *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   PyObject * obj0 = 0 ;
   int result;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_camera_get_port_speed", 1, 1, &obj0)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_camera_get_port_speed" "', argument " "1"" of type '" "Camera *""'"); 
   }
   arg1 = (Camera *)(argp1);
   result = (int)gp_camera_get_port_speed(arg1);
@@ -6886,14 +7244,15 @@
       arg1 = NULL;
       /*@SWIG:src/gphoto2/common/macros.i,25,GPHOTO2_ERROR@*/
       PyErr_SetObject(PyExc_GPhoto2Error, PyInt_FromLong(error));
       /*@SWIG@*/
       SWIG_fail;
     }
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_camera_autodetect", 0, 1, &obj0)) SWIG_fail;
   if (obj0) {
     res2 = SWIG_ConvertPtr(obj0, &argp2,SWIGTYPE_p__GPContext, 0 |  0 );
     if (!SWIG_IsOK(res2)) {
       SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gp_camera_autodetect" "', argument " "2"" of type '" "GPContext *""'"); 
     }
     arg2 = (GPContext *)(argp2);
@@ -6932,14 +7291,15 @@
   PyObject * obj0 = 0 ;
   PyObject * obj1 = 0 ;
   int result;
   
   {
     arg2 = NULL;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_camera_init", 1, 2, &obj0, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_camera_init" "', argument " "1"" of type '" "Camera *""'"); 
   }
   arg1 = (Camera *)(argp1);
   if (obj1) {
@@ -6972,14 +7332,15 @@
   PyObject * obj0 = 0 ;
   PyObject * obj1 = 0 ;
   int result;
   
   {
     arg2 = NULL;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_camera_exit", 1, 2, &obj0, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_camera_exit" "', argument " "1"" of type '" "Camera *""'"); 
   }
   arg1 = (Camera *)(argp1);
   if (obj1) {
@@ -7014,14 +7375,15 @@
   {
     arg3 = NULL;
   }
   {
     temp2 = NULL;
     arg2 = &temp2;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_camera_get_config", 1, 2, &obj0, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_camera_get_config" "', argument " "1"" of type '" "Camera *""'"); 
   }
   arg1 = (Camera *)(argp1);
   if (obj1) {
@@ -7070,14 +7432,15 @@
       arg2 = NULL;
       /*@SWIG:src/gphoto2/common/macros.i,25,GPHOTO2_ERROR@*/
       PyErr_SetObject(PyExc_GPhoto2Error, PyInt_FromLong(error));
       /*@SWIG@*/
       SWIG_fail;
     }
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_camera_list_config", 1, 2, &obj0, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_camera_list_config" "', argument " "1"" of type '" "Camera *""'"); 
   }
   arg1 = (Camera *)(argp1);
   if (obj1) {
@@ -7132,14 +7495,15 @@
   {
     arg4 = NULL;
   }
   {
     temp3 = NULL;
     arg3 = &temp3;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_camera_get_single_config", 2, 3, &obj0, &obj1, &obj2)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_camera_get_single_config" "', argument " "1"" of type '" "Camera *""'"); 
   }
   arg1 = (Camera *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -7188,14 +7552,15 @@
   PyObject * obj1 = 0 ;
   PyObject * obj2 = 0 ;
   int result;
   
   {
     arg3 = NULL;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_camera_set_config", 2, 3, &obj0, &obj1, &obj2)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_camera_set_config" "', argument " "1"" of type '" "Camera *""'"); 
   }
   arg1 = (Camera *)(argp1);
   res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p__CameraWidget, 0 |  0 );
@@ -7242,14 +7607,15 @@
   PyObject * obj2 = 0 ;
   PyObject * obj3 = 0 ;
   int result;
   
   {
     arg4 = NULL;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_camera_set_single_config", 3, 4, &obj0, &obj1, &obj2, &obj3)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_camera_set_single_config" "', argument " "1"" of type '" "Camera *""'"); 
   }
   arg1 = (Camera *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -7302,14 +7668,15 @@
   {
     arg2 = (CameraText *)calloc(1, sizeof(CameraText));
     if (arg2 == NULL) {
       PyErr_SetString(PyExc_MemoryError, "Cannot allocate " "CameraText");
       SWIG_fail;
     }
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_camera_get_summary", 1, 2, &obj0, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_camera_get_summary" "', argument " "1"" of type '" "Camera *""'"); 
   }
   arg1 = (Camera *)(argp1);
   if (obj1) {
@@ -7357,14 +7724,15 @@
   {
     arg2 = (CameraText *)calloc(1, sizeof(CameraText));
     if (arg2 == NULL) {
       PyErr_SetString(PyExc_MemoryError, "Cannot allocate " "CameraText");
       SWIG_fail;
     }
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_camera_get_manual", 1, 2, &obj0, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_camera_get_manual" "', argument " "1"" of type '" "Camera *""'"); 
   }
   arg1 = (Camera *)(argp1);
   if (obj1) {
@@ -7412,14 +7780,15 @@
   {
     arg2 = (CameraText *)calloc(1, sizeof(CameraText));
     if (arg2 == NULL) {
       PyErr_SetString(PyExc_MemoryError, "Cannot allocate " "CameraText");
       SWIG_fail;
     }
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_camera_get_about", 1, 2, &obj0, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_camera_get_about" "', argument " "1"" of type '" "Camera *""'"); 
   }
   arg1 = (Camera *)(argp1);
   if (obj1) {
@@ -7471,14 +7840,15 @@
   {
     arg3 = (CameraFilePath *)calloc(1, sizeof(CameraFilePath));
     if (arg3 == NULL) {
       PyErr_SetString(PyExc_MemoryError, "Cannot allocate " "CameraFilePath");
       SWIG_fail;
     }
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_camera_capture", 2, 3, &obj0, &obj1, &obj2)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_camera_capture" "', argument " "1"" of type '" "Camera *""'"); 
   }
   arg1 = (Camera *)(argp1);
   ecode2 = SWIG_AsVal_int(obj1, &val2);
@@ -7527,14 +7897,15 @@
   PyObject * obj0 = 0 ;
   PyObject * obj1 = 0 ;
   int result;
   
   {
     arg2 = NULL;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_camera_trigger_capture", 1, 2, &obj0, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_camera_trigger_capture" "', argument " "1"" of type '" "Camera *""'"); 
   }
   arg1 = (Camera *)(argp1);
   if (obj1) {
@@ -7581,14 +7952,15 @@
   }
   {
     temp_type3 = -1;
     temp_data3 = NULL;
     arg3 = &temp_type3;
     arg4 = &temp_data3;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_camera_wait_for_event", 2, 3, &obj0, &obj1, &obj2)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_camera_wait_for_event" "', argument " "1"" of type '" "Camera *""'"); 
   }
   arg1 = (Camera *)(argp1);
   ecode2 = SWIG_AsVal_int(obj1, &val2);
@@ -7654,14 +8026,15 @@
   }
   {
     temp_ptr2 = NULL;
     temp_cnt2 = 0;
     arg2 = &temp_ptr2;
     arg3 = &temp_cnt2;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_camera_get_storageinfo", 1, 2, &obj0, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_camera_get_storageinfo" "', argument " "1"" of type '" "Camera *""'"); 
   }
   arg1 = (Camera *)(argp1);
   if (obj1) {
@@ -7730,14 +8103,15 @@
       arg3 = NULL;
       /*@SWIG:src/gphoto2/common/macros.i,25,GPHOTO2_ERROR@*/
       PyErr_SetObject(PyExc_GPhoto2Error, PyInt_FromLong(error));
       /*@SWIG@*/
       SWIG_fail;
     }
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_camera_folder_list_files", 2, 3, &obj0, &obj1, &obj2)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_camera_folder_list_files" "', argument " "1"" of type '" "Camera *""'"); 
   }
   arg1 = (Camera *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -7808,14 +8182,15 @@
       arg3 = NULL;
       /*@SWIG:src/gphoto2/common/macros.i,25,GPHOTO2_ERROR@*/
       PyErr_SetObject(PyExc_GPhoto2Error, PyInt_FromLong(error));
       /*@SWIG@*/
       SWIG_fail;
     }
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_camera_folder_list_folders", 2, 3, &obj0, &obj1, &obj2)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_camera_folder_list_folders" "', argument " "1"" of type '" "Camera *""'"); 
   }
   arg1 = (Camera *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -7875,14 +8250,15 @@
   PyObject * obj1 = 0 ;
   PyObject * obj2 = 0 ;
   int result;
   
   {
     arg3 = NULL;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_camera_folder_delete_all", 2, 3, &obj0, &obj1, &obj2)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_camera_folder_delete_all" "', argument " "1"" of type '" "Camera *""'"); 
   }
   arg1 = (Camera *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -7940,14 +8316,15 @@
   PyObject * obj4 = 0 ;
   PyObject * obj5 = 0 ;
   int result;
   
   {
     arg6 = NULL;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_camera_folder_put_file", 5, 6, &obj0, &obj1, &obj2, &obj3, &obj4, &obj5)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_camera_folder_put_file" "', argument " "1"" of type '" "Camera *""'"); 
   }
   arg1 = (Camera *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -8014,14 +8391,15 @@
   PyObject * obj2 = 0 ;
   PyObject * obj3 = 0 ;
   int result;
   
   {
     arg4 = NULL;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_camera_folder_make_dir", 3, 4, &obj0, &obj1, &obj2, &obj3)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_camera_folder_make_dir" "', argument " "1"" of type '" "Camera *""'"); 
   }
   arg1 = (Camera *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -8074,14 +8452,15 @@
   PyObject * obj2 = 0 ;
   PyObject * obj3 = 0 ;
   int result;
   
   {
     arg4 = NULL;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_camera_folder_remove_dir", 3, 4, &obj0, &obj1, &obj2, &obj3)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_camera_folder_remove_dir" "', argument " "1"" of type '" "Camera *""'"); 
   }
   arg1 = (Camera *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -8142,14 +8521,15 @@
   {
     arg4 = (CameraFileInfo *)calloc(1, sizeof(CameraFileInfo));
     if (arg4 == NULL) {
       PyErr_SetString(PyExc_MemoryError, "Cannot allocate " "CameraFileInfo");
       SWIG_fail;
     }
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_camera_file_get_info", 3, 4, &obj0, &obj1, &obj2, &obj3)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_camera_file_get_info" "', argument " "1"" of type '" "Camera *""'"); 
   }
   arg1 = (Camera *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -8221,14 +8601,15 @@
   PyObject * obj3 = 0 ;
   PyObject * obj4 = 0 ;
   int result;
   
   {
     arg5 = NULL;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_camera_file_set_info", 4, 5, &obj0, &obj1, &obj2, &obj3, &obj4)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_camera_file_set_info" "', argument " "1"" of type '" "Camera *""'"); 
   }
   arg1 = (Camera *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -8307,14 +8688,15 @@
       arg5 = NULL;
       /*@SWIG:src/gphoto2/common/macros.i,25,GPHOTO2_ERROR@*/
       PyErr_SetObject(PyExc_GPhoto2Error, PyInt_FromLong(error));
       /*@SWIG@*/
       SWIG_fail;
     }
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_camera_file_get", 4, 5, &obj0, &obj1, &obj2, &obj3, &obj4)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_camera_file_get" "', argument " "1"" of type '" "Camera *""'"); 
   }
   arg1 = (Camera *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -8403,14 +8785,15 @@
   PyObject * obj5 = 0 ;
   PyObject * obj6 = 0 ;
   int result;
   
   {
     arg8 = NULL;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_camera_file_read", 6, 7, &obj0, &obj1, &obj2, &obj3, &obj4, &obj5, &obj6)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_camera_file_read" "', argument " "1"" of type '" "Camera *""'"); 
   }
   arg1 = (Camera *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -8499,14 +8882,15 @@
   PyObject * obj2 = 0 ;
   PyObject * obj3 = 0 ;
   int result;
   
   {
     arg4 = NULL;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_camera_file_delete", 3, 4, &obj0, &obj1, &obj2, &obj3)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_camera_file_delete" "', argument " "1"" of type '" "Camera *""'"); 
   }
   arg1 = (Camera *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -8548,14 +8932,15 @@
   int res1 = 0 ;
   int res4 ;
   PyObject * obj0 = 0 ;
   PyObject * obj1 = 0 ;
   PyObject * obj2 = 0 ;
   PyObject * obj3 = 0 ;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_camera_set_timeout_funcs", 4, 4, &obj0, &obj1, &obj2, &obj3)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_camera_set_timeout_funcs" "', argument " "1"" of type '" "Camera *""'"); 
   }
   arg1 = (Camera *)(argp1);
   {
@@ -8592,14 +8977,15 @@
   unsigned int val2 ;
   int ecode2 = 0 ;
   PyObject * obj0 = 0 ;
   PyObject * obj1 = 0 ;
   PyObject * obj2 = 0 ;
   int result;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_camera_start_timeout", 3, 3, &obj0, &obj1, &obj2)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_camera_start_timeout" "', argument " "1"" of type '" "Camera *""'"); 
   }
   arg1 = (Camera *)(argp1);
   ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
@@ -8628,14 +9014,15 @@
   void *argp1 = 0 ;
   int res1 = 0 ;
   unsigned int val2 ;
   int ecode2 = 0 ;
   PyObject * obj0 = 0 ;
   PyObject * obj1 = 0 ;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_camera_stop_timeout", 2, 2, &obj0, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__Camera, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_camera_stop_timeout" "', argument " "1"" of type '" "Camera *""'"); 
   }
   arg1 = (Camera *)(argp1);
   ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
@@ -8648,1067 +9035,14 @@
   return resultobj;
 fail:
   return NULL;
 }
 
 
 static PyMethodDef SwigMethods[] = {
-	 { "SWIG_PyInstanceMethod_New", SWIG_PyInstanceMethod_New, METH_O, NULL},
-	 { "SWIG_PyStaticMethod_New", SWIG_PyStaticMethod_New, METH_O, NULL},
-	 { "gp_camera_capture_preview", _wrap_gp_camera_capture_preview, METH_VARARGS, "\n"
-		"gp_camera_capture_preview(camera, context) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"camera: gphoto2.Camera\n"
-		"context: gphoto2.Context (default=None)\n"
-		"\n"
-		"Captures a preview that won't be stored on the camera but returned in\n"
-		"supplied file.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `camera` :  \n"
-		"    a Camera  \n"
-		"* `file` :  \n"
-		"    a CameraFile  \n"
-		"* `context` :  \n"
-		"    a GPContext  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code  \n"
-		"\n"
-		"For example, you could use gp_capture_preview() for taking some sample\n"
-		"pictures before calling gp_capture().\n"
-		"\n"
-		"See also gphoto2.Camera.capture_preview\n"
-		""},
-	 { "Camera_autodetect", _wrap_Camera_autodetect, METH_VARARGS, "\n"
-		"Camera_autodetect(context)\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"context: gphoto2.Context (default=None)\n"
-		"\n"
-		"Autodetect all detectable camera  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `list` :  \n"
-		"    a CameraList that receives the autodetected cameras  \n"
-		"* `context` :  \n"
-		"    a GPContext  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"the number of cameras detected (0 to n) or a gphoto2 error code (<0)  \n"
-		"\n"
-		"This camera will autodetected all cameras that can be autodetected. This\n"
-		"will for instance detect all USB cameras.  \n"
-		"\n"
-		"CameraList *list; gp_list_new (&list); gp_camera_autodetect (list,\n"
-		"context); ... done! ...\n"
-		"\n"
-		"See also gphoto2.gp_camera_autodetect\n"
-		""},
-	 { "gp_camera_new", _wrap_gp_camera_new, METH_VARARGS, "\n"
-		"gp_camera_new() -> int\n"
-		"Allocates the memory for a Camera.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `camera` :  \n"
-		"    the Camera object to initialize.  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code\n"
-		"\n"
-		"See also gphoto2.Camera\n"
-		""},
-	 { "gp_camera_set_abilities", _wrap_gp_camera_set_abilities, METH_VARARGS, "\n"
-		"gp_camera_set_abilities(camera, abilities) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"camera: gphoto2.Camera\n"
-		"abilities: gphoto2.CameraAbilities\n"
-		"\n"
-		"Sets the camera abilities.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `camera` :  \n"
-		"    a Camera  \n"
-		"* `abilities` :  \n"
-		"    the CameraAbilities to be set  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code  \n"
-		"\n"
-		"You need to call this function before calling gp_camera_init the first\n"
-		"time unless you want gphoto2 to autodetect cameras and choose the first\n"
-		"detected one. By setting the `abilities`, you tell gphoto2 what model\n"
-		"the `camera` is and what camera driver should be used for accessing the\n"
-		"`camera`. You can get `abilities` by calling\n"
-		"gp_abilities_list_get_abilities.\n"
-		"\n"
-		"See also gphoto2.Camera.set_abilities\n"
-		""},
-	 { "gp_camera_get_abilities", _wrap_gp_camera_get_abilities, METH_VARARGS, "\n"
-		"gp_camera_get_abilities(camera) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"camera: gphoto2.Camera\n"
-		"\n"
-		"Retrieve the `abilities` of the `camera`.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `camera` :  \n"
-		"    a Camera  \n"
-		"* `abilities` :  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code\n"
-		"\n"
-		"See also gphoto2.Camera.get_abilities\n"
-		""},
-	 { "gp_camera_set_port_info", _wrap_gp_camera_set_port_info, METH_VARARGS, "\n"
-		"gp_camera_set_port_info(camera, info) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"camera: gphoto2.Camera\n"
-		"info: gphoto2.GPPortInfo\n"
-		"\n"
-		""},
-	 { "gp_camera_get_port_info", _wrap_gp_camera_get_port_info, METH_VARARGS, "\n"
-		"gp_camera_get_port_info(camera) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"camera: gphoto2.Camera\n"
-		"\n"
-		""},
-	 { "gp_camera_set_port_speed", _wrap_gp_camera_set_port_speed, METH_VARARGS, "\n"
-		"gp_camera_set_port_speed(camera, speed) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"camera: gphoto2.Camera\n"
-		"speed: int\n"
-		"\n"
-		"Set the camera speed.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `camera` :  \n"
-		"    a Camera  \n"
-		"* `speed` :  \n"
-		"    the speed  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code  \n"
-		"\n"
-		"This function is typically used prior first initialization using\n"
-		"gp_camera_init for debugging purposes. Normally, a camera driver will\n"
-		"try to figure out the current speed of the camera and set the speed to\n"
-		"the optimal one automatically. Note that this function only works with\n"
-		"serial ports. In other words, you have to set the camera's port to a\n"
-		"serial one (using #gp_camera_set_port_path or #gp_camera_set_port_name)\n"
-		"prior calling this function.\n"
-		"\n"
-		"See also gphoto2.Camera.set_port_speed\n"
-		""},
-	 { "gp_camera_get_port_speed", _wrap_gp_camera_get_port_speed, METH_VARARGS, "\n"
-		"gp_camera_get_port_speed(camera) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"camera: gphoto2.Camera\n"
-		"\n"
-		"Retrieve the current speed.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `camera` :  \n"
-		"    a Camera  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"The current speed or a gphoto2 error code\n"
-		"\n"
-		"See also gphoto2.Camera.get_port_speed\n"
-		""},
-	 { "gp_camera_autodetect", _wrap_gp_camera_autodetect, METH_VARARGS, "\n"
-		"gp_camera_autodetect(context) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"context: gphoto2.Context (default=None)\n"
-		"\n"
-		"Autodetect all detectable camera  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `list` :  \n"
-		"    a CameraList that receives the autodetected cameras  \n"
-		"* `context` :  \n"
-		"    a GPContext  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"the number of cameras detected (0 to n) or a gphoto2 error code (<0)  \n"
-		"\n"
-		"This camera will autodetected all cameras that can be autodetected. This\n"
-		"will for instance detect all USB cameras.  \n"
-		"\n"
-		"CameraList *list; gp_list_new (&list); gp_camera_autodetect (list,\n"
-		"context); ... done! ...\n"
-		"\n"
-		"See also gphoto2.Camera.autodetect\n"
-		""},
-	 { "gp_camera_init", _wrap_gp_camera_init, METH_VARARGS, "\n"
-		"gp_camera_init(camera, context) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"camera: gphoto2.Camera\n"
-		"context: gphoto2.Context (default=None)\n"
-		"\n"
-		"Initiate a connection to the `camera`.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `camera` :  \n"
-		"    a Camera  \n"
-		"* `context` :  \n"
-		"    a GPContext  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code  \n"
-		"\n"
-		"Before calling this function, the `camera` should be set up using\n"
-		"gp_camera_set_port_path() or gp_camera_set_port_name() and\n"
-		"gp_camera_set_abilities(). If that has been omitted, gphoto2 tries to\n"
-		"autodetect any cameras and chooses the first one if any cameras are\n"
-		"found. It is generally a good idea to call gp_camera_exit() after\n"
-		"transactions have been completed in order to give other applications the\n"
-		"chance to access the camera, too.\n"
-		"\n"
-		"See also gphoto2.Camera.init\n"
-		""},
-	 { "gp_camera_exit", _wrap_gp_camera_exit, METH_VARARGS, "\n"
-		"gp_camera_exit(camera, context) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"camera: gphoto2.Camera\n"
-		"context: gphoto2.Context (default=None)\n"
-		"\n"
-		"Close connection to camera.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `camera` :  \n"
-		"    a Camera object  \n"
-		"* `context` :  \n"
-		"    a GPContext object  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.  \n"
-		"\n"
-		"Closes a connection to the camera and therefore gives other application\n"
-		"the possibility to access the camera, too.  \n"
-		"\n"
-		"It is recommended that you call this function when you currently don't\n"
-		"need the camera. The camera will get reinitialized by gp_camera_init()\n"
-		"automatically if you try to access the camera again.\n"
-		"\n"
-		"See also gphoto2.Camera.exit\n"
-		""},
-	 { "gp_camera_get_config", _wrap_gp_camera_get_config, METH_VARARGS, "\n"
-		"gp_camera_get_config(camera, context) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"camera: gphoto2.Camera\n"
-		"context: gphoto2.Context (default=None)\n"
-		"\n"
-		"Retrieve a configuration `window` for the `camera`.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `camera` :  \n"
-		"    a Camera  \n"
-		"* `window` :  \n"
-		"    a CameraWidget  \n"
-		"* `context` :  \n"
-		"    a GPContext  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"gphoto2 error code  \n"
-		"\n"
-		"This `window` can be used for construction of a configuration dialog.\n"
-		"\n"
-		"See also gphoto2.Camera.get_config\n"
-		""},
-	 { "gp_camera_list_config", _wrap_gp_camera_list_config, METH_VARARGS, "\n"
-		"gp_camera_list_config(camera, context) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"camera: gphoto2.Camera\n"
-		"context: gphoto2.Context (default=None)\n"
-		"\n"
-		""},
-	 { "gp_camera_get_single_config", _wrap_gp_camera_get_single_config, METH_VARARGS, "\n"
-		"gp_camera_get_single_config(camera, name, context) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"camera: gphoto2.Camera\n"
-		"name: str\n"
-		"context: gphoto2.Context (default=None)\n"
-		"\n"
-		"Retrieve a single configuration `widget` for the `camera`.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `camera` :  \n"
-		"    a Camera  \n"
-		"* `name` :  \n"
-		"    the name of a configuration widget  \n"
-		"* `widget` :  \n"
-		"    a CameraWidget  \n"
-		"* `context` :  \n"
-		"    a GPContext  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"gphoto2 error code  \n"
-		"\n"
-		"This `widget` will then contain the current and the possible values and\n"
-		"the type.\n"
-		"\n"
-		"See also gphoto2.Camera.get_single_config\n"
-		""},
-	 { "gp_camera_set_config", _wrap_gp_camera_set_config, METH_VARARGS, "\n"
-		"gp_camera_set_config(camera, window, context) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"camera: gphoto2.Camera\n"
-		"window: gphoto2.CameraWidget\n"
-		"context: gphoto2.Context (default=None)\n"
-		"\n"
-		"Sets the configuration.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `camera` :  \n"
-		"    a Camera  \n"
-		"* `window` :  \n"
-		"    a CameraWidget  \n"
-		"* `context` :  \n"
-		"    a GPContext  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code  \n"
-		"\n"
-		"Typically, a `window` is retrieved using gp_camera_get_config and passed\n"
-		"to this function in order to adjust the settings on the camera.\n"
-		"\n"
-		"See also gphoto2.Camera.set_config\n"
-		""},
-	 { "gp_camera_set_single_config", _wrap_gp_camera_set_single_config, METH_VARARGS, "\n"
-		"gp_camera_set_single_config(camera, name, widget, context) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"camera: gphoto2.Camera\n"
-		"name: str\n"
-		"widget: gphoto2.CameraWidget\n"
-		"context: gphoto2.Context (default=None)\n"
-		"\n"
-		"Set a single configuration `widget` for the `camera`.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `camera` :  \n"
-		"    a Camera  \n"
-		"* `name` :  \n"
-		"    the name of a configuration widget  \n"
-		"* `widget` :  \n"
-		"    a CameraWidget  \n"
-		"* `context` :  \n"
-		"    a GPContext  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"gphoto2 error code  \n"
-		"\n"
-		"This `widget` contains the new value of the widget to set.\n"
-		"\n"
-		"See also gphoto2.Camera.set_single_config\n"
-		""},
-	 { "gp_camera_get_summary", _wrap_gp_camera_get_summary, METH_VARARGS, "\n"
-		"gp_camera_get_summary(camera, context) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"camera: gphoto2.Camera\n"
-		"context: gphoto2.Context (default=None)\n"
-		"\n"
-		"Retrieves a camera summary.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `camera` :  \n"
-		"    a Camera  \n"
-		"* `summary` :  \n"
-		"    a CameraText  \n"
-		"* `context` :  \n"
-		"    a GPContext  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code  \n"
-		"\n"
-		"This summary typically contains information like manufacturer, pictures\n"
-		"taken, or generally information that is not configurable.\n"
-		"\n"
-		"See also gphoto2.Camera.get_summary\n"
-		""},
-	 { "gp_camera_get_manual", _wrap_gp_camera_get_manual, METH_VARARGS, "\n"
-		"gp_camera_get_manual(camera, context) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"camera: gphoto2.Camera\n"
-		"context: gphoto2.Context (default=None)\n"
-		"\n"
-		"Retrieves the `manual` for given `camera`.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `camera` :  \n"
-		"    a Camera  \n"
-		"* `manual` :  \n"
-		"    a CameraText  \n"
-		"* `context` :  \n"
-		"    a GPContext  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code  \n"
-		"\n"
-		"This manual typically contains information about using the camera.\n"
-		"\n"
-		"See also gphoto2.Camera.get_manual\n"
-		""},
-	 { "gp_camera_get_about", _wrap_gp_camera_get_about, METH_VARARGS, "\n"
-		"gp_camera_get_about(camera, context) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"camera: gphoto2.Camera\n"
-		"context: gphoto2.Context (default=None)\n"
-		"\n"
-		"Retrieves information about the camera driver.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `camera` :  \n"
-		"    a Camera  \n"
-		"* `about` :  \n"
-		"    a CameraText  \n"
-		"* `context` :  \n"
-		"    a GPContext  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code  \n"
-		"\n"
-		"Typically, this information contains name and address of the author,\n"
-		"acknowledgements, etc.\n"
-		"\n"
-		"See also gphoto2.Camera.get_about\n"
-		""},
-	 { "gp_camera_capture", _wrap_gp_camera_capture, METH_VARARGS, "\n"
-		"gp_camera_capture(camera, type, context) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"camera: gphoto2.Camera\n"
-		"type: CameraCaptureType (gphoto2.GP_CAPTURE_IMAGE etc.)\n"
-		"context: gphoto2.Context (default=None)\n"
-		"\n"
-		"Captures an image, movie, or sound clip depending on the given `type`.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `camera` :  \n"
-		"    a Camera  \n"
-		"* `type` :  \n"
-		"    a CameraCaptureType  \n"
-		"* `path` :  \n"
-		"    a CameraFilePath  \n"
-		"* `context` :  \n"
-		"    a GPContext  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code  \n"
-		"\n"
-		"The resulting file will be stored on the camera. The location gets\n"
-		"stored in `path`. The file can then be downloaded using\n"
-		"gp_camera_file_get.\n"
-		"\n"
-		"See also gphoto2.Camera.capture\n"
-		""},
-	 { "gp_camera_trigger_capture", _wrap_gp_camera_trigger_capture, METH_VARARGS, "\n"
-		"gp_camera_trigger_capture(camera, context) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"camera: gphoto2.Camera\n"
-		"context: gphoto2.Context (default=None)\n"
-		"\n"
-		"Triggers capture of one or more images.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `camera` :  \n"
-		"    a Camera  \n"
-		"* `context` :  \n"
-		"    a GPContext  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code  \n"
-		"\n"
-		"This functions just remotely causes the shutter release and returns\n"
-		"immediately. You will want to run #gp_camera_wait_event until a image is\n"
-		"added which can be downloaded using gp_camera_file_get.\n"
-		"\n"
-		"See also gphoto2.Camera.trigger_capture\n"
-		""},
-	 { "gp_camera_wait_for_event", _wrap_gp_camera_wait_for_event, METH_VARARGS, "\n"
-		"gp_camera_wait_for_event(camera, timeout, context) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"camera: gphoto2.Camera\n"
-		"timeout: int\n"
-		"context: gphoto2.Context (default=None)\n"
-		"\n"
-		"Wait and retrieve an event from the camera.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `camera` :  \n"
-		"    a Camera  \n"
-		"* `timeout` :  \n"
-		"    amount of time to wait in 1/1000 seconds  \n"
-		"* `eventtype` :  \n"
-		"    received CameraEventType [out]  \n"
-		"* `eventdata` :  \n"
-		"    received event specific data [out]  \n"
-		"* `context` :  \n"
-		"    a GPContext  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"gphoto2 error code  \n"
-		"\n"
-		"This function blocks and waits for an event to come from the camera. If\n"
-		"a timeout occurs before an event is received then eventtype will be\n"
-		"GP_EVENT_TIMEOUT and eventdata is left unchanged.  \n"
-		"\n"
-		"If an event is received then eventtype is set to the type of event, and\n"
-		"eventdata is set to event specific data. See the CameraEventType enum to\n"
-		"see which eventtypes match to which types of eventdata.  \n"
-		"\n"
-		"Note that this function will return one event after each other, you need\n"
-		"to be able to call it multiple times, e.g. in a loop, when waiting for\n"
-		"specific events.\n"
-		"\n"
-		"See also gphoto2.Camera.wait_for_event\n"
-		""},
-	 { "gp_camera_get_storageinfo", _wrap_gp_camera_get_storageinfo, METH_VARARGS, "\n"
-		"gp_camera_get_storageinfo(camera, context) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"camera: gphoto2.Camera\n"
-		"context: gphoto2.Context (default=None)\n"
-		"\n"
-		"Gets information on the camera attached storage.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `camera` :  \n"
-		"    a Camera  \n"
-		"* `sifs` :  \n"
-		"    Pointer to receive a pointer to/array of storage info items  \n"
-		"* `nrofsifs` :  \n"
-		"    Pointer to receive number of array entries  \n"
-		"* `context` :  \n"
-		"    a GPContext  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code  \n"
-		"\n"
-		"Retrieves the storage information, like maximum and free space, for the\n"
-		"specified filesystem, if supported by the device. The storage\n"
-		"information is returned in an newly allocated array of\n"
-		"CameraStorageInformation objects, to which the pointer pointed to by\n"
-		"#sifs will be set.  \n"
-		"\n"
-		"The variable pointed to by #nrofsifs will be set to the number of\n"
-		"elements in that array.  \n"
-		"\n"
-		"It is the caller's responsibility to free the memory of the array.\n"
-		"\n"
-		"See also gphoto2.Camera.get_storageinfo\n"
-		""},
-	 { "gp_camera_folder_list_files", _wrap_gp_camera_folder_list_files, METH_VARARGS, "\n"
-		"gp_camera_folder_list_files(camera, folder, context) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"camera: gphoto2.Camera\n"
-		"folder: str\n"
-		"context: gphoto2.Context (default=None)\n"
-		"\n"
-		"Lists the files in supplied `folder`.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `camera` :  \n"
-		"    a Camera  \n"
-		"* `folder` :  \n"
-		"    a folder  \n"
-		"* `list` :  \n"
-		"    a CameraList  \n"
-		"* `context` :  \n"
-		"    a GPContext  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code\n"
-		"\n"
-		"See also gphoto2.Camera.folder_list_files\n"
-		""},
-	 { "gp_camera_folder_list_folders", _wrap_gp_camera_folder_list_folders, METH_VARARGS, "\n"
-		"gp_camera_folder_list_folders(camera, folder, context) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"camera: gphoto2.Camera\n"
-		"folder: str\n"
-		"context: gphoto2.Context (default=None)\n"
-		"\n"
-		"Lists the folders in supplied `folder`.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `camera` :  \n"
-		"    a Camera  \n"
-		"* `folder` :  \n"
-		"    a folder  \n"
-		"* `list` :  \n"
-		"    a CameraList  \n"
-		"* `context` :  \n"
-		"    a GPContext  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code\n"
-		"\n"
-		"See also gphoto2.Camera.folder_list_folders\n"
-		""},
-	 { "gp_camera_folder_delete_all", _wrap_gp_camera_folder_delete_all, METH_VARARGS, "\n"
-		"gp_camera_folder_delete_all(camera, folder, context) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"camera: gphoto2.Camera\n"
-		"folder: str\n"
-		"context: gphoto2.Context (default=None)\n"
-		"\n"
-		"Deletes all files in a given `folder`.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `camera` :  \n"
-		"    a Camera  \n"
-		"* `folder` :  \n"
-		"    a folder  \n"
-		"* `context` :  \n"
-		"    a GPContext  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code\n"
-		"\n"
-		"See also gphoto2.Camera.folder_delete_all\n"
-		""},
-	 { "gp_camera_folder_put_file", _wrap_gp_camera_folder_put_file, METH_VARARGS, "\n"
-		"gp_camera_folder_put_file(camera, folder, filename, type, file, context) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"camera: gphoto2.Camera\n"
-		"folder: str\n"
-		"filename: str\n"
-		"type: CameraFileType (gphoto2.GP_FILE_TYPE_PREVIEW etc.)\n"
-		"file: gphoto2.CameraFile\n"
-		"context: gphoto2.Context (default=None)\n"
-		"\n"
-		"Uploads a file into given `folder`.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `camera` :  \n"
-		"    a Camera  \n"
-		"* `folder` :  \n"
-		"    a folder  \n"
-		"* `file` :  \n"
-		"    a CameraFile  \n"
-		"* `context` :  \n"
-		"    a GPContext  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code\n"
-		"\n"
-		"See also gphoto2.Camera.folder_put_file\n"
-		""},
-	 { "gp_camera_folder_make_dir", _wrap_gp_camera_folder_make_dir, METH_VARARGS, "\n"
-		"gp_camera_folder_make_dir(camera, folder, name, context) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"camera: gphoto2.Camera\n"
-		"folder: str\n"
-		"name: str\n"
-		"context: gphoto2.Context (default=None)\n"
-		"\n"
-		"Creates a new directory called `name` in the given `folder`.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `camera` :  \n"
-		"    a Camera  \n"
-		"* `folder` :  \n"
-		"    the location where to create the new directory  \n"
-		"* `name` :  \n"
-		"    the name of the directory to be created  \n"
-		"* `context` :  \n"
-		"    a GPContext  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code\n"
-		"\n"
-		"See also gphoto2.Camera.folder_make_dir\n"
-		""},
-	 { "gp_camera_folder_remove_dir", _wrap_gp_camera_folder_remove_dir, METH_VARARGS, "\n"
-		"gp_camera_folder_remove_dir(camera, folder, name, context) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"camera: gphoto2.Camera\n"
-		"folder: str\n"
-		"name: str\n"
-		"context: gphoto2.Context (default=None)\n"
-		"\n"
-		"Removes an (empty) directory called `name` from the given `folder`.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `camera` :  \n"
-		"    a Camera  \n"
-		"* `folder` :  \n"
-		"    the folder from which to remove the directory  \n"
-		"* `name` :  \n"
-		"    the name of the directory to be removed  \n"
-		"* `context` :  \n"
-		"    a GPContext  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code\n"
-		"\n"
-		"See also gphoto2.Camera.folder_remove_dir\n"
-		""},
-	 { "gp_camera_file_get_info", _wrap_gp_camera_file_get_info, METH_VARARGS, "\n"
-		"gp_camera_file_get_info(camera, folder, file, context) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"camera: gphoto2.Camera\n"
-		"folder: str\n"
-		"file: str\n"
-		"context: gphoto2.Context (default=None)\n"
-		"\n"
-		"Retrieves information about a file.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `camera` :  \n"
-		"    a Camera  \n"
-		"* `folder` :  \n"
-		"    a folder  \n"
-		"* `file` :  \n"
-		"    the name of the file  \n"
-		"* `info` :  \n"
-		"* `context` :  \n"
-		"    a GPContext  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code\n"
-		"\n"
-		"See also gphoto2.Camera.file_get_info\n"
-		""},
-	 { "gp_camera_file_set_info", _wrap_gp_camera_file_set_info, METH_VARARGS, "\n"
-		"gp_camera_file_set_info(camera, folder, file, info, context) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"camera: gphoto2.Camera\n"
-		"folder: str\n"
-		"file: str\n"
-		"info: gphoto2.CameraFileInfo\n"
-		"context: gphoto2.Context (default=None)\n"
-		"\n"
-		"Sets some file properties like name or permissions.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `camera` :  \n"
-		"    a Camera  \n"
-		"* `folder` :  \n"
-		"    a folder  \n"
-		"* `file` :  \n"
-		"    the name of a file  \n"
-		"* `info` :  \n"
-		"    the CameraFileInfo  \n"
-		"* `context` :  \n"
-		"    a GPContext  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code\n"
-		"\n"
-		"See also gphoto2.Camera.file_set_info\n"
-		""},
-	 { "gp_camera_file_get", _wrap_gp_camera_file_get, METH_VARARGS, "\n"
-		"gp_camera_file_get(camera, folder, file, type, context) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"camera: gphoto2.Camera\n"
-		"folder: str\n"
-		"file: str\n"
-		"type: CameraFileType (gphoto2.GP_FILE_TYPE_PREVIEW etc.)\n"
-		"context: gphoto2.Context (default=None)\n"
-		"\n"
-		"Retrieves a file from the Camera.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `camera` :  \n"
-		"    a Camera  \n"
-		"* `folder` :  \n"
-		"    a folder  \n"
-		"* `file` :  \n"
-		"    the name of a file  \n"
-		"* `type` :  \n"
-		"    the CameraFileType  \n"
-		"* `camera_file` :  \n"
-		"    a CameraFile  \n"
-		"* `context` :  \n"
-		"    a GPContext  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code\n"
-		"\n"
-		"See also gphoto2.Camera.file_get\n"
-		""},
-	 { "gp_camera_file_read", _wrap_gp_camera_file_read, METH_VARARGS, "\n"
-		"gp_camera_file_read(camera, folder, file, type, offset, buf, context) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"camera: gphoto2.Camera\n"
-		"folder: str\n"
-		"file: str\n"
-		"type: CameraFileType (gphoto2.GP_FILE_TYPE_PREVIEW etc.)\n"
-		"offset: int\n"
-		"buf: writable buffer (e.g. memoryview)\n"
-		"context: gphoto2.Context (default=None)\n"
-		"\n"
-		"Reads a file partially from the Camera.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `camera` :  \n"
-		"    a Camera  \n"
-		"* `folder` :  \n"
-		"    a folder  \n"
-		"* `file` :  \n"
-		"    the name of a file  \n"
-		"* `type` :  \n"
-		"    the CameraFileType  \n"
-		"* `offset` :  \n"
-		"    the offset into the camera file  \n"
-		"* `data` :  \n"
-		"    the buffer receiving the data  \n"
-		"* `size` :  \n"
-		"    the size to be read and that was read. (Note: size should not exceed\n"
-		"    32 bits)  \n"
-		"* `context` :  \n"
-		"    a GPContext  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code\n"
-		"\n"
-		"See also gphoto2.Camera.file_read\n"
-		""},
-	 { "gp_camera_file_delete", _wrap_gp_camera_file_delete, METH_VARARGS, "\n"
-		"gp_camera_file_delete(camera, folder, file, context) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"camera: gphoto2.Camera\n"
-		"folder: str\n"
-		"file: str\n"
-		"context: gphoto2.Context (default=None)\n"
-		"\n"
-		"Deletes the file from `folder`.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `camera` :  \n"
-		"    a Camera  \n"
-		"* `folder` :  \n"
-		"    a folder  \n"
-		"* `file` :  \n"
-		"    the name of a file  \n"
-		"* `context` :  \n"
-		"    a GPContext  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code\n"
-		"\n"
-		"See also gphoto2.Camera.file_delete\n"
-		""},
-	 { "gp_camera_set_timeout_funcs", _wrap_gp_camera_set_timeout_funcs, METH_VARARGS, "\n"
-		"gp_camera_set_timeout_funcs(camera, start_func, stop_func, data)\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"camera: gphoto2.Camera\n"
-		"start_func: CameraTimeoutStartFunc\n"
-		"stop_func: CameraTimeoutStopFunc\n"
-		"data: void *\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `camera` :  \n"
-		"    a Camera  \n"
-		"* `start_func` :  \n"
-		"* `stop_func` :  \n"
-		"* `data` :  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code  \n"
-		"\n"
-		"If your frontend has something like idle loops, it is recommended you\n"
-		"use gp_camera_set_timeout_funcs in order to give the camera driver the\n"
-		"possibility to keep up the connection to the camera.\n"
-		"\n"
-		"See also gphoto2.Camera.set_timeout_funcs\n"
-		""},
-	 { "gp_camera_start_timeout", _wrap_gp_camera_start_timeout, METH_VARARGS, "\n"
-		"gp_camera_start_timeout(camera, timeout, func) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"camera: gphoto2.Camera\n"
-		"timeout: unsigned int\n"
-		"func: CameraTimeoutFunc\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `camera` :  \n"
-		"    a Camera  \n"
-		"* `timeout` :  \n"
-		"    number of seconds that should pass between each call to `func`  \n"
-		"* `func` :  \n"
-		"    the function that should be called each `timeout` seconds  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"The id of the background process or a gphoto2 error code  \n"
-		"\n"
-		"This function should be called by the camera driver during camera_init()\n"
-		"if the camera needs to be sent messages periodically in order to prevent\n"
-		"it from shutting down.\n"
-		"\n"
-		"See also gphoto2.Camera.start_timeout\n"
-		""},
-	 { "gp_camera_stop_timeout", _wrap_gp_camera_stop_timeout, METH_VARARGS, "\n"
-		"gp_camera_stop_timeout(camera, id)\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"camera: gphoto2.Camera\n"
-		"id: unsigned int\n"
-		"\n"
-		"Stop periodic calls to keepalive function.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `camera` :  \n"
-		"    a Camera  \n"
-		"* `id` :  \n"
-		"    the id of the background process previously returned by\n"
-		"    gp_camera_start_timeout  \n"
-		"\n"
-		"Call this function in the camera driver if you want to stop a periodic\n"
-		"call to a function that has been started using gp_camera_start_timeout.\n"
-		"\n"
-		"See also gphoto2.Camera.stop_timeout\n"
-		""},
-	 { NULL, NULL, 0, NULL }
-};
-
-static PyMethodDef SwigMethods_proxydocs[] = {
-	 { "SWIG_PyInstanceMethod_New", SWIG_PyInstanceMethod_New, METH_O, NULL},
-	 { "SWIG_PyStaticMethod_New", SWIG_PyStaticMethod_New, METH_O, NULL},
 	 { "gp_camera_capture_preview", _wrap_gp_camera_capture_preview, METH_VARARGS, "\n"
 		"gp_camera_capture_preview(camera, context) -> int\n"
 		"\n"
 		"Parameters\n"
 		"----------\n"
 		"camera: gphoto2.Camera\n"
 		"context: gphoto2.Context (default=None)\n"
@@ -9730,42 +9064,14 @@
 		"a gphoto2 error code  \n"
 		"\n"
 		"For example, you could use gp_capture_preview() for taking some sample\n"
 		"pictures before calling gp_capture().\n"
 		"\n"
 		"See also gphoto2.Camera.capture_preview\n"
 		""},
-	 { "Camera_autodetect", _wrap_Camera_autodetect, METH_VARARGS, "\n"
-		"autodetect(context)\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"context: gphoto2.Context (default=None)\n"
-		"\n"
-		"Autodetect all detectable camera  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `list` :  \n"
-		"    a CameraList that receives the autodetected cameras  \n"
-		"* `context` :  \n"
-		"    a GPContext  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"the number of cameras detected (0 to n) or a gphoto2 error code (<0)  \n"
-		"\n"
-		"This camera will autodetected all cameras that can be autodetected. This\n"
-		"will for instance detect all USB cameras.  \n"
-		"\n"
-		"CameraList *list; gp_list_new (&list); gp_camera_autodetect (list,\n"
-		"context); ... done! ...\n"
-		"\n"
-		"See also gphoto2.gp_camera_autodetect\n"
-		""},
 	 { "gp_camera_new", _wrap_gp_camera_new, METH_VARARGS, "\n"
 		"gp_camera_new() -> int\n"
 		"Allocates the memory for a Camera.  \n"
 		"\n"
 		"Parameters\n"
 		"----------\n"
 		"* `camera` :  \n"
@@ -10815,15 +10121,19 @@
     PyObject_HEAD_INIT(NULL)
     0,                                        /* ob_size */
 #endif
     "gphoto2.camera.CameraText",              /* tp_name */
     sizeof(SwigPyObject),                     /* tp_basicsize */
     0,                                        /* tp_itemsize */
     _wrap_delete_CameraText_destructor_closure,                   /* tp_dealloc */
+#if PY_VERSION_HEX < 0x030800b4
     (printfunc) 0,                            /* tp_print */
+#else
+    (Py_ssize_t) 0,                           /* tp_vectorcall_offset */
+#endif
     (getattrfunc) 0,                          /* tp_getattr */
     (setattrfunc) 0,                          /* tp_setattr */
 #if PY_VERSION_HEX >= 0x03000000
     0,                                        /* tp_compare */
 #else
     (cmpfunc) 0,                              /* tp_compare */
 #endif
@@ -10894,14 +10204,17 @@
 #endif
   },
 #if PY_VERSION_HEX >= 0x03050000
   {
     (unaryfunc) 0,                            /* am_await */
     (unaryfunc) 0,                            /* am_aiter */
     (unaryfunc) 0,                            /* am_anext */
+# if PY_VERSION_HEX >= 0x030a0000
+    (sendfunc) 0,                             /* am_send */
+# endif
   },
 #endif
   {
     (binaryfunc) 0,                           /* nb_add */
     (binaryfunc) 0,                           /* nb_subtract */
     (binaryfunc) 0,                           /* nb_multiply */
 #if PY_VERSION_HEX < 0x03000000
@@ -10994,25 +10307,34 @@
   },
     (PyObject *) 0,                           /* ht_name */
     (PyObject *) 0,                           /* ht_slots */
 #if PY_VERSION_HEX >= 0x03030000
     (PyObject *) 0,                           /* ht_qualname */
     0,                                        /* ht_cached_keys */
 #endif
+#if PY_VERSION_HEX >= 0x03090000
+    (PyObject *) 0,                           /* ht_module */
+#endif
+#if PY_VERSION_HEX >= 0x030b0000
+    (char *) 0,                               /* _ht_tpname */
+  {
+    (PyObject *) 0,                           /* getitem */
+  }
+#endif
 };
 
 SWIGINTERN SwigPyClientData SwigPyBuiltin__CameraText_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__CameraText_type};
 
 static SwigPyGetSet CameraFilePath_name_getset = { _wrap_CameraFilePath_name_get, 0 };
-static SwigPyGetSet CameraFilePath___dict___getset = { SwigPyObject_get___dict__, 0 };
 static SwigPyGetSet CameraFilePath_folder_getset = { _wrap_CameraFilePath_folder_get, 0 };
+static SwigPyGetSet CameraFilePath___dict___getset = { SwigPyObject_get___dict__, 0 };
 SWIGINTERN PyGetSetDef SwigPyBuiltin__CameraFilePath_getset[] = {
     { (char *)"name", SwigPyBuiltin_GetterClosure, 0, (char *)"name", &CameraFilePath_name_getset },
-    { (char *)"__dict__", SwigPyBuiltin_GetterClosure, 0, (char *)"name", &CameraFilePath___dict___getset },
     { (char *)"folder", SwigPyBuiltin_GetterClosure, 0, (char *)"folder", &CameraFilePath_folder_getset },
+    { (char *)"__dict__", SwigPyBuiltin_GetterClosure, 0, (char *)"name", &CameraFilePath___dict___getset },
     { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
 };
 
 SWIGINTERN PyObject *
 SwigPyBuiltin__CameraFilePath_richcompare(PyObject *self, PyObject *other, int op) {
   PyObject *result = NULL;
   PyObject *tuple = PyTuple_New(1);
@@ -11043,15 +10365,19 @@
     PyObject_HEAD_INIT(NULL)
     0,                                        /* ob_size */
 #endif
     "gphoto2.camera.CameraFilePath",          /* tp_name */
     sizeof(SwigPyObject),                     /* tp_basicsize */
     0,                                        /* tp_itemsize */
     _wrap_delete_CameraFilePath_destructor_closure,               /* tp_dealloc */
+#if PY_VERSION_HEX < 0x030800b4
     (printfunc) 0,                            /* tp_print */
+#else
+    (Py_ssize_t) 0,                           /* tp_vectorcall_offset */
+#endif
     (getattrfunc) 0,                          /* tp_getattr */
     (setattrfunc) 0,                          /* tp_setattr */
 #if PY_VERSION_HEX >= 0x03000000
     0,                                        /* tp_compare */
 #else
     (cmpfunc) 0,                              /* tp_compare */
 #endif
@@ -11123,14 +10449,17 @@
 #endif
   },
 #if PY_VERSION_HEX >= 0x03050000
   {
     (unaryfunc) 0,                            /* am_await */
     (unaryfunc) 0,                            /* am_aiter */
     (unaryfunc) 0,                            /* am_anext */
+# if PY_VERSION_HEX >= 0x030a0000
+    (sendfunc) 0,                             /* am_send */
+# endif
   },
 #endif
   {
     (binaryfunc) 0,                           /* nb_add */
     (binaryfunc) 0,                           /* nb_subtract */
     (binaryfunc) 0,                           /* nb_multiply */
 #if PY_VERSION_HEX < 0x03000000
@@ -11223,14 +10552,23 @@
   },
     (PyObject *) 0,                           /* ht_name */
     (PyObject *) 0,                           /* ht_slots */
 #if PY_VERSION_HEX >= 0x03030000
     (PyObject *) 0,                           /* ht_qualname */
     0,                                        /* ht_cached_keys */
 #endif
+#if PY_VERSION_HEX >= 0x03090000
+    (PyObject *) 0,                           /* ht_module */
+#endif
+#if PY_VERSION_HEX >= 0x030b0000
+    (char *) 0,                               /* _ht_tpname */
+  {
+    (PyObject *) 0,                           /* getitem */
+  }
+#endif
 };
 
 SWIGINTERN SwigPyClientData SwigPyBuiltin__CameraFilePath_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__CameraFilePath_type};
 
 static SwigPyGetSet Camera___dict___getset = { SwigPyObject_get___dict__, 0 };
 SWIGINTERN PyGetSetDef SwigPyBuiltin___Camera_getset[] = {
     { (char *)"__dict__", SwigPyBuiltin_GetterClosure, 0, (char *)"_Camera", &Camera___dict___getset },
@@ -12145,15 +11483,19 @@
     PyObject_HEAD_INIT(NULL)
     0,                                        /* ob_size */
 #endif
     "gphoto2.camera.Camera",                  /* tp_name */
     sizeof(SwigPyObject),                     /* tp_basicsize */
     0,                                        /* tp_itemsize */
     _wrap_delete_Camera_destructor_closure,   /* tp_dealloc */
+#if PY_VERSION_HEX < 0x030800b4
     (printfunc) 0,                            /* tp_print */
+#else
+    (Py_ssize_t) 0,                           /* tp_vectorcall_offset */
+#endif
     (getattrfunc) 0,                          /* tp_getattr */
     (setattrfunc) 0,                          /* tp_setattr */
 #if PY_VERSION_HEX >= 0x03000000
     0,                                        /* tp_compare */
 #else
     (cmpfunc) 0,                              /* tp_compare */
 #endif
@@ -12217,14 +11559,17 @@
 #endif
   },
 #if PY_VERSION_HEX >= 0x03050000
   {
     (unaryfunc) 0,                            /* am_await */
     (unaryfunc) 0,                            /* am_aiter */
     (unaryfunc) 0,                            /* am_anext */
+# if PY_VERSION_HEX >= 0x030a0000
+    (sendfunc) 0,                             /* am_send */
+# endif
   },
 #endif
   {
     (binaryfunc) 0,                           /* nb_add */
     (binaryfunc) 0,                           /* nb_subtract */
     (binaryfunc) 0,                           /* nb_multiply */
 #if PY_VERSION_HEX < 0x03000000
@@ -12317,83 +11662,92 @@
   },
     (PyObject *) 0,                           /* ht_name */
     (PyObject *) 0,                           /* ht_slots */
 #if PY_VERSION_HEX >= 0x03030000
     (PyObject *) 0,                           /* ht_qualname */
     0,                                        /* ht_cached_keys */
 #endif
+#if PY_VERSION_HEX >= 0x03090000
+    (PyObject *) 0,                           /* ht_module */
+#endif
+#if PY_VERSION_HEX >= 0x030b0000
+    (char *) 0,                               /* _ht_tpname */
+  {
+    (PyObject *) 0,                           /* getitem */
+  }
+#endif
 };
 
 SWIGINTERN SwigPyClientData SwigPyBuiltin___Camera_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin___Camera_type};
 
 
 /* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */
 
 static swig_type_info _swigt__p_CameraAbilities = {"_p_CameraAbilities", "CameraAbilities *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraCaptureType = {"_p_CameraCaptureType", "enum CameraCaptureType *|CameraCaptureType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraDriverStatus = {"_p_CameraDriverStatus", "enum CameraDriverStatus *|CameraDriverStatus *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraEventType = {"_p_CameraEventType", "enum CameraEventType *|CameraEventType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileAccessType = {"_p_CameraFileAccessType", "enum CameraFileAccessType *|CameraFileAccessType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileInfoFields = {"_p_CameraFileInfoFields", "enum CameraFileInfoFields *|CameraFileInfoFields *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileOperation = {"_p_CameraFileOperation", "enum CameraFileOperation *|CameraFileOperation *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraCaptureType = {"_p_CameraCaptureType", "CameraCaptureType *|enum CameraCaptureType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraDriverStatus = {"_p_CameraDriverStatus", "CameraDriverStatus *|enum CameraDriverStatus *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraEventType = {"_p_CameraEventType", "CameraEventType *|enum CameraEventType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileAccessType = {"_p_CameraFileAccessType", "CameraFileAccessType *|enum CameraFileAccessType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileInfoFields = {"_p_CameraFileInfoFields", "CameraFileInfoFields *|enum CameraFileInfoFields *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileOperation = {"_p_CameraFileOperation", "CameraFileOperation *|enum CameraFileOperation *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_CameraFilePath = {"_p_CameraFilePath", "CameraFilePath *", 0, 0, (void*)&SwigPyBuiltin__CameraFilePath_clientdata, 0};
-static swig_type_info _swigt__p_CameraFilePermissions = {"_p_CameraFilePermissions", "enum CameraFilePermissions *|CameraFilePermissions *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileStatus = {"_p_CameraFileStatus", "enum CameraFileStatus *|CameraFileStatus *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileType = {"_p_CameraFileType", "enum CameraFileType *|CameraFileType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFolderOperation = {"_p_CameraFolderOperation", "enum CameraFolderOperation *|CameraFolderOperation *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraOperation = {"_p_CameraOperation", "enum CameraOperation *|CameraOperation *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraStorageAccessType = {"_p_CameraStorageAccessType", "enum CameraStorageAccessType *|CameraStorageAccessType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraStorageFilesystemType = {"_p_CameraStorageFilesystemType", "enum CameraStorageFilesystemType *|CameraStorageFilesystemType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraStorageInfoFields = {"_p_CameraStorageInfoFields", "enum CameraStorageInfoFields *|CameraStorageInfoFields *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraStorageType = {"_p_CameraStorageType", "enum CameraStorageType *|CameraStorageType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFilePermissions = {"_p_CameraFilePermissions", "CameraFilePermissions *|enum CameraFilePermissions *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileStatus = {"_p_CameraFileStatus", "CameraFileStatus *|enum CameraFileStatus *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileType = {"_p_CameraFileType", "CameraFileType *|enum CameraFileType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFolderOperation = {"_p_CameraFolderOperation", "CameraFolderOperation *|enum CameraFolderOperation *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraOperation = {"_p_CameraOperation", "CameraOperation *|enum CameraOperation *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraStorageAccessType = {"_p_CameraStorageAccessType", "CameraStorageAccessType *|enum CameraStorageAccessType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraStorageFilesystemType = {"_p_CameraStorageFilesystemType", "CameraStorageFilesystemType *|enum CameraStorageFilesystemType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraStorageInfoFields = {"_p_CameraStorageInfoFields", "CameraStorageInfoFields *|enum CameraStorageInfoFields *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraStorageType = {"_p_CameraStorageType", "CameraStorageType *|enum CameraStorageType *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_CameraText = {"_p_CameraText", "CameraText *", 0, 0, (void*)&SwigPyBuiltin__CameraText_clientdata, 0};
-static swig_type_info _swigt__p_CameraWidgetType = {"_p_CameraWidgetType", "enum CameraWidgetType *|CameraWidgetType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_GPLogLevel = {"_p_GPLogLevel", "enum GPLogLevel *|GPLogLevel *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_GPPortType = {"_p_GPPortType", "enum GPPortType *|GPPortType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_GPVersionVerbosity = {"_p_GPVersionVerbosity", "enum GPVersionVerbosity *|GPVersionVerbosity *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_GphotoDeviceType = {"_p_GphotoDeviceType", "enum GphotoDeviceType *|GphotoDeviceType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraWidgetType = {"_p_CameraWidgetType", "CameraWidgetType *|enum CameraWidgetType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GPLogLevel = {"_p_GPLogLevel", "GPLogLevel *|enum GPLogLevel *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GPPortType = {"_p_GPPortType", "GPPortType *|enum GPPortType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GPVersionVerbosity = {"_p_GPVersionVerbosity", "GPVersionVerbosity *|enum GPVersionVerbosity *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GphotoDeviceType = {"_p_GphotoDeviceType", "GphotoDeviceType *|enum GphotoDeviceType *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_SwigPyObject = {"_p_SwigPyObject", "SwigPyObject *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__Camera = {"_p__Camera", "struct _Camera *|Camera *|_Camera *", 0, 0, (void*)&SwigPyBuiltin___Camera_clientdata, 0};
-static swig_type_info _swigt__p__CameraAbilitiesList = {"_p__CameraAbilitiesList", "struct _CameraAbilitiesList *|CameraAbilitiesList *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFile = {"_p__CameraFile", "struct _CameraFile *|CameraFile *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFileHandler = {"_p__CameraFileHandler", "struct _CameraFileHandler *|CameraFileHandler *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFileInfo = {"_p__CameraFileInfo", "struct _CameraFileInfo *|CameraFileInfo *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFileInfoAudio = {"_p__CameraFileInfoAudio", "struct _CameraFileInfoAudio *|CameraFileInfoAudio *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFileInfoFile = {"_p__CameraFileInfoFile", "struct _CameraFileInfoFile *|CameraFileInfoFile *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFileInfoPreview = {"_p__CameraFileInfoPreview", "struct _CameraFileInfoPreview *|CameraFileInfoPreview *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFilesystem = {"_p__CameraFilesystem", "struct _CameraFilesystem *|CameraFilesystem *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFilesystemFuncs = {"_p__CameraFilesystemFuncs", "struct _CameraFilesystemFuncs *|CameraFilesystemFuncs *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFunctions = {"_p__CameraFunctions", "struct _CameraFunctions *|CameraFunctions *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraList = {"_p__CameraList", "struct _CameraList *|CameraList *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraPrivateCore = {"_p__CameraPrivateCore", "struct _CameraPrivateCore *|CameraPrivateCore *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraPrivateLibrary = {"_p__CameraPrivateLibrary", "struct _CameraPrivateLibrary *|CameraPrivateLibrary *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraStorageInformation = {"_p__CameraStorageInformation", "struct _CameraStorageInformation *|CameraStorageInformation *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraWidget = {"_p__CameraWidget", "struct _CameraWidget *|CameraWidget *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__GPContext = {"_p__GPContext", "struct _GPContext *|GPContext *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__GPContextFeedback = {"_p__GPContextFeedback", "enum _GPContextFeedback *|GPContextFeedback *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__GPPortInfo = {"_p__GPPortInfo", "_GPPortInfo *|struct _GPPortInfo *|GPPortInfo", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__GPPortInfoList = {"_p__GPPortInfoList", "struct _GPPortInfoList *|GPPortInfoList *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__Camera = {"_p__Camera", "Camera *|struct _Camera *|_Camera *", 0, 0, (void*)&SwigPyBuiltin___Camera_clientdata, 0};
+static swig_type_info _swigt__p__CameraAbilitiesList = {"_p__CameraAbilitiesList", "CameraAbilitiesList *|struct _CameraAbilitiesList *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFile = {"_p__CameraFile", "CameraFile *|struct _CameraFile *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFileHandler = {"_p__CameraFileHandler", "CameraFileHandler *|struct _CameraFileHandler *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFileInfo = {"_p__CameraFileInfo", "CameraFileInfo *|struct _CameraFileInfo *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFileInfoAudio = {"_p__CameraFileInfoAudio", "CameraFileInfoAudio *|struct _CameraFileInfoAudio *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFileInfoFile = {"_p__CameraFileInfoFile", "CameraFileInfoFile *|struct _CameraFileInfoFile *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFileInfoPreview = {"_p__CameraFileInfoPreview", "CameraFileInfoPreview *|struct _CameraFileInfoPreview *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFilesystem = {"_p__CameraFilesystem", "CameraFilesystem *|struct _CameraFilesystem *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFilesystemFuncs = {"_p__CameraFilesystemFuncs", "CameraFilesystemFuncs *|struct _CameraFilesystemFuncs *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFunctions = {"_p__CameraFunctions", "CameraFunctions *|struct _CameraFunctions *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraList = {"_p__CameraList", "CameraList *|struct _CameraList *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraPrivateCore = {"_p__CameraPrivateCore", "CameraPrivateCore *|struct _CameraPrivateCore *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraPrivateLibrary = {"_p__CameraPrivateLibrary", "CameraPrivateLibrary *|struct _CameraPrivateLibrary *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraStorageInformation = {"_p__CameraStorageInformation", "CameraStorageInformation *|struct _CameraStorageInformation *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraWidget = {"_p__CameraWidget", "CameraWidget *|struct _CameraWidget *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__GPContext = {"_p__GPContext", "GPContext *|struct _GPContext *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__GPContextFeedback = {"_p__GPContextFeedback", "GPContextFeedback *|enum _GPContextFeedback *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__GPPortInfo = {"_p__GPPortInfo", "GPPortInfo|struct _GPPortInfo *|_GPPortInfo *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__GPPortInfoList = {"_p__GPPortInfoList", "GPPortInfoList *|struct _GPPortInfoList *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_f_p_struct__Camera_p_struct__GPContext__int = {"_p_f_p_struct__Camera_p_struct__GPContext__int", "int (*)(struct _Camera *,struct _GPContext *)|CameraTimeoutFunc", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_f_p_struct__Camera_unsigned_int_p_f_p_struct__Camera_p_struct__GPContext__int_p_void__unsigned_int = {"_p_f_p_struct__Camera_unsigned_int_p_f_p_struct__Camera_p_struct__GPContext__int_p_void__unsigned_int", "unsigned int (*)(struct _Camera *,unsigned int,int (*)(struct _Camera *,struct _GPContext *),void *)|CameraTimeoutStartFunc", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_f_p_struct__Camera_unsigned_int_p_void__void = {"_p_f_p_struct__Camera_unsigned_int_p_void__void", "void (*)(struct _Camera *,unsigned int,void *)|CameraTimeoutStopFunc", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_int = {"_p_int", "intptr_t *|int *|int_least32_t *|int_fast32_t *|int32_t *|int_fast16_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_long = {"_p_long", "long *|time_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_long_long = {"_p_long_long", "int_least64_t *|int_fast64_t *|int64_t *|long long *|intmax_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_p__Camera = {"_p_p__Camera", "struct _Camera **|Camera **", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_p__CameraStorageInformation = {"_p_p__CameraStorageInformation", "struct _CameraStorageInformation **|CameraStorageInformation **", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_p__CameraWidget = {"_p_p__CameraWidget", "struct _CameraWidget **|CameraWidget **", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_f_p_struct__Camera_p_struct__GPContext__int = {"_p_f_p_struct__Camera_p_struct__GPContext__int", "CameraTimeoutFunc|int (*)(struct _Camera *,struct _GPContext *)", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_f_p_struct__Camera_unsigned_int_p_f_p_struct__Camera_p_struct__GPContext__int_p_void__unsigned_int = {"_p_f_p_struct__Camera_unsigned_int_p_f_p_struct__Camera_p_struct__GPContext__int_p_void__unsigned_int", "CameraTimeoutStartFunc|unsigned int (*)(struct _Camera *,unsigned int,int (*)(struct _Camera *,struct _GPContext *),void *)", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_f_p_struct__Camera_unsigned_int_p_void__void = {"_p_f_p_struct__Camera_unsigned_int_p_void__void", "CameraTimeoutStopFunc|void (*)(struct _Camera *,unsigned int,void *)", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_int = {"_p_int", "int32_t *|int_fast16_t *|int_fast32_t *|int_least32_t *|intptr_t *|int *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_long = {"_p_long", "time_t *|long *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_long_long = {"_p_long_long", "int64_t *|int_fast64_t *|int_least64_t *|intmax_t *|long long *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_p__Camera = {"_p_p__Camera", "Camera **|struct _Camera **", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_p__CameraStorageInformation = {"_p_p__CameraStorageInformation", "CameraStorageInformation **|struct _CameraStorageInformation **", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_p__CameraWidget = {"_p_p__CameraWidget", "CameraWidget **|struct _CameraWidget **", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_p__GPPortInfo = {"_p_p__GPPortInfo", "GPPortInfo *|struct _GPPortInfo **", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_p_void = {"_p_p_void", "void **", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_short = {"_p_short", "short *|int_least16_t *|int16_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_signed_char = {"_p_signed_char", "signed char *|int_least8_t *|int_fast8_t *|int8_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_unsigned_char = {"_p_unsigned_char", "unsigned char *|uint_least8_t *|uint_fast8_t *|uint8_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_unsigned_int = {"_p_unsigned_int", "uintptr_t *|uint_least32_t *|uint_fast32_t *|uint32_t *|unsigned int *|uint_fast16_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_unsigned_long_long = {"_p_unsigned_long_long", "uint_least64_t *|uint_fast64_t *|uint64_t *|unsigned long long *|uintmax_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_unsigned_short = {"_p_unsigned_short", "unsigned short *|uint_least16_t *|uint16_t *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_short = {"_p_short", "int16_t *|int_least16_t *|short *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_signed_char = {"_p_signed_char", "int8_t *|int_fast8_t *|int_least8_t *|signed char *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_unsigned_char = {"_p_unsigned_char", "uint8_t *|uint_fast8_t *|uint_least8_t *|unsigned char *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_unsigned_int = {"_p_unsigned_int", "uint32_t *|uint_fast16_t *|uint_fast32_t *|uint_least32_t *|uintptr_t *|unsigned int *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_unsigned_long_long = {"_p_unsigned_long_long", "uint64_t *|uint_fast64_t *|uint_least64_t *|uintmax_t *|unsigned long long *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_unsigned_short = {"_p_unsigned_short", "uint16_t *|uint_least16_t *|unsigned short *", 0, 0, (void*)0, 0};
 
 static swig_type_info *swig_type_initial[] = {
   &_swigt__p_CameraAbilities,
   &_swigt__p_CameraCaptureType,
   &_swigt__p_CameraDriverStatus,
   &_swigt__p_CameraEventType,
   &_swigt__p_CameraFileAccessType,
@@ -12643,17 +11997,20 @@
 #endif
 #endif
 
 #if 0
 #define SWIGRUNTIME_DEBUG
 #endif
 
+#ifndef SWIG_INIT_CLIENT_DATA_TYPE
+#define SWIG_INIT_CLIENT_DATA_TYPE void *
+#endif
 
 SWIGRUNTIME void
-SWIG_InitializeModule(void *clientdata) {
+SWIG_InitializeModule(SWIG_INIT_CLIENT_DATA_TYPE clientdata) {
   size_t i;
   swig_module_info *module_head, *iter;
   int init;
   
   /* check to see if the circular list has been setup, if not, set it up */
   if (swig_module.next==0) {
     /* Initialize the swig_module */
@@ -12828,228 +12185,14 @@
 
 
 
 #ifdef __cplusplus
 extern "C" {
 #endif
   
-  /* Python-specific SWIG API */
-#define SWIG_newvarlink()                             SWIG_Python_newvarlink()
-#define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
-#define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)
-  
-  /* -----------------------------------------------------------------------------
-   * global variable support code.
-   * ----------------------------------------------------------------------------- */
-  
-  typedef struct swig_globalvar {
-    char       *name;                  /* Name of global variable */
-    PyObject *(*get_attr)(void);       /* Return the current value */
-    int       (*set_attr)(PyObject *); /* Set the value */
-    struct swig_globalvar *next;
-  } swig_globalvar;
-  
-  typedef struct swig_varlinkobject {
-    PyObject_HEAD
-    swig_globalvar *vars;
-  } swig_varlinkobject;
-  
-  SWIGINTERN PyObject *
-  swig_varlink_repr(swig_varlinkobject *SWIGUNUSEDPARM(v)) {
-#if PY_VERSION_HEX >= 0x03000000
-    return PyUnicode_InternFromString("<Swig global variables>");
-#else
-    return PyString_FromString("<Swig global variables>");
-#endif
-  }
-  
-  SWIGINTERN PyObject *
-  swig_varlink_str(swig_varlinkobject *v) {
-#if PY_VERSION_HEX >= 0x03000000
-    PyObject *str = PyUnicode_InternFromString("(");
-    PyObject *tail;
-    PyObject *joined;
-    swig_globalvar *var;
-    for (var = v->vars; var; var=var->next) {
-      tail = PyUnicode_FromString(var->name);
-      joined = PyUnicode_Concat(str, tail);
-      Py_DecRef(str);
-      Py_DecRef(tail);
-      str = joined;
-      if (var->next) {
-        tail = PyUnicode_InternFromString(", ");
-        joined = PyUnicode_Concat(str, tail);
-        Py_DecRef(str);
-        Py_DecRef(tail);
-        str = joined;
-      }
-    }
-    tail = PyUnicode_InternFromString(")");
-    joined = PyUnicode_Concat(str, tail);
-    Py_DecRef(str);
-    Py_DecRef(tail);
-    str = joined;
-#else
-    PyObject *str = PyString_FromString("(");
-    swig_globalvar *var;
-    for (var = v->vars; var; var=var->next) {
-      PyString_ConcatAndDel(&str,PyString_FromString(var->name));
-      if (var->next) PyString_ConcatAndDel(&str,PyString_FromString(", "));
-    }
-    PyString_ConcatAndDel(&str,PyString_FromString(")"));
-#endif
-    return str;
-  }
-  
-  SWIGINTERN void
-  swig_varlink_dealloc(swig_varlinkobject *v) {
-    swig_globalvar *var = v->vars;
-    while (var) {
-      swig_globalvar *n = var->next;
-      free(var->name);
-      free(var);
-      var = n;
-    }
-  }
-  
-  SWIGINTERN PyObject *
-  swig_varlink_getattr(swig_varlinkobject *v, char *n) {
-    PyObject *res = NULL;
-    swig_globalvar *var = v->vars;
-    while (var) {
-      if (strcmp(var->name,n) == 0) {
-        res = (*var->get_attr)();
-        break;
-      }
-      var = var->next;
-    }
-    if (res == NULL && !PyErr_Occurred()) {
-      PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
-    }
-    return res;
-  }
-  
-  SWIGINTERN int
-  swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
-    int res = 1;
-    swig_globalvar *var = v->vars;
-    while (var) {
-      if (strcmp(var->name,n) == 0) {
-        res = (*var->set_attr)(p);
-        break;
-      }
-      var = var->next;
-    }
-    if (res == 1 && !PyErr_Occurred()) {
-      PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
-    }
-    return res;
-  }
-  
-  SWIGINTERN PyTypeObject*
-  swig_varlink_type(void) {
-    static char varlink__doc__[] = "Swig var link object";
-    static PyTypeObject varlink_type;
-    static int type_init = 0;
-    if (!type_init) {
-      const PyTypeObject tmp = {
-#if PY_VERSION_HEX >= 0x03000000
-        PyVarObject_HEAD_INIT(NULL, 0)
-#else
-        PyObject_HEAD_INIT(NULL)
-        0,                                  /* ob_size */
-#endif
-        "swigvarlink",                      /* tp_name */
-        sizeof(swig_varlinkobject),         /* tp_basicsize */
-        0,                                  /* tp_itemsize */
-        (destructor) swig_varlink_dealloc,  /* tp_dealloc */
-        0,                                  /* tp_print */
-        (getattrfunc) swig_varlink_getattr, /* tp_getattr */
-        (setattrfunc) swig_varlink_setattr, /* tp_setattr */
-        0,                                  /* tp_compare */
-        (reprfunc) swig_varlink_repr,       /* tp_repr */
-        0,                                  /* tp_as_number */
-        0,                                  /* tp_as_sequence */
-        0,                                  /* tp_as_mapping */
-        0,                                  /* tp_hash */
-        0,                                  /* tp_call */
-        (reprfunc) swig_varlink_str,        /* tp_str */
-        0,                                  /* tp_getattro */
-        0,                                  /* tp_setattro */
-        0,                                  /* tp_as_buffer */
-        0,                                  /* tp_flags */
-        varlink__doc__,                     /* tp_doc */
-        0,                                  /* tp_traverse */
-        0,                                  /* tp_clear */
-        0,                                  /* tp_richcompare */
-        0,                                  /* tp_weaklistoffset */
-        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
-        0,                                  /* tp_del */
-        0,                                  /* tp_version_tag */
-#if PY_VERSION_HEX >= 0x03040000
-        0,                                  /* tp_finalize */
-#endif
-#if PY_VERSION_HEX >= 0x03080000
-        0,                                  /* tp_vectorcall */
-#endif
-#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
-        0,                                  /* tp_print */
-#endif
-#ifdef COUNT_ALLOCS
-        0,                                  /* tp_allocs */
-        0,                                  /* tp_frees */
-        0,                                  /* tp_maxalloc */
-        0,                                  /* tp_prev */
-        0                                   /* tp_next */
-#endif
-      };
-      varlink_type = tmp;
-      type_init = 1;
-      if (PyType_Ready(&varlink_type) < 0)
-      return NULL;
-    }
-    return &varlink_type;
-  }
-  
-  /* Create a variable linking object for use later */
-  SWIGINTERN PyObject *
-  SWIG_Python_newvarlink(void) {
-    swig_varlinkobject *result = PyObject_NEW(swig_varlinkobject, swig_varlink_type());
-    if (result) {
-      result->vars = 0;
-    }
-    return ((PyObject*) result);
-  }
-  
-  SWIGINTERN void 
-  SWIG_Python_addvarlink(PyObject *p, const char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
-    swig_varlinkobject *v = (swig_varlinkobject *) p;
-    swig_globalvar *gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
-    if (gv) {
-      size_t size = strlen(name)+1;
-      gv->name = (char *)malloc(size);
-      if (gv->name) {
-        memcpy(gv->name, name, size);
-        gv->get_attr = get_attr;
-        gv->set_attr = set_attr;
-        gv->next = v->vars;
-      }
-    }
-    v->vars = gv;
-  }
-  
-  SWIGINTERN PyObject *
-  SWIG_globals(void) {
-    static PyObject *globals = 0;
-    if (!globals) {
-      globals = SWIG_newvarlink();
-    }
-    return globals;
-  }
-  
   /* -----------------------------------------------------------------------------
    * constants/methods manipulation
    * ----------------------------------------------------------------------------- */
   
   /* Install Constants */
   SWIGINTERN void
   SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
@@ -13070,31 +12213,28 @@
       if (obj) {
         PyDict_SetItemString(d, constants[i].name, obj);
         Py_DECREF(obj);
       }
     }
   }
   
-  /* -----------------------------------------------------------------------------*/
-  /* Fix SwigMethods to carry the callback ptrs when needed */
-  /* -----------------------------------------------------------------------------*/
+  /* -----------------------------------------------------------------------------
+   * Patch %callback methods' docstrings to hold the callback ptrs
+   * -----------------------------------------------------------------------------*/
   
   SWIGINTERN void
-  SWIG_Python_FixMethods(PyMethodDef *methods,
-    swig_const_info *const_table,
-    swig_type_info **types,
-    swig_type_info **types_initial) {
+  SWIG_Python_FixMethods(PyMethodDef *methods, const swig_const_info *const_table, swig_type_info **types, swig_type_info **types_initial) {
     size_t i;
     for (i = 0; methods[i].ml_name; ++i) {
       const char *c = methods[i].ml_doc;
       if (!c) continue;
       c = strstr(c, "swig_ptr: ");
       if (c) {
         int j;
-        swig_const_info *ci = 0;
+        const swig_const_info *ci = 0;
         const char *name = c + 10;
         for (j = 0; const_table[j].type; ++j) {
           if (strncmp(const_table[j].name, name, 
               strlen(const_table[j].name)) == 0) {
             ci = &(const_table[j]);
             break;
           }
@@ -13118,76 +12258,21 @@
             }
           }
         }
       }
     }
   } 
   
-  /* -----------------------------------------------------------------------------
-   * Method creation and docstring support functions
-   * ----------------------------------------------------------------------------- */
-  
-  /* -----------------------------------------------------------------------------
-   * Function to find the method definition with the correct docstring for the
-   * proxy module as opposed to the low-level API
-   * ----------------------------------------------------------------------------- */
-  
-  SWIGINTERN PyMethodDef *SWIG_PythonGetProxyDoc(const char *name) {
-    /* Find the function in the modified method table */
-    size_t offset = 0;
-    int found = 0;
-    while (SwigMethods_proxydocs[offset].ml_meth != NULL) {
-      if (strcmp(SwigMethods_proxydocs[offset].ml_name, name) == 0) {
-        found = 1;
-        break;
-      }
-      offset++;
-    }
-    /* Use the copy with the modified docstring if available */
-    return found ? &SwigMethods_proxydocs[offset] : NULL;
-  }
-  
-  /* -----------------------------------------------------------------------------
-   * Wrapper of PyInstanceMethod_New() used in Python 3
-   * It is exported to the generated module, used for -fastproxy
-   * ----------------------------------------------------------------------------- */
-  
-  SWIGINTERN PyObject *SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func) {
-    if (PyCFunction_Check(func)) {
-      PyCFunctionObject *funcobj = (PyCFunctionObject *)func;
-      PyMethodDef *ml = SWIG_PythonGetProxyDoc(funcobj->m_ml->ml_name);
-      if (ml)
-      func = PyCFunction_NewEx(ml, funcobj->m_self, funcobj->m_module);
-    }
-#if PY_VERSION_HEX >= 0x03000000
-    return PyInstanceMethod_New(func);
-#else
-    return PyMethod_New(func, NULL, NULL);
-#endif
-  }
-  
-  /* -----------------------------------------------------------------------------
-   * Wrapper of PyStaticMethod_New()
-   * It is exported to the generated module, used for -fastproxy
-   * ----------------------------------------------------------------------------- */
-  
-  SWIGINTERN PyObject *SWIG_PyStaticMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func) {
-    if (PyCFunction_Check(func)) {
-      PyCFunctionObject *funcobj = (PyCFunctionObject *)func;
-      PyMethodDef *ml = SWIG_PythonGetProxyDoc(funcobj->m_ml->ml_name);
-      if (ml)
-      func = PyCFunction_NewEx(ml, funcobj->m_self, funcobj->m_module);
-    }
-    return PyStaticMethod_New(func);
-  }
-  
 #ifdef __cplusplus
 }
 #endif
 
+
+
+
 /* -----------------------------------------------------------------------------*
  *  Partial Init method
  * -----------------------------------------------------------------------------*/
 
 #ifdef __cplusplus
 extern "C"
 #endif
```

### Comparing `gphoto2-2.3.4/src/swig-gp2.5.30/context_wrap.c` & `gphoto2-2.3.5/src/swig-gp2_5_30/context_wrap.c`

 * *Files 1% similar despite different names*

```diff
@@ -1,24 +1,21 @@
 /* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 4.0.2
+ * This file was automatically generated by SWIG (https://www.swig.org).
+ * Version 4.1.1
  *
- * This file is not intended to be easily readable and contains a number of
- * coding conventions designed to improve portability and efficiency. Do not make
- * changes to this file unless you know what you are doing--modify the SWIG
- * interface file instead.
+ * Do not make changes to this file unless you know what you are doing - modify
+ * the SWIG interface file instead.
  * ----------------------------------------------------------------------------- */
 
 
-#ifndef SWIGPYTHON
+#define SWIG_VERSION 0x040101
 #define SWIGPYTHON
-#endif
-
 #define SWIG_PYTHON_DIRECTOR_NO_VTABLE
 #define SWIGPYTHON_BUILTIN
+#define SWIGPYTHON_FASTPROXY
 
 /* -----------------------------------------------------------------------------
  *  This section contains generic SWIG labels for method/variable
  *  declarations/attributes, and other compiler dependent labels.
  * ----------------------------------------------------------------------------- */
 
 /* template workaround for compilers that cannot correctly implement the C++ standard */
@@ -142,23 +139,45 @@
 
 
 #if defined(__GNUC__) && defined(_WIN32) && !defined(SWIG_PYTHON_NO_HYPOT_WORKAROUND)
 /* Workaround for '::hypot' has not been declared', see https://bugs.python.org/issue11566 */
 # include <math.h>
 #endif
 
+#if !defined(PY_SSIZE_T_CLEAN) && !defined(SWIG_NO_PY_SSIZE_T_CLEAN)
+#define PY_SSIZE_T_CLEAN
+#endif
+
+#if __GNUC__ >= 7
+#pragma GCC diagnostic push
+#if defined(__cplusplus) && __cplusplus >=201703L
+#pragma GCC diagnostic ignored "-Wregister" /* For python-2.7 headers that use register */
+#endif
+#endif
+
 #if defined(_DEBUG) && defined(SWIG_PYTHON_INTERPRETER_NO_DEBUG)
 /* Use debug wrappers with the Python release dll */
+
+#if defined(_MSC_VER) && _MSC_VER >= 1929
+/* Workaround compilation errors when redefining _DEBUG in MSVC 2019 version 16.10 and later
+ * See https://github.com/swig/swig/issues/2090 */
+# include <corecrt.h>
+#endif
+
 # undef _DEBUG
 # include <Python.h>
 # define _DEBUG 1
 #else
 # include <Python.h>
 #endif
 
+#if __GNUC__ >= 7
+#pragma GCC diagnostic pop
+#endif
+
 /* -----------------------------------------------------------------------------
  * swigrun.swg
  *
  * This file contains generic C API SWIG runtime support for pointer
  * type checking.
  * ----------------------------------------------------------------------------- */
 
@@ -197,14 +216,16 @@
 # define SWIG_BUFFER_SIZE 1024
 #endif
 
 /* Flags for pointer conversions */
 #define SWIG_POINTER_DISOWN        0x1
 #define SWIG_CAST_NEW_MEMORY       0x2
 #define SWIG_POINTER_NO_NULL       0x4
+#define SWIG_POINTER_CLEAR         0x8
+#define SWIG_POINTER_RELEASE       (SWIG_POINTER_CLEAR | SWIG_POINTER_DISOWN)
 
 /* Flags for new pointer objects */
 #define SWIG_POINTER_OWN           0x1
 
 
 /*
    Flags/methods for returning states.
@@ -268,44 +289,50 @@
       }
 
    Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
    more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
    SWIG errors code.
 
    Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
-   allows to return the 'cast rank', for example, if you have this
+   allows returning the 'cast rank', for example, if you have this
 
        int food(double)
        int fooi(int);
 
    and you call
 
       food(1)   // cast rank '1'  (1 -> 1.0)
       fooi(1)   // cast rank '0'
 
    just use the SWIG_AddCast()/SWIG_CheckState()
 */
 
 #define SWIG_OK                    (0)
+/* Runtime errors are < 0 */
 #define SWIG_ERROR                 (-1)
+/* Errors in range -1 to -99 are in swigerrors.swg (errors for all languages including those not using the runtime) */
+/* Errors in range -100 to -199 are language specific errors defined in *errors.swg */
+/* Errors < -200 are generic runtime specific errors */
+#define SWIG_ERROR_RELEASE_NOT_OWNED (-200)
+
 #define SWIG_IsOK(r)               (r >= 0)
 #define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)
 
 /* The CastRankLimit says how many bits are used for the cast rank */
 #define SWIG_CASTRANKLIMIT         (1 << 8)
 /* The NewMask denotes the object was created (using new/malloc) */
 #define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
 /* The TmpMask is for in/out typemaps that use temporal objects */
 #define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
 /* Simple returning values */
 #define SWIG_BADOBJ                (SWIG_ERROR)
 #define SWIG_OLDOBJ                (SWIG_OK)
 #define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
 #define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
-/* Check, add and del mask methods */
+/* Check, add and del object mask methods */
 #define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
 #define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
 #define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
 #define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
 #define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
 #define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))
 
@@ -443,15 +470,15 @@
   return 0;
 }
 
 /*
   Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
 */
 SWIGRUNTIME swig_cast_info *
-SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty) {
+SWIG_TypeCheckStruct(const swig_type_info *from, swig_type_info *ty) {
   if (ty) {
     swig_cast_info *iter = ty->cast;
     while (iter) {
       if (iter->type == from) {
         if (iter == ty->cast)
           return iter;
         /* Move iter to the top of the linked list */
@@ -503,17 +530,17 @@
 /*
   Return the pretty name associated with this type,
   that is an unmangled type name in a form presentable to the user.
 */
 SWIGRUNTIME const char *
 SWIG_TypePrettyName(const swig_type_info *type) {
   /* The "str" field contains the equivalent pretty names of the
-     type, separated by vertical-bar characters.  We choose
-     to print the last name, as it is often (?) the most
-     specific. */
+     type, separated by vertical-bar characters.  Choose the last
+     name. It should be the most specific; a fully resolved name
+     but not necessarily with default template parameters expanded. */
   if (!type) return NULL;
   if (type->str != NULL) {
     const char *last_name = type->str;
     const char *s;
     for (s = type->str; *s; s++)
       if (*s == '|') last_name = s+1;
     return last_name;
@@ -725,15 +752,15 @@
   return SWIG_UnpackData(++c,ptr,sz);
 }
 
 #ifdef __cplusplus
 }
 #endif
 
-/*  Errors in SWIG */
+/* SWIG Errors applicable to all language modules, values are reserved from -1 to -99 */
 #define  SWIG_UnknownError    	   -1
 #define  SWIG_IOError        	   -2
 #define  SWIG_RuntimeError   	   -3
 #define  SWIG_IndexError     	   -4
 #define  SWIG_TypeError      	   -5
 #define  SWIG_DivisionByZero 	   -6
 #define  SWIG_OverflowError  	   -7
@@ -741,15 +768,14 @@
 #define  SWIG_ValueError     	   -9
 #define  SWIG_SystemError    	   -10
 #define  SWIG_AttributeError 	   -11
 #define  SWIG_MemoryError    	   -12
 #define  SWIG_NullReferenceError   -13
 
 
-
 /* Compatibility macros for Python 3 */
 #if PY_VERSION_HEX >= 0x03000000
 
 #define PyClass_Check(obj) PyObject_IsInstance(obj, (PyObject *)&PyType_Type)
 #define PyInt_Check(x) PyLong_Check(x)
 #define PyInt_AsLong(x) PyLong_AsLong(x)
 #define PyInt_FromLong(x) PyLong_FromLong(x)
@@ -757,15 +783,14 @@
 #define PyString_Check(name) PyBytes_Check(name)
 #define PyString_FromString(x) PyUnicode_FromString(x)
 #define PyString_Format(fmt, args)  PyUnicode_Format(fmt, args)
 #define PyString_AsString(str) PyBytes_AsString(str)
 #define PyString_Size(str) PyBytes_Size(str)	
 #define PyString_InternFromString(key) PyUnicode_InternFromString(key)
 #define Py_TPFLAGS_HAVE_CLASS Py_TPFLAGS_BASETYPE
-#define PyString_AS_STRING(x) PyUnicode_AS_STRING(x)
 #define _PyLong_FromSsize_t(x) PyLong_FromSsize_t(x)
 
 #endif
 
 #ifndef Py_TYPE
 #  define Py_TYPE(op) ((op)->ob_type)
 #endif
@@ -775,46 +800,27 @@
 #if PY_VERSION_HEX >= 0x03000000
 #  define SWIG_Python_str_FromFormat PyUnicode_FromFormat
 #else
 #  define SWIG_Python_str_FromFormat PyString_FromFormat
 #endif
 
 
-/* Warning: This function will allocate a new string in Python 3,
- * so please call SWIG_Python_str_DelForPy3(x) to free the space.
- */
 SWIGINTERN char*
 SWIG_Python_str_AsChar(PyObject *str)
 {
 #if PY_VERSION_HEX >= 0x03030000
   return (char *)PyUnicode_AsUTF8(str);
-#elif PY_VERSION_HEX >= 0x03000000
-  char *newstr = 0;
-  str = PyUnicode_AsUTF8String(str);
-  if (str) {
-    char *cstr;
-    Py_ssize_t len;
-    if (PyBytes_AsStringAndSize(str, &cstr, &len) != -1) {
-      newstr = (char *) malloc(len+1);
-      if (newstr)
-        memcpy(newstr, cstr, len+1);
-    }
-    Py_XDECREF(str);
-  }
-  return newstr;
 #else
   return PyString_AsString(str);
 #endif
 }
 
-#if PY_VERSION_HEX >= 0x03030000 || PY_VERSION_HEX < 0x03000000
-#  define SWIG_Python_str_DelForPy3(x)
-#else
-#  define SWIG_Python_str_DelForPy3(x) free( (void*) (x) )
-#endif
+/* Was useful for Python 3.0.x-3.2.x - now provided only for compatibility
+ * with any uses in user interface files. */
+#define SWIG_Python_str_DelForPy3(x)
 
 
 SWIGINTERN PyObject*
 SWIG_Python_str_FromChar(const char *c)
 {
 #if PY_VERSION_HEX >= 0x03000000
   return PyUnicode_FromString(c); 
@@ -823,18 +829,22 @@
 #endif
 }
 
 #ifndef PyObject_DEL
 # define PyObject_DEL PyObject_Del
 #endif
 
-// SWIGPY_USE_CAPSULE is no longer used within SWIG itself, but some user
-// interface files check for it.
+/* SWIGPY_USE_CAPSULE is no longer used within SWIG itself, but some user interface files check for it. */
 # define SWIGPY_USE_CAPSULE
-# define SWIGPY_CAPSULE_NAME ("swig_runtime_data" SWIG_RUNTIME_VERSION ".type_pointer_capsule" SWIG_TYPE_TABLE_NAME)
+#ifdef SWIGPYTHON_BUILTIN
+# define SWIGPY_CAPSULE_ATTR_NAME "type_pointer_capsule_builtin" SWIG_TYPE_TABLE_NAME
+#else
+# define SWIGPY_CAPSULE_ATTR_NAME "type_pointer_capsule" SWIG_TYPE_TABLE_NAME
+#endif
+# define SWIGPY_CAPSULE_NAME ("swig_runtime_data" SWIG_RUNTIME_VERSION "." SWIGPY_CAPSULE_ATTR_NAME)
 
 #if PY_VERSION_HEX < 0x03020000
 #define PyDescr_TYPE(x) (((PyDescrObject *)(x))->d_type)
 #define PyDescr_NAME(x) (((PyDescrObject *)(x))->d_name)
 #define Py_hash_t long
 #endif
 
@@ -900,15 +910,14 @@
     const char *tmp = SWIG_Python_str_AsChar(old_str);
     PyErr_Clear();
     Py_XINCREF(type);
     if (tmp)
       PyErr_Format(type, "%s %s", tmp, mesg);
     else
       PyErr_Format(type, "%s", mesg);
-    SWIG_Python_str_DelForPy3(tmp);
     Py_DECREF(old_str);
     Py_DECREF(value);
   } else {
     PyErr_SetString(PyExc_RuntimeError, mesg);
   }
 }
 
@@ -931,16 +940,20 @@
     PyObject *type = NULL, *value = NULL, *traceback = NULL;
     PyErr_Fetch(&type, &value, &traceback);
 #if PY_VERSION_HEX >= 0x03000000
     newvalue = PyUnicode_FromFormat("%S\nAdditional information:\n%s", value, message);
 #else
     newvalue = PyString_FromFormat("%s\nAdditional information:\n%s", PyString_AsString(value), message);
 #endif
-    Py_XDECREF(value);
-    PyErr_Restore(type, newvalue, traceback);
+    if (newvalue) {
+      Py_XDECREF(value);
+      PyErr_Restore(type, newvalue, traceback);
+    } else {
+      PyErr_Restore(type, value, traceback);
+    }
   } else {
     /* Raise TypeError using given message */
     PyErr_SetString(PyExc_TypeError, message);
   }
 }
 
 #if defined(SWIG_PYTHON_NO_THREADS)
@@ -949,16 +962,20 @@
 #  endif
 #endif
 #if defined(SWIG_PYTHON_THREADS) /* Threading support is enabled */
 #  if !defined(SWIG_PYTHON_USE_GIL) && !defined(SWIG_PYTHON_NO_USE_GIL)
 #    define SWIG_PYTHON_USE_GIL
 #  endif
 #  if defined(SWIG_PYTHON_USE_GIL) /* Use PyGILState threads calls */
-#    ifndef SWIG_PYTHON_INITIALIZE_THREADS
-#     define SWIG_PYTHON_INITIALIZE_THREADS  PyEval_InitThreads() 
+#    if !defined(SWIG_PYTHON_INITIALIZE_THREADS)
+#      if PY_VERSION_HEX < 0x03070000
+#        define SWIG_PYTHON_INITIALIZE_THREADS PyEval_InitThreads()
+#      else
+#        define SWIG_PYTHON_INITIALIZE_THREADS
+#      endif
 #    endif
 #    ifdef __cplusplus /* C++ code */
        class SWIG_Python_Thread_Block {
          bool status;
          PyGILState_STATE state;
        public:
          void end() { if (status) { PyGILState_Release(state); status = false;} }
@@ -1048,16 +1065,16 @@
  *
  * ----------------------------------------------------------------------------- */
 
 #if PY_VERSION_HEX < 0x02070000 /* 2.7.0 */
 # error "This version of SWIG only supports Python >= 2.7"
 #endif
 
-#if PY_VERSION_HEX >= 0x03000000 && PY_VERSION_HEX < 0x03020000
-# error "This version of SWIG only supports Python 3 >= 3.2"
+#if PY_VERSION_HEX >= 0x03000000 && PY_VERSION_HEX < 0x03030000
+# error "This version of SWIG only supports Python 3 >= 3.3"
 #endif
 
 /* Common SWIG API */
 
 /* for raw pointers */
 #define SWIG_Python_ConvertPtr(obj, pptr, type, flags)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, 0)
 #define SWIG_ConvertPtr(obj, pptr, type, flags)         SWIG_Python_ConvertPtr(obj, pptr, type, flags)
@@ -1164,15 +1181,20 @@
   } else if (result == Py_None) {
     Py_DECREF(result);
     result = obj;
   } else {
     if (!PyList_Check(result)) {
       PyObject *o2 = result;
       result = PyList_New(1);
-      PyList_SetItem(result, 0, o2);
+      if (result) {
+        PyList_SET_ITEM(result, 0, o2);
+      } else {
+        Py_DECREF(obj);
+        return o2;
+      }
     }
     PyList_Append(result,obj);
     Py_DECREF(obj);
   }
   return result;
 }
 
@@ -1246,14 +1268,246 @@
 */
 #ifdef __cplusplus
 #define SWIG_STATIC_POINTER(var)  var
 #else
 #define SWIG_STATIC_POINTER(var)  var = 0; if (!var) var
 #endif
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Python-specific SWIG API */
+#define SWIG_newvarlink()                             SWIG_Python_newvarlink()
+#define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
+#define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)
+ 
+/* -----------------------------------------------------------------------------
+ * global variable support code.
+ * ----------------------------------------------------------------------------- */
+ 
+typedef struct swig_globalvar {   
+  char       *name;                  /* Name of global variable */
+  PyObject *(*get_attr)(void);       /* Return the current value */
+  int       (*set_attr)(PyObject *); /* Set the value */
+  struct swig_globalvar *next;
+} swig_globalvar;
+
+typedef struct swig_varlinkobject {
+  PyObject_HEAD
+  swig_globalvar *vars;
+} swig_varlinkobject;
+
+SWIGINTERN PyObject *
+swig_varlink_repr(PyObject *SWIGUNUSEDPARM(v)) {
+#if PY_VERSION_HEX >= 0x03000000
+  return PyUnicode_InternFromString("<Swig global variables>");
+#else
+  return PyString_FromString("<Swig global variables>");
+#endif
+}
+
+SWIGINTERN PyObject *
+swig_varlink_str(PyObject *o) {
+  swig_varlinkobject *v = (swig_varlinkobject *) o;
+#if PY_VERSION_HEX >= 0x03000000
+  PyObject *str = PyUnicode_InternFromString("(");
+  PyObject *tail;
+  PyObject *joined;
+  swig_globalvar *var;
+  for (var = v->vars; var; var=var->next) {
+    tail = PyUnicode_FromString(var->name);
+    joined = PyUnicode_Concat(str, tail);
+    Py_DecRef(str);
+    Py_DecRef(tail);
+    str = joined;
+    if (var->next) {
+        tail = PyUnicode_InternFromString(", ");
+        joined = PyUnicode_Concat(str, tail);
+        Py_DecRef(str);
+        Py_DecRef(tail);
+        str = joined;
+    }
+  }
+  tail = PyUnicode_InternFromString(")");
+  joined = PyUnicode_Concat(str, tail);
+  Py_DecRef(str);
+  Py_DecRef(tail);
+  str = joined;
+#else
+  PyObject *str = PyString_FromString("(");
+  swig_globalvar *var;
+  for (var = v->vars; var; var=var->next) {
+    PyString_ConcatAndDel(&str,PyString_FromString(var->name));
+    if (var->next) PyString_ConcatAndDel(&str,PyString_FromString(", "));
+  }
+  PyString_ConcatAndDel(&str,PyString_FromString(")"));
+#endif
+  return str;
+}
+
+SWIGINTERN void
+swig_varlink_dealloc(PyObject *o) {
+  swig_varlinkobject *v = (swig_varlinkobject *) o;
+  swig_globalvar *var = v->vars;
+  while (var) {
+    swig_globalvar *n = var->next;
+    free(var->name);
+    free(var);
+    var = n;
+  }
+}
+
+SWIGINTERN PyObject *
+swig_varlink_getattr(PyObject *o, char *n) {
+  swig_varlinkobject *v = (swig_varlinkobject *) o;
+  PyObject *res = NULL;
+  swig_globalvar *var = v->vars;
+  while (var) {
+    if (strcmp(var->name,n) == 0) {
+      res = (*var->get_attr)();
+      break;
+    }
+    var = var->next;
+  }
+  if (res == NULL && !PyErr_Occurred()) {
+    PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
+  }
+  return res;
+}
+
+SWIGINTERN int
+swig_varlink_setattr(PyObject *o, char *n, PyObject *p) {
+  swig_varlinkobject *v = (swig_varlinkobject *) o;
+  int res = 1;
+  swig_globalvar *var = v->vars;
+  while (var) {
+    if (strcmp(var->name,n) == 0) {
+      res = (*var->set_attr)(p);
+      break;
+    }
+    var = var->next;
+  }
+  if (res == 1 && !PyErr_Occurred()) {
+    PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
+  }
+  return res;
+}
+
+SWIGINTERN PyTypeObject*
+swig_varlink_type(void) {
+  static char varlink__doc__[] = "Swig var link object";
+  static PyTypeObject varlink_type;
+  static int type_init = 0;
+  if (!type_init) {
+    const PyTypeObject tmp = {
+#if PY_VERSION_HEX >= 0x03000000
+      PyVarObject_HEAD_INIT(NULL, 0)
+#else
+      PyObject_HEAD_INIT(NULL)
+      0,                                  /* ob_size */
+#endif
+      "swigvarlink",                      /* tp_name */
+      sizeof(swig_varlinkobject),         /* tp_basicsize */
+      0,                                  /* tp_itemsize */
+      (destructor) swig_varlink_dealloc,  /* tp_dealloc */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                       /*tp_print*/
+#else
+      (Py_ssize_t)0,                      /*tp_vectorcall_offset*/
+#endif
+      (getattrfunc) swig_varlink_getattr, /* tp_getattr */
+      (setattrfunc) swig_varlink_setattr, /* tp_setattr */
+      0,                                  /* tp_compare */
+      (reprfunc) swig_varlink_repr,       /* tp_repr */
+      0,                                  /* tp_as_number */
+      0,                                  /* tp_as_sequence */
+      0,                                  /* tp_as_mapping */
+      0,                                  /* tp_hash */
+      0,                                  /* tp_call */
+      (reprfunc) swig_varlink_str,        /* tp_str */
+      0,                                  /* tp_getattro */
+      0,                                  /* tp_setattro */
+      0,                                  /* tp_as_buffer */
+      0,                                  /* tp_flags */
+      varlink__doc__,                     /* tp_doc */
+      0,                                  /* tp_traverse */
+      0,                                  /* tp_clear */
+      0,                                  /* tp_richcompare */
+      0,                                  /* tp_weaklistoffset */
+      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
+      0,                                  /* tp_del */
+      0,                                  /* tp_version_tag */
+#if PY_VERSION_HEX >= 0x03040000
+      0,                                  /* tp_finalize */
+#endif
+#if PY_VERSION_HEX >= 0x03080000
+      0,                                  /* tp_vectorcall */
+#endif
+#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
+      0,                                  /* tp_print */
+#endif
+#ifdef COUNT_ALLOCS
+      0,                                  /* tp_allocs */
+      0,                                  /* tp_frees */
+      0,                                  /* tp_maxalloc */
+      0,                                  /* tp_prev */
+      0                                   /* tp_next */
+#endif
+    };
+    varlink_type = tmp;
+    type_init = 1;
+    if (PyType_Ready(&varlink_type) < 0)
+      return NULL;
+  }
+  return &varlink_type;
+}
+
+/* Create a variable linking object for use later */
+SWIGINTERN PyObject *
+SWIG_Python_newvarlink(void) {
+  swig_varlinkobject *result = PyObject_NEW(swig_varlinkobject, swig_varlink_type());
+  if (result) {
+    result->vars = 0;
+  }
+  return ((PyObject*) result);
+}
+
+SWIGINTERN void 
+SWIG_Python_addvarlink(PyObject *p, const char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
+  swig_varlinkobject *v = (swig_varlinkobject *) p;
+  swig_globalvar *gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
+  if (gv) {
+    size_t size = strlen(name)+1;
+    gv->name = (char *)malloc(size);
+    if (gv->name) {
+      memcpy(gv->name, name, size);
+      gv->get_attr = get_attr;
+      gv->set_attr = set_attr;
+      gv->next = v->vars;
+    }
+  }
+  v->vars = gv;
+}
+
+
+static PyObject *Swig_Globals_global = NULL;
+  
+SWIGINTERN PyObject *
+SWIG_globals(void) {
+  if (Swig_Globals_global == NULL) {
+    Swig_Globals_global = SWIG_newvarlink();
+  }
+  return Swig_Globals_global;
+}
+
+#ifdef __cplusplus
+}
+#endif
+
 /* -----------------------------------------------------------------------------
  * Pointer declarations
  * ----------------------------------------------------------------------------- */
 
 /* Flags for new pointer objects */
 #define SWIG_POINTER_NOSHADOW       (SWIG_POINTER_OWN      << 1)
 #define SWIG_POINTER_NEW            (SWIG_POINTER_NOSHADOW | SWIG_POINTER_OWN)
@@ -1316,52 +1570,59 @@
     SwigPyClientData *data = (SwigPyClientData *)malloc(sizeof(SwigPyClientData));
     /* the klass element */
     data->klass = obj;
     Py_INCREF(data->klass);
     /* the newraw method and newargs arguments used to create a new raw instance */
     if (PyClass_Check(obj)) {
       data->newraw = 0;
-      data->newargs = obj;
       Py_INCREF(obj);
+      data->newargs = obj;
     } else {
       data->newraw = PyObject_GetAttrString(data->klass, "__new__");
       if (data->newraw) {
-	Py_INCREF(data->newraw);
-	data->newargs = PyTuple_New(1);
-	PyTuple_SetItem(data->newargs, 0, obj);
+        data->newargs = PyTuple_New(1);
+        if (data->newargs) {
+          Py_INCREF(obj);
+          PyTuple_SET_ITEM(data->newargs, 0, obj);
+        } else {
+          Py_DECREF(data->newraw);
+          Py_DECREF(data->klass);
+          free(data);
+          return 0;
+        }
       } else {
-	data->newargs = obj;
+        Py_INCREF(obj);
+        data->newargs = obj;
       }
-      Py_INCREF(data->newargs);
     }
     /* the destroy method, aka as the C++ delete method */
     data->destroy = PyObject_GetAttrString(data->klass, "__swig_destroy__");
     if (PyErr_Occurred()) {
       PyErr_Clear();
       data->destroy = 0;
     }
     if (data->destroy) {
-      int flags;
-      Py_INCREF(data->destroy);
-      flags = PyCFunction_GET_FLAGS(data->destroy);
-      data->delargs = !(flags & (METH_O));
+      data->delargs = !(PyCFunction_GET_FLAGS(data->destroy) & METH_O);
     } else {
       data->delargs = 0;
     }
     data->implicitconv = 0;
     data->pytype = 0;
     return data;
   }
 }
 
 SWIGRUNTIME void 
-SwigPyClientData_Del(SwigPyClientData *data) {
+SwigPyClientData_Del(SwigPyClientData *data)
+{
+  Py_XDECREF(data->klass);
   Py_XDECREF(data->newraw);
   Py_XDECREF(data->newargs);
   Py_XDECREF(data->destroy);
+  free(data);
 }
 
 /* =============== SwigPyObject =====================*/
 
 typedef struct {
   PyObject_HEAD
   void *ptr;
@@ -1380,15 +1641,15 @@
 SwigPyObject_get___dict__(PyObject *v, PyObject *SWIGUNUSEDPARM(args))
 {
   SwigPyObject *sobj = (SwigPyObject *)v;
 
   if (!sobj->dict)
     sobj->dict = PyDict_New();
 
-  Py_INCREF(sobj->dict);
+  Py_XINCREF(sobj->dict);
   return sobj->dict;
 }
 
 #endif
 
 SWIGRUNTIME PyObject *
 SwigPyObject_long(SwigPyObject *v)
@@ -1398,26 +1659,29 @@
 
 SWIGRUNTIME PyObject *
 SwigPyObject_format(const char* fmt, SwigPyObject *v)
 {
   PyObject *res = NULL;
   PyObject *args = PyTuple_New(1);
   if (args) {
-    if (PyTuple_SetItem(args, 0, SwigPyObject_long(v)) == 0) {
-      PyObject *ofmt = SWIG_Python_str_FromChar(fmt);
+    PyObject *val = SwigPyObject_long(v);
+    if (val) {
+      PyObject *ofmt;
+      PyTuple_SET_ITEM(args, 0, val);
+      ofmt = SWIG_Python_str_FromChar(fmt);
       if (ofmt) {
 #if PY_VERSION_HEX >= 0x03000000
-	res = PyUnicode_Format(ofmt,args);
+        res = PyUnicode_Format(ofmt,args);
 #else
-	res = PyString_Format(ofmt,args);
+        res = PyString_Format(ofmt,args);
 #endif
-	Py_DECREF(ofmt);
+        Py_DECREF(ofmt);
       }
-      Py_DECREF(args);
     }
+    Py_DECREF(args);
   }
   return res;
 }
 
 SWIGRUNTIME PyObject *
 SwigPyObject_oct(SwigPyObject *v)
 {
@@ -1431,26 +1695,31 @@
 }
 
 SWIGRUNTIME PyObject *
 SwigPyObject_repr(SwigPyObject *v)
 {
   const char *name = SWIG_TypePrettyName(v->ty);
   PyObject *repr = SWIG_Python_str_FromFormat("<Swig Object of type '%s' at %p>", (name ? name : "unknown"), (void *)v);
-  if (v->next) {
+  if (repr && v->next) {
     PyObject *nrep = SwigPyObject_repr((SwigPyObject *)v->next);
+    if (nrep) {
 # if PY_VERSION_HEX >= 0x03000000
-    PyObject *joined = PyUnicode_Concat(repr, nrep);
-    Py_DecRef(repr);
-    Py_DecRef(nrep);
-    repr = joined;
+      PyObject *joined = PyUnicode_Concat(repr, nrep);
+      Py_DecRef(repr);
+      Py_DecRef(nrep);
+      repr = joined;
 # else
-    PyString_ConcatAndDel(&repr,nrep);
+      PyString_ConcatAndDel(&repr,nrep);
 # endif
+    } else {
+      Py_DecRef(repr);
+      repr = NULL;
+    }
   }
-  return repr;  
+  return repr;
 }
 
 /* We need a version taking two PyObject* parameters so it's a valid
  * PyCFunction to use in swigobject_methods[]. */
 SWIGRUNTIME PyObject *
 SwigPyObject_repr2(PyObject *v, PyObject *SWIGUNUSEDPARM(args))
 {
@@ -1512,14 +1781,16 @@
     || (strcmp(Py_TYPE(op)->tp_name,"SwigPyObject") == 0);
 #endif
 }
 
 SWIGRUNTIME PyObject *
 SwigPyObject_New(void *ptr, swig_type_info *ty, int own);
 
+static PyObject* Swig_Capsule_global = NULL;
+
 SWIGRUNTIME void
 SwigPyObject_dealloc(PyObject *v)
 {
   SwigPyObject *sobj = (SwigPyObject *) v;
   PyObject *next = sobj->next;
   if (sobj->own == SWIG_POINTER_OWN) {
     swig_type_info *ty = sobj->ty;
@@ -1538,16 +1809,20 @@
       
       PyObject *type = NULL, *value = NULL, *traceback = NULL;
       PyErr_Fetch(&type, &value, &traceback);
 
       if (data->delargs) {
         /* we need to create a temporary object to carry the destroy operation */
         PyObject *tmp = SwigPyObject_New(sobj->ptr, ty, 0);
-        res = SWIG_Python_CallFunctor(destroy, tmp);
-        Py_DECREF(tmp);
+        if (tmp) {
+          res = SWIG_Python_CallFunctor(destroy, tmp);
+        } else {
+          res = 0;
+        }
+        Py_XDECREF(tmp);
       } else {
         PyCFunction meth = PyCFunction_GET_FUNCTION(destroy);
         PyObject *mself = PyCFunction_GET_SELF(destroy);
         res = ((*meth)(mself, v));
       }
       if (!res)
         PyErr_WriteUnraisable(destroy);
@@ -1558,27 +1833,32 @@
     } 
 #if !defined(SWIG_PYTHON_SILENT_MEMLEAK)
     else {
       const char *name = SWIG_TypePrettyName(ty);
       printf("swig/python detected a memory leak of type '%s', no destructor found.\n", (name ? name : "unknown"));
     }
 #endif
-  } 
+    Py_XDECREF(Swig_Capsule_global);
+  }
   Py_XDECREF(next);
+#ifdef SWIGPYTHON_BUILTIN
+  Py_XDECREF(sobj->dict);
+#endif
   PyObject_DEL(v);
 }
 
 SWIGRUNTIME PyObject* 
 SwigPyObject_append(PyObject* v, PyObject* next)
 {
   SwigPyObject *sobj = (SwigPyObject *) v;
   if (!SwigPyObject_Check(next)) {
     PyErr_SetString(PyExc_TypeError, "Attempt to append a non SwigPyObject");
     return NULL;
   }
+  ((SwigPyObject *)next)->next = sobj->next;
   sobj->next = next;
   Py_INCREF(next);
   return SWIG_Py_Void();
 }
 
 SWIGRUNTIME PyObject* 
 SwigPyObject_next(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
@@ -1615,17 +1895,17 @@
   if (!PyArg_UnpackTuple(args, "own", 0, 1, &val)) {
     return NULL;
   } else {
     SwigPyObject *sobj = (SwigPyObject *)v;
     PyObject *obj = PyBool_FromLong(sobj->own);
     if (val) {
       if (PyObject_IsTrue(val)) {
-        SwigPyObject_acquire(v,args);
+        Py_DECREF(SwigPyObject_acquire(v,args));
       } else {
-        SwigPyObject_disown(v,args);
+        Py_DECREF(SwigPyObject_disown(v,args));
       }
     } 
     return obj;
   }
 }
 
 static PyMethodDef
@@ -1697,15 +1977,19 @@
       PyObject_HEAD_INIT(NULL)
       0,                                    /* ob_size */
 #endif
       "SwigPyObject",                       /* tp_name */
       sizeof(SwigPyObject),                 /* tp_basicsize */
       0,                                    /* tp_itemsize */
       (destructor)SwigPyObject_dealloc,     /* tp_dealloc */
-      0,                                    /* tp_print */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                         /*tp_print*/
+#else
+      (Py_ssize_t)0,                        /*tp_vectorcall_offset*/
+#endif
       (getattrfunc)0,                       /* tp_getattr */
       (setattrfunc)0,                       /* tp_setattr */
 #if PY_VERSION_HEX >= 0x03000000
       0, /* tp_reserved in 3.0.1, tp_compare in 3.0.0 but not used */
 #else
       (cmpfunc)SwigPyObject_compare,        /* tp_compare */
 #endif
@@ -1762,29 +2046,38 @@
       0,                                    /* tp_maxalloc */
       0,                                    /* tp_prev */
       0                                     /* tp_next */
 #endif
     };
     swigpyobject_type = tmp;
     type_init = 1;
-    if (PyType_Ready(&swigpyobject_type) < 0)
+    if (PyType_Ready(&swigpyobject_type) != 0)
       return NULL;
   }
   return &swigpyobject_type;
 }
 
 SWIGRUNTIME PyObject *
 SwigPyObject_New(void *ptr, swig_type_info *ty, int own)
 {
   SwigPyObject *sobj = PyObject_NEW(SwigPyObject, SwigPyObject_type());
   if (sobj) {
     sobj->ptr  = ptr;
     sobj->ty   = ty;
     sobj->own  = own;
     sobj->next = 0;
+#ifdef SWIGPYTHON_BUILTIN
+    sobj->dict = 0;
+#endif
+    if (own == SWIG_POINTER_OWN) {
+      /* Obtain a reference to the Python capsule wrapping the module information, so that the
+       * module information is correctly destroyed after all SWIG python objects have been freed
+       * by the GC (and corresponding destructors invoked) */
+      Py_XINCREF(Swig_Capsule_global);
+    }
   }
   return (PyObject *)sobj;
 }
 
 /* -----------------------------------------------------------------------------
  * Implements a simple Swig Packed type, and use it instead of string
  * ----------------------------------------------------------------------------- */
@@ -1864,15 +2157,19 @@
       PyObject_HEAD_INIT(NULL)
       0,                                    /* ob_size */
 #endif
       "SwigPyPacked",                       /* tp_name */
       sizeof(SwigPyPacked),                 /* tp_basicsize */
       0,                                    /* tp_itemsize */
       (destructor)SwigPyPacked_dealloc,     /* tp_dealloc */
-      0,                                    /* tp_print */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                         /*tp_print*/
+#else
+      (Py_ssize_t)0,                        /*tp_vectorcall_offset*/
+#endif
       (getattrfunc)0,                       /* tp_getattr */
       (setattrfunc)0,                       /* tp_setattr */
 #if PY_VERSION_HEX>=0x03000000
       0, /* tp_reserved in 3.0.1 */
 #else
       (cmpfunc)SwigPyPacked_compare,        /* tp_compare */
 #endif
@@ -1929,15 +2226,15 @@
       0,                                    /* tp_maxalloc */
       0,                                    /* tp_prev */
       0                                     /* tp_next */
 #endif
     };
     swigpypacked_type = tmp;
     type_init = 1;
-    if (PyType_Ready(&swigpypacked_type) < 0)
+    if (PyType_Ready(&swigpypacked_type) != 0)
       return NULL;
   }
   return &swigpypacked_type;
 }
 
 SWIGRUNTIME PyObject *
 SwigPyPacked_New(void *ptr, size_t size, swig_type_info *ty)
@@ -2119,20 +2416,27 @@
       }
     } else {
       if (ptr) *ptr = vptr;
       break;
     }
   }
   if (sobj) {
-    if (own)
-      *own = *own | sobj->own;
-    if (flags & SWIG_POINTER_DISOWN) {
-      sobj->own = 0;
+    if (((flags & SWIG_POINTER_RELEASE) == SWIG_POINTER_RELEASE) && !sobj->own) {
+      res = SWIG_ERROR_RELEASE_NOT_OWNED;
+    } else {
+      if (own)
+        *own = *own | sobj->own;
+      if (flags & SWIG_POINTER_DISOWN) {
+        sobj->own = 0;
+      }
+      if (flags & SWIG_POINTER_CLEAR) {
+        sobj->ptr = 0;
+      }
+      res = SWIG_OK;
     }
-    res = SWIG_OK;
   } else {
     if (implicit_conv) {
       SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
       if (data && !data->implicitconv) {
         PyObject *klass = data->klass;
         if (klass) {
           PyObject *impconv;
@@ -2237,20 +2541,25 @@
   PyObject *newraw = data->newraw;
   if (newraw) {
     inst = PyObject_Call(newraw, data->newargs, NULL);
     if (inst) {
 #if !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
       PyObject **dictptr = _PyObject_GetDictPtr(inst);
       if (dictptr != NULL) {
-	PyObject *dict = *dictptr;
-	if (dict == NULL) {
-	  dict = PyDict_New();
-	  *dictptr = dict;
-	  PyDict_SetItem(dict, SWIG_This(), swig_this);
-	}
+        PyObject *dict = *dictptr;
+        if (dict == NULL) {
+          dict = PyDict_New();
+          *dictptr = dict;
+        }
+        if (dict) {
+          PyDict_SetItem(dict, SWIG_This(), swig_this);
+        } else{
+          Py_DECREF(inst);
+          inst = 0;
+        }
       }
 #else
       if (PyObject_SetAttr(inst, SWIG_This(), swig_this) == -1) {
         Py_DECREF(inst);
         inst = 0;
       }
 #endif
@@ -2264,15 +2573,15 @@
         inst = ((PyTypeObject *)data->newargs)->tp_new((PyTypeObject *)data->newargs, empty_args, empty_kwargs);
         Py_DECREF(empty_kwargs);
         if (inst) {
           if (PyObject_SetAttr(inst, SWIG_This(), swig_this) == -1) {
             Py_DECREF(inst);
             inst = 0;
           } else {
-            Py_TYPE(inst)->tp_flags &= ~Py_TPFLAGS_VALID_VERSION_TAG;
+            PyType_Modified(Py_TYPE(inst));
           }
         }
       }
       Py_DECREF(empty_args);
     }
 #else
     PyObject *dict = PyDict_New();
@@ -2293,30 +2602,34 @@
   PyObject **dictptr = _PyObject_GetDictPtr(inst);
   if (dictptr != NULL) {
     PyObject *dict = *dictptr;
     if (dict == NULL) {
       dict = PyDict_New();
       *dictptr = dict;
     }
-    return PyDict_SetItem(dict, SWIG_This(), swig_this);
+    if (dict) {
+      return PyDict_SetItem(dict, SWIG_This(), swig_this);
+    } else{
+      return -1;
+    }
   }
 #endif
   return PyObject_SetAttr(inst, SWIG_This(), swig_this);
 } 
 
 
 SWIGINTERN PyObject *
 SWIG_Python_InitShadowInstance(PyObject *args) {
   PyObject *obj[2];
   if (!SWIG_Python_UnpackTuple(args, "swiginit", 2, 2, obj)) {
     return NULL;
   } else {
     SwigPyObject *sthis = SWIG_Python_GetSwigThis(obj[0]);
     if (sthis) {
-      SwigPyObject_append((PyObject*) sthis, obj[1]);
+      Py_DECREF(SwigPyObject_append((PyObject*) sthis, obj[1]));
     } else {
       if (SWIG_Python_SetSwigThis(obj[0], obj[1]) != 0)
         return NULL;
     }
     return SWIG_Py_Void();
   }
 }
@@ -2347,15 +2660,17 @@
 #ifdef SWIGPYTHON_BUILTIN
         newobj->dict = 0;
 #endif
       }
     } else {
       newobj = PyObject_New(SwigPyObject, clientdata->pytype);
 #ifdef SWIGPYTHON_BUILTIN
-      newobj->dict = 0;
+      if (newobj) {
+        newobj->dict = 0;
+      }
 #endif
     }
     if (newobj) {
       newobj->ptr = ptr;
       newobj->ty = type;
       newobj->own = own;
       newobj->next = 0;
@@ -2386,89 +2701,111 @@
  *  Get type list 
  * -----------------------------------------------------------------------------*/
 
 #ifdef SWIG_LINK_RUNTIME
 void *SWIG_ReturnGlobalTypeList(void *);
 #endif
 
+static PyObject *Swig_TypeCache_global = NULL;
+
+/* The python cached type query */
+SWIGRUNTIME PyObject *
+SWIG_Python_TypeCache(void) {
+  if (Swig_TypeCache_global == NULL) {
+    Swig_TypeCache_global = PyDict_New();
+  }
+  return Swig_TypeCache_global;
+}
+
 SWIGRUNTIME swig_module_info *
 SWIG_Python_GetModule(void *SWIGUNUSEDPARM(clientdata)) {
+#ifdef SWIG_LINK_RUNTIME
   static void *type_pointer = (void *)0;
   /* first check if module already created */
   if (!type_pointer) {
-#ifdef SWIG_LINK_RUNTIME
     type_pointer = SWIG_ReturnGlobalTypeList((void *)0);
+  }
 #else
-    type_pointer = PyCapsule_Import(SWIGPY_CAPSULE_NAME, 0);
-    if (PyErr_Occurred()) {
-      PyErr_Clear();
-      type_pointer = (void *)0;
-    }
-#endif
+  void *type_pointer = PyCapsule_Import(SWIGPY_CAPSULE_NAME, 0);
+  if (PyErr_Occurred()) {
+    PyErr_Clear();
+    type_pointer = (void *)0;
   }
+#endif
   return (swig_module_info *) type_pointer;
 }
 
+
+static int interpreter_counter = 0; // how many (sub-)interpreters are using swig_module's types
+
 SWIGRUNTIME void
 SWIG_Python_DestroyModule(PyObject *obj)
 {
   swig_module_info *swig_module = (swig_module_info *) PyCapsule_GetPointer(obj, SWIGPY_CAPSULE_NAME);
   swig_type_info **types = swig_module->types;
   size_t i;
+  if (--interpreter_counter != 0) // another sub-interpreter may still be using the swig_module's types
+    return;
   for (i =0; i < swig_module->size; ++i) {
     swig_type_info *ty = types[i];
     if (ty->owndata) {
       SwigPyClientData *data = (SwigPyClientData *) ty->clientdata;
+      ty->clientdata = 0;
       if (data) SwigPyClientData_Del(data);
     }
   }
   Py_DECREF(SWIG_This());
   Swig_This_global = NULL;
+  Py_DECREF(SWIG_globals());
+  Swig_Globals_global = NULL;
+  Py_DECREF(SWIG_Python_TypeCache());
+  Swig_TypeCache_global = NULL;
+  Swig_Capsule_global = NULL;
 }
 
 SWIGRUNTIME void
 SWIG_Python_SetModule(swig_module_info *swig_module) {
 #if PY_VERSION_HEX >= 0x03000000
  /* Add a dummy module object into sys.modules */
   PyObject *module = PyImport_AddModule("swig_runtime_data" SWIG_RUNTIME_VERSION);
 #else
   static PyMethodDef swig_empty_runtime_method_table[] = { {NULL, NULL, 0, NULL} }; /* Sentinel */
   PyObject *module = Py_InitModule("swig_runtime_data" SWIG_RUNTIME_VERSION, swig_empty_runtime_method_table);
 #endif
   PyObject *pointer = PyCapsule_New((void *) swig_module, SWIGPY_CAPSULE_NAME, SWIG_Python_DestroyModule);
   if (pointer && module) {
-    PyModule_AddObject(module, "type_pointer_capsule" SWIG_TYPE_TABLE_NAME, pointer);
+    if (PyModule_AddObject(module, SWIGPY_CAPSULE_ATTR_NAME, pointer) == 0) {
+      ++interpreter_counter;
+      Swig_Capsule_global = pointer;
+    } else {
+      Py_DECREF(pointer);
+    }
   } else {
     Py_XDECREF(pointer);
   }
 }
 
-/* The python cached type query */
-SWIGRUNTIME PyObject *
-SWIG_Python_TypeCache(void) {
-  static PyObject *SWIG_STATIC_POINTER(cache) = PyDict_New();
-  return cache;
-}
-
 SWIGRUNTIME swig_type_info *
 SWIG_Python_TypeQuery(const char *type)
 {
   PyObject *cache = SWIG_Python_TypeCache();
   PyObject *key = SWIG_Python_str_FromChar(type); 
   PyObject *obj = PyDict_GetItem(cache, key);
   swig_type_info *descriptor;
   if (obj) {
     descriptor = (swig_type_info *) PyCapsule_GetPointer(obj, NULL);
   } else {
     swig_module_info *swig_module = SWIG_GetModule(0);
     descriptor = SWIG_TypeQueryModule(swig_module, swig_module, type);
     if (descriptor) {
       obj = PyCapsule_New((void*) descriptor, NULL, NULL);
-      PyDict_SetItem(cache, key, obj);
-      Py_DECREF(obj);
+      if (obj) {
+        PyDict_SetItem(cache, key, obj);
+        Py_DECREF(obj);
+      }
     }
   }
   Py_DECREF(key);
   return descriptor;
 }
 
 /* 
@@ -2493,15 +2830,14 @@
       Py_XINCREF(type);
       PyErr_Clear();
       if (infront) {
 	PyErr_Format(type, "%s %s", mesg, errmesg);
       } else {
 	PyErr_Format(type, "%s %s", errmesg, mesg);
       }
-      SWIG_Python_str_DelForPy3(tmp);
       Py_DECREF(old_str);
     }
     return 1;
   } else {
     return 0;
   }
 }
@@ -2545,15 +2881,14 @@
       const char *otype = (obj ? obj->ob_type->tp_name : 0); 
       if (otype) {
 	PyObject *str = PyObject_Str(obj);
 	const char *cstr = str ? SWIG_Python_str_AsChar(str) : 0;
 	if (cstr) {
 	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s(%s)' is received",
 		       type, otype, cstr);
-          SWIG_Python_str_DelForPy3(cstr);
 	} else {
 	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s' is received",
 		       type, otype);
 	}
 	Py_XDECREF(str);
 	return;
       }
@@ -2567,20 +2902,14 @@
 
 /* Convert a pointer value, signal an exception on a type mismatch */
 SWIGRUNTIME void *
 SWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int SWIGUNUSEDPARM(argnum), int flags) {
   void *result;
   if (SWIG_Python_ConvertPtr(obj, &result, ty, flags) == -1) {
     PyErr_Clear();
-#if SWIG_POINTER_EXCEPTION
-    if (flags) {
-      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);
-      SWIG_Python_ArgFail(argnum);
-    }
-#endif
   }
   return result;
 }
 
 #ifdef SWIGPYTHON_BUILTIN
 SWIGRUNTIME int
 SWIG_Python_NonDynamicSetAttr(PyObject *obj, PyObject *name, PyObject *value) {
@@ -2603,30 +2932,30 @@
     PyErr_Format(PyExc_TypeError, "attribute name must be string, not '%.200s'", name->ob_type->tp_name);
     return -1;
   } else {
     Py_INCREF(name);
   }
 
   if (!tp->tp_dict) {
-    if (PyType_Ready(tp) < 0)
+    if (PyType_Ready(tp) != 0)
       goto done;
   }
 
   descr = _PyType_Lookup(tp, name);
   f = NULL;
   if (descr != NULL)
     f = descr->ob_type->tp_descr_set;
   if (!f) {
     if (PyString_Check(name)) {
       encoded_name = name;
       Py_INCREF(name);
     } else {
       encoded_name = PyUnicode_AsUTF8String(name);
       if (!encoded_name)
-        return -1;
+        goto done;
     }
     PyErr_Format(PyExc_AttributeError, "'%.100s' object has no attribute '%.200s'", tp->tp_name, PyString_AsString(encoded_name));
     Py_DECREF(encoded_name);
   } else {
     res = f(descr, obj, value);
   }
   
@@ -2645,15 +2974,19 @@
 extern "C" {
 #endif
 
 SWIGINTERN Py_hash_t
 SwigPyObject_hash(PyObject *obj) {
   SwigPyObject *sobj = (SwigPyObject *)obj;
   void *ptr = sobj->ptr;
+#if PY_VERSION_HEX < 0x03020000
+  return (Py_hash_t)(Py_ssize_t)ptr;
+#else
   return (Py_hash_t)ptr;
+#endif
 }
 
 SWIGINTERN Py_hash_t
 SWIG_PyNumber_AsPyHash(PyObject *obj) {
   Py_hash_t result = -1;
 #if PY_VERSION_HEX < 0x03020000
   if (PyInt_Check(obj))
@@ -2850,15 +3183,19 @@
       PyObject_HEAD_INIT(&PyType_Type)
       0,                                        /* ob_size */
 #endif
       "swig_static_var_getset_descriptor",      /* tp_name */
       sizeof(PyGetSetDescrObject),              /* tp_basicsize */
       0,                                        /* tp_itemsize */
       (destructor)SwigPyStaticVar_dealloc,      /* tp_dealloc */
-      0,                                        /* tp_print */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                             /* tp_print */
+#else
+      (Py_ssize_t)0,                            /* tp_vectorcall_offset */
+#endif
       0,                                        /* tp_getattr */
       0,                                        /* tp_setattr */
       0,                                        /* tp_compare */
       (reprfunc)SwigPyStaticVar_repr,           /* tp_repr */
       0,                                        /* tp_as_number */
       0,                                        /* tp_as_sequence */
       0,                                        /* tp_as_mapping */
@@ -2934,15 +3271,19 @@
       PyObject_HEAD_INIT(&PyType_Type)
       0,                                        /* ob_size */
 #endif
       "SwigPyObjectType",                       /* tp_name */
       PyType_Type.tp_basicsize,                 /* tp_basicsize */
       0,                                        /* tp_itemsize */
       0,                                        /* tp_dealloc */
-      0,                                        /* tp_print */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                             /* tp_print */
+#else
+      (Py_ssize_t)0,                            /* tp_vectorcall_offset */
+#endif
       0,                                        /* tp_getattr */
       0,                                        /* tp_setattr */
       0,                                        /* tp_compare */
       0,                                        /* tp_repr */
       0,                                        /* tp_as_number */
       0,                                        /* tp_as_sequence */
       0,                                        /* tp_as_mapping */
@@ -3053,18 +3394,18 @@
   Py_XINCREF(result);
   return result;
 }
 
 SWIGINTERN void
 SwigPyBuiltin_SetMetaType (PyTypeObject *type, PyTypeObject *metatype)
 {
-#if PY_VERSION_HEX >= 0x03000000
-    type->ob_base.ob_base.ob_type = metatype;
+#if PY_VERSION_HEX >= 0x030900a4
+    Py_SET_TYPE(type, metatype);
 #else
-    type->ob_type = metatype;
+    Py_TYPE(type) = metatype;
 #endif
 }
 
 
 /* Start of callback function macros for use in PyTypeObject */
 
 typedef PyObject *(*SwigPyWrapperFunction)(PyObject *, PyObject *);
@@ -3394,31 +3735,16 @@
 #endif
 
 
 
 
 #define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 
 
-#define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 
-
-
+#define SWIG_contract_assert(expr, msg) do { if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } } while (0) 
 
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* Method creation and docstring support functions */
-
-SWIGINTERN PyMethodDef *SWIG_PythonGetProxyDoc(const char *name);
-SWIGINTERN PyObject *SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func);
-SWIGINTERN PyObject *SWIG_PyStaticMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func);
-
-#ifdef __cplusplus
-}
-#endif
 
 
 /* -------- TYPES TABLE (BEGIN) -------- */
 
 #define SWIGTYPE_p_CallbackDetails swig_types[0]
 #define SWIGTYPE_p_CameraAbilities swig_types[1]
 #define SWIGTYPE_p_CameraCaptureType swig_types[2]
@@ -3501,18 +3827,14 @@
 
 #else
 #  define SWIG_init    init_context
 
 #endif
 #define SWIG_name    "_context"
 
-#define SWIGVERSION 0x040002 
-#define SWIG_VERSION SWIGVERSION
-
-
 #define SWIG_as_voidptr(a) (void *)((const void *)(a)) 
 #define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),(void**)(a)) 
 
 
 #include <stddef.h>
 
 
@@ -3911,14 +4233,15 @@
   PyObject *resultobj = 0;
   struct CallbackDetails *arg1 = (struct CallbackDetails *) 0 ;
   PyObject *arg2 = (PyObject *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   PyObject * obj1 = 0 ;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "CallbackDetails_func_1_set", 1, 1, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CallbackDetails, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CallbackDetails_func_1_set" "', argument " "1"" of type '" "struct CallbackDetails *""'"); 
   }
   arg1 = (struct CallbackDetails *)(argp1);
   arg2 = obj1;
@@ -3933,14 +4256,15 @@
 SWIGINTERN PyObject *_wrap_CallbackDetails_func_1_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct CallbackDetails *arg1 = (struct CallbackDetails *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   PyObject *result = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CallbackDetails_func_1_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CallbackDetails, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CallbackDetails_func_1_get" "', argument " "1"" of type '" "struct CallbackDetails *""'"); 
   }
   arg1 = (struct CallbackDetails *)(argp1);
   result = (PyObject *) ((arg1)->func_1);
@@ -3955,14 +4279,15 @@
   PyObject *resultobj = 0;
   struct CallbackDetails *arg1 = (struct CallbackDetails *) 0 ;
   PyObject *arg2 = (PyObject *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   PyObject * obj1 = 0 ;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "CallbackDetails_func_2_set", 1, 1, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CallbackDetails, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CallbackDetails_func_2_set" "', argument " "1"" of type '" "struct CallbackDetails *""'"); 
   }
   arg1 = (struct CallbackDetails *)(argp1);
   arg2 = obj1;
@@ -3977,14 +4302,15 @@
 SWIGINTERN PyObject *_wrap_CallbackDetails_func_2_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct CallbackDetails *arg1 = (struct CallbackDetails *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   PyObject *result = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CallbackDetails_func_2_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CallbackDetails, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CallbackDetails_func_2_get" "', argument " "1"" of type '" "struct CallbackDetails *""'"); 
   }
   arg1 = (struct CallbackDetails *)(argp1);
   result = (PyObject *) ((arg1)->func_2);
@@ -3999,14 +4325,15 @@
   PyObject *resultobj = 0;
   struct CallbackDetails *arg1 = (struct CallbackDetails *) 0 ;
   PyObject *arg2 = (PyObject *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   PyObject * obj1 = 0 ;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "CallbackDetails_func_3_set", 1, 1, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CallbackDetails, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CallbackDetails_func_3_set" "', argument " "1"" of type '" "struct CallbackDetails *""'"); 
   }
   arg1 = (struct CallbackDetails *)(argp1);
   arg2 = obj1;
@@ -4021,14 +4348,15 @@
 SWIGINTERN PyObject *_wrap_CallbackDetails_func_3_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct CallbackDetails *arg1 = (struct CallbackDetails *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   PyObject *result = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CallbackDetails_func_3_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CallbackDetails, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CallbackDetails_func_3_get" "', argument " "1"" of type '" "struct CallbackDetails *""'"); 
   }
   arg1 = (struct CallbackDetails *)(argp1);
   result = (PyObject *) ((arg1)->func_3);
@@ -4041,14 +4369,15 @@
 
 SWIGINTERN PyObject *_wrap_delete_CallbackDetails(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct CallbackDetails *arg1 = (struct CallbackDetails *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_CallbackDetails takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CallbackDetails, SWIG_POINTER_DISOWN |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CallbackDetails" "', argument " "1"" of type '" "struct CallbackDetails *""'"); 
   }
   arg1 = (struct CallbackDetails *)(argp1);
   delete_CallbackDetails(arg1);
@@ -4069,14 +4398,15 @@
   void *argp1 = 0 ;
   int res1 = 0 ;
   int res3 ;
   PyObject * obj0 = 0 ;
   PyObject * obj1 = 0 ;
   PyObject * obj2 = 0 ;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "unset_progress_funcs", 3, 3, &obj0, &obj1, &obj2)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__GPContext, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unset_progress_funcs" "', argument " "1"" of type '" "GPContext *""'"); 
   }
   arg1 = (GPContext *)(argp1);
   {
@@ -4097,14 +4427,15 @@
 }
 
 
 SWIGINTERN int _wrap_new_Context(PyObject *self, PyObject *args, PyObject *kwargs) {
   PyObject *resultobj = 0;
   struct _GPContext *result = 0 ;
   
+  (void)self;
   if (!SWIG_Python_CheckNoKeywords(kwargs, "new_Context")) SWIG_fail;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "new_Context takes no arguments");
   result = (struct _GPContext *)new__GPContext();
   resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p__GPContext, SWIG_BUILTIN_INIT |  0 );
   return resultobj == Py_None ? -1 : 0;
 fail:
   return -1;
@@ -4113,14 +4444,15 @@
 
 SWIGINTERN PyObject *_wrap_delete_Context(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _GPContext *arg1 = (struct _GPContext *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_Context takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__GPContext, SWIG_POINTER_DISOWN |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Context" "', argument " "1"" of type '" "struct _GPContext *""'"); 
   }
   arg1 = (struct _GPContext *)(argp1);
   delete__GPContext(arg1);
@@ -4144,14 +4476,15 @@
       arg2 = NULL;
       /*@SWIG:src/gphoto2/common/macros.i,25,GPHOTO2_ERROR@*/
       PyErr_SetObject(PyExc_GPhoto2Error, PyInt_FromLong(error));
       /*@SWIG@*/
       SWIG_fail;
     }
   }
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Context_camera_autodetect takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__GPContext, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Context_camera_autodetect" "', argument " "1"" of type '" "struct _GPContext *""'"); 
   }
   arg1 = (struct _GPContext *)(argp1);
   {
@@ -4202,14 +4535,15 @@
     _global_callbacks->context = NULL;
     _global_callbacks->func_1 = NULL;
     _global_callbacks->func_2 = NULL;
     _global_callbacks->func_3 = NULL;
     _global_callbacks->data = NULL;
     _global_callbacks->remove = (RemoveFunc) gp_context_set_idle_func;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "Context_set_idle_func", 2, 2, &obj1, &obj2)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__GPContext, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Context_set_idle_func" "', argument " "1"" of type '" "struct _GPContext *""'"); 
   }
   arg1 = (struct _GPContext *)(argp1);
   {
@@ -4266,14 +4600,15 @@
     _global_callbacks->context = NULL;
     _global_callbacks->func_1 = NULL;
     _global_callbacks->func_2 = NULL;
     _global_callbacks->func_3 = NULL;
     _global_callbacks->data = NULL;
     _global_callbacks->remove = (RemoveFunc) gp_context_set_error_func;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "Context_set_error_func", 2, 2, &obj1, &obj2)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__GPContext, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Context_set_error_func" "', argument " "1"" of type '" "struct _GPContext *""'"); 
   }
   arg1 = (struct _GPContext *)(argp1);
   {
@@ -4330,14 +4665,15 @@
     _global_callbacks->context = NULL;
     _global_callbacks->func_1 = NULL;
     _global_callbacks->func_2 = NULL;
     _global_callbacks->func_3 = NULL;
     _global_callbacks->data = NULL;
     _global_callbacks->remove = (RemoveFunc) gp_context_set_message_func;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "Context_set_message_func", 2, 2, &obj1, &obj2)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__GPContext, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Context_set_message_func" "', argument " "1"" of type '" "struct _GPContext *""'"); 
   }
   arg1 = (struct _GPContext *)(argp1);
   {
@@ -4394,14 +4730,15 @@
     _global_callbacks->context = NULL;
     _global_callbacks->func_1 = NULL;
     _global_callbacks->func_2 = NULL;
     _global_callbacks->func_3 = NULL;
     _global_callbacks->data = NULL;
     _global_callbacks->remove = (RemoveFunc) gp_context_set_question_func;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "Context_set_question_func", 2, 2, &obj1, &obj2)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__GPContext, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Context_set_question_func" "', argument " "1"" of type '" "struct _GPContext *""'"); 
   }
   arg1 = (struct _GPContext *)(argp1);
   {
@@ -4458,14 +4795,15 @@
     _global_callbacks->context = NULL;
     _global_callbacks->func_1 = NULL;
     _global_callbacks->func_2 = NULL;
     _global_callbacks->func_3 = NULL;
     _global_callbacks->data = NULL;
     _global_callbacks->remove = (RemoveFunc) gp_context_set_cancel_func;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "Context_set_cancel_func", 2, 2, &obj1, &obj2)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__GPContext, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Context_set_cancel_func" "', argument " "1"" of type '" "struct _GPContext *""'"); 
   }
   arg1 = (struct _GPContext *)(argp1);
   {
@@ -4526,14 +4864,15 @@
     _global_callbacks->context = NULL;
     _global_callbacks->func_1 = NULL;
     _global_callbacks->func_2 = NULL;
     _global_callbacks->func_3 = NULL;
     _global_callbacks->data = NULL;
     _global_callbacks->remove = (RemoveFunc) unset_progress_funcs;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "Context_set_progress_funcs", 4, 4, &obj1, &obj2, &obj3, &obj4)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__GPContext, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Context_set_progress_funcs" "', argument " "1"" of type '" "struct _GPContext *""'"); 
   }
   arg1 = (struct _GPContext *)(argp1);
   {
@@ -4606,14 +4945,15 @@
     _global_callbacks->context = NULL;
     _global_callbacks->func_1 = NULL;
     _global_callbacks->func_2 = NULL;
     _global_callbacks->func_3 = NULL;
     _global_callbacks->data = NULL;
     _global_callbacks->remove = (RemoveFunc) gp_context_set_status_func;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "Context_set_status_func", 2, 2, &obj1, &obj2)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__GPContext, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Context_set_status_func" "', argument " "1"" of type '" "struct _GPContext *""'"); 
   }
   arg1 = (struct _GPContext *)(argp1);
   {
@@ -4652,14 +4992,15 @@
 
 SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_Context) /* defines _wrap_delete_Context_destructor_closure */
 
 SWIGINTERN PyObject *_wrap_gp_context_new(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   GPContext *result = 0 ;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_context_new", 0, 0)) SWIG_fail;
   result = (GPContext *)gp_context_new();
   resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p__GPContext, SWIG_POINTER_OWN |  0 );
   return resultobj;
 fail:
   return NULL;
 }
@@ -4686,14 +5027,15 @@
     _global_callbacks->context = NULL;
     _global_callbacks->func_1 = NULL;
     _global_callbacks->func_2 = NULL;
     _global_callbacks->func_3 = NULL;
     _global_callbacks->data = NULL;
     _global_callbacks->remove = (RemoveFunc) gp_context_set_idle_func;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_context_set_idle_func", 3, 3, &obj0, &obj1, &obj2)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__GPContext, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_context_set_idle_func" "', argument " "1"" of type '" "GPContext *""'"); 
   }
   arg1 = (GPContext *)(argp1);
   {
@@ -4758,14 +5100,15 @@
     _global_callbacks->context = NULL;
     _global_callbacks->func_1 = NULL;
     _global_callbacks->func_2 = NULL;
     _global_callbacks->func_3 = NULL;
     _global_callbacks->data = NULL;
     _global_callbacks->remove = (RemoveFunc) unset_progress_funcs;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_context_set_progress_funcs", 5, 5, &obj0, &obj1, &obj2, &obj3, &obj4)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__GPContext, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_context_set_progress_funcs" "', argument " "1"" of type '" "GPContext *""'"); 
   }
   arg1 = (GPContext *)(argp1);
   {
@@ -4842,14 +5185,15 @@
     _global_callbacks->context = NULL;
     _global_callbacks->func_1 = NULL;
     _global_callbacks->func_2 = NULL;
     _global_callbacks->func_3 = NULL;
     _global_callbacks->data = NULL;
     _global_callbacks->remove = (RemoveFunc) gp_context_set_error_func;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_context_set_error_func", 3, 3, &obj0, &obj1, &obj2)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__GPContext, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_context_set_error_func" "', argument " "1"" of type '" "GPContext *""'"); 
   }
   arg1 = (GPContext *)(argp1);
   {
@@ -4910,14 +5254,15 @@
     _global_callbacks->context = NULL;
     _global_callbacks->func_1 = NULL;
     _global_callbacks->func_2 = NULL;
     _global_callbacks->func_3 = NULL;
     _global_callbacks->data = NULL;
     _global_callbacks->remove = (RemoveFunc) gp_context_set_status_func;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_context_set_status_func", 3, 3, &obj0, &obj1, &obj2)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__GPContext, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_context_set_status_func" "', argument " "1"" of type '" "GPContext *""'"); 
   }
   arg1 = (GPContext *)(argp1);
   {
@@ -4978,14 +5323,15 @@
     _global_callbacks->context = NULL;
     _global_callbacks->func_1 = NULL;
     _global_callbacks->func_2 = NULL;
     _global_callbacks->func_3 = NULL;
     _global_callbacks->data = NULL;
     _global_callbacks->remove = (RemoveFunc) gp_context_set_question_func;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_context_set_question_func", 3, 3, &obj0, &obj1, &obj2)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__GPContext, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_context_set_question_func" "', argument " "1"" of type '" "GPContext *""'"); 
   }
   arg1 = (GPContext *)(argp1);
   {
@@ -5046,14 +5392,15 @@
     _global_callbacks->context = NULL;
     _global_callbacks->func_1 = NULL;
     _global_callbacks->func_2 = NULL;
     _global_callbacks->func_3 = NULL;
     _global_callbacks->data = NULL;
     _global_callbacks->remove = (RemoveFunc) gp_context_set_cancel_func;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_context_set_cancel_func", 3, 3, &obj0, &obj1, &obj2)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__GPContext, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_context_set_cancel_func" "', argument " "1"" of type '" "GPContext *""'"); 
   }
   arg1 = (GPContext *)(argp1);
   {
@@ -5114,14 +5461,15 @@
     _global_callbacks->context = NULL;
     _global_callbacks->func_1 = NULL;
     _global_callbacks->func_2 = NULL;
     _global_callbacks->func_3 = NULL;
     _global_callbacks->data = NULL;
     _global_callbacks->remove = (RemoveFunc) gp_context_set_message_func;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_context_set_message_func", 3, 3, &obj0, &obj1, &obj2)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__GPContext, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_context_set_message_func" "', argument " "1"" of type '" "GPContext *""'"); 
   }
   arg1 = (GPContext *)(argp1);
   {
@@ -5158,116 +5506,14 @@
     del_CallbackDetails(_global_callbacks);
   }
   return NULL;
 }
 
 
 static PyMethodDef SwigMethods[] = {
-	 { "SWIG_PyInstanceMethod_New", SWIG_PyInstanceMethod_New, METH_O, NULL},
-	 { "SWIG_PyStaticMethod_New", SWIG_PyStaticMethod_New, METH_O, NULL},
-	 { "unset_progress_funcs", _wrap_unset_progress_funcs, METH_VARARGS, "\n"
-		"unset_progress_funcs(context, start_func, data)\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"context: gphoto2.GPContext\n"
-		"start_func: GPContextProgressStartFunc\n"
-		"data: void *\n"
-		"\n"
-		""},
-	 { "gp_context_new", _wrap_gp_context_new, METH_VARARGS, "\n"
-		"gp_context_new() -> Context\n"
-		"Creates a new context.  \n"
-		"\n"
-		"To be used by the frontend.  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a GPContext.\n"
-		"\n"
-		"See also gphoto2.Context\n"
-		""},
-	 { "gp_context_set_idle_func", _wrap_gp_context_set_idle_func, METH_VARARGS, "\n"
-		"gp_context_set_idle_func(context, func, data)\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"context: gphoto2.GPContext\n"
-		"func: callable function\n"
-		"data: object\n"
-		"\n"
-		""},
-	 { "gp_context_set_progress_funcs", _wrap_gp_context_set_progress_funcs, METH_VARARGS, "\n"
-		"gp_context_set_progress_funcs(context, start_func, update_func, stop_func, data)\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"context: gphoto2.GPContext\n"
-		"start_func: callable function\n"
-		"update_func: callable function\n"
-		"stop_func: callable function\n"
-		"data: object\n"
-		"\n"
-		""},
-	 { "gp_context_set_error_func", _wrap_gp_context_set_error_func, METH_VARARGS, "\n"
-		"gp_context_set_error_func(context, func, data)\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"context: gphoto2.GPContext\n"
-		"func: callable function\n"
-		"data: object\n"
-		"\n"
-		""},
-	 { "gp_context_set_status_func", _wrap_gp_context_set_status_func, METH_VARARGS, "\n"
-		"gp_context_set_status_func(context, func, data)\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"context: gphoto2.GPContext\n"
-		"func: callable function\n"
-		"data: object\n"
-		"\n"
-		""},
-	 { "gp_context_set_question_func", _wrap_gp_context_set_question_func, METH_VARARGS, "\n"
-		"gp_context_set_question_func(context, func, data)\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"context: gphoto2.GPContext\n"
-		"func: callable function\n"
-		"data: object\n"
-		"\n"
-		""},
-	 { "gp_context_set_cancel_func", _wrap_gp_context_set_cancel_func, METH_VARARGS, "\n"
-		"gp_context_set_cancel_func(context, func, data)\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"context: gphoto2.GPContext\n"
-		"func: callable function\n"
-		"data: object\n"
-		"\n"
-		""},
-	 { "gp_context_set_message_func", _wrap_gp_context_set_message_func, METH_VARARGS, "\n"
-		"gp_context_set_message_func(context, func, data)\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"context: gphoto2.GPContext\n"
-		"func: callable function\n"
-		"data: object\n"
-		"\n"
-		""},
-	 { NULL, NULL, 0, NULL }
-};
-
-static PyMethodDef SwigMethods_proxydocs[] = {
-	 { "SWIG_PyInstanceMethod_New", SWIG_PyInstanceMethod_New, METH_O, NULL},
-	 { "SWIG_PyStaticMethod_New", SWIG_PyStaticMethod_New, METH_O, NULL},
 	 { "unset_progress_funcs", _wrap_unset_progress_funcs, METH_VARARGS, "\n"
 		"unset_progress_funcs(context, start_func, data)\n"
 		"\n"
 		"Parameters\n"
 		"----------\n"
 		"context: gphoto2.GPContext\n"
 		"start_func: GPContextProgressStartFunc\n"
@@ -5357,22 +5603,22 @@
 		"func: callable function\n"
 		"data: object\n"
 		"\n"
 		""},
 	 { NULL, NULL, 0, NULL }
 };
 
+static SwigPyGetSet CallbackDetails___dict___getset = { SwigPyObject_get___dict__, 0 };
 static SwigPyGetSet CallbackDetails_func_1_getset = { _wrap_CallbackDetails_func_1_get, _wrap_CallbackDetails_func_1_set };
 static SwigPyGetSet CallbackDetails_func_2_getset = { _wrap_CallbackDetails_func_2_get, _wrap_CallbackDetails_func_2_set };
-static SwigPyGetSet CallbackDetails___dict___getset = { SwigPyObject_get___dict__, 0 };
 static SwigPyGetSet CallbackDetails_func_3_getset = { _wrap_CallbackDetails_func_3_get, _wrap_CallbackDetails_func_3_set };
 SWIGINTERN PyGetSetDef SwigPyBuiltin__CallbackDetails_getset[] = {
+    { (char *)"__dict__", SwigPyBuiltin_GetterClosure, 0, (char *)"func_1", &CallbackDetails___dict___getset },
     { (char *)"func_1", SwigPyBuiltin_GetterClosure, SwigPyBuiltin_SetterClosure, (char *)"func_1", &CallbackDetails_func_1_getset },
     { (char *)"func_2", SwigPyBuiltin_GetterClosure, SwigPyBuiltin_SetterClosure, (char *)"func_2", &CallbackDetails_func_2_getset },
-    { (char *)"__dict__", SwigPyBuiltin_GetterClosure, 0, (char *)"func_1", &CallbackDetails___dict___getset },
     { (char *)"func_3", SwigPyBuiltin_GetterClosure, SwigPyBuiltin_SetterClosure, (char *)"func_3", &CallbackDetails_func_3_getset },
     { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
 };
 
 SWIGINTERN PyObject *
 SwigPyBuiltin__CallbackDetails_richcompare(PyObject *self, PyObject *other, int op) {
   PyObject *result = NULL;
@@ -5404,15 +5650,19 @@
     PyObject_HEAD_INIT(NULL)
     0,                                        /* ob_size */
 #endif
     "gphoto2.context.CallbackDetails",        /* tp_name */
     sizeof(SwigPyObject),                     /* tp_basicsize */
     0,                                        /* tp_itemsize */
     _wrap_delete_CallbackDetails_destructor_closure,              /* tp_dealloc */
+#if PY_VERSION_HEX < 0x030800b4
     (printfunc) 0,                            /* tp_print */
+#else
+    (Py_ssize_t) 0,                           /* tp_vectorcall_offset */
+#endif
     (getattrfunc) 0,                          /* tp_getattr */
     (setattrfunc) 0,                          /* tp_setattr */
 #if PY_VERSION_HEX >= 0x03000000
     0,                                        /* tp_compare */
 #else
     (cmpfunc) 0,                              /* tp_compare */
 #endif
@@ -5476,14 +5726,17 @@
 #endif
   },
 #if PY_VERSION_HEX >= 0x03050000
   {
     (unaryfunc) 0,                            /* am_await */
     (unaryfunc) 0,                            /* am_aiter */
     (unaryfunc) 0,                            /* am_anext */
+# if PY_VERSION_HEX >= 0x030a0000
+    (sendfunc) 0,                             /* am_send */
+# endif
   },
 #endif
   {
     (binaryfunc) 0,                           /* nb_add */
     (binaryfunc) 0,                           /* nb_subtract */
     (binaryfunc) 0,                           /* nb_multiply */
 #if PY_VERSION_HEX < 0x03000000
@@ -5576,14 +5829,23 @@
   },
     (PyObject *) 0,                           /* ht_name */
     (PyObject *) 0,                           /* ht_slots */
 #if PY_VERSION_HEX >= 0x03030000
     (PyObject *) 0,                           /* ht_qualname */
     0,                                        /* ht_cached_keys */
 #endif
+#if PY_VERSION_HEX >= 0x03090000
+    (PyObject *) 0,                           /* ht_module */
+#endif
+#if PY_VERSION_HEX >= 0x030b0000
+    (char *) 0,                               /* _ht_tpname */
+  {
+    (PyObject *) 0,                           /* getitem */
+  }
+#endif
 };
 
 SWIGINTERN SwigPyClientData SwigPyBuiltin__CallbackDetails_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__CallbackDetails_type};
 
 static SwigPyGetSet Context___dict___getset = { SwigPyObject_get___dict__, 0 };
 SWIGINTERN PyGetSetDef SwigPyBuiltin___GPContext_getset[] = {
     { (char *)"__dict__", SwigPyBuiltin_GetterClosure, 0, (char *)"unset_progress_funcs", &Context___dict___getset },
@@ -5687,15 +5949,19 @@
     PyObject_HEAD_INIT(NULL)
     0,                                        /* ob_size */
 #endif
     "gphoto2.context.Context",                /* tp_name */
     sizeof(SwigPyObject),                     /* tp_basicsize */
     0,                                        /* tp_itemsize */
     _wrap_delete_Context_destructor_closure,  /* tp_dealloc */
+#if PY_VERSION_HEX < 0x030800b4
     (printfunc) 0,                            /* tp_print */
+#else
+    (Py_ssize_t) 0,                           /* tp_vectorcall_offset */
+#endif
     (getattrfunc) 0,                          /* tp_getattr */
     (setattrfunc) 0,                          /* tp_setattr */
 #if PY_VERSION_HEX >= 0x03000000
     0,                                        /* tp_compare */
 #else
     (cmpfunc) 0,                              /* tp_compare */
 #endif
@@ -5759,14 +6025,17 @@
 #endif
   },
 #if PY_VERSION_HEX >= 0x03050000
   {
     (unaryfunc) 0,                            /* am_await */
     (unaryfunc) 0,                            /* am_aiter */
     (unaryfunc) 0,                            /* am_anext */
+# if PY_VERSION_HEX >= 0x030a0000
+    (sendfunc) 0,                             /* am_send */
+# endif
   },
 #endif
   {
     (binaryfunc) 0,                           /* nb_add */
     (binaryfunc) 0,                           /* nb_subtract */
     (binaryfunc) 0,                           /* nb_multiply */
 #if PY_VERSION_HEX < 0x03000000
@@ -5859,83 +6128,92 @@
   },
     (PyObject *) 0,                           /* ht_name */
     (PyObject *) 0,                           /* ht_slots */
 #if PY_VERSION_HEX >= 0x03030000
     (PyObject *) 0,                           /* ht_qualname */
     0,                                        /* ht_cached_keys */
 #endif
+#if PY_VERSION_HEX >= 0x03090000
+    (PyObject *) 0,                           /* ht_module */
+#endif
+#if PY_VERSION_HEX >= 0x030b0000
+    (char *) 0,                               /* _ht_tpname */
+  {
+    (PyObject *) 0,                           /* getitem */
+  }
+#endif
 };
 
 SWIGINTERN SwigPyClientData SwigPyBuiltin___GPContext_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin___GPContext_type};
 
 
 /* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */
 
-static swig_type_info _swigt__p_CallbackDetails = {"_p_CallbackDetails", "struct CallbackDetails *|CallbackDetails *", 0, 0, (void*)&SwigPyBuiltin__CallbackDetails_clientdata, 0};
+static swig_type_info _swigt__p_CallbackDetails = {"_p_CallbackDetails", "CallbackDetails *|struct CallbackDetails *", 0, 0, (void*)&SwigPyBuiltin__CallbackDetails_clientdata, 0};
 static swig_type_info _swigt__p_CameraAbilities = {"_p_CameraAbilities", "CameraAbilities *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraCaptureType = {"_p_CameraCaptureType", "enum CameraCaptureType *|CameraCaptureType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraDriverStatus = {"_p_CameraDriverStatus", "enum CameraDriverStatus *|CameraDriverStatus *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraEventType = {"_p_CameraEventType", "enum CameraEventType *|CameraEventType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileAccessType = {"_p_CameraFileAccessType", "enum CameraFileAccessType *|CameraFileAccessType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileInfoFields = {"_p_CameraFileInfoFields", "enum CameraFileInfoFields *|CameraFileInfoFields *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileOperation = {"_p_CameraFileOperation", "enum CameraFileOperation *|CameraFileOperation *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraCaptureType = {"_p_CameraCaptureType", "CameraCaptureType *|enum CameraCaptureType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraDriverStatus = {"_p_CameraDriverStatus", "CameraDriverStatus *|enum CameraDriverStatus *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraEventType = {"_p_CameraEventType", "CameraEventType *|enum CameraEventType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileAccessType = {"_p_CameraFileAccessType", "CameraFileAccessType *|enum CameraFileAccessType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileInfoFields = {"_p_CameraFileInfoFields", "CameraFileInfoFields *|enum CameraFileInfoFields *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileOperation = {"_p_CameraFileOperation", "CameraFileOperation *|enum CameraFileOperation *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_CameraFilePath = {"_p_CameraFilePath", "CameraFilePath *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFilePermissions = {"_p_CameraFilePermissions", "enum CameraFilePermissions *|CameraFilePermissions *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileStatus = {"_p_CameraFileStatus", "enum CameraFileStatus *|CameraFileStatus *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileType = {"_p_CameraFileType", "enum CameraFileType *|CameraFileType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFolderOperation = {"_p_CameraFolderOperation", "enum CameraFolderOperation *|CameraFolderOperation *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraOperation = {"_p_CameraOperation", "enum CameraOperation *|CameraOperation *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraStorageAccessType = {"_p_CameraStorageAccessType", "enum CameraStorageAccessType *|CameraStorageAccessType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraStorageFilesystemType = {"_p_CameraStorageFilesystemType", "enum CameraStorageFilesystemType *|CameraStorageFilesystemType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraStorageInfoFields = {"_p_CameraStorageInfoFields", "enum CameraStorageInfoFields *|CameraStorageInfoFields *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraStorageType = {"_p_CameraStorageType", "enum CameraStorageType *|CameraStorageType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFilePermissions = {"_p_CameraFilePermissions", "CameraFilePermissions *|enum CameraFilePermissions *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileStatus = {"_p_CameraFileStatus", "CameraFileStatus *|enum CameraFileStatus *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileType = {"_p_CameraFileType", "CameraFileType *|enum CameraFileType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFolderOperation = {"_p_CameraFolderOperation", "CameraFolderOperation *|enum CameraFolderOperation *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraOperation = {"_p_CameraOperation", "CameraOperation *|enum CameraOperation *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraStorageAccessType = {"_p_CameraStorageAccessType", "CameraStorageAccessType *|enum CameraStorageAccessType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraStorageFilesystemType = {"_p_CameraStorageFilesystemType", "CameraStorageFilesystemType *|enum CameraStorageFilesystemType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraStorageInfoFields = {"_p_CameraStorageInfoFields", "CameraStorageInfoFields *|enum CameraStorageInfoFields *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraStorageType = {"_p_CameraStorageType", "CameraStorageType *|enum CameraStorageType *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_CameraText = {"_p_CameraText", "CameraText *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraWidgetType = {"_p_CameraWidgetType", "enum CameraWidgetType *|CameraWidgetType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_GPLogLevel = {"_p_GPLogLevel", "enum GPLogLevel *|GPLogLevel *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_GPPortType = {"_p_GPPortType", "enum GPPortType *|GPPortType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_GPVersionVerbosity = {"_p_GPVersionVerbosity", "enum GPVersionVerbosity *|GPVersionVerbosity *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_GphotoDeviceType = {"_p_GphotoDeviceType", "enum GphotoDeviceType *|GphotoDeviceType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraWidgetType = {"_p_CameraWidgetType", "CameraWidgetType *|enum CameraWidgetType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GPLogLevel = {"_p_GPLogLevel", "GPLogLevel *|enum GPLogLevel *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GPPortType = {"_p_GPPortType", "GPPortType *|enum GPPortType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GPVersionVerbosity = {"_p_GPVersionVerbosity", "GPVersionVerbosity *|enum GPVersionVerbosity *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GphotoDeviceType = {"_p_GphotoDeviceType", "GphotoDeviceType *|enum GphotoDeviceType *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_SwigPyObject = {"_p_SwigPyObject", "SwigPyObject *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__Camera = {"_p__Camera", "struct _Camera *|Camera *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraAbilitiesList = {"_p__CameraAbilitiesList", "struct _CameraAbilitiesList *|CameraAbilitiesList *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFile = {"_p__CameraFile", "struct _CameraFile *|CameraFile *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFileHandler = {"_p__CameraFileHandler", "struct _CameraFileHandler *|CameraFileHandler *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFileInfo = {"_p__CameraFileInfo", "struct _CameraFileInfo *|CameraFileInfo *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFileInfoAudio = {"_p__CameraFileInfoAudio", "struct _CameraFileInfoAudio *|CameraFileInfoAudio *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFileInfoFile = {"_p__CameraFileInfoFile", "struct _CameraFileInfoFile *|CameraFileInfoFile *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFileInfoPreview = {"_p__CameraFileInfoPreview", "struct _CameraFileInfoPreview *|CameraFileInfoPreview *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFilesystem = {"_p__CameraFilesystem", "struct _CameraFilesystem *|CameraFilesystem *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFilesystemFuncs = {"_p__CameraFilesystemFuncs", "struct _CameraFilesystemFuncs *|CameraFilesystemFuncs *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFunctions = {"_p__CameraFunctions", "struct _CameraFunctions *|CameraFunctions *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraList = {"_p__CameraList", "struct _CameraList *|CameraList *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraPrivateCore = {"_p__CameraPrivateCore", "struct _CameraPrivateCore *|CameraPrivateCore *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraPrivateLibrary = {"_p__CameraPrivateLibrary", "struct _CameraPrivateLibrary *|CameraPrivateLibrary *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraStorageInformation = {"_p__CameraStorageInformation", "struct _CameraStorageInformation *|CameraStorageInformation *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraWidget = {"_p__CameraWidget", "struct _CameraWidget *|CameraWidget *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__GPContext = {"_p__GPContext", "struct _GPContext *|GPContext *|_GPContext *", 0, 0, (void*)&SwigPyBuiltin___GPContext_clientdata, 0};
-static swig_type_info _swigt__p__GPContextFeedback = {"_p__GPContextFeedback", "enum _GPContextFeedback *|GPContextFeedback *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__Camera = {"_p__Camera", "Camera *|struct _Camera *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraAbilitiesList = {"_p__CameraAbilitiesList", "CameraAbilitiesList *|struct _CameraAbilitiesList *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFile = {"_p__CameraFile", "CameraFile *|struct _CameraFile *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFileHandler = {"_p__CameraFileHandler", "CameraFileHandler *|struct _CameraFileHandler *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFileInfo = {"_p__CameraFileInfo", "CameraFileInfo *|struct _CameraFileInfo *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFileInfoAudio = {"_p__CameraFileInfoAudio", "CameraFileInfoAudio *|struct _CameraFileInfoAudio *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFileInfoFile = {"_p__CameraFileInfoFile", "CameraFileInfoFile *|struct _CameraFileInfoFile *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFileInfoPreview = {"_p__CameraFileInfoPreview", "CameraFileInfoPreview *|struct _CameraFileInfoPreview *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFilesystem = {"_p__CameraFilesystem", "CameraFilesystem *|struct _CameraFilesystem *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFilesystemFuncs = {"_p__CameraFilesystemFuncs", "CameraFilesystemFuncs *|struct _CameraFilesystemFuncs *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFunctions = {"_p__CameraFunctions", "CameraFunctions *|struct _CameraFunctions *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraList = {"_p__CameraList", "CameraList *|struct _CameraList *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraPrivateCore = {"_p__CameraPrivateCore", "CameraPrivateCore *|struct _CameraPrivateCore *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraPrivateLibrary = {"_p__CameraPrivateLibrary", "CameraPrivateLibrary *|struct _CameraPrivateLibrary *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraStorageInformation = {"_p__CameraStorageInformation", "CameraStorageInformation *|struct _CameraStorageInformation *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraWidget = {"_p__CameraWidget", "CameraWidget *|struct _CameraWidget *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__GPContext = {"_p__GPContext", "GPContext *|struct _GPContext *|_GPContext *", 0, 0, (void*)&SwigPyBuiltin___GPContext_clientdata, 0};
+static swig_type_info _swigt__p__GPContextFeedback = {"_p__GPContextFeedback", "GPContextFeedback *|enum _GPContextFeedback *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p__GPPortInfo = {"_p__GPPortInfo", "_GPPortInfo *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__GPPortInfoList = {"_p__GPPortInfoList", "struct _GPPortInfoList *|GPPortInfoList *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__GPPortInfoList = {"_p__GPPortInfoList", "GPPortInfoList *|struct _GPPortInfoList *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_f_p_struct__GPContext_float_p_q_const__char_p_void__unsigned_int = {"_p_f_p_struct__GPContext_float_p_q_const__char_p_void__unsigned_int", "unsigned int (*)(struct _GPContext *,float,char const *,void *)|GPContextProgressStartFunc", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_f_p_struct__GPContext_p_q_const__char_p_void___GPContextFeedback = {"_p_f_p_struct__GPContext_p_q_const__char_p_void___GPContextFeedback", "enum _GPContextFeedback (*)(struct _GPContext *,char const *,void *)|GPContextQuestionFunc", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_f_p_struct__GPContext_float_p_q_const__char_p_void__unsigned_int = {"_p_f_p_struct__GPContext_float_p_q_const__char_p_void__unsigned_int", "GPContextProgressStartFunc|unsigned int (*)(struct _GPContext *,float,char const *,void *)", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_f_p_struct__GPContext_p_q_const__char_p_void___GPContextFeedback = {"_p_f_p_struct__GPContext_p_q_const__char_p_void___GPContextFeedback", "GPContextQuestionFunc|enum _GPContextFeedback (*)(struct _GPContext *,char const *,void *)", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_f_p_struct__GPContext_p_q_const__char_p_void__void = {"_p_f_p_struct__GPContext_p_q_const__char_p_void__void", "GPContextErrorFunc|GPContextMessageFunc|GPContextStatusFunc|void (*)(struct _GPContext *,char const *,void *)", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_f_p_struct__GPContext_p_void___GPContextFeedback = {"_p_f_p_struct__GPContext_p_void___GPContextFeedback", "enum _GPContextFeedback (*)(struct _GPContext *,void *)|GPContextCancelFunc", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_f_p_struct__GPContext_p_void__void = {"_p_f_p_struct__GPContext_p_void__void", "void (*)(struct _GPContext *,void *)|GPContextIdleFunc", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_f_p_struct__GPContext_unsigned_int_float_p_void__void = {"_p_f_p_struct__GPContext_unsigned_int_float_p_void__void", "void (*)(struct _GPContext *,unsigned int,float,void *)|GPContextProgressUpdateFunc", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_f_p_struct__GPContext_unsigned_int_p_void__void = {"_p_f_p_struct__GPContext_unsigned_int_p_void__void", "void (*)(struct _GPContext *,unsigned int,void *)|GPContextProgressStopFunc", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_int = {"_p_int", "intptr_t *|int *|int_least32_t *|int_fast32_t *|int32_t *|int_fast16_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_long = {"_p_long", "long *|time_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_long_long = {"_p_long_long", "int_least64_t *|int_fast64_t *|int64_t *|long long *|intmax_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_short = {"_p_short", "short *|int_least16_t *|int16_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_signed_char = {"_p_signed_char", "signed char *|int_least8_t *|int_fast8_t *|int8_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_unsigned_char = {"_p_unsigned_char", "unsigned char *|uint_least8_t *|uint_fast8_t *|uint8_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_unsigned_int = {"_p_unsigned_int", "uintptr_t *|uint_least32_t *|uint_fast32_t *|uint32_t *|unsigned int *|uint_fast16_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_unsigned_long_long = {"_p_unsigned_long_long", "uint_least64_t *|uint_fast64_t *|uint64_t *|unsigned long long *|uintmax_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_unsigned_short = {"_p_unsigned_short", "unsigned short *|uint_least16_t *|uint16_t *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_f_p_struct__GPContext_p_void___GPContextFeedback = {"_p_f_p_struct__GPContext_p_void___GPContextFeedback", "GPContextCancelFunc|enum _GPContextFeedback (*)(struct _GPContext *,void *)", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_f_p_struct__GPContext_p_void__void = {"_p_f_p_struct__GPContext_p_void__void", "GPContextIdleFunc|void (*)(struct _GPContext *,void *)", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_f_p_struct__GPContext_unsigned_int_float_p_void__void = {"_p_f_p_struct__GPContext_unsigned_int_float_p_void__void", "GPContextProgressUpdateFunc|void (*)(struct _GPContext *,unsigned int,float,void *)", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_f_p_struct__GPContext_unsigned_int_p_void__void = {"_p_f_p_struct__GPContext_unsigned_int_p_void__void", "GPContextProgressStopFunc|void (*)(struct _GPContext *,unsigned int,void *)", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_int = {"_p_int", "int32_t *|int_fast16_t *|int_fast32_t *|int_least32_t *|intptr_t *|int *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_long = {"_p_long", "time_t *|long *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_long_long = {"_p_long_long", "int64_t *|int_fast64_t *|int_least64_t *|intmax_t *|long long *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_short = {"_p_short", "int16_t *|int_least16_t *|short *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_signed_char = {"_p_signed_char", "int8_t *|int_fast8_t *|int_least8_t *|signed char *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_unsigned_char = {"_p_unsigned_char", "uint8_t *|uint_fast8_t *|uint_least8_t *|unsigned char *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_unsigned_int = {"_p_unsigned_int", "uint32_t *|uint_fast16_t *|uint_fast32_t *|uint_least32_t *|uintptr_t *|unsigned int *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_unsigned_long_long = {"_p_unsigned_long_long", "uint64_t *|uint_fast64_t *|uint_least64_t *|uintmax_t *|unsigned long long *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_unsigned_short = {"_p_unsigned_short", "uint16_t *|uint_least16_t *|unsigned short *", 0, 0, (void*)0, 0};
 
 static swig_type_info *swig_type_initial[] = {
   &_swigt__p_CallbackDetails,
   &_swigt__p_CameraAbilities,
   &_swigt__p_CameraCaptureType,
   &_swigt__p_CameraDriverStatus,
   &_swigt__p_CameraEventType,
@@ -6185,17 +6463,20 @@
 #endif
 #endif
 
 #if 0
 #define SWIGRUNTIME_DEBUG
 #endif
 
+#ifndef SWIG_INIT_CLIENT_DATA_TYPE
+#define SWIG_INIT_CLIENT_DATA_TYPE void *
+#endif
 
 SWIGRUNTIME void
-SWIG_InitializeModule(void *clientdata) {
+SWIG_InitializeModule(SWIG_INIT_CLIENT_DATA_TYPE clientdata) {
   size_t i;
   swig_module_info *module_head, *iter;
   int init;
   
   /* check to see if the circular list has been setup, if not, set it up */
   if (swig_module.next==0) {
     /* Initialize the swig_module */
@@ -6370,228 +6651,14 @@
 
 
 
 #ifdef __cplusplus
 extern "C" {
 #endif
   
-  /* Python-specific SWIG API */
-#define SWIG_newvarlink()                             SWIG_Python_newvarlink()
-#define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
-#define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)
-  
-  /* -----------------------------------------------------------------------------
-   * global variable support code.
-   * ----------------------------------------------------------------------------- */
-  
-  typedef struct swig_globalvar {
-    char       *name;                  /* Name of global variable */
-    PyObject *(*get_attr)(void);       /* Return the current value */
-    int       (*set_attr)(PyObject *); /* Set the value */
-    struct swig_globalvar *next;
-  } swig_globalvar;
-  
-  typedef struct swig_varlinkobject {
-    PyObject_HEAD
-    swig_globalvar *vars;
-  } swig_varlinkobject;
-  
-  SWIGINTERN PyObject *
-  swig_varlink_repr(swig_varlinkobject *SWIGUNUSEDPARM(v)) {
-#if PY_VERSION_HEX >= 0x03000000
-    return PyUnicode_InternFromString("<Swig global variables>");
-#else
-    return PyString_FromString("<Swig global variables>");
-#endif
-  }
-  
-  SWIGINTERN PyObject *
-  swig_varlink_str(swig_varlinkobject *v) {
-#if PY_VERSION_HEX >= 0x03000000
-    PyObject *str = PyUnicode_InternFromString("(");
-    PyObject *tail;
-    PyObject *joined;
-    swig_globalvar *var;
-    for (var = v->vars; var; var=var->next) {
-      tail = PyUnicode_FromString(var->name);
-      joined = PyUnicode_Concat(str, tail);
-      Py_DecRef(str);
-      Py_DecRef(tail);
-      str = joined;
-      if (var->next) {
-        tail = PyUnicode_InternFromString(", ");
-        joined = PyUnicode_Concat(str, tail);
-        Py_DecRef(str);
-        Py_DecRef(tail);
-        str = joined;
-      }
-    }
-    tail = PyUnicode_InternFromString(")");
-    joined = PyUnicode_Concat(str, tail);
-    Py_DecRef(str);
-    Py_DecRef(tail);
-    str = joined;
-#else
-    PyObject *str = PyString_FromString("(");
-    swig_globalvar *var;
-    for (var = v->vars; var; var=var->next) {
-      PyString_ConcatAndDel(&str,PyString_FromString(var->name));
-      if (var->next) PyString_ConcatAndDel(&str,PyString_FromString(", "));
-    }
-    PyString_ConcatAndDel(&str,PyString_FromString(")"));
-#endif
-    return str;
-  }
-  
-  SWIGINTERN void
-  swig_varlink_dealloc(swig_varlinkobject *v) {
-    swig_globalvar *var = v->vars;
-    while (var) {
-      swig_globalvar *n = var->next;
-      free(var->name);
-      free(var);
-      var = n;
-    }
-  }
-  
-  SWIGINTERN PyObject *
-  swig_varlink_getattr(swig_varlinkobject *v, char *n) {
-    PyObject *res = NULL;
-    swig_globalvar *var = v->vars;
-    while (var) {
-      if (strcmp(var->name,n) == 0) {
-        res = (*var->get_attr)();
-        break;
-      }
-      var = var->next;
-    }
-    if (res == NULL && !PyErr_Occurred()) {
-      PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
-    }
-    return res;
-  }
-  
-  SWIGINTERN int
-  swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
-    int res = 1;
-    swig_globalvar *var = v->vars;
-    while (var) {
-      if (strcmp(var->name,n) == 0) {
-        res = (*var->set_attr)(p);
-        break;
-      }
-      var = var->next;
-    }
-    if (res == 1 && !PyErr_Occurred()) {
-      PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
-    }
-    return res;
-  }
-  
-  SWIGINTERN PyTypeObject*
-  swig_varlink_type(void) {
-    static char varlink__doc__[] = "Swig var link object";
-    static PyTypeObject varlink_type;
-    static int type_init = 0;
-    if (!type_init) {
-      const PyTypeObject tmp = {
-#if PY_VERSION_HEX >= 0x03000000
-        PyVarObject_HEAD_INIT(NULL, 0)
-#else
-        PyObject_HEAD_INIT(NULL)
-        0,                                  /* ob_size */
-#endif
-        "swigvarlink",                      /* tp_name */
-        sizeof(swig_varlinkobject),         /* tp_basicsize */
-        0,                                  /* tp_itemsize */
-        (destructor) swig_varlink_dealloc,  /* tp_dealloc */
-        0,                                  /* tp_print */
-        (getattrfunc) swig_varlink_getattr, /* tp_getattr */
-        (setattrfunc) swig_varlink_setattr, /* tp_setattr */
-        0,                                  /* tp_compare */
-        (reprfunc) swig_varlink_repr,       /* tp_repr */
-        0,                                  /* tp_as_number */
-        0,                                  /* tp_as_sequence */
-        0,                                  /* tp_as_mapping */
-        0,                                  /* tp_hash */
-        0,                                  /* tp_call */
-        (reprfunc) swig_varlink_str,        /* tp_str */
-        0,                                  /* tp_getattro */
-        0,                                  /* tp_setattro */
-        0,                                  /* tp_as_buffer */
-        0,                                  /* tp_flags */
-        varlink__doc__,                     /* tp_doc */
-        0,                                  /* tp_traverse */
-        0,                                  /* tp_clear */
-        0,                                  /* tp_richcompare */
-        0,                                  /* tp_weaklistoffset */
-        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
-        0,                                  /* tp_del */
-        0,                                  /* tp_version_tag */
-#if PY_VERSION_HEX >= 0x03040000
-        0,                                  /* tp_finalize */
-#endif
-#if PY_VERSION_HEX >= 0x03080000
-        0,                                  /* tp_vectorcall */
-#endif
-#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
-        0,                                  /* tp_print */
-#endif
-#ifdef COUNT_ALLOCS
-        0,                                  /* tp_allocs */
-        0,                                  /* tp_frees */
-        0,                                  /* tp_maxalloc */
-        0,                                  /* tp_prev */
-        0                                   /* tp_next */
-#endif
-      };
-      varlink_type = tmp;
-      type_init = 1;
-      if (PyType_Ready(&varlink_type) < 0)
-      return NULL;
-    }
-    return &varlink_type;
-  }
-  
-  /* Create a variable linking object for use later */
-  SWIGINTERN PyObject *
-  SWIG_Python_newvarlink(void) {
-    swig_varlinkobject *result = PyObject_NEW(swig_varlinkobject, swig_varlink_type());
-    if (result) {
-      result->vars = 0;
-    }
-    return ((PyObject*) result);
-  }
-  
-  SWIGINTERN void 
-  SWIG_Python_addvarlink(PyObject *p, const char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
-    swig_varlinkobject *v = (swig_varlinkobject *) p;
-    swig_globalvar *gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
-    if (gv) {
-      size_t size = strlen(name)+1;
-      gv->name = (char *)malloc(size);
-      if (gv->name) {
-        memcpy(gv->name, name, size);
-        gv->get_attr = get_attr;
-        gv->set_attr = set_attr;
-        gv->next = v->vars;
-      }
-    }
-    v->vars = gv;
-  }
-  
-  SWIGINTERN PyObject *
-  SWIG_globals(void) {
-    static PyObject *globals = 0;
-    if (!globals) {
-      globals = SWIG_newvarlink();
-    }
-    return globals;
-  }
-  
   /* -----------------------------------------------------------------------------
    * constants/methods manipulation
    * ----------------------------------------------------------------------------- */
   
   /* Install Constants */
   SWIGINTERN void
   SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
@@ -6612,31 +6679,28 @@
       if (obj) {
         PyDict_SetItemString(d, constants[i].name, obj);
         Py_DECREF(obj);
       }
     }
   }
   
-  /* -----------------------------------------------------------------------------*/
-  /* Fix SwigMethods to carry the callback ptrs when needed */
-  /* -----------------------------------------------------------------------------*/
+  /* -----------------------------------------------------------------------------
+   * Patch %callback methods' docstrings to hold the callback ptrs
+   * -----------------------------------------------------------------------------*/
   
   SWIGINTERN void
-  SWIG_Python_FixMethods(PyMethodDef *methods,
-    swig_const_info *const_table,
-    swig_type_info **types,
-    swig_type_info **types_initial) {
+  SWIG_Python_FixMethods(PyMethodDef *methods, const swig_const_info *const_table, swig_type_info **types, swig_type_info **types_initial) {
     size_t i;
     for (i = 0; methods[i].ml_name; ++i) {
       const char *c = methods[i].ml_doc;
       if (!c) continue;
       c = strstr(c, "swig_ptr: ");
       if (c) {
         int j;
-        swig_const_info *ci = 0;
+        const swig_const_info *ci = 0;
         const char *name = c + 10;
         for (j = 0; const_table[j].type; ++j) {
           if (strncmp(const_table[j].name, name, 
               strlen(const_table[j].name)) == 0) {
             ci = &(const_table[j]);
             break;
           }
@@ -6660,76 +6724,21 @@
             }
           }
         }
       }
     }
   } 
   
-  /* -----------------------------------------------------------------------------
-   * Method creation and docstring support functions
-   * ----------------------------------------------------------------------------- */
-  
-  /* -----------------------------------------------------------------------------
-   * Function to find the method definition with the correct docstring for the
-   * proxy module as opposed to the low-level API
-   * ----------------------------------------------------------------------------- */
-  
-  SWIGINTERN PyMethodDef *SWIG_PythonGetProxyDoc(const char *name) {
-    /* Find the function in the modified method table */
-    size_t offset = 0;
-    int found = 0;
-    while (SwigMethods_proxydocs[offset].ml_meth != NULL) {
-      if (strcmp(SwigMethods_proxydocs[offset].ml_name, name) == 0) {
-        found = 1;
-        break;
-      }
-      offset++;
-    }
-    /* Use the copy with the modified docstring if available */
-    return found ? &SwigMethods_proxydocs[offset] : NULL;
-  }
-  
-  /* -----------------------------------------------------------------------------
-   * Wrapper of PyInstanceMethod_New() used in Python 3
-   * It is exported to the generated module, used for -fastproxy
-   * ----------------------------------------------------------------------------- */
-  
-  SWIGINTERN PyObject *SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func) {
-    if (PyCFunction_Check(func)) {
-      PyCFunctionObject *funcobj = (PyCFunctionObject *)func;
-      PyMethodDef *ml = SWIG_PythonGetProxyDoc(funcobj->m_ml->ml_name);
-      if (ml)
-      func = PyCFunction_NewEx(ml, funcobj->m_self, funcobj->m_module);
-    }
-#if PY_VERSION_HEX >= 0x03000000
-    return PyInstanceMethod_New(func);
-#else
-    return PyMethod_New(func, NULL, NULL);
-#endif
-  }
-  
-  /* -----------------------------------------------------------------------------
-   * Wrapper of PyStaticMethod_New()
-   * It is exported to the generated module, used for -fastproxy
-   * ----------------------------------------------------------------------------- */
-  
-  SWIGINTERN PyObject *SWIG_PyStaticMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func) {
-    if (PyCFunction_Check(func)) {
-      PyCFunctionObject *funcobj = (PyCFunctionObject *)func;
-      PyMethodDef *ml = SWIG_PythonGetProxyDoc(funcobj->m_ml->ml_name);
-      if (ml)
-      func = PyCFunction_NewEx(ml, funcobj->m_self, funcobj->m_module);
-    }
-    return PyStaticMethod_New(func);
-  }
-  
 #ifdef __cplusplus
 }
 #endif
 
+
+
+
 /* -----------------------------------------------------------------------------*
  *  Partial Init method
  * -----------------------------------------------------------------------------*/
 
 #ifdef __cplusplus
 extern "C"
 #endif
```

### Comparing `gphoto2-2.3.4/src/swig-gp2.5.30/file_wrap.c` & `gphoto2-2.3.5/src/swig-gp2_5_30/file_wrap.c`

 * *Files 4% similar despite different names*

```diff
@@ -1,25 +1,22 @@
 /* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 4.0.2
+ * This file was automatically generated by SWIG (https://www.swig.org).
+ * Version 4.1.1
  *
- * This file is not intended to be easily readable and contains a number of
- * coding conventions designed to improve portability and efficiency. Do not make
- * changes to this file unless you know what you are doing--modify the SWIG
- * interface file instead.
+ * Do not make changes to this file unless you know what you are doing - modify
+ * the SWIG interface file instead.
  * ----------------------------------------------------------------------------- */
 
 
-#ifndef SWIGPYTHON
+#define SWIG_VERSION 0x040101
 #define SWIGPYTHON
-#endif
-
 #define SWIG_PYTHON_THREADS
 #define SWIG_PYTHON_DIRECTOR_NO_VTABLE
 #define SWIGPYTHON_BUILTIN
+#define SWIGPYTHON_FASTPROXY
 
 /* -----------------------------------------------------------------------------
  *  This section contains generic SWIG labels for method/variable
  *  declarations/attributes, and other compiler dependent labels.
  * ----------------------------------------------------------------------------- */
 
 /* template workaround for compilers that cannot correctly implement the C++ standard */
@@ -143,23 +140,45 @@
 
 
 #if defined(__GNUC__) && defined(_WIN32) && !defined(SWIG_PYTHON_NO_HYPOT_WORKAROUND)
 /* Workaround for '::hypot' has not been declared', see https://bugs.python.org/issue11566 */
 # include <math.h>
 #endif
 
+#if !defined(PY_SSIZE_T_CLEAN) && !defined(SWIG_NO_PY_SSIZE_T_CLEAN)
+#define PY_SSIZE_T_CLEAN
+#endif
+
+#if __GNUC__ >= 7
+#pragma GCC diagnostic push
+#if defined(__cplusplus) && __cplusplus >=201703L
+#pragma GCC diagnostic ignored "-Wregister" /* For python-2.7 headers that use register */
+#endif
+#endif
+
 #if defined(_DEBUG) && defined(SWIG_PYTHON_INTERPRETER_NO_DEBUG)
 /* Use debug wrappers with the Python release dll */
+
+#if defined(_MSC_VER) && _MSC_VER >= 1929
+/* Workaround compilation errors when redefining _DEBUG in MSVC 2019 version 16.10 and later
+ * See https://github.com/swig/swig/issues/2090 */
+# include <corecrt.h>
+#endif
+
 # undef _DEBUG
 # include <Python.h>
 # define _DEBUG 1
 #else
 # include <Python.h>
 #endif
 
+#if __GNUC__ >= 7
+#pragma GCC diagnostic pop
+#endif
+
 /* -----------------------------------------------------------------------------
  * swigrun.swg
  *
  * This file contains generic C API SWIG runtime support for pointer
  * type checking.
  * ----------------------------------------------------------------------------- */
 
@@ -198,14 +217,16 @@
 # define SWIG_BUFFER_SIZE 1024
 #endif
 
 /* Flags for pointer conversions */
 #define SWIG_POINTER_DISOWN        0x1
 #define SWIG_CAST_NEW_MEMORY       0x2
 #define SWIG_POINTER_NO_NULL       0x4
+#define SWIG_POINTER_CLEAR         0x8
+#define SWIG_POINTER_RELEASE       (SWIG_POINTER_CLEAR | SWIG_POINTER_DISOWN)
 
 /* Flags for new pointer objects */
 #define SWIG_POINTER_OWN           0x1
 
 
 /*
    Flags/methods for returning states.
@@ -269,44 +290,50 @@
       }
 
    Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
    more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
    SWIG errors code.
 
    Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
-   allows to return the 'cast rank', for example, if you have this
+   allows returning the 'cast rank', for example, if you have this
 
        int food(double)
        int fooi(int);
 
    and you call
 
       food(1)   // cast rank '1'  (1 -> 1.0)
       fooi(1)   // cast rank '0'
 
    just use the SWIG_AddCast()/SWIG_CheckState()
 */
 
 #define SWIG_OK                    (0)
+/* Runtime errors are < 0 */
 #define SWIG_ERROR                 (-1)
+/* Errors in range -1 to -99 are in swigerrors.swg (errors for all languages including those not using the runtime) */
+/* Errors in range -100 to -199 are language specific errors defined in *errors.swg */
+/* Errors < -200 are generic runtime specific errors */
+#define SWIG_ERROR_RELEASE_NOT_OWNED (-200)
+
 #define SWIG_IsOK(r)               (r >= 0)
 #define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)
 
 /* The CastRankLimit says how many bits are used for the cast rank */
 #define SWIG_CASTRANKLIMIT         (1 << 8)
 /* The NewMask denotes the object was created (using new/malloc) */
 #define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
 /* The TmpMask is for in/out typemaps that use temporal objects */
 #define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
 /* Simple returning values */
 #define SWIG_BADOBJ                (SWIG_ERROR)
 #define SWIG_OLDOBJ                (SWIG_OK)
 #define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
 #define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
-/* Check, add and del mask methods */
+/* Check, add and del object mask methods */
 #define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
 #define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
 #define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
 #define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
 #define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
 #define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))
 
@@ -444,15 +471,15 @@
   return 0;
 }
 
 /*
   Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
 */
 SWIGRUNTIME swig_cast_info *
-SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty) {
+SWIG_TypeCheckStruct(const swig_type_info *from, swig_type_info *ty) {
   if (ty) {
     swig_cast_info *iter = ty->cast;
     while (iter) {
       if (iter->type == from) {
         if (iter == ty->cast)
           return iter;
         /* Move iter to the top of the linked list */
@@ -504,17 +531,17 @@
 /*
   Return the pretty name associated with this type,
   that is an unmangled type name in a form presentable to the user.
 */
 SWIGRUNTIME const char *
 SWIG_TypePrettyName(const swig_type_info *type) {
   /* The "str" field contains the equivalent pretty names of the
-     type, separated by vertical-bar characters.  We choose
-     to print the last name, as it is often (?) the most
-     specific. */
+     type, separated by vertical-bar characters.  Choose the last
+     name. It should be the most specific; a fully resolved name
+     but not necessarily with default template parameters expanded. */
   if (!type) return NULL;
   if (type->str != NULL) {
     const char *last_name = type->str;
     const char *s;
     for (s = type->str; *s; s++)
       if (*s == '|') last_name = s+1;
     return last_name;
@@ -726,15 +753,15 @@
   return SWIG_UnpackData(++c,ptr,sz);
 }
 
 #ifdef __cplusplus
 }
 #endif
 
-/*  Errors in SWIG */
+/* SWIG Errors applicable to all language modules, values are reserved from -1 to -99 */
 #define  SWIG_UnknownError    	   -1
 #define  SWIG_IOError        	   -2
 #define  SWIG_RuntimeError   	   -3
 #define  SWIG_IndexError     	   -4
 #define  SWIG_TypeError      	   -5
 #define  SWIG_DivisionByZero 	   -6
 #define  SWIG_OverflowError  	   -7
@@ -742,15 +769,14 @@
 #define  SWIG_ValueError     	   -9
 #define  SWIG_SystemError    	   -10
 #define  SWIG_AttributeError 	   -11
 #define  SWIG_MemoryError    	   -12
 #define  SWIG_NullReferenceError   -13
 
 
-
 /* Compatibility macros for Python 3 */
 #if PY_VERSION_HEX >= 0x03000000
 
 #define PyClass_Check(obj) PyObject_IsInstance(obj, (PyObject *)&PyType_Type)
 #define PyInt_Check(x) PyLong_Check(x)
 #define PyInt_AsLong(x) PyLong_AsLong(x)
 #define PyInt_FromLong(x) PyLong_FromLong(x)
@@ -758,15 +784,14 @@
 #define PyString_Check(name) PyBytes_Check(name)
 #define PyString_FromString(x) PyUnicode_FromString(x)
 #define PyString_Format(fmt, args)  PyUnicode_Format(fmt, args)
 #define PyString_AsString(str) PyBytes_AsString(str)
 #define PyString_Size(str) PyBytes_Size(str)	
 #define PyString_InternFromString(key) PyUnicode_InternFromString(key)
 #define Py_TPFLAGS_HAVE_CLASS Py_TPFLAGS_BASETYPE
-#define PyString_AS_STRING(x) PyUnicode_AS_STRING(x)
 #define _PyLong_FromSsize_t(x) PyLong_FromSsize_t(x)
 
 #endif
 
 #ifndef Py_TYPE
 #  define Py_TYPE(op) ((op)->ob_type)
 #endif
@@ -776,46 +801,27 @@
 #if PY_VERSION_HEX >= 0x03000000
 #  define SWIG_Python_str_FromFormat PyUnicode_FromFormat
 #else
 #  define SWIG_Python_str_FromFormat PyString_FromFormat
 #endif
 
 
-/* Warning: This function will allocate a new string in Python 3,
- * so please call SWIG_Python_str_DelForPy3(x) to free the space.
- */
 SWIGINTERN char*
 SWIG_Python_str_AsChar(PyObject *str)
 {
 #if PY_VERSION_HEX >= 0x03030000
   return (char *)PyUnicode_AsUTF8(str);
-#elif PY_VERSION_HEX >= 0x03000000
-  char *newstr = 0;
-  str = PyUnicode_AsUTF8String(str);
-  if (str) {
-    char *cstr;
-    Py_ssize_t len;
-    if (PyBytes_AsStringAndSize(str, &cstr, &len) != -1) {
-      newstr = (char *) malloc(len+1);
-      if (newstr)
-        memcpy(newstr, cstr, len+1);
-    }
-    Py_XDECREF(str);
-  }
-  return newstr;
 #else
   return PyString_AsString(str);
 #endif
 }
 
-#if PY_VERSION_HEX >= 0x03030000 || PY_VERSION_HEX < 0x03000000
-#  define SWIG_Python_str_DelForPy3(x)
-#else
-#  define SWIG_Python_str_DelForPy3(x) free( (void*) (x) )
-#endif
+/* Was useful for Python 3.0.x-3.2.x - now provided only for compatibility
+ * with any uses in user interface files. */
+#define SWIG_Python_str_DelForPy3(x)
 
 
 SWIGINTERN PyObject*
 SWIG_Python_str_FromChar(const char *c)
 {
 #if PY_VERSION_HEX >= 0x03000000
   return PyUnicode_FromString(c); 
@@ -824,18 +830,22 @@
 #endif
 }
 
 #ifndef PyObject_DEL
 # define PyObject_DEL PyObject_Del
 #endif
 
-// SWIGPY_USE_CAPSULE is no longer used within SWIG itself, but some user
-// interface files check for it.
+/* SWIGPY_USE_CAPSULE is no longer used within SWIG itself, but some user interface files check for it. */
 # define SWIGPY_USE_CAPSULE
-# define SWIGPY_CAPSULE_NAME ("swig_runtime_data" SWIG_RUNTIME_VERSION ".type_pointer_capsule" SWIG_TYPE_TABLE_NAME)
+#ifdef SWIGPYTHON_BUILTIN
+# define SWIGPY_CAPSULE_ATTR_NAME "type_pointer_capsule_builtin" SWIG_TYPE_TABLE_NAME
+#else
+# define SWIGPY_CAPSULE_ATTR_NAME "type_pointer_capsule" SWIG_TYPE_TABLE_NAME
+#endif
+# define SWIGPY_CAPSULE_NAME ("swig_runtime_data" SWIG_RUNTIME_VERSION "." SWIGPY_CAPSULE_ATTR_NAME)
 
 #if PY_VERSION_HEX < 0x03020000
 #define PyDescr_TYPE(x) (((PyDescrObject *)(x))->d_type)
 #define PyDescr_NAME(x) (((PyDescrObject *)(x))->d_name)
 #define Py_hash_t long
 #endif
 
@@ -901,15 +911,14 @@
     const char *tmp = SWIG_Python_str_AsChar(old_str);
     PyErr_Clear();
     Py_XINCREF(type);
     if (tmp)
       PyErr_Format(type, "%s %s", tmp, mesg);
     else
       PyErr_Format(type, "%s", mesg);
-    SWIG_Python_str_DelForPy3(tmp);
     Py_DECREF(old_str);
     Py_DECREF(value);
   } else {
     PyErr_SetString(PyExc_RuntimeError, mesg);
   }
 }
 
@@ -932,16 +941,20 @@
     PyObject *type = NULL, *value = NULL, *traceback = NULL;
     PyErr_Fetch(&type, &value, &traceback);
 #if PY_VERSION_HEX >= 0x03000000
     newvalue = PyUnicode_FromFormat("%S\nAdditional information:\n%s", value, message);
 #else
     newvalue = PyString_FromFormat("%s\nAdditional information:\n%s", PyString_AsString(value), message);
 #endif
-    Py_XDECREF(value);
-    PyErr_Restore(type, newvalue, traceback);
+    if (newvalue) {
+      Py_XDECREF(value);
+      PyErr_Restore(type, newvalue, traceback);
+    } else {
+      PyErr_Restore(type, value, traceback);
+    }
   } else {
     /* Raise TypeError using given message */
     PyErr_SetString(PyExc_TypeError, message);
   }
 }
 
 #if defined(SWIG_PYTHON_NO_THREADS)
@@ -950,16 +963,20 @@
 #  endif
 #endif
 #if defined(SWIG_PYTHON_THREADS) /* Threading support is enabled */
 #  if !defined(SWIG_PYTHON_USE_GIL) && !defined(SWIG_PYTHON_NO_USE_GIL)
 #    define SWIG_PYTHON_USE_GIL
 #  endif
 #  if defined(SWIG_PYTHON_USE_GIL) /* Use PyGILState threads calls */
-#    ifndef SWIG_PYTHON_INITIALIZE_THREADS
-#     define SWIG_PYTHON_INITIALIZE_THREADS  PyEval_InitThreads() 
+#    if !defined(SWIG_PYTHON_INITIALIZE_THREADS)
+#      if PY_VERSION_HEX < 0x03070000
+#        define SWIG_PYTHON_INITIALIZE_THREADS PyEval_InitThreads()
+#      else
+#        define SWIG_PYTHON_INITIALIZE_THREADS
+#      endif
 #    endif
 #    ifdef __cplusplus /* C++ code */
        class SWIG_Python_Thread_Block {
          bool status;
          PyGILState_STATE state;
        public:
          void end() { if (status) { PyGILState_Release(state); status = false;} }
@@ -1049,16 +1066,16 @@
  *
  * ----------------------------------------------------------------------------- */
 
 #if PY_VERSION_HEX < 0x02070000 /* 2.7.0 */
 # error "This version of SWIG only supports Python >= 2.7"
 #endif
 
-#if PY_VERSION_HEX >= 0x03000000 && PY_VERSION_HEX < 0x03020000
-# error "This version of SWIG only supports Python 3 >= 3.2"
+#if PY_VERSION_HEX >= 0x03000000 && PY_VERSION_HEX < 0x03030000
+# error "This version of SWIG only supports Python 3 >= 3.3"
 #endif
 
 /* Common SWIG API */
 
 /* for raw pointers */
 #define SWIG_Python_ConvertPtr(obj, pptr, type, flags)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, 0)
 #define SWIG_ConvertPtr(obj, pptr, type, flags)         SWIG_Python_ConvertPtr(obj, pptr, type, flags)
@@ -1165,15 +1182,20 @@
   } else if (result == Py_None) {
     Py_DECREF(result);
     result = obj;
   } else {
     if (!PyList_Check(result)) {
       PyObject *o2 = result;
       result = PyList_New(1);
-      PyList_SetItem(result, 0, o2);
+      if (result) {
+        PyList_SET_ITEM(result, 0, o2);
+      } else {
+        Py_DECREF(obj);
+        return o2;
+      }
     }
     PyList_Append(result,obj);
     Py_DECREF(obj);
   }
   return result;
 }
 
@@ -1247,14 +1269,246 @@
 */
 #ifdef __cplusplus
 #define SWIG_STATIC_POINTER(var)  var
 #else
 #define SWIG_STATIC_POINTER(var)  var = 0; if (!var) var
 #endif
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Python-specific SWIG API */
+#define SWIG_newvarlink()                             SWIG_Python_newvarlink()
+#define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
+#define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)
+ 
+/* -----------------------------------------------------------------------------
+ * global variable support code.
+ * ----------------------------------------------------------------------------- */
+ 
+typedef struct swig_globalvar {   
+  char       *name;                  /* Name of global variable */
+  PyObject *(*get_attr)(void);       /* Return the current value */
+  int       (*set_attr)(PyObject *); /* Set the value */
+  struct swig_globalvar *next;
+} swig_globalvar;
+
+typedef struct swig_varlinkobject {
+  PyObject_HEAD
+  swig_globalvar *vars;
+} swig_varlinkobject;
+
+SWIGINTERN PyObject *
+swig_varlink_repr(PyObject *SWIGUNUSEDPARM(v)) {
+#if PY_VERSION_HEX >= 0x03000000
+  return PyUnicode_InternFromString("<Swig global variables>");
+#else
+  return PyString_FromString("<Swig global variables>");
+#endif
+}
+
+SWIGINTERN PyObject *
+swig_varlink_str(PyObject *o) {
+  swig_varlinkobject *v = (swig_varlinkobject *) o;
+#if PY_VERSION_HEX >= 0x03000000
+  PyObject *str = PyUnicode_InternFromString("(");
+  PyObject *tail;
+  PyObject *joined;
+  swig_globalvar *var;
+  for (var = v->vars; var; var=var->next) {
+    tail = PyUnicode_FromString(var->name);
+    joined = PyUnicode_Concat(str, tail);
+    Py_DecRef(str);
+    Py_DecRef(tail);
+    str = joined;
+    if (var->next) {
+        tail = PyUnicode_InternFromString(", ");
+        joined = PyUnicode_Concat(str, tail);
+        Py_DecRef(str);
+        Py_DecRef(tail);
+        str = joined;
+    }
+  }
+  tail = PyUnicode_InternFromString(")");
+  joined = PyUnicode_Concat(str, tail);
+  Py_DecRef(str);
+  Py_DecRef(tail);
+  str = joined;
+#else
+  PyObject *str = PyString_FromString("(");
+  swig_globalvar *var;
+  for (var = v->vars; var; var=var->next) {
+    PyString_ConcatAndDel(&str,PyString_FromString(var->name));
+    if (var->next) PyString_ConcatAndDel(&str,PyString_FromString(", "));
+  }
+  PyString_ConcatAndDel(&str,PyString_FromString(")"));
+#endif
+  return str;
+}
+
+SWIGINTERN void
+swig_varlink_dealloc(PyObject *o) {
+  swig_varlinkobject *v = (swig_varlinkobject *) o;
+  swig_globalvar *var = v->vars;
+  while (var) {
+    swig_globalvar *n = var->next;
+    free(var->name);
+    free(var);
+    var = n;
+  }
+}
+
+SWIGINTERN PyObject *
+swig_varlink_getattr(PyObject *o, char *n) {
+  swig_varlinkobject *v = (swig_varlinkobject *) o;
+  PyObject *res = NULL;
+  swig_globalvar *var = v->vars;
+  while (var) {
+    if (strcmp(var->name,n) == 0) {
+      res = (*var->get_attr)();
+      break;
+    }
+    var = var->next;
+  }
+  if (res == NULL && !PyErr_Occurred()) {
+    PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
+  }
+  return res;
+}
+
+SWIGINTERN int
+swig_varlink_setattr(PyObject *o, char *n, PyObject *p) {
+  swig_varlinkobject *v = (swig_varlinkobject *) o;
+  int res = 1;
+  swig_globalvar *var = v->vars;
+  while (var) {
+    if (strcmp(var->name,n) == 0) {
+      res = (*var->set_attr)(p);
+      break;
+    }
+    var = var->next;
+  }
+  if (res == 1 && !PyErr_Occurred()) {
+    PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
+  }
+  return res;
+}
+
+SWIGINTERN PyTypeObject*
+swig_varlink_type(void) {
+  static char varlink__doc__[] = "Swig var link object";
+  static PyTypeObject varlink_type;
+  static int type_init = 0;
+  if (!type_init) {
+    const PyTypeObject tmp = {
+#if PY_VERSION_HEX >= 0x03000000
+      PyVarObject_HEAD_INIT(NULL, 0)
+#else
+      PyObject_HEAD_INIT(NULL)
+      0,                                  /* ob_size */
+#endif
+      "swigvarlink",                      /* tp_name */
+      sizeof(swig_varlinkobject),         /* tp_basicsize */
+      0,                                  /* tp_itemsize */
+      (destructor) swig_varlink_dealloc,  /* tp_dealloc */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                       /*tp_print*/
+#else
+      (Py_ssize_t)0,                      /*tp_vectorcall_offset*/
+#endif
+      (getattrfunc) swig_varlink_getattr, /* tp_getattr */
+      (setattrfunc) swig_varlink_setattr, /* tp_setattr */
+      0,                                  /* tp_compare */
+      (reprfunc) swig_varlink_repr,       /* tp_repr */
+      0,                                  /* tp_as_number */
+      0,                                  /* tp_as_sequence */
+      0,                                  /* tp_as_mapping */
+      0,                                  /* tp_hash */
+      0,                                  /* tp_call */
+      (reprfunc) swig_varlink_str,        /* tp_str */
+      0,                                  /* tp_getattro */
+      0,                                  /* tp_setattro */
+      0,                                  /* tp_as_buffer */
+      0,                                  /* tp_flags */
+      varlink__doc__,                     /* tp_doc */
+      0,                                  /* tp_traverse */
+      0,                                  /* tp_clear */
+      0,                                  /* tp_richcompare */
+      0,                                  /* tp_weaklistoffset */
+      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
+      0,                                  /* tp_del */
+      0,                                  /* tp_version_tag */
+#if PY_VERSION_HEX >= 0x03040000
+      0,                                  /* tp_finalize */
+#endif
+#if PY_VERSION_HEX >= 0x03080000
+      0,                                  /* tp_vectorcall */
+#endif
+#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
+      0,                                  /* tp_print */
+#endif
+#ifdef COUNT_ALLOCS
+      0,                                  /* tp_allocs */
+      0,                                  /* tp_frees */
+      0,                                  /* tp_maxalloc */
+      0,                                  /* tp_prev */
+      0                                   /* tp_next */
+#endif
+    };
+    varlink_type = tmp;
+    type_init = 1;
+    if (PyType_Ready(&varlink_type) < 0)
+      return NULL;
+  }
+  return &varlink_type;
+}
+
+/* Create a variable linking object for use later */
+SWIGINTERN PyObject *
+SWIG_Python_newvarlink(void) {
+  swig_varlinkobject *result = PyObject_NEW(swig_varlinkobject, swig_varlink_type());
+  if (result) {
+    result->vars = 0;
+  }
+  return ((PyObject*) result);
+}
+
+SWIGINTERN void 
+SWIG_Python_addvarlink(PyObject *p, const char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
+  swig_varlinkobject *v = (swig_varlinkobject *) p;
+  swig_globalvar *gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
+  if (gv) {
+    size_t size = strlen(name)+1;
+    gv->name = (char *)malloc(size);
+    if (gv->name) {
+      memcpy(gv->name, name, size);
+      gv->get_attr = get_attr;
+      gv->set_attr = set_attr;
+      gv->next = v->vars;
+    }
+  }
+  v->vars = gv;
+}
+
+
+static PyObject *Swig_Globals_global = NULL;
+  
+SWIGINTERN PyObject *
+SWIG_globals(void) {
+  if (Swig_Globals_global == NULL) {
+    Swig_Globals_global = SWIG_newvarlink();
+  }
+  return Swig_Globals_global;
+}
+
+#ifdef __cplusplus
+}
+#endif
+
 /* -----------------------------------------------------------------------------
  * Pointer declarations
  * ----------------------------------------------------------------------------- */
 
 /* Flags for new pointer objects */
 #define SWIG_POINTER_NOSHADOW       (SWIG_POINTER_OWN      << 1)
 #define SWIG_POINTER_NEW            (SWIG_POINTER_NOSHADOW | SWIG_POINTER_OWN)
@@ -1317,52 +1571,59 @@
     SwigPyClientData *data = (SwigPyClientData *)malloc(sizeof(SwigPyClientData));
     /* the klass element */
     data->klass = obj;
     Py_INCREF(data->klass);
     /* the newraw method and newargs arguments used to create a new raw instance */
     if (PyClass_Check(obj)) {
       data->newraw = 0;
-      data->newargs = obj;
       Py_INCREF(obj);
+      data->newargs = obj;
     } else {
       data->newraw = PyObject_GetAttrString(data->klass, "__new__");
       if (data->newraw) {
-	Py_INCREF(data->newraw);
-	data->newargs = PyTuple_New(1);
-	PyTuple_SetItem(data->newargs, 0, obj);
+        data->newargs = PyTuple_New(1);
+        if (data->newargs) {
+          Py_INCREF(obj);
+          PyTuple_SET_ITEM(data->newargs, 0, obj);
+        } else {
+          Py_DECREF(data->newraw);
+          Py_DECREF(data->klass);
+          free(data);
+          return 0;
+        }
       } else {
-	data->newargs = obj;
+        Py_INCREF(obj);
+        data->newargs = obj;
       }
-      Py_INCREF(data->newargs);
     }
     /* the destroy method, aka as the C++ delete method */
     data->destroy = PyObject_GetAttrString(data->klass, "__swig_destroy__");
     if (PyErr_Occurred()) {
       PyErr_Clear();
       data->destroy = 0;
     }
     if (data->destroy) {
-      int flags;
-      Py_INCREF(data->destroy);
-      flags = PyCFunction_GET_FLAGS(data->destroy);
-      data->delargs = !(flags & (METH_O));
+      data->delargs = !(PyCFunction_GET_FLAGS(data->destroy) & METH_O);
     } else {
       data->delargs = 0;
     }
     data->implicitconv = 0;
     data->pytype = 0;
     return data;
   }
 }
 
 SWIGRUNTIME void 
-SwigPyClientData_Del(SwigPyClientData *data) {
+SwigPyClientData_Del(SwigPyClientData *data)
+{
+  Py_XDECREF(data->klass);
   Py_XDECREF(data->newraw);
   Py_XDECREF(data->newargs);
   Py_XDECREF(data->destroy);
+  free(data);
 }
 
 /* =============== SwigPyObject =====================*/
 
 typedef struct {
   PyObject_HEAD
   void *ptr;
@@ -1381,15 +1642,15 @@
 SwigPyObject_get___dict__(PyObject *v, PyObject *SWIGUNUSEDPARM(args))
 {
   SwigPyObject *sobj = (SwigPyObject *)v;
 
   if (!sobj->dict)
     sobj->dict = PyDict_New();
 
-  Py_INCREF(sobj->dict);
+  Py_XINCREF(sobj->dict);
   return sobj->dict;
 }
 
 #endif
 
 SWIGRUNTIME PyObject *
 SwigPyObject_long(SwigPyObject *v)
@@ -1399,26 +1660,29 @@
 
 SWIGRUNTIME PyObject *
 SwigPyObject_format(const char* fmt, SwigPyObject *v)
 {
   PyObject *res = NULL;
   PyObject *args = PyTuple_New(1);
   if (args) {
-    if (PyTuple_SetItem(args, 0, SwigPyObject_long(v)) == 0) {
-      PyObject *ofmt = SWIG_Python_str_FromChar(fmt);
+    PyObject *val = SwigPyObject_long(v);
+    if (val) {
+      PyObject *ofmt;
+      PyTuple_SET_ITEM(args, 0, val);
+      ofmt = SWIG_Python_str_FromChar(fmt);
       if (ofmt) {
 #if PY_VERSION_HEX >= 0x03000000
-	res = PyUnicode_Format(ofmt,args);
+        res = PyUnicode_Format(ofmt,args);
 #else
-	res = PyString_Format(ofmt,args);
+        res = PyString_Format(ofmt,args);
 #endif
-	Py_DECREF(ofmt);
+        Py_DECREF(ofmt);
       }
-      Py_DECREF(args);
     }
+    Py_DECREF(args);
   }
   return res;
 }
 
 SWIGRUNTIME PyObject *
 SwigPyObject_oct(SwigPyObject *v)
 {
@@ -1432,26 +1696,31 @@
 }
 
 SWIGRUNTIME PyObject *
 SwigPyObject_repr(SwigPyObject *v)
 {
   const char *name = SWIG_TypePrettyName(v->ty);
   PyObject *repr = SWIG_Python_str_FromFormat("<Swig Object of type '%s' at %p>", (name ? name : "unknown"), (void *)v);
-  if (v->next) {
+  if (repr && v->next) {
     PyObject *nrep = SwigPyObject_repr((SwigPyObject *)v->next);
+    if (nrep) {
 # if PY_VERSION_HEX >= 0x03000000
-    PyObject *joined = PyUnicode_Concat(repr, nrep);
-    Py_DecRef(repr);
-    Py_DecRef(nrep);
-    repr = joined;
+      PyObject *joined = PyUnicode_Concat(repr, nrep);
+      Py_DecRef(repr);
+      Py_DecRef(nrep);
+      repr = joined;
 # else
-    PyString_ConcatAndDel(&repr,nrep);
+      PyString_ConcatAndDel(&repr,nrep);
 # endif
+    } else {
+      Py_DecRef(repr);
+      repr = NULL;
+    }
   }
-  return repr;  
+  return repr;
 }
 
 /* We need a version taking two PyObject* parameters so it's a valid
  * PyCFunction to use in swigobject_methods[]. */
 SWIGRUNTIME PyObject *
 SwigPyObject_repr2(PyObject *v, PyObject *SWIGUNUSEDPARM(args))
 {
@@ -1513,14 +1782,16 @@
     || (strcmp(Py_TYPE(op)->tp_name,"SwigPyObject") == 0);
 #endif
 }
 
 SWIGRUNTIME PyObject *
 SwigPyObject_New(void *ptr, swig_type_info *ty, int own);
 
+static PyObject* Swig_Capsule_global = NULL;
+
 SWIGRUNTIME void
 SwigPyObject_dealloc(PyObject *v)
 {
   SwigPyObject *sobj = (SwigPyObject *) v;
   PyObject *next = sobj->next;
   if (sobj->own == SWIG_POINTER_OWN) {
     swig_type_info *ty = sobj->ty;
@@ -1539,16 +1810,20 @@
       
       PyObject *type = NULL, *value = NULL, *traceback = NULL;
       PyErr_Fetch(&type, &value, &traceback);
 
       if (data->delargs) {
         /* we need to create a temporary object to carry the destroy operation */
         PyObject *tmp = SwigPyObject_New(sobj->ptr, ty, 0);
-        res = SWIG_Python_CallFunctor(destroy, tmp);
-        Py_DECREF(tmp);
+        if (tmp) {
+          res = SWIG_Python_CallFunctor(destroy, tmp);
+        } else {
+          res = 0;
+        }
+        Py_XDECREF(tmp);
       } else {
         PyCFunction meth = PyCFunction_GET_FUNCTION(destroy);
         PyObject *mself = PyCFunction_GET_SELF(destroy);
         res = ((*meth)(mself, v));
       }
       if (!res)
         PyErr_WriteUnraisable(destroy);
@@ -1559,27 +1834,32 @@
     } 
 #if !defined(SWIG_PYTHON_SILENT_MEMLEAK)
     else {
       const char *name = SWIG_TypePrettyName(ty);
       printf("swig/python detected a memory leak of type '%s', no destructor found.\n", (name ? name : "unknown"));
     }
 #endif
-  } 
+    Py_XDECREF(Swig_Capsule_global);
+  }
   Py_XDECREF(next);
+#ifdef SWIGPYTHON_BUILTIN
+  Py_XDECREF(sobj->dict);
+#endif
   PyObject_DEL(v);
 }
 
 SWIGRUNTIME PyObject* 
 SwigPyObject_append(PyObject* v, PyObject* next)
 {
   SwigPyObject *sobj = (SwigPyObject *) v;
   if (!SwigPyObject_Check(next)) {
     PyErr_SetString(PyExc_TypeError, "Attempt to append a non SwigPyObject");
     return NULL;
   }
+  ((SwigPyObject *)next)->next = sobj->next;
   sobj->next = next;
   Py_INCREF(next);
   return SWIG_Py_Void();
 }
 
 SWIGRUNTIME PyObject* 
 SwigPyObject_next(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
@@ -1616,17 +1896,17 @@
   if (!PyArg_UnpackTuple(args, "own", 0, 1, &val)) {
     return NULL;
   } else {
     SwigPyObject *sobj = (SwigPyObject *)v;
     PyObject *obj = PyBool_FromLong(sobj->own);
     if (val) {
       if (PyObject_IsTrue(val)) {
-        SwigPyObject_acquire(v,args);
+        Py_DECREF(SwigPyObject_acquire(v,args));
       } else {
-        SwigPyObject_disown(v,args);
+        Py_DECREF(SwigPyObject_disown(v,args));
       }
     } 
     return obj;
   }
 }
 
 static PyMethodDef
@@ -1698,15 +1978,19 @@
       PyObject_HEAD_INIT(NULL)
       0,                                    /* ob_size */
 #endif
       "SwigPyObject",                       /* tp_name */
       sizeof(SwigPyObject),                 /* tp_basicsize */
       0,                                    /* tp_itemsize */
       (destructor)SwigPyObject_dealloc,     /* tp_dealloc */
-      0,                                    /* tp_print */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                         /*tp_print*/
+#else
+      (Py_ssize_t)0,                        /*tp_vectorcall_offset*/
+#endif
       (getattrfunc)0,                       /* tp_getattr */
       (setattrfunc)0,                       /* tp_setattr */
 #if PY_VERSION_HEX >= 0x03000000
       0, /* tp_reserved in 3.0.1, tp_compare in 3.0.0 but not used */
 #else
       (cmpfunc)SwigPyObject_compare,        /* tp_compare */
 #endif
@@ -1763,29 +2047,38 @@
       0,                                    /* tp_maxalloc */
       0,                                    /* tp_prev */
       0                                     /* tp_next */
 #endif
     };
     swigpyobject_type = tmp;
     type_init = 1;
-    if (PyType_Ready(&swigpyobject_type) < 0)
+    if (PyType_Ready(&swigpyobject_type) != 0)
       return NULL;
   }
   return &swigpyobject_type;
 }
 
 SWIGRUNTIME PyObject *
 SwigPyObject_New(void *ptr, swig_type_info *ty, int own)
 {
   SwigPyObject *sobj = PyObject_NEW(SwigPyObject, SwigPyObject_type());
   if (sobj) {
     sobj->ptr  = ptr;
     sobj->ty   = ty;
     sobj->own  = own;
     sobj->next = 0;
+#ifdef SWIGPYTHON_BUILTIN
+    sobj->dict = 0;
+#endif
+    if (own == SWIG_POINTER_OWN) {
+      /* Obtain a reference to the Python capsule wrapping the module information, so that the
+       * module information is correctly destroyed after all SWIG python objects have been freed
+       * by the GC (and corresponding destructors invoked) */
+      Py_XINCREF(Swig_Capsule_global);
+    }
   }
   return (PyObject *)sobj;
 }
 
 /* -----------------------------------------------------------------------------
  * Implements a simple Swig Packed type, and use it instead of string
  * ----------------------------------------------------------------------------- */
@@ -1865,15 +2158,19 @@
       PyObject_HEAD_INIT(NULL)
       0,                                    /* ob_size */
 #endif
       "SwigPyPacked",                       /* tp_name */
       sizeof(SwigPyPacked),                 /* tp_basicsize */
       0,                                    /* tp_itemsize */
       (destructor)SwigPyPacked_dealloc,     /* tp_dealloc */
-      0,                                    /* tp_print */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                         /*tp_print*/
+#else
+      (Py_ssize_t)0,                        /*tp_vectorcall_offset*/
+#endif
       (getattrfunc)0,                       /* tp_getattr */
       (setattrfunc)0,                       /* tp_setattr */
 #if PY_VERSION_HEX>=0x03000000
       0, /* tp_reserved in 3.0.1 */
 #else
       (cmpfunc)SwigPyPacked_compare,        /* tp_compare */
 #endif
@@ -1930,15 +2227,15 @@
       0,                                    /* tp_maxalloc */
       0,                                    /* tp_prev */
       0                                     /* tp_next */
 #endif
     };
     swigpypacked_type = tmp;
     type_init = 1;
-    if (PyType_Ready(&swigpypacked_type) < 0)
+    if (PyType_Ready(&swigpypacked_type) != 0)
       return NULL;
   }
   return &swigpypacked_type;
 }
 
 SWIGRUNTIME PyObject *
 SwigPyPacked_New(void *ptr, size_t size, swig_type_info *ty)
@@ -2120,20 +2417,27 @@
       }
     } else {
       if (ptr) *ptr = vptr;
       break;
     }
   }
   if (sobj) {
-    if (own)
-      *own = *own | sobj->own;
-    if (flags & SWIG_POINTER_DISOWN) {
-      sobj->own = 0;
+    if (((flags & SWIG_POINTER_RELEASE) == SWIG_POINTER_RELEASE) && !sobj->own) {
+      res = SWIG_ERROR_RELEASE_NOT_OWNED;
+    } else {
+      if (own)
+        *own = *own | sobj->own;
+      if (flags & SWIG_POINTER_DISOWN) {
+        sobj->own = 0;
+      }
+      if (flags & SWIG_POINTER_CLEAR) {
+        sobj->ptr = 0;
+      }
+      res = SWIG_OK;
     }
-    res = SWIG_OK;
   } else {
     if (implicit_conv) {
       SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
       if (data && !data->implicitconv) {
         PyObject *klass = data->klass;
         if (klass) {
           PyObject *impconv;
@@ -2238,20 +2542,25 @@
   PyObject *newraw = data->newraw;
   if (newraw) {
     inst = PyObject_Call(newraw, data->newargs, NULL);
     if (inst) {
 #if !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
       PyObject **dictptr = _PyObject_GetDictPtr(inst);
       if (dictptr != NULL) {
-	PyObject *dict = *dictptr;
-	if (dict == NULL) {
-	  dict = PyDict_New();
-	  *dictptr = dict;
-	  PyDict_SetItem(dict, SWIG_This(), swig_this);
-	}
+        PyObject *dict = *dictptr;
+        if (dict == NULL) {
+          dict = PyDict_New();
+          *dictptr = dict;
+        }
+        if (dict) {
+          PyDict_SetItem(dict, SWIG_This(), swig_this);
+        } else{
+          Py_DECREF(inst);
+          inst = 0;
+        }
       }
 #else
       if (PyObject_SetAttr(inst, SWIG_This(), swig_this) == -1) {
         Py_DECREF(inst);
         inst = 0;
       }
 #endif
@@ -2265,15 +2574,15 @@
         inst = ((PyTypeObject *)data->newargs)->tp_new((PyTypeObject *)data->newargs, empty_args, empty_kwargs);
         Py_DECREF(empty_kwargs);
         if (inst) {
           if (PyObject_SetAttr(inst, SWIG_This(), swig_this) == -1) {
             Py_DECREF(inst);
             inst = 0;
           } else {
-            Py_TYPE(inst)->tp_flags &= ~Py_TPFLAGS_VALID_VERSION_TAG;
+            PyType_Modified(Py_TYPE(inst));
           }
         }
       }
       Py_DECREF(empty_args);
     }
 #else
     PyObject *dict = PyDict_New();
@@ -2294,30 +2603,34 @@
   PyObject **dictptr = _PyObject_GetDictPtr(inst);
   if (dictptr != NULL) {
     PyObject *dict = *dictptr;
     if (dict == NULL) {
       dict = PyDict_New();
       *dictptr = dict;
     }
-    return PyDict_SetItem(dict, SWIG_This(), swig_this);
+    if (dict) {
+      return PyDict_SetItem(dict, SWIG_This(), swig_this);
+    } else{
+      return -1;
+    }
   }
 #endif
   return PyObject_SetAttr(inst, SWIG_This(), swig_this);
 } 
 
 
 SWIGINTERN PyObject *
 SWIG_Python_InitShadowInstance(PyObject *args) {
   PyObject *obj[2];
   if (!SWIG_Python_UnpackTuple(args, "swiginit", 2, 2, obj)) {
     return NULL;
   } else {
     SwigPyObject *sthis = SWIG_Python_GetSwigThis(obj[0]);
     if (sthis) {
-      SwigPyObject_append((PyObject*) sthis, obj[1]);
+      Py_DECREF(SwigPyObject_append((PyObject*) sthis, obj[1]));
     } else {
       if (SWIG_Python_SetSwigThis(obj[0], obj[1]) != 0)
         return NULL;
     }
     return SWIG_Py_Void();
   }
 }
@@ -2348,15 +2661,17 @@
 #ifdef SWIGPYTHON_BUILTIN
         newobj->dict = 0;
 #endif
       }
     } else {
       newobj = PyObject_New(SwigPyObject, clientdata->pytype);
 #ifdef SWIGPYTHON_BUILTIN
-      newobj->dict = 0;
+      if (newobj) {
+        newobj->dict = 0;
+      }
 #endif
     }
     if (newobj) {
       newobj->ptr = ptr;
       newobj->ty = type;
       newobj->own = own;
       newobj->next = 0;
@@ -2387,89 +2702,111 @@
  *  Get type list 
  * -----------------------------------------------------------------------------*/
 
 #ifdef SWIG_LINK_RUNTIME
 void *SWIG_ReturnGlobalTypeList(void *);
 #endif
 
+static PyObject *Swig_TypeCache_global = NULL;
+
+/* The python cached type query */
+SWIGRUNTIME PyObject *
+SWIG_Python_TypeCache(void) {
+  if (Swig_TypeCache_global == NULL) {
+    Swig_TypeCache_global = PyDict_New();
+  }
+  return Swig_TypeCache_global;
+}
+
 SWIGRUNTIME swig_module_info *
 SWIG_Python_GetModule(void *SWIGUNUSEDPARM(clientdata)) {
+#ifdef SWIG_LINK_RUNTIME
   static void *type_pointer = (void *)0;
   /* first check if module already created */
   if (!type_pointer) {
-#ifdef SWIG_LINK_RUNTIME
     type_pointer = SWIG_ReturnGlobalTypeList((void *)0);
+  }
 #else
-    type_pointer = PyCapsule_Import(SWIGPY_CAPSULE_NAME, 0);
-    if (PyErr_Occurred()) {
-      PyErr_Clear();
-      type_pointer = (void *)0;
-    }
-#endif
+  void *type_pointer = PyCapsule_Import(SWIGPY_CAPSULE_NAME, 0);
+  if (PyErr_Occurred()) {
+    PyErr_Clear();
+    type_pointer = (void *)0;
   }
+#endif
   return (swig_module_info *) type_pointer;
 }
 
+
+static int interpreter_counter = 0; // how many (sub-)interpreters are using swig_module's types
+
 SWIGRUNTIME void
 SWIG_Python_DestroyModule(PyObject *obj)
 {
   swig_module_info *swig_module = (swig_module_info *) PyCapsule_GetPointer(obj, SWIGPY_CAPSULE_NAME);
   swig_type_info **types = swig_module->types;
   size_t i;
+  if (--interpreter_counter != 0) // another sub-interpreter may still be using the swig_module's types
+    return;
   for (i =0; i < swig_module->size; ++i) {
     swig_type_info *ty = types[i];
     if (ty->owndata) {
       SwigPyClientData *data = (SwigPyClientData *) ty->clientdata;
+      ty->clientdata = 0;
       if (data) SwigPyClientData_Del(data);
     }
   }
   Py_DECREF(SWIG_This());
   Swig_This_global = NULL;
+  Py_DECREF(SWIG_globals());
+  Swig_Globals_global = NULL;
+  Py_DECREF(SWIG_Python_TypeCache());
+  Swig_TypeCache_global = NULL;
+  Swig_Capsule_global = NULL;
 }
 
 SWIGRUNTIME void
 SWIG_Python_SetModule(swig_module_info *swig_module) {
 #if PY_VERSION_HEX >= 0x03000000
  /* Add a dummy module object into sys.modules */
   PyObject *module = PyImport_AddModule("swig_runtime_data" SWIG_RUNTIME_VERSION);
 #else
   static PyMethodDef swig_empty_runtime_method_table[] = { {NULL, NULL, 0, NULL} }; /* Sentinel */
   PyObject *module = Py_InitModule("swig_runtime_data" SWIG_RUNTIME_VERSION, swig_empty_runtime_method_table);
 #endif
   PyObject *pointer = PyCapsule_New((void *) swig_module, SWIGPY_CAPSULE_NAME, SWIG_Python_DestroyModule);
   if (pointer && module) {
-    PyModule_AddObject(module, "type_pointer_capsule" SWIG_TYPE_TABLE_NAME, pointer);
+    if (PyModule_AddObject(module, SWIGPY_CAPSULE_ATTR_NAME, pointer) == 0) {
+      ++interpreter_counter;
+      Swig_Capsule_global = pointer;
+    } else {
+      Py_DECREF(pointer);
+    }
   } else {
     Py_XDECREF(pointer);
   }
 }
 
-/* The python cached type query */
-SWIGRUNTIME PyObject *
-SWIG_Python_TypeCache(void) {
-  static PyObject *SWIG_STATIC_POINTER(cache) = PyDict_New();
-  return cache;
-}
-
 SWIGRUNTIME swig_type_info *
 SWIG_Python_TypeQuery(const char *type)
 {
   PyObject *cache = SWIG_Python_TypeCache();
   PyObject *key = SWIG_Python_str_FromChar(type); 
   PyObject *obj = PyDict_GetItem(cache, key);
   swig_type_info *descriptor;
   if (obj) {
     descriptor = (swig_type_info *) PyCapsule_GetPointer(obj, NULL);
   } else {
     swig_module_info *swig_module = SWIG_GetModule(0);
     descriptor = SWIG_TypeQueryModule(swig_module, swig_module, type);
     if (descriptor) {
       obj = PyCapsule_New((void*) descriptor, NULL, NULL);
-      PyDict_SetItem(cache, key, obj);
-      Py_DECREF(obj);
+      if (obj) {
+        PyDict_SetItem(cache, key, obj);
+        Py_DECREF(obj);
+      }
     }
   }
   Py_DECREF(key);
   return descriptor;
 }
 
 /* 
@@ -2494,15 +2831,14 @@
       Py_XINCREF(type);
       PyErr_Clear();
       if (infront) {
 	PyErr_Format(type, "%s %s", mesg, errmesg);
       } else {
 	PyErr_Format(type, "%s %s", errmesg, mesg);
       }
-      SWIG_Python_str_DelForPy3(tmp);
       Py_DECREF(old_str);
     }
     return 1;
   } else {
     return 0;
   }
 }
@@ -2546,15 +2882,14 @@
       const char *otype = (obj ? obj->ob_type->tp_name : 0); 
       if (otype) {
 	PyObject *str = PyObject_Str(obj);
 	const char *cstr = str ? SWIG_Python_str_AsChar(str) : 0;
 	if (cstr) {
 	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s(%s)' is received",
 		       type, otype, cstr);
-          SWIG_Python_str_DelForPy3(cstr);
 	} else {
 	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s' is received",
 		       type, otype);
 	}
 	Py_XDECREF(str);
 	return;
       }
@@ -2568,20 +2903,14 @@
 
 /* Convert a pointer value, signal an exception on a type mismatch */
 SWIGRUNTIME void *
 SWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int SWIGUNUSEDPARM(argnum), int flags) {
   void *result;
   if (SWIG_Python_ConvertPtr(obj, &result, ty, flags) == -1) {
     PyErr_Clear();
-#if SWIG_POINTER_EXCEPTION
-    if (flags) {
-      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);
-      SWIG_Python_ArgFail(argnum);
-    }
-#endif
   }
   return result;
 }
 
 #ifdef SWIGPYTHON_BUILTIN
 SWIGRUNTIME int
 SWIG_Python_NonDynamicSetAttr(PyObject *obj, PyObject *name, PyObject *value) {
@@ -2604,30 +2933,30 @@
     PyErr_Format(PyExc_TypeError, "attribute name must be string, not '%.200s'", name->ob_type->tp_name);
     return -1;
   } else {
     Py_INCREF(name);
   }
 
   if (!tp->tp_dict) {
-    if (PyType_Ready(tp) < 0)
+    if (PyType_Ready(tp) != 0)
       goto done;
   }
 
   descr = _PyType_Lookup(tp, name);
   f = NULL;
   if (descr != NULL)
     f = descr->ob_type->tp_descr_set;
   if (!f) {
     if (PyString_Check(name)) {
       encoded_name = name;
       Py_INCREF(name);
     } else {
       encoded_name = PyUnicode_AsUTF8String(name);
       if (!encoded_name)
-        return -1;
+        goto done;
     }
     PyErr_Format(PyExc_AttributeError, "'%.100s' object has no attribute '%.200s'", tp->tp_name, PyString_AsString(encoded_name));
     Py_DECREF(encoded_name);
   } else {
     res = f(descr, obj, value);
   }
   
@@ -2646,15 +2975,19 @@
 extern "C" {
 #endif
 
 SWIGINTERN Py_hash_t
 SwigPyObject_hash(PyObject *obj) {
   SwigPyObject *sobj = (SwigPyObject *)obj;
   void *ptr = sobj->ptr;
+#if PY_VERSION_HEX < 0x03020000
+  return (Py_hash_t)(Py_ssize_t)ptr;
+#else
   return (Py_hash_t)ptr;
+#endif
 }
 
 SWIGINTERN Py_hash_t
 SWIG_PyNumber_AsPyHash(PyObject *obj) {
   Py_hash_t result = -1;
 #if PY_VERSION_HEX < 0x03020000
   if (PyInt_Check(obj))
@@ -2851,15 +3184,19 @@
       PyObject_HEAD_INIT(&PyType_Type)
       0,                                        /* ob_size */
 #endif
       "swig_static_var_getset_descriptor",      /* tp_name */
       sizeof(PyGetSetDescrObject),              /* tp_basicsize */
       0,                                        /* tp_itemsize */
       (destructor)SwigPyStaticVar_dealloc,      /* tp_dealloc */
-      0,                                        /* tp_print */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                             /* tp_print */
+#else
+      (Py_ssize_t)0,                            /* tp_vectorcall_offset */
+#endif
       0,                                        /* tp_getattr */
       0,                                        /* tp_setattr */
       0,                                        /* tp_compare */
       (reprfunc)SwigPyStaticVar_repr,           /* tp_repr */
       0,                                        /* tp_as_number */
       0,                                        /* tp_as_sequence */
       0,                                        /* tp_as_mapping */
@@ -2935,15 +3272,19 @@
       PyObject_HEAD_INIT(&PyType_Type)
       0,                                        /* ob_size */
 #endif
       "SwigPyObjectType",                       /* tp_name */
       PyType_Type.tp_basicsize,                 /* tp_basicsize */
       0,                                        /* tp_itemsize */
       0,                                        /* tp_dealloc */
-      0,                                        /* tp_print */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                             /* tp_print */
+#else
+      (Py_ssize_t)0,                            /* tp_vectorcall_offset */
+#endif
       0,                                        /* tp_getattr */
       0,                                        /* tp_setattr */
       0,                                        /* tp_compare */
       0,                                        /* tp_repr */
       0,                                        /* tp_as_number */
       0,                                        /* tp_as_sequence */
       0,                                        /* tp_as_mapping */
@@ -3054,18 +3395,18 @@
   Py_XINCREF(result);
   return result;
 }
 
 SWIGINTERN void
 SwigPyBuiltin_SetMetaType (PyTypeObject *type, PyTypeObject *metatype)
 {
-#if PY_VERSION_HEX >= 0x03000000
-    type->ob_base.ob_base.ob_type = metatype;
+#if PY_VERSION_HEX >= 0x030900a4
+    Py_SET_TYPE(type, metatype);
 #else
-    type->ob_type = metatype;
+    Py_TYPE(type) = metatype;
 #endif
 }
 
 
 /* Start of callback function macros for use in PyTypeObject */
 
 typedef PyObject *(*SwigPyWrapperFunction)(PyObject *, PyObject *);
@@ -3395,31 +3736,16 @@
 #endif
 
 
 
 
 #define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 
 
-#define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 
-
-
+#define SWIG_contract_assert(expr, msg) do { if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } } while (0) 
 
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* Method creation and docstring support functions */
-
-SWIGINTERN PyMethodDef *SWIG_PythonGetProxyDoc(const char *name);
-SWIGINTERN PyObject *SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func);
-SWIGINTERN PyObject *SWIG_PyStaticMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func);
-
-#ifdef __cplusplus
-}
-#endif
 
 
 /* -------- TYPES TABLE (BEGIN) -------- */
 
 #define SWIGTYPE_p_CameraAbilities swig_types[0]
 #define SWIGTYPE_p_CameraCaptureType swig_types[1]
 #define SWIGTYPE_p_CameraDriverStatus swig_types[2]
@@ -3497,18 +3823,14 @@
 
 #else
 #  define SWIG_init    init_file
 
 #endif
 #define SWIG_name    "_file"
 
-#define SWIGVERSION 0x040002 
-#define SWIG_VERSION SWIGVERSION
-
-
 #define SWIG_as_voidptr(a) (void *)((const void *)(a)) 
 #define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),(void**)(a)) 
 
 
 #include <stddef.h>
 
 
@@ -4135,29 +4457,14 @@
     if (result < 0) /*@SWIG:src/gphoto2/common/macros.i,25,GPHOTO2_ERROR@*/
 PyErr_SetObject(PyExc_GPhoto2Error, PyInt_FromLong(result));
 /*@SWIG@*/
 
 
 
   }
-SWIGINTERN void _CameraFile_append(struct _CameraFile *self,char const *data,unsigned long size){
-
-    SWIG_PYTHON_THREAD_BEGIN_ALLOW;
-
-    int result = gp_file_append (self, data, size);
-
-    SWIG_PYTHON_THREAD_END_ALLOW;
-
-    if (result < 0) /*@SWIG:src/gphoto2/common/macros.i,25,GPHOTO2_ERROR@*/
-PyErr_SetObject(PyExc_GPhoto2Error, PyInt_FromLong(result));
-/*@SWIG@*/
-
-
-
-  }
 
 SWIGINTERNINLINE PyObject *
 SWIG_FromCharPtrAndSize(const char* carray, size_t size)
 {
   if (carray) {
     if (size > INT_MAX) {
       swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
@@ -4205,14 +4512,15 @@
       arg1 = NULL;
       /*@SWIG:src/gphoto2/common/macros.i,25,GPHOTO2_ERROR@*/
       PyErr_SetObject(PyExc_GPhoto2Error, PyInt_FromLong(error));
       /*@SWIG@*/
       SWIG_fail;
     }
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_file_open", 1, 1, &obj0)) SWIG_fail;
   res2 = SWIG_AsCharPtrAndSize(obj0, &buf2, NULL, &alloc2);
   if (!SWIG_IsOK(res2)) {
     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gp_file_open" "', argument " "2"" of type '" "char const *""'");
   }
   arg2 = (char *)(buf2);
   result = (int)gp_file_open(arg1,(char const *)arg2);
@@ -4240,14 +4548,15 @@
 }
 
 
 SWIGINTERN int _wrap_new_CameraFile(PyObject *self, PyObject *args, PyObject *kwargs) {
   PyObject *resultobj = 0;
   struct _CameraFile *result = 0 ;
   
+  (void)self;
   if (!SWIG_Python_CheckNoKeywords(kwargs, "new_CameraFile")) SWIG_fail;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "new_CameraFile takes no arguments");
   {
     result = (struct _CameraFile *)new__CameraFile();
     if (PyErr_Occurred()) SWIG_fail;
   }
   resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p__CameraFile, SWIG_BUILTIN_INIT |  0 );
@@ -4259,14 +4568,15 @@
 
 SWIGINTERN PyObject *_wrap_delete_CameraFile(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraFile *arg1 = (struct _CameraFile *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_CameraFile takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFile, SWIG_POINTER_DISOWN |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CameraFile" "', argument " "1"" of type '" "struct _CameraFile *""'"); 
   }
   arg1 = (struct _CameraFile *)(argp1);
   {
@@ -4287,14 +4597,15 @@
   void *argp1 = 0 ;
   int res1 = 0 ;
   int res2 ;
   char *buf2 = 0 ;
   int alloc2 = 0 ;
   PyObject * obj1 = 0 ;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "CameraFile_set_name", 1, 1, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFile, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraFile_set_name" "', argument " "1"" of type '" "struct _CameraFile *""'"); 
   }
   arg1 = (struct _CameraFile *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -4323,14 +4634,15 @@
   int res1 = 0 ;
   char *temp2 ;
   
   {
     temp2 = NULL;
     arg2 = &temp2;
   }
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraFile_get_name takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFile, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraFile_get_name" "', argument " "1"" of type '" "struct _CameraFile *""'"); 
   }
   arg1 = (struct _CameraFile *)(argp1);
   {
@@ -4360,14 +4672,15 @@
   void *argp1 = 0 ;
   int res1 = 0 ;
   int res2 ;
   char *buf2 = 0 ;
   int alloc2 = 0 ;
   PyObject * obj1 = 0 ;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "CameraFile_set_mime_type", 1, 1, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFile, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraFile_set_mime_type" "', argument " "1"" of type '" "struct _CameraFile *""'"); 
   }
   arg1 = (struct _CameraFile *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -4396,14 +4709,15 @@
   int res1 = 0 ;
   char *temp2 ;
   
   {
     temp2 = NULL;
     arg2 = &temp2;
   }
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraFile_get_mime_type takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFile, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraFile_get_mime_type" "', argument " "1"" of type '" "struct _CameraFile *""'"); 
   }
   arg1 = (struct _CameraFile *)(argp1);
   {
@@ -4432,14 +4746,15 @@
   time_t arg2 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   long val2 ;
   int ecode2 = 0 ;
   PyObject * obj1 = 0 ;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "CameraFile_set_mtime", 1, 1, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFile, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraFile_set_mtime" "', argument " "1"" of type '" "struct _CameraFile *""'"); 
   }
   arg1 = (struct _CameraFile *)(argp1);
   ecode2 = SWIG_AsVal_long(obj1, &val2);
@@ -4464,14 +4779,15 @@
   time_t *arg2 = (time_t *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   time_t temp2 ;
   int res2 = SWIG_TMPOBJ ;
   
   arg2 = &temp2;
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraFile_get_mtime takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFile, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraFile_get_mtime" "', argument " "1"" of type '" "struct _CameraFile *""'"); 
   }
   arg1 = (struct _CameraFile *)(argp1);
   {
@@ -4493,14 +4809,15 @@
 
 SWIGINTERN PyObject *_wrap_CameraFile_detect_mime_type(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraFile *arg1 = (struct _CameraFile *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraFile_detect_mime_type takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFile, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraFile_detect_mime_type" "', argument " "1"" of type '" "struct _CameraFile *""'"); 
   }
   arg1 = (struct _CameraFile *)(argp1);
   {
@@ -4516,14 +4833,15 @@
 
 SWIGINTERN PyObject *_wrap_CameraFile_adjust_name_for_mime_type(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraFile *arg1 = (struct _CameraFile *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraFile_adjust_name_for_mime_type takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFile, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraFile_adjust_name_for_mime_type" "', argument " "1"" of type '" "struct _CameraFile *""'"); 
   }
   arg1 = (struct _CameraFile *)(argp1);
   {
@@ -4554,14 +4872,15 @@
   PyObject * obj1 = 0 ;
   PyObject * obj2 = 0 ;
   
   {
     temp4 = NULL;
     arg4 = &temp4;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "CameraFile_get_name_by_type", 2, 2, &obj1, &obj2)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFile, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraFile_get_name_by_type" "', argument " "1"" of type '" "struct _CameraFile *""'"); 
   }
   arg1 = (struct _CameraFile *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -4601,14 +4920,15 @@
   struct _CameraFile *arg1 = (struct _CameraFile *) 0 ;
   char *arg2 = (char *) 0 ;
   unsigned long arg3 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   PyObject * obj1 = 0 ;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "CameraFile_set_data_and_size", 1, 1, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFile, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraFile_set_data_and_size" "', argument " "1"" of type '" "struct _CameraFile *""'"); 
   }
   arg1 = (struct _CameraFile *)(argp1);
   {
@@ -4659,14 +4979,15 @@
   
   {
     temp_data2 = NULL;
     temp_size2 = 0;
     arg2 = &temp_data2;
     arg3 = &temp_size2;
   }
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraFile_get_data_and_size takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFile, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraFile_get_data_and_size" "', argument " "1"" of type '" "struct _CameraFile *""'"); 
   }
   arg1 = (struct _CameraFile *)(argp1);
   {
@@ -4697,14 +5018,15 @@
   void *argp1 = 0 ;
   int res1 = 0 ;
   int res2 ;
   char *buf2 = 0 ;
   int alloc2 = 0 ;
   PyObject * obj1 = 0 ;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "CameraFile_save", 1, 1, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFile, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraFile_save" "', argument " "1"" of type '" "struct _CameraFile *""'"); 
   }
   arg1 = (struct _CameraFile *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -4727,14 +5049,15 @@
 
 SWIGINTERN PyObject *_wrap_CameraFile_clean(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraFile *arg1 = (struct _CameraFile *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraFile_clean takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFile, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraFile_clean" "', argument " "1"" of type '" "struct _CameraFile *""'"); 
   }
   arg1 = (struct _CameraFile *)(argp1);
   {
@@ -4754,14 +5077,15 @@
   CameraFile *arg2 = (CameraFile *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   void *argp2 = 0 ;
   int res2 = 0 ;
   PyObject * obj1 = 0 ;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "CameraFile_copy", 1, 1, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFile, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraFile_copy" "', argument " "1"" of type '" "struct _CameraFile *""'"); 
   }
   arg1 = (struct _CameraFile *)(argp1);
   res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p__CameraFile, 0 |  0 );
@@ -4776,70 +5100,27 @@
   resultobj = SWIG_Py_Void();
   return resultobj;
 fail:
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_CameraFile_append(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0;
-  struct _CameraFile *arg1 = (struct _CameraFile *) 0 ;
-  char *arg2 = (char *) 0 ;
-  unsigned long arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj1 = 0 ;
-  
-  if (!PyArg_UnpackTuple(args, "CameraFile_append", 1, 1, &obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFile, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraFile_append" "', argument " "1"" of type '" "struct _CameraFile *""'"); 
-  }
-  arg1 = (struct _CameraFile *)(argp1);
-  {
-    Py_buffer view;
-    if (PyObject_CheckBuffer(obj1) != 1) {
-      PyErr_SetString(
-        PyExc_TypeError,
-        "in method 'CameraFile_append', argument 2 does not support the buffer interface");
-      SWIG_fail;
-    }
-    if (PyObject_GetBuffer(obj1, &view, PyBUF_SIMPLE) != 0) {
-      PyErr_SetString(
-        PyExc_TypeError,
-        "in method 'CameraFile_append', argument 2 does not export a simple buffer");
-      SWIG_fail;
-    }
-    arg2 = view.buf;
-    arg3 = view.len;
-    PyBuffer_Release(&view);
-  }
-  {
-    _CameraFile_append(arg1,(char const *)arg2,arg3);
-    if (PyErr_Occurred()) SWIG_fail;
-  }
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
 SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_CameraFile) /* defines _wrap_delete_CameraFile_destructor_closure */
 
 SWIGINTERN PyObject *_wrap_gp_file_new(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   CameraFile **arg1 = (CameraFile **) 0 ;
   CameraFile *temp1 ;
   int result;
   
   {
     temp1 = NULL;
     arg1 = &temp1;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_file_new", 0, 0)) SWIG_fail;
   result = (int)gp_file_new(arg1);
   resultobj = SWIG_From_int((int)(result));
   {
     resultobj = SWIG_Python_AppendOutput(
       resultobj, SWIG_NewPointerObj(*arg1, SWIGTYPE_p__CameraFile, SWIG_POINTER_OWN));
   }
@@ -4859,14 +5140,15 @@
   PyObject * obj0 = 0 ;
   int result;
   
   {
     temp1 = NULL;
     arg1 = &temp1;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_file_new_from_fd", 1, 1, &obj0)) SWIG_fail;
   ecode2 = SWIG_AsVal_int(obj0, &val2);
   if (!SWIG_IsOK(ecode2)) {
     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "gp_file_new_from_fd" "', argument " "2"" of type '" "int""'");
   } 
   arg2 = (int)(val2);
   result = (int)gp_file_new_from_fd(arg1,arg2);
@@ -4894,14 +5176,15 @@
   PyObject * obj1 = 0 ;
   int result;
   
   {
     temp1 = NULL;
     arg1 = &temp1;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_file_new_from_handler", 2, 2, &obj0, &obj1)) SWIG_fail;
   res2 = SWIG_ConvertPtr(obj0, &argp2,SWIGTYPE_p__CameraFileHandler, 0 |  0 );
   if (!SWIG_IsOK(res2)) {
     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gp_file_new_from_handler" "', argument " "2"" of type '" "CameraFileHandler *""'"); 
   }
   arg2 = (CameraFileHandler *)(argp2);
   res3 = SWIG_ConvertPtr(obj1,SWIG_as_voidptrptr(&arg3), 0, 0);
@@ -4929,14 +5212,15 @@
   int res2 ;
   char *buf2 = 0 ;
   int alloc2 = 0 ;
   PyObject * obj0 = 0 ;
   PyObject * obj1 = 0 ;
   int result;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_file_set_name", 2, 2, &obj0, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraFile, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_file_set_name" "', argument " "1"" of type '" "CameraFile *""'"); 
   }
   arg1 = (CameraFile *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -4964,14 +5248,15 @@
   PyObject * obj0 = 0 ;
   int result;
   
   {
     temp2 = NULL;
     arg2 = &temp2;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_file_get_name", 1, 1, &obj0)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraFile, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_file_get_name" "', argument " "1"" of type '" "CameraFile *""'"); 
   }
   arg1 = (CameraFile *)(argp1);
   result = (int)gp_file_get_name(arg1,(char const **)arg2);
@@ -5000,14 +5285,15 @@
   int res2 ;
   char *buf2 = 0 ;
   int alloc2 = 0 ;
   PyObject * obj0 = 0 ;
   PyObject * obj1 = 0 ;
   int result;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_file_set_mime_type", 2, 2, &obj0, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraFile, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_file_set_mime_type" "', argument " "1"" of type '" "CameraFile *""'"); 
   }
   arg1 = (CameraFile *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -5035,14 +5321,15 @@
   PyObject * obj0 = 0 ;
   int result;
   
   {
     temp2 = NULL;
     arg2 = &temp2;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_file_get_mime_type", 1, 1, &obj0)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraFile, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_file_get_mime_type" "', argument " "1"" of type '" "CameraFile *""'"); 
   }
   arg1 = (CameraFile *)(argp1);
   result = (int)gp_file_get_mime_type(arg1,(char const **)arg2);
@@ -5070,14 +5357,15 @@
   int res1 = 0 ;
   long val2 ;
   int ecode2 = 0 ;
   PyObject * obj0 = 0 ;
   PyObject * obj1 = 0 ;
   int result;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_file_set_mtime", 2, 2, &obj0, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraFile, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_file_set_mtime" "', argument " "1"" of type '" "CameraFile *""'"); 
   }
   arg1 = (CameraFile *)(argp1);
   ecode2 = SWIG_AsVal_long(obj1, &val2);
@@ -5101,14 +5389,15 @@
   int res1 = 0 ;
   time_t temp2 ;
   int res2 = SWIG_TMPOBJ ;
   PyObject * obj0 = 0 ;
   int result;
   
   arg2 = &temp2;
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_file_get_mtime", 1, 1, &obj0)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraFile, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_file_get_mtime" "', argument " "1"" of type '" "CameraFile *""'"); 
   }
   arg1 = (CameraFile *)(argp1);
   result = (int)gp_file_get_mtime(arg1,arg2);
@@ -5129,14 +5418,15 @@
   PyObject *resultobj = 0;
   CameraFile *arg1 = (CameraFile *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   PyObject * obj0 = 0 ;
   int result;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_file_detect_mime_type", 1, 1, &obj0)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraFile, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_file_detect_mime_type" "', argument " "1"" of type '" "CameraFile *""'"); 
   }
   arg1 = (CameraFile *)(argp1);
   result = (int)gp_file_detect_mime_type(arg1);
@@ -5151,14 +5441,15 @@
   PyObject *resultobj = 0;
   CameraFile *arg1 = (CameraFile *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   PyObject * obj0 = 0 ;
   int result;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_file_adjust_name_for_mime_type", 1, 1, &obj0)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraFile, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_file_adjust_name_for_mime_type" "', argument " "1"" of type '" "CameraFile *""'"); 
   }
   arg1 = (CameraFile *)(argp1);
   result = (int)gp_file_adjust_name_for_mime_type(arg1);
@@ -5188,14 +5479,15 @@
   PyObject * obj2 = 0 ;
   int result;
   
   {
     temp4 = NULL;
     arg4 = &temp4;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_file_get_name_by_type", 3, 3, &obj0, &obj1, &obj2)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraFile, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_file_get_name_by_type" "', argument " "1"" of type '" "CameraFile *""'"); 
   }
   arg1 = (CameraFile *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -5234,14 +5526,15 @@
   unsigned long arg3 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   PyObject * obj0 = 0 ;
   PyObject * obj1 = 0 ;
   int result;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_file_set_data_and_size", 2, 2, &obj0, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraFile, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_file_set_data_and_size" "', argument " "1"" of type '" "CameraFile *""'"); 
   }
   arg1 = (CameraFile *)(argp1);
   {
@@ -5295,14 +5588,15 @@
   
   {
     temp_data2 = NULL;
     temp_size2 = 0;
     arg2 = &temp_data2;
     arg3 = &temp_size2;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_file_get_data_and_size", 1, 1, &obj0)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraFile, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_file_get_data_and_size" "', argument " "1"" of type '" "CameraFile *""'"); 
   }
   arg1 = (CameraFile *)(argp1);
   {
@@ -5336,14 +5630,15 @@
   int res2 ;
   char *buf2 = 0 ;
   int alloc2 = 0 ;
   PyObject * obj0 = 0 ;
   PyObject * obj1 = 0 ;
   int result;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_file_save", 2, 2, &obj0, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraFile, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_file_save" "', argument " "1"" of type '" "CameraFile *""'"); 
   }
   arg1 = (CameraFile *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -5369,14 +5664,15 @@
   PyObject *resultobj = 0;
   CameraFile *arg1 = (CameraFile *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   PyObject * obj0 = 0 ;
   int result;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_file_clean", 1, 1, &obj0)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraFile, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_file_clean" "', argument " "1"" of type '" "CameraFile *""'"); 
   }
   arg1 = (CameraFile *)(argp1);
   result = (int)gp_file_clean(arg1);
@@ -5395,14 +5691,15 @@
   int res1 = 0 ;
   void *argp2 = 0 ;
   int res2 = 0 ;
   PyObject * obj0 = 0 ;
   PyObject * obj1 = 0 ;
   int result;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_file_copy", 2, 2, &obj0, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraFile, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_file_copy" "', argument " "1"" of type '" "CameraFile *""'"); 
   }
   arg1 = (CameraFile *)(argp1);
   res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p__CameraFile, 0 |  0 );
@@ -5418,478 +5715,15 @@
   resultobj = SWIG_From_int((int)(result));
   return resultobj;
 fail:
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_gp_file_append(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0;
-  CameraFile *arg1 = (CameraFile *) 0 ;
-  char *arg2 = (char *) 0 ;
-  unsigned long arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  int result;
-  
-  if (!PyArg_UnpackTuple(args, "gp_file_append", 2, 2, &obj0, &obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraFile, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_file_append" "', argument " "1"" of type '" "CameraFile *""'"); 
-  }
-  arg1 = (CameraFile *)(argp1);
-  {
-    Py_buffer view;
-    if (PyObject_CheckBuffer(obj1) != 1) {
-      PyErr_SetString(
-        PyExc_TypeError,
-        "in method 'gp_file_append', argument 2 does not support the buffer interface");
-      SWIG_fail;
-    }
-    if (PyObject_GetBuffer(obj1, &view, PyBUF_SIMPLE) != 0) {
-      PyErr_SetString(
-        PyExc_TypeError,
-        "in method 'gp_file_append', argument 2 does not export a simple buffer");
-      SWIG_fail;
-    }
-    arg2 = view.buf;
-    arg3 = view.len;
-    PyBuffer_Release(&view);
-  }
-  {
-    SWIG_PYTHON_THREAD_BEGIN_ALLOW;
-    result = (int)gp_file_append(arg1,(char const *)arg2,arg3);
-    SWIG_PYTHON_THREAD_END_ALLOW;
-  }
-  resultobj = SWIG_From_int((int)(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
 static PyMethodDef SwigMethods[] = {
-	 { "SWIG_PyInstanceMethod_New", SWIG_PyInstanceMethod_New, METH_O, NULL},
-	 { "SWIG_PyStaticMethod_New", SWIG_PyStaticMethod_New, METH_O, NULL},
-	 { "gp_file_open", _wrap_gp_file_open, METH_VARARGS, "\n"
-		"gp_file_open(filename) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"filename: str\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `file` :  \n"
-		"    a CameraFile  \n"
-		"* `filename` :  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		"\n"
-		"See also gphoto2.CameraFile.open\n"
-		""},
-	 { "gp_file_new", _wrap_gp_file_new, METH_VARARGS, "\n"
-		"gp_file_new() -> int\n"
-		"Create new CameraFile object.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `file` :  \n"
-		"    a pointer to a CameraFile  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		"\n"
-		"See also gphoto2.CameraFile\n"
-		""},
-	 { "gp_file_new_from_fd", _wrap_gp_file_new_from_fd, METH_VARARGS, "\n"
-		"gp_file_new_from_fd(fd) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"fd: int\n"
-		"\n"
-		"Create new CameraFile object from a UNIX filedescriptor.  \n"
-		"\n"
-		"This function takes ownership of the filedescriptor and will close it\n"
-		"when closing the CameraFile.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `file` :  \n"
-		"    a pointer to a CameraFile  \n"
-		"* `fd` :  \n"
-		"    a UNIX filedescriptor  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		"\n"
-		"See also gphoto2.CameraFile.new_from_fd\n"
-		""},
-	 { "gp_file_new_from_handler", _wrap_gp_file_new_from_handler, METH_VARARGS, "\n"
-		"gp_file_new_from_handler(handler, priv) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"handler: gphoto2.CameraFileHandler\n"
-		"priv: void *\n"
-		"\n"
-		"Create new CameraFile object using a programmatic handler.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `file` :  \n"
-		"    a pointer to a CameraFile  \n"
-		"* `handler` :  \n"
-		"    a #CameraFileHandler  \n"
-		"* `private` :  \n"
-		"    a private pointer for frontend use  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		"\n"
-		"See also gphoto2.CameraFile.new_from_handler\n"
-		""},
-	 { "gp_file_set_name", _wrap_gp_file_set_name, METH_VARARGS, "\n"
-		"gp_file_set_name(file, name) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"file: gphoto2.CameraFile\n"
-		"name: str\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `file` :  \n"
-		"    a CameraFile  \n"
-		"* `name` :  \n"
-		"    a pointer to a MIME type string  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		"\n"
-		"See also gphoto2.CameraFile.set_name\n"
-		""},
-	 { "gp_file_get_name", _wrap_gp_file_get_name, METH_VARARGS, "\n"
-		"gp_file_get_name(file) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"file: gphoto2.CameraFile\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `file` :  \n"
-		"    a CameraFile  \n"
-		"* `name` :  \n"
-		"    a pointer to a name string  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		"\n"
-		"See also gphoto2.CameraFile.get_name\n"
-		""},
-	 { "gp_file_set_mime_type", _wrap_gp_file_set_mime_type, METH_VARARGS, "\n"
-		"gp_file_set_mime_type(file, mime_type) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"file: gphoto2.CameraFile\n"
-		"mime_type: str\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `file` :  \n"
-		"    a CameraFile  \n"
-		"* `mime_type` :  \n"
-		"    a MIME type string  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		"\n"
-		"See also gphoto2.CameraFile.set_mime_type\n"
-		""},
-	 { "gp_file_get_mime_type", _wrap_gp_file_get_mime_type, METH_VARARGS, "\n"
-		"gp_file_get_mime_type(file) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"file: gphoto2.CameraFile\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `file` :  \n"
-		"    a CameraFile  \n"
-		"* `mime_type` :  \n"
-		"    a pointer to a MIME type string  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		"\n"
-		"See also gphoto2.CameraFile.get_mime_type\n"
-		""},
-	 { "gp_file_set_mtime", _wrap_gp_file_set_mtime, METH_VARARGS, "\n"
-		"gp_file_set_mtime(file, mtime) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"file: gphoto2.CameraFile\n"
-		"mtime: int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `file` :  \n"
-		"    a CameraFile  \n"
-		"* `mtime` :  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		"\n"
-		"See also gphoto2.CameraFile.set_mtime\n"
-		""},
-	 { "gp_file_get_mtime", _wrap_gp_file_get_mtime, METH_VARARGS, "\n"
-		"gp_file_get_mtime(file) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"file: gphoto2.CameraFile\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `file` :  \n"
-		"    a CameraFile  \n"
-		"* `mtime` :  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		"\n"
-		"See also gphoto2.CameraFile.get_mtime\n"
-		""},
-	 { "gp_file_detect_mime_type", _wrap_gp_file_detect_mime_type, METH_VARARGS, "\n"
-		"gp_file_detect_mime_type(file) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"file: gphoto2.CameraFile\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `file` :  \n"
-		"    a CameraFile  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		"\n"
-		"See also gphoto2.CameraFile.detect_mime_type\n"
-		""},
-	 { "gp_file_adjust_name_for_mime_type", _wrap_gp_file_adjust_name_for_mime_type, METH_VARARGS, "\n"
-		"gp_file_adjust_name_for_mime_type(file) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"file: gphoto2.CameraFile\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `file` :  \n"
-		"    a CameraFile  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		"\n"
-		"See also gphoto2.CameraFile.adjust_name_for_mime_type\n"
-		""},
-	 { "gp_file_get_name_by_type", _wrap_gp_file_get_name_by_type, METH_VARARGS, "\n"
-		"gp_file_get_name_by_type(file, basename, type) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"file: gphoto2.CameraFile\n"
-		"basename: str\n"
-		"type: CameraFileType (gphoto2.GP_FILE_TYPE_PREVIEW etc.)\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `file` :  \n"
-		"    a CameraFile  \n"
-		"* `basename` :  \n"
-		"    the basename of the file  \n"
-		"* `type` :  \n"
-		"    the gphoto type of the file  \n"
-		"* `newname` :  \n"
-		"    the new name generated  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.  \n"
-		"\n"
-		"This function takes the basename and generates a filename out of it\n"
-		"depending on the gphoto filetype and the mime type in the file. The\n"
-		"gphoto filetype will be converted to a prefix, like thumb_ or raw_, the\n"
-		"mimetype will replace the current suffix by a different one (if\n"
-		"necessary).  \n"
-		"\n"
-		"This can be used so that saving thumbnails or metadata will not\n"
-		"overwrite the normal files.\n"
-		"\n"
-		"See also gphoto2.CameraFile.get_name_by_type\n"
-		""},
-	 { "gp_file_set_data_and_size", _wrap_gp_file_set_data_and_size, METH_VARARGS, "\n"
-		"gp_file_set_data_and_size(arg1, data) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"arg1: gphoto2.CameraFile\n"
-		"data: readable buffer (e.g. bytes)\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `file` :  \n"
-		"    a CameraFile  \n"
-		"* `data` :  \n"
-		"* `size` :  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		"\n"
-		"See also gphoto2.CameraFile.set_data_and_size\n"
-		""},
-	 { "gp_file_get_data_and_size", _wrap_gp_file_get_data_and_size, METH_VARARGS, "\n"
-		"gp_file_get_data_and_size(arg1) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"arg1: gphoto2.CameraFile\n"
-		"\n"
-		"Get a pointer to the data and the file's size.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `file` :  \n"
-		"    a CameraFile  \n"
-		"* `data` :  \n"
-		"* `size` :  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.  \n"
-		"\n"
-		"Both data and size can be NULL and will then be ignored.  \n"
-		"\n"
-		"For regular CameraFiles, the pointer to data that is returned is still\n"
-		"owned by libgphoto2 and its lifetime is the same as the #file.  \n"
-		"\n"
-		"For filedescriptor or handler based CameraFile types, the returned data\n"
-		"pointer is owned by the caller and needs to be free()d to avoid memory\n"
-		"leaks.\n"
-		"\n"
-		"See also gphoto2.CameraFile.get_data_and_size\n"
-		""},
-	 { "gp_file_save", _wrap_gp_file_save, METH_VARARGS, "\n"
-		"gp_file_save(file, filename) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"file: gphoto2.CameraFile\n"
-		"filename: str\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `file` :  \n"
-		"    a CameraFile  \n"
-		"* `filename` :  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		"\n"
-		"See also gphoto2.CameraFile.save\n"
-		""},
-	 { "gp_file_clean", _wrap_gp_file_clean, METH_VARARGS, "\n"
-		"gp_file_clean(file) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"file: gphoto2.CameraFile\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `file` :  \n"
-		"    a CameraFile  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		"\n"
-		"See also gphoto2.CameraFile.clean\n"
-		""},
-	 { "gp_file_copy", _wrap_gp_file_copy, METH_VARARGS, "\n"
-		"gp_file_copy(destination, source) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"destination: gphoto2.CameraFile\n"
-		"source: gphoto2.CameraFile\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `destination` :  \n"
-		"    a CameraFile  \n"
-		"* `source` :  \n"
-		"    a CameraFile  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		"\n"
-		"See also gphoto2.CameraFile.copy\n"
-		""},
-	 { "gp_file_append", _wrap_gp_file_append, METH_VARARGS, "\n"
-		"gp_file_append(arg1, data) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"arg1: gphoto2.CameraFile\n"
-		"data: readable buffer (e.g. bytes)\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `file` :  \n"
-		"    a CameraFile  \n"
-		"* `data` :  \n"
-		"* `size` :  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		"\n"
-		"See also gphoto2.CameraFile.append\n"
-		""},
-	 { NULL, NULL, 0, NULL }
-};
-
-static PyMethodDef SwigMethods_proxydocs[] = {
-	 { "SWIG_PyInstanceMethod_New", SWIG_PyInstanceMethod_New, METH_O, NULL},
-	 { "SWIG_PyStaticMethod_New", SWIG_PyStaticMethod_New, METH_O, NULL},
 	 { "gp_file_open", _wrap_gp_file_open, METH_VARARGS, "\n"
 		"gp_file_open(filename) -> int\n"
 		"\n"
 		"Parameters\n"
 		"----------\n"
 		"filename: str\n"
 		"\n"
@@ -6269,35 +6103,14 @@
 		"\n"
 		"Returns\n"
 		"-------\n"
 		"a gphoto2 error code.\n"
 		"\n"
 		"See also gphoto2.CameraFile.copy\n"
 		""},
-	 { "gp_file_append", _wrap_gp_file_append, METH_VARARGS, "\n"
-		"gp_file_append(arg1, data) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"arg1: gphoto2.CameraFile\n"
-		"data: readable buffer (e.g. bytes)\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `file` :  \n"
-		"    a CameraFile  \n"
-		"* `data` :  \n"
-		"* `size` :  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		"\n"
-		"See also gphoto2.CameraFile.append\n"
-		""},
 	 { NULL, NULL, 0, NULL }
 };
 
 static SwigPyGetSet CameraFile___dict___getset = { SwigPyObject_get___dict__, 0 };
 SWIGINTERN PyGetSetDef SwigPyBuiltin___CameraFile_getset[] = {
     { (char *)"__dict__", SwigPyBuiltin_GetterClosure, 0, (char *)"\n"
 		"gp_file_open\n"
@@ -6593,34 +6406,14 @@
 		"\n"
 		"Returns\n"
 		"-------\n"
 		"a gphoto2 error code.\n"
 		"\n"
 		"See also gphoto2.gp_file_copy\n"
 		"" },
-  { "append", _wrap_CameraFile_append, METH_VARARGS, "\n"
-		"append(self, data)\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"data: readable buffer (e.g. bytes)\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `file` :  \n"
-		"    a CameraFile  \n"
-		"* `data` :  \n"
-		"* `size` :  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		"\n"
-		"See also gphoto2.gp_file_append\n"
-		"" },
   { NULL, NULL, 0, NULL } /* Sentinel */
 };
 
 static PyHeapTypeObject SwigPyBuiltin___CameraFile_type = {
   {
 #if PY_VERSION_HEX >= 0x03000000
     PyVarObject_HEAD_INIT(NULL, 0)
@@ -6628,15 +6421,19 @@
     PyObject_HEAD_INIT(NULL)
     0,                                        /* ob_size */
 #endif
     "gphoto2.file.CameraFile",                /* tp_name */
     sizeof(SwigPyObject),                     /* tp_basicsize */
     0,                                        /* tp_itemsize */
     _wrap_delete_CameraFile_destructor_closure,                   /* tp_dealloc */
+#if PY_VERSION_HEX < 0x030800b4
     (printfunc) 0,                            /* tp_print */
+#else
+    (Py_ssize_t) 0,                           /* tp_vectorcall_offset */
+#endif
     (getattrfunc) 0,                          /* tp_getattr */
     (setattrfunc) 0,                          /* tp_setattr */
 #if PY_VERSION_HEX >= 0x03000000
     0,                                        /* tp_compare */
 #else
     (cmpfunc) 0,                              /* tp_compare */
 #endif
@@ -6700,14 +6497,17 @@
 #endif
   },
 #if PY_VERSION_HEX >= 0x03050000
   {
     (unaryfunc) 0,                            /* am_await */
     (unaryfunc) 0,                            /* am_aiter */
     (unaryfunc) 0,                            /* am_anext */
+# if PY_VERSION_HEX >= 0x030a0000
+    (sendfunc) 0,                             /* am_send */
+# endif
   },
 #endif
   {
     (binaryfunc) 0,                           /* nb_add */
     (binaryfunc) 0,                           /* nb_subtract */
     (binaryfunc) 0,                           /* nb_multiply */
 #if PY_VERSION_HEX < 0x03000000
@@ -6800,78 +6600,87 @@
   },
     (PyObject *) 0,                           /* ht_name */
     (PyObject *) 0,                           /* ht_slots */
 #if PY_VERSION_HEX >= 0x03030000
     (PyObject *) 0,                           /* ht_qualname */
     0,                                        /* ht_cached_keys */
 #endif
+#if PY_VERSION_HEX >= 0x03090000
+    (PyObject *) 0,                           /* ht_module */
+#endif
+#if PY_VERSION_HEX >= 0x030b0000
+    (char *) 0,                               /* _ht_tpname */
+  {
+    (PyObject *) 0,                           /* getitem */
+  }
+#endif
 };
 
 SWIGINTERN SwigPyClientData SwigPyBuiltin___CameraFile_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin___CameraFile_type};
 
 
 /* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */
 
 static swig_type_info _swigt__p_CameraAbilities = {"_p_CameraAbilities", "CameraAbilities *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraCaptureType = {"_p_CameraCaptureType", "enum CameraCaptureType *|CameraCaptureType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraDriverStatus = {"_p_CameraDriverStatus", "enum CameraDriverStatus *|CameraDriverStatus *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraEventType = {"_p_CameraEventType", "enum CameraEventType *|CameraEventType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileAccessType = {"_p_CameraFileAccessType", "enum CameraFileAccessType *|CameraFileAccessType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileInfoFields = {"_p_CameraFileInfoFields", "enum CameraFileInfoFields *|CameraFileInfoFields *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileOperation = {"_p_CameraFileOperation", "enum CameraFileOperation *|CameraFileOperation *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraCaptureType = {"_p_CameraCaptureType", "CameraCaptureType *|enum CameraCaptureType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraDriverStatus = {"_p_CameraDriverStatus", "CameraDriverStatus *|enum CameraDriverStatus *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraEventType = {"_p_CameraEventType", "CameraEventType *|enum CameraEventType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileAccessType = {"_p_CameraFileAccessType", "CameraFileAccessType *|enum CameraFileAccessType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileInfoFields = {"_p_CameraFileInfoFields", "CameraFileInfoFields *|enum CameraFileInfoFields *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileOperation = {"_p_CameraFileOperation", "CameraFileOperation *|enum CameraFileOperation *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_CameraFilePath = {"_p_CameraFilePath", "CameraFilePath *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFilePermissions = {"_p_CameraFilePermissions", "enum CameraFilePermissions *|CameraFilePermissions *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileStatus = {"_p_CameraFileStatus", "enum CameraFileStatus *|CameraFileStatus *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileType = {"_p_CameraFileType", "enum CameraFileType *|CameraFileType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFolderOperation = {"_p_CameraFolderOperation", "enum CameraFolderOperation *|CameraFolderOperation *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraOperation = {"_p_CameraOperation", "enum CameraOperation *|CameraOperation *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraStorageAccessType = {"_p_CameraStorageAccessType", "enum CameraStorageAccessType *|CameraStorageAccessType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraStorageFilesystemType = {"_p_CameraStorageFilesystemType", "enum CameraStorageFilesystemType *|CameraStorageFilesystemType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraStorageInfoFields = {"_p_CameraStorageInfoFields", "enum CameraStorageInfoFields *|CameraStorageInfoFields *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraStorageType = {"_p_CameraStorageType", "enum CameraStorageType *|CameraStorageType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFilePermissions = {"_p_CameraFilePermissions", "CameraFilePermissions *|enum CameraFilePermissions *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileStatus = {"_p_CameraFileStatus", "CameraFileStatus *|enum CameraFileStatus *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileType = {"_p_CameraFileType", "CameraFileType *|enum CameraFileType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFolderOperation = {"_p_CameraFolderOperation", "CameraFolderOperation *|enum CameraFolderOperation *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraOperation = {"_p_CameraOperation", "CameraOperation *|enum CameraOperation *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraStorageAccessType = {"_p_CameraStorageAccessType", "CameraStorageAccessType *|enum CameraStorageAccessType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraStorageFilesystemType = {"_p_CameraStorageFilesystemType", "CameraStorageFilesystemType *|enum CameraStorageFilesystemType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraStorageInfoFields = {"_p_CameraStorageInfoFields", "CameraStorageInfoFields *|enum CameraStorageInfoFields *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraStorageType = {"_p_CameraStorageType", "CameraStorageType *|enum CameraStorageType *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_CameraText = {"_p_CameraText", "CameraText *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraWidgetType = {"_p_CameraWidgetType", "enum CameraWidgetType *|CameraWidgetType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_GPLogLevel = {"_p_GPLogLevel", "enum GPLogLevel *|GPLogLevel *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_GPPortType = {"_p_GPPortType", "enum GPPortType *|GPPortType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_GPVersionVerbosity = {"_p_GPVersionVerbosity", "enum GPVersionVerbosity *|GPVersionVerbosity *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_GphotoDeviceType = {"_p_GphotoDeviceType", "enum GphotoDeviceType *|GphotoDeviceType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraWidgetType = {"_p_CameraWidgetType", "CameraWidgetType *|enum CameraWidgetType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GPLogLevel = {"_p_GPLogLevel", "GPLogLevel *|enum GPLogLevel *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GPPortType = {"_p_GPPortType", "GPPortType *|enum GPPortType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GPVersionVerbosity = {"_p_GPVersionVerbosity", "GPVersionVerbosity *|enum GPVersionVerbosity *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GphotoDeviceType = {"_p_GphotoDeviceType", "GphotoDeviceType *|enum GphotoDeviceType *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_SwigPyObject = {"_p_SwigPyObject", "SwigPyObject *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__Camera = {"_p__Camera", "struct _Camera *|Camera *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraAbilitiesList = {"_p__CameraAbilitiesList", "struct _CameraAbilitiesList *|CameraAbilitiesList *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFile = {"_p__CameraFile", "struct _CameraFile *|CameraFile *|_CameraFile *", 0, 0, (void*)&SwigPyBuiltin___CameraFile_clientdata, 0};
-static swig_type_info _swigt__p__CameraFileHandler = {"_p__CameraFileHandler", "struct _CameraFileHandler *|CameraFileHandler *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFileInfo = {"_p__CameraFileInfo", "struct _CameraFileInfo *|CameraFileInfo *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFileInfoAudio = {"_p__CameraFileInfoAudio", "struct _CameraFileInfoAudio *|CameraFileInfoAudio *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFileInfoFile = {"_p__CameraFileInfoFile", "struct _CameraFileInfoFile *|CameraFileInfoFile *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFileInfoPreview = {"_p__CameraFileInfoPreview", "struct _CameraFileInfoPreview *|CameraFileInfoPreview *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFilesystem = {"_p__CameraFilesystem", "struct _CameraFilesystem *|CameraFilesystem *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFilesystemFuncs = {"_p__CameraFilesystemFuncs", "struct _CameraFilesystemFuncs *|CameraFilesystemFuncs *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFunctions = {"_p__CameraFunctions", "struct _CameraFunctions *|CameraFunctions *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraList = {"_p__CameraList", "struct _CameraList *|CameraList *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraPrivateCore = {"_p__CameraPrivateCore", "struct _CameraPrivateCore *|CameraPrivateCore *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraPrivateLibrary = {"_p__CameraPrivateLibrary", "struct _CameraPrivateLibrary *|CameraPrivateLibrary *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraStorageInformation = {"_p__CameraStorageInformation", "struct _CameraStorageInformation *|CameraStorageInformation *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraWidget = {"_p__CameraWidget", "struct _CameraWidget *|CameraWidget *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__GPContext = {"_p__GPContext", "struct _GPContext *|GPContext *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__GPContextFeedback = {"_p__GPContextFeedback", "enum _GPContextFeedback *|GPContextFeedback *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__Camera = {"_p__Camera", "Camera *|struct _Camera *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraAbilitiesList = {"_p__CameraAbilitiesList", "CameraAbilitiesList *|struct _CameraAbilitiesList *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFile = {"_p__CameraFile", "CameraFile *|struct _CameraFile *|_CameraFile *", 0, 0, (void*)&SwigPyBuiltin___CameraFile_clientdata, 0};
+static swig_type_info _swigt__p__CameraFileHandler = {"_p__CameraFileHandler", "CameraFileHandler *|struct _CameraFileHandler *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFileInfo = {"_p__CameraFileInfo", "CameraFileInfo *|struct _CameraFileInfo *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFileInfoAudio = {"_p__CameraFileInfoAudio", "CameraFileInfoAudio *|struct _CameraFileInfoAudio *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFileInfoFile = {"_p__CameraFileInfoFile", "CameraFileInfoFile *|struct _CameraFileInfoFile *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFileInfoPreview = {"_p__CameraFileInfoPreview", "CameraFileInfoPreview *|struct _CameraFileInfoPreview *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFilesystem = {"_p__CameraFilesystem", "CameraFilesystem *|struct _CameraFilesystem *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFilesystemFuncs = {"_p__CameraFilesystemFuncs", "CameraFilesystemFuncs *|struct _CameraFilesystemFuncs *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFunctions = {"_p__CameraFunctions", "CameraFunctions *|struct _CameraFunctions *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraList = {"_p__CameraList", "CameraList *|struct _CameraList *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraPrivateCore = {"_p__CameraPrivateCore", "CameraPrivateCore *|struct _CameraPrivateCore *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraPrivateLibrary = {"_p__CameraPrivateLibrary", "CameraPrivateLibrary *|struct _CameraPrivateLibrary *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraStorageInformation = {"_p__CameraStorageInformation", "CameraStorageInformation *|struct _CameraStorageInformation *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraWidget = {"_p__CameraWidget", "CameraWidget *|struct _CameraWidget *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__GPContext = {"_p__GPContext", "GPContext *|struct _GPContext *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__GPContextFeedback = {"_p__GPContextFeedback", "GPContextFeedback *|enum _GPContextFeedback *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p__GPPortInfo = {"_p__GPPortInfo", "_GPPortInfo *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__GPPortInfoList = {"_p__GPPortInfoList", "struct _GPPortInfoList *|GPPortInfoList *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__GPPortInfoList = {"_p__GPPortInfoList", "GPPortInfoList *|struct _GPPortInfoList *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_int = {"_p_int", "intptr_t *|int *|int_least32_t *|int_fast32_t *|int32_t *|int_fast16_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_long = {"_p_long", "long *|time_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_long_long = {"_p_long_long", "int_least64_t *|int_fast64_t *|int64_t *|long long *|intmax_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_p__CameraFile = {"_p_p__CameraFile", "struct _CameraFile **|CameraFile **", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_int = {"_p_int", "int32_t *|int_fast16_t *|int_fast32_t *|int_least32_t *|intptr_t *|int *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_long = {"_p_long", "time_t *|long *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_long_long = {"_p_long_long", "int64_t *|int_fast64_t *|int_least64_t *|intmax_t *|long long *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_p__CameraFile = {"_p_p__CameraFile", "CameraFile **|struct _CameraFile **", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_p_char = {"_p_p_char", "char **", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_short = {"_p_short", "short *|int_least16_t *|int16_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_signed_char = {"_p_signed_char", "signed char *|int_least8_t *|int_fast8_t *|int8_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_unsigned_char = {"_p_unsigned_char", "unsigned char *|uint_least8_t *|uint_fast8_t *|uint8_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_unsigned_int = {"_p_unsigned_int", "uintptr_t *|uint_least32_t *|uint_fast32_t *|uint32_t *|unsigned int *|uint_fast16_t *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_short = {"_p_short", "int16_t *|int_least16_t *|short *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_signed_char = {"_p_signed_char", "int8_t *|int_fast8_t *|int_least8_t *|signed char *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_unsigned_char = {"_p_unsigned_char", "uint8_t *|uint_fast8_t *|uint_least8_t *|unsigned char *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_unsigned_int = {"_p_unsigned_int", "uint32_t *|uint_fast16_t *|uint_fast32_t *|uint_least32_t *|uintptr_t *|unsigned int *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_unsigned_long = {"_p_unsigned_long", "unsigned long *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_unsigned_long_long = {"_p_unsigned_long_long", "uint_least64_t *|uint_fast64_t *|uint64_t *|unsigned long long *|uintmax_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_unsigned_short = {"_p_unsigned_short", "unsigned short *|uint_least16_t *|uint16_t *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_unsigned_long_long = {"_p_unsigned_long_long", "uint64_t *|uint_fast64_t *|uint_least64_t *|uintmax_t *|unsigned long long *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_unsigned_short = {"_p_unsigned_short", "uint16_t *|uint_least16_t *|unsigned short *", 0, 0, (void*)0, 0};
 
 static swig_type_info *swig_type_initial[] = {
   &_swigt__p_CameraAbilities,
   &_swigt__p_CameraCaptureType,
   &_swigt__p_CameraDriverStatus,
   &_swigt__p_CameraEventType,
   &_swigt__p_CameraFileAccessType,
@@ -7106,17 +6915,20 @@
 #endif
 #endif
 
 #if 0
 #define SWIGRUNTIME_DEBUG
 #endif
 
+#ifndef SWIG_INIT_CLIENT_DATA_TYPE
+#define SWIG_INIT_CLIENT_DATA_TYPE void *
+#endif
 
 SWIGRUNTIME void
-SWIG_InitializeModule(void *clientdata) {
+SWIG_InitializeModule(SWIG_INIT_CLIENT_DATA_TYPE clientdata) {
   size_t i;
   swig_module_info *module_head, *iter;
   int init;
   
   /* check to see if the circular list has been setup, if not, set it up */
   if (swig_module.next==0) {
     /* Initialize the swig_module */
@@ -7291,228 +7103,14 @@
 
 
 
 #ifdef __cplusplus
 extern "C" {
 #endif
   
-  /* Python-specific SWIG API */
-#define SWIG_newvarlink()                             SWIG_Python_newvarlink()
-#define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
-#define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)
-  
-  /* -----------------------------------------------------------------------------
-   * global variable support code.
-   * ----------------------------------------------------------------------------- */
-  
-  typedef struct swig_globalvar {
-    char       *name;                  /* Name of global variable */
-    PyObject *(*get_attr)(void);       /* Return the current value */
-    int       (*set_attr)(PyObject *); /* Set the value */
-    struct swig_globalvar *next;
-  } swig_globalvar;
-  
-  typedef struct swig_varlinkobject {
-    PyObject_HEAD
-    swig_globalvar *vars;
-  } swig_varlinkobject;
-  
-  SWIGINTERN PyObject *
-  swig_varlink_repr(swig_varlinkobject *SWIGUNUSEDPARM(v)) {
-#if PY_VERSION_HEX >= 0x03000000
-    return PyUnicode_InternFromString("<Swig global variables>");
-#else
-    return PyString_FromString("<Swig global variables>");
-#endif
-  }
-  
-  SWIGINTERN PyObject *
-  swig_varlink_str(swig_varlinkobject *v) {
-#if PY_VERSION_HEX >= 0x03000000
-    PyObject *str = PyUnicode_InternFromString("(");
-    PyObject *tail;
-    PyObject *joined;
-    swig_globalvar *var;
-    for (var = v->vars; var; var=var->next) {
-      tail = PyUnicode_FromString(var->name);
-      joined = PyUnicode_Concat(str, tail);
-      Py_DecRef(str);
-      Py_DecRef(tail);
-      str = joined;
-      if (var->next) {
-        tail = PyUnicode_InternFromString(", ");
-        joined = PyUnicode_Concat(str, tail);
-        Py_DecRef(str);
-        Py_DecRef(tail);
-        str = joined;
-      }
-    }
-    tail = PyUnicode_InternFromString(")");
-    joined = PyUnicode_Concat(str, tail);
-    Py_DecRef(str);
-    Py_DecRef(tail);
-    str = joined;
-#else
-    PyObject *str = PyString_FromString("(");
-    swig_globalvar *var;
-    for (var = v->vars; var; var=var->next) {
-      PyString_ConcatAndDel(&str,PyString_FromString(var->name));
-      if (var->next) PyString_ConcatAndDel(&str,PyString_FromString(", "));
-    }
-    PyString_ConcatAndDel(&str,PyString_FromString(")"));
-#endif
-    return str;
-  }
-  
-  SWIGINTERN void
-  swig_varlink_dealloc(swig_varlinkobject *v) {
-    swig_globalvar *var = v->vars;
-    while (var) {
-      swig_globalvar *n = var->next;
-      free(var->name);
-      free(var);
-      var = n;
-    }
-  }
-  
-  SWIGINTERN PyObject *
-  swig_varlink_getattr(swig_varlinkobject *v, char *n) {
-    PyObject *res = NULL;
-    swig_globalvar *var = v->vars;
-    while (var) {
-      if (strcmp(var->name,n) == 0) {
-        res = (*var->get_attr)();
-        break;
-      }
-      var = var->next;
-    }
-    if (res == NULL && !PyErr_Occurred()) {
-      PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
-    }
-    return res;
-  }
-  
-  SWIGINTERN int
-  swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
-    int res = 1;
-    swig_globalvar *var = v->vars;
-    while (var) {
-      if (strcmp(var->name,n) == 0) {
-        res = (*var->set_attr)(p);
-        break;
-      }
-      var = var->next;
-    }
-    if (res == 1 && !PyErr_Occurred()) {
-      PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
-    }
-    return res;
-  }
-  
-  SWIGINTERN PyTypeObject*
-  swig_varlink_type(void) {
-    static char varlink__doc__[] = "Swig var link object";
-    static PyTypeObject varlink_type;
-    static int type_init = 0;
-    if (!type_init) {
-      const PyTypeObject tmp = {
-#if PY_VERSION_HEX >= 0x03000000
-        PyVarObject_HEAD_INIT(NULL, 0)
-#else
-        PyObject_HEAD_INIT(NULL)
-        0,                                  /* ob_size */
-#endif
-        "swigvarlink",                      /* tp_name */
-        sizeof(swig_varlinkobject),         /* tp_basicsize */
-        0,                                  /* tp_itemsize */
-        (destructor) swig_varlink_dealloc,  /* tp_dealloc */
-        0,                                  /* tp_print */
-        (getattrfunc) swig_varlink_getattr, /* tp_getattr */
-        (setattrfunc) swig_varlink_setattr, /* tp_setattr */
-        0,                                  /* tp_compare */
-        (reprfunc) swig_varlink_repr,       /* tp_repr */
-        0,                                  /* tp_as_number */
-        0,                                  /* tp_as_sequence */
-        0,                                  /* tp_as_mapping */
-        0,                                  /* tp_hash */
-        0,                                  /* tp_call */
-        (reprfunc) swig_varlink_str,        /* tp_str */
-        0,                                  /* tp_getattro */
-        0,                                  /* tp_setattro */
-        0,                                  /* tp_as_buffer */
-        0,                                  /* tp_flags */
-        varlink__doc__,                     /* tp_doc */
-        0,                                  /* tp_traverse */
-        0,                                  /* tp_clear */
-        0,                                  /* tp_richcompare */
-        0,                                  /* tp_weaklistoffset */
-        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
-        0,                                  /* tp_del */
-        0,                                  /* tp_version_tag */
-#if PY_VERSION_HEX >= 0x03040000
-        0,                                  /* tp_finalize */
-#endif
-#if PY_VERSION_HEX >= 0x03080000
-        0,                                  /* tp_vectorcall */
-#endif
-#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
-        0,                                  /* tp_print */
-#endif
-#ifdef COUNT_ALLOCS
-        0,                                  /* tp_allocs */
-        0,                                  /* tp_frees */
-        0,                                  /* tp_maxalloc */
-        0,                                  /* tp_prev */
-        0                                   /* tp_next */
-#endif
-      };
-      varlink_type = tmp;
-      type_init = 1;
-      if (PyType_Ready(&varlink_type) < 0)
-      return NULL;
-    }
-    return &varlink_type;
-  }
-  
-  /* Create a variable linking object for use later */
-  SWIGINTERN PyObject *
-  SWIG_Python_newvarlink(void) {
-    swig_varlinkobject *result = PyObject_NEW(swig_varlinkobject, swig_varlink_type());
-    if (result) {
-      result->vars = 0;
-    }
-    return ((PyObject*) result);
-  }
-  
-  SWIGINTERN void 
-  SWIG_Python_addvarlink(PyObject *p, const char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
-    swig_varlinkobject *v = (swig_varlinkobject *) p;
-    swig_globalvar *gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
-    if (gv) {
-      size_t size = strlen(name)+1;
-      gv->name = (char *)malloc(size);
-      if (gv->name) {
-        memcpy(gv->name, name, size);
-        gv->get_attr = get_attr;
-        gv->set_attr = set_attr;
-        gv->next = v->vars;
-      }
-    }
-    v->vars = gv;
-  }
-  
-  SWIGINTERN PyObject *
-  SWIG_globals(void) {
-    static PyObject *globals = 0;
-    if (!globals) {
-      globals = SWIG_newvarlink();
-    }
-    return globals;
-  }
-  
   /* -----------------------------------------------------------------------------
    * constants/methods manipulation
    * ----------------------------------------------------------------------------- */
   
   /* Install Constants */
   SWIGINTERN void
   SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
@@ -7533,31 +7131,28 @@
       if (obj) {
         PyDict_SetItemString(d, constants[i].name, obj);
         Py_DECREF(obj);
       }
     }
   }
   
-  /* -----------------------------------------------------------------------------*/
-  /* Fix SwigMethods to carry the callback ptrs when needed */
-  /* -----------------------------------------------------------------------------*/
+  /* -----------------------------------------------------------------------------
+   * Patch %callback methods' docstrings to hold the callback ptrs
+   * -----------------------------------------------------------------------------*/
   
   SWIGINTERN void
-  SWIG_Python_FixMethods(PyMethodDef *methods,
-    swig_const_info *const_table,
-    swig_type_info **types,
-    swig_type_info **types_initial) {
+  SWIG_Python_FixMethods(PyMethodDef *methods, const swig_const_info *const_table, swig_type_info **types, swig_type_info **types_initial) {
     size_t i;
     for (i = 0; methods[i].ml_name; ++i) {
       const char *c = methods[i].ml_doc;
       if (!c) continue;
       c = strstr(c, "swig_ptr: ");
       if (c) {
         int j;
-        swig_const_info *ci = 0;
+        const swig_const_info *ci = 0;
         const char *name = c + 10;
         for (j = 0; const_table[j].type; ++j) {
           if (strncmp(const_table[j].name, name, 
               strlen(const_table[j].name)) == 0) {
             ci = &(const_table[j]);
             break;
           }
@@ -7581,76 +7176,21 @@
             }
           }
         }
       }
     }
   } 
   
-  /* -----------------------------------------------------------------------------
-   * Method creation and docstring support functions
-   * ----------------------------------------------------------------------------- */
-  
-  /* -----------------------------------------------------------------------------
-   * Function to find the method definition with the correct docstring for the
-   * proxy module as opposed to the low-level API
-   * ----------------------------------------------------------------------------- */
-  
-  SWIGINTERN PyMethodDef *SWIG_PythonGetProxyDoc(const char *name) {
-    /* Find the function in the modified method table */
-    size_t offset = 0;
-    int found = 0;
-    while (SwigMethods_proxydocs[offset].ml_meth != NULL) {
-      if (strcmp(SwigMethods_proxydocs[offset].ml_name, name) == 0) {
-        found = 1;
-        break;
-      }
-      offset++;
-    }
-    /* Use the copy with the modified docstring if available */
-    return found ? &SwigMethods_proxydocs[offset] : NULL;
-  }
-  
-  /* -----------------------------------------------------------------------------
-   * Wrapper of PyInstanceMethod_New() used in Python 3
-   * It is exported to the generated module, used for -fastproxy
-   * ----------------------------------------------------------------------------- */
-  
-  SWIGINTERN PyObject *SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func) {
-    if (PyCFunction_Check(func)) {
-      PyCFunctionObject *funcobj = (PyCFunctionObject *)func;
-      PyMethodDef *ml = SWIG_PythonGetProxyDoc(funcobj->m_ml->ml_name);
-      if (ml)
-      func = PyCFunction_NewEx(ml, funcobj->m_self, funcobj->m_module);
-    }
-#if PY_VERSION_HEX >= 0x03000000
-    return PyInstanceMethod_New(func);
-#else
-    return PyMethod_New(func, NULL, NULL);
-#endif
-  }
-  
-  /* -----------------------------------------------------------------------------
-   * Wrapper of PyStaticMethod_New()
-   * It is exported to the generated module, used for -fastproxy
-   * ----------------------------------------------------------------------------- */
-  
-  SWIGINTERN PyObject *SWIG_PyStaticMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func) {
-    if (PyCFunction_Check(func)) {
-      PyCFunctionObject *funcobj = (PyCFunctionObject *)func;
-      PyMethodDef *ml = SWIG_PythonGetProxyDoc(funcobj->m_ml->ml_name);
-      if (ml)
-      func = PyCFunction_NewEx(ml, funcobj->m_self, funcobj->m_module);
-    }
-    return PyStaticMethod_New(func);
-  }
-  
 #ifdef __cplusplus
 }
 #endif
 
+
+
+
 /* -----------------------------------------------------------------------------*
  *  Partial Init method
  * -----------------------------------------------------------------------------*/
 
 #ifdef __cplusplus
 extern "C"
 #endif
```

### Comparing `gphoto2-2.3.4/src/swig-gp2.5.30/filesys_wrap.c` & `gphoto2-2.3.5/src/swig-gp2_5_30/filesys_wrap.c`

 * *Files 3% similar despite different names*

```diff
@@ -1,24 +1,21 @@
 /* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 4.0.2
+ * This file was automatically generated by SWIG (https://www.swig.org).
+ * Version 4.1.1
  *
- * This file is not intended to be easily readable and contains a number of
- * coding conventions designed to improve portability and efficiency. Do not make
- * changes to this file unless you know what you are doing--modify the SWIG
- * interface file instead.
+ * Do not make changes to this file unless you know what you are doing - modify
+ * the SWIG interface file instead.
  * ----------------------------------------------------------------------------- */
 
 
-#ifndef SWIGPYTHON
+#define SWIG_VERSION 0x040101
 #define SWIGPYTHON
-#endif
-
 #define SWIG_PYTHON_DIRECTOR_NO_VTABLE
 #define SWIGPYTHON_BUILTIN
+#define SWIGPYTHON_FASTPROXY
 
 /* -----------------------------------------------------------------------------
  *  This section contains generic SWIG labels for method/variable
  *  declarations/attributes, and other compiler dependent labels.
  * ----------------------------------------------------------------------------- */
 
 /* template workaround for compilers that cannot correctly implement the C++ standard */
@@ -142,23 +139,45 @@
 
 
 #if defined(__GNUC__) && defined(_WIN32) && !defined(SWIG_PYTHON_NO_HYPOT_WORKAROUND)
 /* Workaround for '::hypot' has not been declared', see https://bugs.python.org/issue11566 */
 # include <math.h>
 #endif
 
+#if !defined(PY_SSIZE_T_CLEAN) && !defined(SWIG_NO_PY_SSIZE_T_CLEAN)
+#define PY_SSIZE_T_CLEAN
+#endif
+
+#if __GNUC__ >= 7
+#pragma GCC diagnostic push
+#if defined(__cplusplus) && __cplusplus >=201703L
+#pragma GCC diagnostic ignored "-Wregister" /* For python-2.7 headers that use register */
+#endif
+#endif
+
 #if defined(_DEBUG) && defined(SWIG_PYTHON_INTERPRETER_NO_DEBUG)
 /* Use debug wrappers with the Python release dll */
+
+#if defined(_MSC_VER) && _MSC_VER >= 1929
+/* Workaround compilation errors when redefining _DEBUG in MSVC 2019 version 16.10 and later
+ * See https://github.com/swig/swig/issues/2090 */
+# include <corecrt.h>
+#endif
+
 # undef _DEBUG
 # include <Python.h>
 # define _DEBUG 1
 #else
 # include <Python.h>
 #endif
 
+#if __GNUC__ >= 7
+#pragma GCC diagnostic pop
+#endif
+
 /* -----------------------------------------------------------------------------
  * swigrun.swg
  *
  * This file contains generic C API SWIG runtime support for pointer
  * type checking.
  * ----------------------------------------------------------------------------- */
 
@@ -197,14 +216,16 @@
 # define SWIG_BUFFER_SIZE 1024
 #endif
 
 /* Flags for pointer conversions */
 #define SWIG_POINTER_DISOWN        0x1
 #define SWIG_CAST_NEW_MEMORY       0x2
 #define SWIG_POINTER_NO_NULL       0x4
+#define SWIG_POINTER_CLEAR         0x8
+#define SWIG_POINTER_RELEASE       (SWIG_POINTER_CLEAR | SWIG_POINTER_DISOWN)
 
 /* Flags for new pointer objects */
 #define SWIG_POINTER_OWN           0x1
 
 
 /*
    Flags/methods for returning states.
@@ -268,44 +289,50 @@
       }
 
    Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
    more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
    SWIG errors code.
 
    Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
-   allows to return the 'cast rank', for example, if you have this
+   allows returning the 'cast rank', for example, if you have this
 
        int food(double)
        int fooi(int);
 
    and you call
 
       food(1)   // cast rank '1'  (1 -> 1.0)
       fooi(1)   // cast rank '0'
 
    just use the SWIG_AddCast()/SWIG_CheckState()
 */
 
 #define SWIG_OK                    (0)
+/* Runtime errors are < 0 */
 #define SWIG_ERROR                 (-1)
+/* Errors in range -1 to -99 are in swigerrors.swg (errors for all languages including those not using the runtime) */
+/* Errors in range -100 to -199 are language specific errors defined in *errors.swg */
+/* Errors < -200 are generic runtime specific errors */
+#define SWIG_ERROR_RELEASE_NOT_OWNED (-200)
+
 #define SWIG_IsOK(r)               (r >= 0)
 #define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)
 
 /* The CastRankLimit says how many bits are used for the cast rank */
 #define SWIG_CASTRANKLIMIT         (1 << 8)
 /* The NewMask denotes the object was created (using new/malloc) */
 #define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
 /* The TmpMask is for in/out typemaps that use temporal objects */
 #define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
 /* Simple returning values */
 #define SWIG_BADOBJ                (SWIG_ERROR)
 #define SWIG_OLDOBJ                (SWIG_OK)
 #define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
 #define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
-/* Check, add and del mask methods */
+/* Check, add and del object mask methods */
 #define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
 #define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
 #define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
 #define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
 #define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
 #define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))
 
@@ -443,15 +470,15 @@
   return 0;
 }
 
 /*
   Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
 */
 SWIGRUNTIME swig_cast_info *
-SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty) {
+SWIG_TypeCheckStruct(const swig_type_info *from, swig_type_info *ty) {
   if (ty) {
     swig_cast_info *iter = ty->cast;
     while (iter) {
       if (iter->type == from) {
         if (iter == ty->cast)
           return iter;
         /* Move iter to the top of the linked list */
@@ -503,17 +530,17 @@
 /*
   Return the pretty name associated with this type,
   that is an unmangled type name in a form presentable to the user.
 */
 SWIGRUNTIME const char *
 SWIG_TypePrettyName(const swig_type_info *type) {
   /* The "str" field contains the equivalent pretty names of the
-     type, separated by vertical-bar characters.  We choose
-     to print the last name, as it is often (?) the most
-     specific. */
+     type, separated by vertical-bar characters.  Choose the last
+     name. It should be the most specific; a fully resolved name
+     but not necessarily with default template parameters expanded. */
   if (!type) return NULL;
   if (type->str != NULL) {
     const char *last_name = type->str;
     const char *s;
     for (s = type->str; *s; s++)
       if (*s == '|') last_name = s+1;
     return last_name;
@@ -725,15 +752,15 @@
   return SWIG_UnpackData(++c,ptr,sz);
 }
 
 #ifdef __cplusplus
 }
 #endif
 
-/*  Errors in SWIG */
+/* SWIG Errors applicable to all language modules, values are reserved from -1 to -99 */
 #define  SWIG_UnknownError    	   -1
 #define  SWIG_IOError        	   -2
 #define  SWIG_RuntimeError   	   -3
 #define  SWIG_IndexError     	   -4
 #define  SWIG_TypeError      	   -5
 #define  SWIG_DivisionByZero 	   -6
 #define  SWIG_OverflowError  	   -7
@@ -741,15 +768,14 @@
 #define  SWIG_ValueError     	   -9
 #define  SWIG_SystemError    	   -10
 #define  SWIG_AttributeError 	   -11
 #define  SWIG_MemoryError    	   -12
 #define  SWIG_NullReferenceError   -13
 
 
-
 /* Compatibility macros for Python 3 */
 #if PY_VERSION_HEX >= 0x03000000
 
 #define PyClass_Check(obj) PyObject_IsInstance(obj, (PyObject *)&PyType_Type)
 #define PyInt_Check(x) PyLong_Check(x)
 #define PyInt_AsLong(x) PyLong_AsLong(x)
 #define PyInt_FromLong(x) PyLong_FromLong(x)
@@ -757,15 +783,14 @@
 #define PyString_Check(name) PyBytes_Check(name)
 #define PyString_FromString(x) PyUnicode_FromString(x)
 #define PyString_Format(fmt, args)  PyUnicode_Format(fmt, args)
 #define PyString_AsString(str) PyBytes_AsString(str)
 #define PyString_Size(str) PyBytes_Size(str)	
 #define PyString_InternFromString(key) PyUnicode_InternFromString(key)
 #define Py_TPFLAGS_HAVE_CLASS Py_TPFLAGS_BASETYPE
-#define PyString_AS_STRING(x) PyUnicode_AS_STRING(x)
 #define _PyLong_FromSsize_t(x) PyLong_FromSsize_t(x)
 
 #endif
 
 #ifndef Py_TYPE
 #  define Py_TYPE(op) ((op)->ob_type)
 #endif
@@ -775,46 +800,27 @@
 #if PY_VERSION_HEX >= 0x03000000
 #  define SWIG_Python_str_FromFormat PyUnicode_FromFormat
 #else
 #  define SWIG_Python_str_FromFormat PyString_FromFormat
 #endif
 
 
-/* Warning: This function will allocate a new string in Python 3,
- * so please call SWIG_Python_str_DelForPy3(x) to free the space.
- */
 SWIGINTERN char*
 SWIG_Python_str_AsChar(PyObject *str)
 {
 #if PY_VERSION_HEX >= 0x03030000
   return (char *)PyUnicode_AsUTF8(str);
-#elif PY_VERSION_HEX >= 0x03000000
-  char *newstr = 0;
-  str = PyUnicode_AsUTF8String(str);
-  if (str) {
-    char *cstr;
-    Py_ssize_t len;
-    if (PyBytes_AsStringAndSize(str, &cstr, &len) != -1) {
-      newstr = (char *) malloc(len+1);
-      if (newstr)
-        memcpy(newstr, cstr, len+1);
-    }
-    Py_XDECREF(str);
-  }
-  return newstr;
 #else
   return PyString_AsString(str);
 #endif
 }
 
-#if PY_VERSION_HEX >= 0x03030000 || PY_VERSION_HEX < 0x03000000
-#  define SWIG_Python_str_DelForPy3(x)
-#else
-#  define SWIG_Python_str_DelForPy3(x) free( (void*) (x) )
-#endif
+/* Was useful for Python 3.0.x-3.2.x - now provided only for compatibility
+ * with any uses in user interface files. */
+#define SWIG_Python_str_DelForPy3(x)
 
 
 SWIGINTERN PyObject*
 SWIG_Python_str_FromChar(const char *c)
 {
 #if PY_VERSION_HEX >= 0x03000000
   return PyUnicode_FromString(c); 
@@ -823,18 +829,22 @@
 #endif
 }
 
 #ifndef PyObject_DEL
 # define PyObject_DEL PyObject_Del
 #endif
 
-// SWIGPY_USE_CAPSULE is no longer used within SWIG itself, but some user
-// interface files check for it.
+/* SWIGPY_USE_CAPSULE is no longer used within SWIG itself, but some user interface files check for it. */
 # define SWIGPY_USE_CAPSULE
-# define SWIGPY_CAPSULE_NAME ("swig_runtime_data" SWIG_RUNTIME_VERSION ".type_pointer_capsule" SWIG_TYPE_TABLE_NAME)
+#ifdef SWIGPYTHON_BUILTIN
+# define SWIGPY_CAPSULE_ATTR_NAME "type_pointer_capsule_builtin" SWIG_TYPE_TABLE_NAME
+#else
+# define SWIGPY_CAPSULE_ATTR_NAME "type_pointer_capsule" SWIG_TYPE_TABLE_NAME
+#endif
+# define SWIGPY_CAPSULE_NAME ("swig_runtime_data" SWIG_RUNTIME_VERSION "." SWIGPY_CAPSULE_ATTR_NAME)
 
 #if PY_VERSION_HEX < 0x03020000
 #define PyDescr_TYPE(x) (((PyDescrObject *)(x))->d_type)
 #define PyDescr_NAME(x) (((PyDescrObject *)(x))->d_name)
 #define Py_hash_t long
 #endif
 
@@ -900,15 +910,14 @@
     const char *tmp = SWIG_Python_str_AsChar(old_str);
     PyErr_Clear();
     Py_XINCREF(type);
     if (tmp)
       PyErr_Format(type, "%s %s", tmp, mesg);
     else
       PyErr_Format(type, "%s", mesg);
-    SWIG_Python_str_DelForPy3(tmp);
     Py_DECREF(old_str);
     Py_DECREF(value);
   } else {
     PyErr_SetString(PyExc_RuntimeError, mesg);
   }
 }
 
@@ -931,16 +940,20 @@
     PyObject *type = NULL, *value = NULL, *traceback = NULL;
     PyErr_Fetch(&type, &value, &traceback);
 #if PY_VERSION_HEX >= 0x03000000
     newvalue = PyUnicode_FromFormat("%S\nAdditional information:\n%s", value, message);
 #else
     newvalue = PyString_FromFormat("%s\nAdditional information:\n%s", PyString_AsString(value), message);
 #endif
-    Py_XDECREF(value);
-    PyErr_Restore(type, newvalue, traceback);
+    if (newvalue) {
+      Py_XDECREF(value);
+      PyErr_Restore(type, newvalue, traceback);
+    } else {
+      PyErr_Restore(type, value, traceback);
+    }
   } else {
     /* Raise TypeError using given message */
     PyErr_SetString(PyExc_TypeError, message);
   }
 }
 
 #if defined(SWIG_PYTHON_NO_THREADS)
@@ -949,16 +962,20 @@
 #  endif
 #endif
 #if defined(SWIG_PYTHON_THREADS) /* Threading support is enabled */
 #  if !defined(SWIG_PYTHON_USE_GIL) && !defined(SWIG_PYTHON_NO_USE_GIL)
 #    define SWIG_PYTHON_USE_GIL
 #  endif
 #  if defined(SWIG_PYTHON_USE_GIL) /* Use PyGILState threads calls */
-#    ifndef SWIG_PYTHON_INITIALIZE_THREADS
-#     define SWIG_PYTHON_INITIALIZE_THREADS  PyEval_InitThreads() 
+#    if !defined(SWIG_PYTHON_INITIALIZE_THREADS)
+#      if PY_VERSION_HEX < 0x03070000
+#        define SWIG_PYTHON_INITIALIZE_THREADS PyEval_InitThreads()
+#      else
+#        define SWIG_PYTHON_INITIALIZE_THREADS
+#      endif
 #    endif
 #    ifdef __cplusplus /* C++ code */
        class SWIG_Python_Thread_Block {
          bool status;
          PyGILState_STATE state;
        public:
          void end() { if (status) { PyGILState_Release(state); status = false;} }
@@ -1048,16 +1065,16 @@
  *
  * ----------------------------------------------------------------------------- */
 
 #if PY_VERSION_HEX < 0x02070000 /* 2.7.0 */
 # error "This version of SWIG only supports Python >= 2.7"
 #endif
 
-#if PY_VERSION_HEX >= 0x03000000 && PY_VERSION_HEX < 0x03020000
-# error "This version of SWIG only supports Python 3 >= 3.2"
+#if PY_VERSION_HEX >= 0x03000000 && PY_VERSION_HEX < 0x03030000
+# error "This version of SWIG only supports Python 3 >= 3.3"
 #endif
 
 /* Common SWIG API */
 
 /* for raw pointers */
 #define SWIG_Python_ConvertPtr(obj, pptr, type, flags)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, 0)
 #define SWIG_ConvertPtr(obj, pptr, type, flags)         SWIG_Python_ConvertPtr(obj, pptr, type, flags)
@@ -1164,15 +1181,20 @@
   } else if (result == Py_None) {
     Py_DECREF(result);
     result = obj;
   } else {
     if (!PyList_Check(result)) {
       PyObject *o2 = result;
       result = PyList_New(1);
-      PyList_SetItem(result, 0, o2);
+      if (result) {
+        PyList_SET_ITEM(result, 0, o2);
+      } else {
+        Py_DECREF(obj);
+        return o2;
+      }
     }
     PyList_Append(result,obj);
     Py_DECREF(obj);
   }
   return result;
 }
 
@@ -1246,14 +1268,246 @@
 */
 #ifdef __cplusplus
 #define SWIG_STATIC_POINTER(var)  var
 #else
 #define SWIG_STATIC_POINTER(var)  var = 0; if (!var) var
 #endif
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Python-specific SWIG API */
+#define SWIG_newvarlink()                             SWIG_Python_newvarlink()
+#define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
+#define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)
+ 
+/* -----------------------------------------------------------------------------
+ * global variable support code.
+ * ----------------------------------------------------------------------------- */
+ 
+typedef struct swig_globalvar {   
+  char       *name;                  /* Name of global variable */
+  PyObject *(*get_attr)(void);       /* Return the current value */
+  int       (*set_attr)(PyObject *); /* Set the value */
+  struct swig_globalvar *next;
+} swig_globalvar;
+
+typedef struct swig_varlinkobject {
+  PyObject_HEAD
+  swig_globalvar *vars;
+} swig_varlinkobject;
+
+SWIGINTERN PyObject *
+swig_varlink_repr(PyObject *SWIGUNUSEDPARM(v)) {
+#if PY_VERSION_HEX >= 0x03000000
+  return PyUnicode_InternFromString("<Swig global variables>");
+#else
+  return PyString_FromString("<Swig global variables>");
+#endif
+}
+
+SWIGINTERN PyObject *
+swig_varlink_str(PyObject *o) {
+  swig_varlinkobject *v = (swig_varlinkobject *) o;
+#if PY_VERSION_HEX >= 0x03000000
+  PyObject *str = PyUnicode_InternFromString("(");
+  PyObject *tail;
+  PyObject *joined;
+  swig_globalvar *var;
+  for (var = v->vars; var; var=var->next) {
+    tail = PyUnicode_FromString(var->name);
+    joined = PyUnicode_Concat(str, tail);
+    Py_DecRef(str);
+    Py_DecRef(tail);
+    str = joined;
+    if (var->next) {
+        tail = PyUnicode_InternFromString(", ");
+        joined = PyUnicode_Concat(str, tail);
+        Py_DecRef(str);
+        Py_DecRef(tail);
+        str = joined;
+    }
+  }
+  tail = PyUnicode_InternFromString(")");
+  joined = PyUnicode_Concat(str, tail);
+  Py_DecRef(str);
+  Py_DecRef(tail);
+  str = joined;
+#else
+  PyObject *str = PyString_FromString("(");
+  swig_globalvar *var;
+  for (var = v->vars; var; var=var->next) {
+    PyString_ConcatAndDel(&str,PyString_FromString(var->name));
+    if (var->next) PyString_ConcatAndDel(&str,PyString_FromString(", "));
+  }
+  PyString_ConcatAndDel(&str,PyString_FromString(")"));
+#endif
+  return str;
+}
+
+SWIGINTERN void
+swig_varlink_dealloc(PyObject *o) {
+  swig_varlinkobject *v = (swig_varlinkobject *) o;
+  swig_globalvar *var = v->vars;
+  while (var) {
+    swig_globalvar *n = var->next;
+    free(var->name);
+    free(var);
+    var = n;
+  }
+}
+
+SWIGINTERN PyObject *
+swig_varlink_getattr(PyObject *o, char *n) {
+  swig_varlinkobject *v = (swig_varlinkobject *) o;
+  PyObject *res = NULL;
+  swig_globalvar *var = v->vars;
+  while (var) {
+    if (strcmp(var->name,n) == 0) {
+      res = (*var->get_attr)();
+      break;
+    }
+    var = var->next;
+  }
+  if (res == NULL && !PyErr_Occurred()) {
+    PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
+  }
+  return res;
+}
+
+SWIGINTERN int
+swig_varlink_setattr(PyObject *o, char *n, PyObject *p) {
+  swig_varlinkobject *v = (swig_varlinkobject *) o;
+  int res = 1;
+  swig_globalvar *var = v->vars;
+  while (var) {
+    if (strcmp(var->name,n) == 0) {
+      res = (*var->set_attr)(p);
+      break;
+    }
+    var = var->next;
+  }
+  if (res == 1 && !PyErr_Occurred()) {
+    PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
+  }
+  return res;
+}
+
+SWIGINTERN PyTypeObject*
+swig_varlink_type(void) {
+  static char varlink__doc__[] = "Swig var link object";
+  static PyTypeObject varlink_type;
+  static int type_init = 0;
+  if (!type_init) {
+    const PyTypeObject tmp = {
+#if PY_VERSION_HEX >= 0x03000000
+      PyVarObject_HEAD_INIT(NULL, 0)
+#else
+      PyObject_HEAD_INIT(NULL)
+      0,                                  /* ob_size */
+#endif
+      "swigvarlink",                      /* tp_name */
+      sizeof(swig_varlinkobject),         /* tp_basicsize */
+      0,                                  /* tp_itemsize */
+      (destructor) swig_varlink_dealloc,  /* tp_dealloc */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                       /*tp_print*/
+#else
+      (Py_ssize_t)0,                      /*tp_vectorcall_offset*/
+#endif
+      (getattrfunc) swig_varlink_getattr, /* tp_getattr */
+      (setattrfunc) swig_varlink_setattr, /* tp_setattr */
+      0,                                  /* tp_compare */
+      (reprfunc) swig_varlink_repr,       /* tp_repr */
+      0,                                  /* tp_as_number */
+      0,                                  /* tp_as_sequence */
+      0,                                  /* tp_as_mapping */
+      0,                                  /* tp_hash */
+      0,                                  /* tp_call */
+      (reprfunc) swig_varlink_str,        /* tp_str */
+      0,                                  /* tp_getattro */
+      0,                                  /* tp_setattro */
+      0,                                  /* tp_as_buffer */
+      0,                                  /* tp_flags */
+      varlink__doc__,                     /* tp_doc */
+      0,                                  /* tp_traverse */
+      0,                                  /* tp_clear */
+      0,                                  /* tp_richcompare */
+      0,                                  /* tp_weaklistoffset */
+      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
+      0,                                  /* tp_del */
+      0,                                  /* tp_version_tag */
+#if PY_VERSION_HEX >= 0x03040000
+      0,                                  /* tp_finalize */
+#endif
+#if PY_VERSION_HEX >= 0x03080000
+      0,                                  /* tp_vectorcall */
+#endif
+#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
+      0,                                  /* tp_print */
+#endif
+#ifdef COUNT_ALLOCS
+      0,                                  /* tp_allocs */
+      0,                                  /* tp_frees */
+      0,                                  /* tp_maxalloc */
+      0,                                  /* tp_prev */
+      0                                   /* tp_next */
+#endif
+    };
+    varlink_type = tmp;
+    type_init = 1;
+    if (PyType_Ready(&varlink_type) < 0)
+      return NULL;
+  }
+  return &varlink_type;
+}
+
+/* Create a variable linking object for use later */
+SWIGINTERN PyObject *
+SWIG_Python_newvarlink(void) {
+  swig_varlinkobject *result = PyObject_NEW(swig_varlinkobject, swig_varlink_type());
+  if (result) {
+    result->vars = 0;
+  }
+  return ((PyObject*) result);
+}
+
+SWIGINTERN void 
+SWIG_Python_addvarlink(PyObject *p, const char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
+  swig_varlinkobject *v = (swig_varlinkobject *) p;
+  swig_globalvar *gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
+  if (gv) {
+    size_t size = strlen(name)+1;
+    gv->name = (char *)malloc(size);
+    if (gv->name) {
+      memcpy(gv->name, name, size);
+      gv->get_attr = get_attr;
+      gv->set_attr = set_attr;
+      gv->next = v->vars;
+    }
+  }
+  v->vars = gv;
+}
+
+
+static PyObject *Swig_Globals_global = NULL;
+  
+SWIGINTERN PyObject *
+SWIG_globals(void) {
+  if (Swig_Globals_global == NULL) {
+    Swig_Globals_global = SWIG_newvarlink();
+  }
+  return Swig_Globals_global;
+}
+
+#ifdef __cplusplus
+}
+#endif
+
 /* -----------------------------------------------------------------------------
  * Pointer declarations
  * ----------------------------------------------------------------------------- */
 
 /* Flags for new pointer objects */
 #define SWIG_POINTER_NOSHADOW       (SWIG_POINTER_OWN      << 1)
 #define SWIG_POINTER_NEW            (SWIG_POINTER_NOSHADOW | SWIG_POINTER_OWN)
@@ -1316,52 +1570,59 @@
     SwigPyClientData *data = (SwigPyClientData *)malloc(sizeof(SwigPyClientData));
     /* the klass element */
     data->klass = obj;
     Py_INCREF(data->klass);
     /* the newraw method and newargs arguments used to create a new raw instance */
     if (PyClass_Check(obj)) {
       data->newraw = 0;
-      data->newargs = obj;
       Py_INCREF(obj);
+      data->newargs = obj;
     } else {
       data->newraw = PyObject_GetAttrString(data->klass, "__new__");
       if (data->newraw) {
-	Py_INCREF(data->newraw);
-	data->newargs = PyTuple_New(1);
-	PyTuple_SetItem(data->newargs, 0, obj);
+        data->newargs = PyTuple_New(1);
+        if (data->newargs) {
+          Py_INCREF(obj);
+          PyTuple_SET_ITEM(data->newargs, 0, obj);
+        } else {
+          Py_DECREF(data->newraw);
+          Py_DECREF(data->klass);
+          free(data);
+          return 0;
+        }
       } else {
-	data->newargs = obj;
+        Py_INCREF(obj);
+        data->newargs = obj;
       }
-      Py_INCREF(data->newargs);
     }
     /* the destroy method, aka as the C++ delete method */
     data->destroy = PyObject_GetAttrString(data->klass, "__swig_destroy__");
     if (PyErr_Occurred()) {
       PyErr_Clear();
       data->destroy = 0;
     }
     if (data->destroy) {
-      int flags;
-      Py_INCREF(data->destroy);
-      flags = PyCFunction_GET_FLAGS(data->destroy);
-      data->delargs = !(flags & (METH_O));
+      data->delargs = !(PyCFunction_GET_FLAGS(data->destroy) & METH_O);
     } else {
       data->delargs = 0;
     }
     data->implicitconv = 0;
     data->pytype = 0;
     return data;
   }
 }
 
 SWIGRUNTIME void 
-SwigPyClientData_Del(SwigPyClientData *data) {
+SwigPyClientData_Del(SwigPyClientData *data)
+{
+  Py_XDECREF(data->klass);
   Py_XDECREF(data->newraw);
   Py_XDECREF(data->newargs);
   Py_XDECREF(data->destroy);
+  free(data);
 }
 
 /* =============== SwigPyObject =====================*/
 
 typedef struct {
   PyObject_HEAD
   void *ptr;
@@ -1380,15 +1641,15 @@
 SwigPyObject_get___dict__(PyObject *v, PyObject *SWIGUNUSEDPARM(args))
 {
   SwigPyObject *sobj = (SwigPyObject *)v;
 
   if (!sobj->dict)
     sobj->dict = PyDict_New();
 
-  Py_INCREF(sobj->dict);
+  Py_XINCREF(sobj->dict);
   return sobj->dict;
 }
 
 #endif
 
 SWIGRUNTIME PyObject *
 SwigPyObject_long(SwigPyObject *v)
@@ -1398,26 +1659,29 @@
 
 SWIGRUNTIME PyObject *
 SwigPyObject_format(const char* fmt, SwigPyObject *v)
 {
   PyObject *res = NULL;
   PyObject *args = PyTuple_New(1);
   if (args) {
-    if (PyTuple_SetItem(args, 0, SwigPyObject_long(v)) == 0) {
-      PyObject *ofmt = SWIG_Python_str_FromChar(fmt);
+    PyObject *val = SwigPyObject_long(v);
+    if (val) {
+      PyObject *ofmt;
+      PyTuple_SET_ITEM(args, 0, val);
+      ofmt = SWIG_Python_str_FromChar(fmt);
       if (ofmt) {
 #if PY_VERSION_HEX >= 0x03000000
-	res = PyUnicode_Format(ofmt,args);
+        res = PyUnicode_Format(ofmt,args);
 #else
-	res = PyString_Format(ofmt,args);
+        res = PyString_Format(ofmt,args);
 #endif
-	Py_DECREF(ofmt);
+        Py_DECREF(ofmt);
       }
-      Py_DECREF(args);
     }
+    Py_DECREF(args);
   }
   return res;
 }
 
 SWIGRUNTIME PyObject *
 SwigPyObject_oct(SwigPyObject *v)
 {
@@ -1431,26 +1695,31 @@
 }
 
 SWIGRUNTIME PyObject *
 SwigPyObject_repr(SwigPyObject *v)
 {
   const char *name = SWIG_TypePrettyName(v->ty);
   PyObject *repr = SWIG_Python_str_FromFormat("<Swig Object of type '%s' at %p>", (name ? name : "unknown"), (void *)v);
-  if (v->next) {
+  if (repr && v->next) {
     PyObject *nrep = SwigPyObject_repr((SwigPyObject *)v->next);
+    if (nrep) {
 # if PY_VERSION_HEX >= 0x03000000
-    PyObject *joined = PyUnicode_Concat(repr, nrep);
-    Py_DecRef(repr);
-    Py_DecRef(nrep);
-    repr = joined;
+      PyObject *joined = PyUnicode_Concat(repr, nrep);
+      Py_DecRef(repr);
+      Py_DecRef(nrep);
+      repr = joined;
 # else
-    PyString_ConcatAndDel(&repr,nrep);
+      PyString_ConcatAndDel(&repr,nrep);
 # endif
+    } else {
+      Py_DecRef(repr);
+      repr = NULL;
+    }
   }
-  return repr;  
+  return repr;
 }
 
 /* We need a version taking two PyObject* parameters so it's a valid
  * PyCFunction to use in swigobject_methods[]. */
 SWIGRUNTIME PyObject *
 SwigPyObject_repr2(PyObject *v, PyObject *SWIGUNUSEDPARM(args))
 {
@@ -1512,14 +1781,16 @@
     || (strcmp(Py_TYPE(op)->tp_name,"SwigPyObject") == 0);
 #endif
 }
 
 SWIGRUNTIME PyObject *
 SwigPyObject_New(void *ptr, swig_type_info *ty, int own);
 
+static PyObject* Swig_Capsule_global = NULL;
+
 SWIGRUNTIME void
 SwigPyObject_dealloc(PyObject *v)
 {
   SwigPyObject *sobj = (SwigPyObject *) v;
   PyObject *next = sobj->next;
   if (sobj->own == SWIG_POINTER_OWN) {
     swig_type_info *ty = sobj->ty;
@@ -1538,16 +1809,20 @@
       
       PyObject *type = NULL, *value = NULL, *traceback = NULL;
       PyErr_Fetch(&type, &value, &traceback);
 
       if (data->delargs) {
         /* we need to create a temporary object to carry the destroy operation */
         PyObject *tmp = SwigPyObject_New(sobj->ptr, ty, 0);
-        res = SWIG_Python_CallFunctor(destroy, tmp);
-        Py_DECREF(tmp);
+        if (tmp) {
+          res = SWIG_Python_CallFunctor(destroy, tmp);
+        } else {
+          res = 0;
+        }
+        Py_XDECREF(tmp);
       } else {
         PyCFunction meth = PyCFunction_GET_FUNCTION(destroy);
         PyObject *mself = PyCFunction_GET_SELF(destroy);
         res = ((*meth)(mself, v));
       }
       if (!res)
         PyErr_WriteUnraisable(destroy);
@@ -1558,27 +1833,32 @@
     } 
 #if !defined(SWIG_PYTHON_SILENT_MEMLEAK)
     else {
       const char *name = SWIG_TypePrettyName(ty);
       printf("swig/python detected a memory leak of type '%s', no destructor found.\n", (name ? name : "unknown"));
     }
 #endif
-  } 
+    Py_XDECREF(Swig_Capsule_global);
+  }
   Py_XDECREF(next);
+#ifdef SWIGPYTHON_BUILTIN
+  Py_XDECREF(sobj->dict);
+#endif
   PyObject_DEL(v);
 }
 
 SWIGRUNTIME PyObject* 
 SwigPyObject_append(PyObject* v, PyObject* next)
 {
   SwigPyObject *sobj = (SwigPyObject *) v;
   if (!SwigPyObject_Check(next)) {
     PyErr_SetString(PyExc_TypeError, "Attempt to append a non SwigPyObject");
     return NULL;
   }
+  ((SwigPyObject *)next)->next = sobj->next;
   sobj->next = next;
   Py_INCREF(next);
   return SWIG_Py_Void();
 }
 
 SWIGRUNTIME PyObject* 
 SwigPyObject_next(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
@@ -1615,17 +1895,17 @@
   if (!PyArg_UnpackTuple(args, "own", 0, 1, &val)) {
     return NULL;
   } else {
     SwigPyObject *sobj = (SwigPyObject *)v;
     PyObject *obj = PyBool_FromLong(sobj->own);
     if (val) {
       if (PyObject_IsTrue(val)) {
-        SwigPyObject_acquire(v,args);
+        Py_DECREF(SwigPyObject_acquire(v,args));
       } else {
-        SwigPyObject_disown(v,args);
+        Py_DECREF(SwigPyObject_disown(v,args));
       }
     } 
     return obj;
   }
 }
 
 static PyMethodDef
@@ -1697,15 +1977,19 @@
       PyObject_HEAD_INIT(NULL)
       0,                                    /* ob_size */
 #endif
       "SwigPyObject",                       /* tp_name */
       sizeof(SwigPyObject),                 /* tp_basicsize */
       0,                                    /* tp_itemsize */
       (destructor)SwigPyObject_dealloc,     /* tp_dealloc */
-      0,                                    /* tp_print */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                         /*tp_print*/
+#else
+      (Py_ssize_t)0,                        /*tp_vectorcall_offset*/
+#endif
       (getattrfunc)0,                       /* tp_getattr */
       (setattrfunc)0,                       /* tp_setattr */
 #if PY_VERSION_HEX >= 0x03000000
       0, /* tp_reserved in 3.0.1, tp_compare in 3.0.0 but not used */
 #else
       (cmpfunc)SwigPyObject_compare,        /* tp_compare */
 #endif
@@ -1762,29 +2046,38 @@
       0,                                    /* tp_maxalloc */
       0,                                    /* tp_prev */
       0                                     /* tp_next */
 #endif
     };
     swigpyobject_type = tmp;
     type_init = 1;
-    if (PyType_Ready(&swigpyobject_type) < 0)
+    if (PyType_Ready(&swigpyobject_type) != 0)
       return NULL;
   }
   return &swigpyobject_type;
 }
 
 SWIGRUNTIME PyObject *
 SwigPyObject_New(void *ptr, swig_type_info *ty, int own)
 {
   SwigPyObject *sobj = PyObject_NEW(SwigPyObject, SwigPyObject_type());
   if (sobj) {
     sobj->ptr  = ptr;
     sobj->ty   = ty;
     sobj->own  = own;
     sobj->next = 0;
+#ifdef SWIGPYTHON_BUILTIN
+    sobj->dict = 0;
+#endif
+    if (own == SWIG_POINTER_OWN) {
+      /* Obtain a reference to the Python capsule wrapping the module information, so that the
+       * module information is correctly destroyed after all SWIG python objects have been freed
+       * by the GC (and corresponding destructors invoked) */
+      Py_XINCREF(Swig_Capsule_global);
+    }
   }
   return (PyObject *)sobj;
 }
 
 /* -----------------------------------------------------------------------------
  * Implements a simple Swig Packed type, and use it instead of string
  * ----------------------------------------------------------------------------- */
@@ -1864,15 +2157,19 @@
       PyObject_HEAD_INIT(NULL)
       0,                                    /* ob_size */
 #endif
       "SwigPyPacked",                       /* tp_name */
       sizeof(SwigPyPacked),                 /* tp_basicsize */
       0,                                    /* tp_itemsize */
       (destructor)SwigPyPacked_dealloc,     /* tp_dealloc */
-      0,                                    /* tp_print */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                         /*tp_print*/
+#else
+      (Py_ssize_t)0,                        /*tp_vectorcall_offset*/
+#endif
       (getattrfunc)0,                       /* tp_getattr */
       (setattrfunc)0,                       /* tp_setattr */
 #if PY_VERSION_HEX>=0x03000000
       0, /* tp_reserved in 3.0.1 */
 #else
       (cmpfunc)SwigPyPacked_compare,        /* tp_compare */
 #endif
@@ -1929,15 +2226,15 @@
       0,                                    /* tp_maxalloc */
       0,                                    /* tp_prev */
       0                                     /* tp_next */
 #endif
     };
     swigpypacked_type = tmp;
     type_init = 1;
-    if (PyType_Ready(&swigpypacked_type) < 0)
+    if (PyType_Ready(&swigpypacked_type) != 0)
       return NULL;
   }
   return &swigpypacked_type;
 }
 
 SWIGRUNTIME PyObject *
 SwigPyPacked_New(void *ptr, size_t size, swig_type_info *ty)
@@ -2119,20 +2416,27 @@
       }
     } else {
       if (ptr) *ptr = vptr;
       break;
     }
   }
   if (sobj) {
-    if (own)
-      *own = *own | sobj->own;
-    if (flags & SWIG_POINTER_DISOWN) {
-      sobj->own = 0;
+    if (((flags & SWIG_POINTER_RELEASE) == SWIG_POINTER_RELEASE) && !sobj->own) {
+      res = SWIG_ERROR_RELEASE_NOT_OWNED;
+    } else {
+      if (own)
+        *own = *own | sobj->own;
+      if (flags & SWIG_POINTER_DISOWN) {
+        sobj->own = 0;
+      }
+      if (flags & SWIG_POINTER_CLEAR) {
+        sobj->ptr = 0;
+      }
+      res = SWIG_OK;
     }
-    res = SWIG_OK;
   } else {
     if (implicit_conv) {
       SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
       if (data && !data->implicitconv) {
         PyObject *klass = data->klass;
         if (klass) {
           PyObject *impconv;
@@ -2237,20 +2541,25 @@
   PyObject *newraw = data->newraw;
   if (newraw) {
     inst = PyObject_Call(newraw, data->newargs, NULL);
     if (inst) {
 #if !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
       PyObject **dictptr = _PyObject_GetDictPtr(inst);
       if (dictptr != NULL) {
-	PyObject *dict = *dictptr;
-	if (dict == NULL) {
-	  dict = PyDict_New();
-	  *dictptr = dict;
-	  PyDict_SetItem(dict, SWIG_This(), swig_this);
-	}
+        PyObject *dict = *dictptr;
+        if (dict == NULL) {
+          dict = PyDict_New();
+          *dictptr = dict;
+        }
+        if (dict) {
+          PyDict_SetItem(dict, SWIG_This(), swig_this);
+        } else{
+          Py_DECREF(inst);
+          inst = 0;
+        }
       }
 #else
       if (PyObject_SetAttr(inst, SWIG_This(), swig_this) == -1) {
         Py_DECREF(inst);
         inst = 0;
       }
 #endif
@@ -2264,15 +2573,15 @@
         inst = ((PyTypeObject *)data->newargs)->tp_new((PyTypeObject *)data->newargs, empty_args, empty_kwargs);
         Py_DECREF(empty_kwargs);
         if (inst) {
           if (PyObject_SetAttr(inst, SWIG_This(), swig_this) == -1) {
             Py_DECREF(inst);
             inst = 0;
           } else {
-            Py_TYPE(inst)->tp_flags &= ~Py_TPFLAGS_VALID_VERSION_TAG;
+            PyType_Modified(Py_TYPE(inst));
           }
         }
       }
       Py_DECREF(empty_args);
     }
 #else
     PyObject *dict = PyDict_New();
@@ -2293,30 +2602,34 @@
   PyObject **dictptr = _PyObject_GetDictPtr(inst);
   if (dictptr != NULL) {
     PyObject *dict = *dictptr;
     if (dict == NULL) {
       dict = PyDict_New();
       *dictptr = dict;
     }
-    return PyDict_SetItem(dict, SWIG_This(), swig_this);
+    if (dict) {
+      return PyDict_SetItem(dict, SWIG_This(), swig_this);
+    } else{
+      return -1;
+    }
   }
 #endif
   return PyObject_SetAttr(inst, SWIG_This(), swig_this);
 } 
 
 
 SWIGINTERN PyObject *
 SWIG_Python_InitShadowInstance(PyObject *args) {
   PyObject *obj[2];
   if (!SWIG_Python_UnpackTuple(args, "swiginit", 2, 2, obj)) {
     return NULL;
   } else {
     SwigPyObject *sthis = SWIG_Python_GetSwigThis(obj[0]);
     if (sthis) {
-      SwigPyObject_append((PyObject*) sthis, obj[1]);
+      Py_DECREF(SwigPyObject_append((PyObject*) sthis, obj[1]));
     } else {
       if (SWIG_Python_SetSwigThis(obj[0], obj[1]) != 0)
         return NULL;
     }
     return SWIG_Py_Void();
   }
 }
@@ -2347,15 +2660,17 @@
 #ifdef SWIGPYTHON_BUILTIN
         newobj->dict = 0;
 #endif
       }
     } else {
       newobj = PyObject_New(SwigPyObject, clientdata->pytype);
 #ifdef SWIGPYTHON_BUILTIN
-      newobj->dict = 0;
+      if (newobj) {
+        newobj->dict = 0;
+      }
 #endif
     }
     if (newobj) {
       newobj->ptr = ptr;
       newobj->ty = type;
       newobj->own = own;
       newobj->next = 0;
@@ -2386,89 +2701,111 @@
  *  Get type list 
  * -----------------------------------------------------------------------------*/
 
 #ifdef SWIG_LINK_RUNTIME
 void *SWIG_ReturnGlobalTypeList(void *);
 #endif
 
+static PyObject *Swig_TypeCache_global = NULL;
+
+/* The python cached type query */
+SWIGRUNTIME PyObject *
+SWIG_Python_TypeCache(void) {
+  if (Swig_TypeCache_global == NULL) {
+    Swig_TypeCache_global = PyDict_New();
+  }
+  return Swig_TypeCache_global;
+}
+
 SWIGRUNTIME swig_module_info *
 SWIG_Python_GetModule(void *SWIGUNUSEDPARM(clientdata)) {
+#ifdef SWIG_LINK_RUNTIME
   static void *type_pointer = (void *)0;
   /* first check if module already created */
   if (!type_pointer) {
-#ifdef SWIG_LINK_RUNTIME
     type_pointer = SWIG_ReturnGlobalTypeList((void *)0);
+  }
 #else
-    type_pointer = PyCapsule_Import(SWIGPY_CAPSULE_NAME, 0);
-    if (PyErr_Occurred()) {
-      PyErr_Clear();
-      type_pointer = (void *)0;
-    }
-#endif
+  void *type_pointer = PyCapsule_Import(SWIGPY_CAPSULE_NAME, 0);
+  if (PyErr_Occurred()) {
+    PyErr_Clear();
+    type_pointer = (void *)0;
   }
+#endif
   return (swig_module_info *) type_pointer;
 }
 
+
+static int interpreter_counter = 0; // how many (sub-)interpreters are using swig_module's types
+
 SWIGRUNTIME void
 SWIG_Python_DestroyModule(PyObject *obj)
 {
   swig_module_info *swig_module = (swig_module_info *) PyCapsule_GetPointer(obj, SWIGPY_CAPSULE_NAME);
   swig_type_info **types = swig_module->types;
   size_t i;
+  if (--interpreter_counter != 0) // another sub-interpreter may still be using the swig_module's types
+    return;
   for (i =0; i < swig_module->size; ++i) {
     swig_type_info *ty = types[i];
     if (ty->owndata) {
       SwigPyClientData *data = (SwigPyClientData *) ty->clientdata;
+      ty->clientdata = 0;
       if (data) SwigPyClientData_Del(data);
     }
   }
   Py_DECREF(SWIG_This());
   Swig_This_global = NULL;
+  Py_DECREF(SWIG_globals());
+  Swig_Globals_global = NULL;
+  Py_DECREF(SWIG_Python_TypeCache());
+  Swig_TypeCache_global = NULL;
+  Swig_Capsule_global = NULL;
 }
 
 SWIGRUNTIME void
 SWIG_Python_SetModule(swig_module_info *swig_module) {
 #if PY_VERSION_HEX >= 0x03000000
  /* Add a dummy module object into sys.modules */
   PyObject *module = PyImport_AddModule("swig_runtime_data" SWIG_RUNTIME_VERSION);
 #else
   static PyMethodDef swig_empty_runtime_method_table[] = { {NULL, NULL, 0, NULL} }; /* Sentinel */
   PyObject *module = Py_InitModule("swig_runtime_data" SWIG_RUNTIME_VERSION, swig_empty_runtime_method_table);
 #endif
   PyObject *pointer = PyCapsule_New((void *) swig_module, SWIGPY_CAPSULE_NAME, SWIG_Python_DestroyModule);
   if (pointer && module) {
-    PyModule_AddObject(module, "type_pointer_capsule" SWIG_TYPE_TABLE_NAME, pointer);
+    if (PyModule_AddObject(module, SWIGPY_CAPSULE_ATTR_NAME, pointer) == 0) {
+      ++interpreter_counter;
+      Swig_Capsule_global = pointer;
+    } else {
+      Py_DECREF(pointer);
+    }
   } else {
     Py_XDECREF(pointer);
   }
 }
 
-/* The python cached type query */
-SWIGRUNTIME PyObject *
-SWIG_Python_TypeCache(void) {
-  static PyObject *SWIG_STATIC_POINTER(cache) = PyDict_New();
-  return cache;
-}
-
 SWIGRUNTIME swig_type_info *
 SWIG_Python_TypeQuery(const char *type)
 {
   PyObject *cache = SWIG_Python_TypeCache();
   PyObject *key = SWIG_Python_str_FromChar(type); 
   PyObject *obj = PyDict_GetItem(cache, key);
   swig_type_info *descriptor;
   if (obj) {
     descriptor = (swig_type_info *) PyCapsule_GetPointer(obj, NULL);
   } else {
     swig_module_info *swig_module = SWIG_GetModule(0);
     descriptor = SWIG_TypeQueryModule(swig_module, swig_module, type);
     if (descriptor) {
       obj = PyCapsule_New((void*) descriptor, NULL, NULL);
-      PyDict_SetItem(cache, key, obj);
-      Py_DECREF(obj);
+      if (obj) {
+        PyDict_SetItem(cache, key, obj);
+        Py_DECREF(obj);
+      }
     }
   }
   Py_DECREF(key);
   return descriptor;
 }
 
 /* 
@@ -2493,15 +2830,14 @@
       Py_XINCREF(type);
       PyErr_Clear();
       if (infront) {
 	PyErr_Format(type, "%s %s", mesg, errmesg);
       } else {
 	PyErr_Format(type, "%s %s", errmesg, mesg);
       }
-      SWIG_Python_str_DelForPy3(tmp);
       Py_DECREF(old_str);
     }
     return 1;
   } else {
     return 0;
   }
 }
@@ -2545,15 +2881,14 @@
       const char *otype = (obj ? obj->ob_type->tp_name : 0); 
       if (otype) {
 	PyObject *str = PyObject_Str(obj);
 	const char *cstr = str ? SWIG_Python_str_AsChar(str) : 0;
 	if (cstr) {
 	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s(%s)' is received",
 		       type, otype, cstr);
-          SWIG_Python_str_DelForPy3(cstr);
 	} else {
 	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s' is received",
 		       type, otype);
 	}
 	Py_XDECREF(str);
 	return;
       }
@@ -2567,20 +2902,14 @@
 
 /* Convert a pointer value, signal an exception on a type mismatch */
 SWIGRUNTIME void *
 SWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int SWIGUNUSEDPARM(argnum), int flags) {
   void *result;
   if (SWIG_Python_ConvertPtr(obj, &result, ty, flags) == -1) {
     PyErr_Clear();
-#if SWIG_POINTER_EXCEPTION
-    if (flags) {
-      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);
-      SWIG_Python_ArgFail(argnum);
-    }
-#endif
   }
   return result;
 }
 
 #ifdef SWIGPYTHON_BUILTIN
 SWIGRUNTIME int
 SWIG_Python_NonDynamicSetAttr(PyObject *obj, PyObject *name, PyObject *value) {
@@ -2603,30 +2932,30 @@
     PyErr_Format(PyExc_TypeError, "attribute name must be string, not '%.200s'", name->ob_type->tp_name);
     return -1;
   } else {
     Py_INCREF(name);
   }
 
   if (!tp->tp_dict) {
-    if (PyType_Ready(tp) < 0)
+    if (PyType_Ready(tp) != 0)
       goto done;
   }
 
   descr = _PyType_Lookup(tp, name);
   f = NULL;
   if (descr != NULL)
     f = descr->ob_type->tp_descr_set;
   if (!f) {
     if (PyString_Check(name)) {
       encoded_name = name;
       Py_INCREF(name);
     } else {
       encoded_name = PyUnicode_AsUTF8String(name);
       if (!encoded_name)
-        return -1;
+        goto done;
     }
     PyErr_Format(PyExc_AttributeError, "'%.100s' object has no attribute '%.200s'", tp->tp_name, PyString_AsString(encoded_name));
     Py_DECREF(encoded_name);
   } else {
     res = f(descr, obj, value);
   }
   
@@ -2645,15 +2974,19 @@
 extern "C" {
 #endif
 
 SWIGINTERN Py_hash_t
 SwigPyObject_hash(PyObject *obj) {
   SwigPyObject *sobj = (SwigPyObject *)obj;
   void *ptr = sobj->ptr;
+#if PY_VERSION_HEX < 0x03020000
+  return (Py_hash_t)(Py_ssize_t)ptr;
+#else
   return (Py_hash_t)ptr;
+#endif
 }
 
 SWIGINTERN Py_hash_t
 SWIG_PyNumber_AsPyHash(PyObject *obj) {
   Py_hash_t result = -1;
 #if PY_VERSION_HEX < 0x03020000
   if (PyInt_Check(obj))
@@ -2850,15 +3183,19 @@
       PyObject_HEAD_INIT(&PyType_Type)
       0,                                        /* ob_size */
 #endif
       "swig_static_var_getset_descriptor",      /* tp_name */
       sizeof(PyGetSetDescrObject),              /* tp_basicsize */
       0,                                        /* tp_itemsize */
       (destructor)SwigPyStaticVar_dealloc,      /* tp_dealloc */
-      0,                                        /* tp_print */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                             /* tp_print */
+#else
+      (Py_ssize_t)0,                            /* tp_vectorcall_offset */
+#endif
       0,                                        /* tp_getattr */
       0,                                        /* tp_setattr */
       0,                                        /* tp_compare */
       (reprfunc)SwigPyStaticVar_repr,           /* tp_repr */
       0,                                        /* tp_as_number */
       0,                                        /* tp_as_sequence */
       0,                                        /* tp_as_mapping */
@@ -2934,15 +3271,19 @@
       PyObject_HEAD_INIT(&PyType_Type)
       0,                                        /* ob_size */
 #endif
       "SwigPyObjectType",                       /* tp_name */
       PyType_Type.tp_basicsize,                 /* tp_basicsize */
       0,                                        /* tp_itemsize */
       0,                                        /* tp_dealloc */
-      0,                                        /* tp_print */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                             /* tp_print */
+#else
+      (Py_ssize_t)0,                            /* tp_vectorcall_offset */
+#endif
       0,                                        /* tp_getattr */
       0,                                        /* tp_setattr */
       0,                                        /* tp_compare */
       0,                                        /* tp_repr */
       0,                                        /* tp_as_number */
       0,                                        /* tp_as_sequence */
       0,                                        /* tp_as_mapping */
@@ -3053,18 +3394,18 @@
   Py_XINCREF(result);
   return result;
 }
 
 SWIGINTERN void
 SwigPyBuiltin_SetMetaType (PyTypeObject *type, PyTypeObject *metatype)
 {
-#if PY_VERSION_HEX >= 0x03000000
-    type->ob_base.ob_base.ob_type = metatype;
+#if PY_VERSION_HEX >= 0x030900a4
+    Py_SET_TYPE(type, metatype);
 #else
-    type->ob_type = metatype;
+    Py_TYPE(type) = metatype;
 #endif
 }
 
 
 /* Start of callback function macros for use in PyTypeObject */
 
 typedef PyObject *(*SwigPyWrapperFunction)(PyObject *, PyObject *);
@@ -3394,33 +3735,18 @@
 #endif
 
 
 
 
 #define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 
 
-#define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 
+#define SWIG_contract_assert(expr, msg) do { if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } } while (0) 
 
 
 
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* Method creation and docstring support functions */
-
-SWIGINTERN PyMethodDef *SWIG_PythonGetProxyDoc(const char *name);
-SWIGINTERN PyObject *SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func);
-SWIGINTERN PyObject *SWIG_PyStaticMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func);
-
-#ifdef __cplusplus
-}
-#endif
-
-
 /* -------- TYPES TABLE (BEGIN) -------- */
 
 #define SWIGTYPE_p_CameraAbilities swig_types[0]
 #define SWIGTYPE_p_CameraCaptureType swig_types[1]
 #define SWIGTYPE_p_CameraDriverStatus swig_types[2]
 #define SWIGTYPE_p_CameraEventType swig_types[3]
 #define SWIGTYPE_p_CameraFileAccessType swig_types[4]
@@ -3504,18 +3830,14 @@
 
 #else
 #  define SWIG_init    init_filesys
 
 #endif
 #define SWIG_name    "_filesys"
 
-#define SWIGVERSION 0x040002 
-#define SWIG_VERSION SWIGVERSION
-
-
 #define SWIG_as_voidptr(a) (void *)((const void *)(a)) 
 #define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),(void**)(a)) 
 
 
 #include <stddef.h>
 
 
@@ -3974,14 +4296,15 @@
 #ifdef __cplusplus
 extern "C" {
 #endif
 SWIGINTERN int _wrap_new__CameraFilesystem(PyObject *self, PyObject *args, PyObject *kwargs) {
   PyObject *resultobj = 0;
   struct _CameraFilesystem *result = 0 ;
   
+  (void)self;
   if (!SWIG_Python_CheckNoKeywords(kwargs, "new__CameraFilesystem")) SWIG_fail;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "new__CameraFilesystem takes no arguments");
   {
     result = (struct _CameraFilesystem *)new__CameraFilesystem();
     if (PyErr_Occurred()) SWIG_fail;
   }
   resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p__CameraFilesystem, SWIG_BUILTIN_INIT |  0 );
@@ -3993,14 +4316,15 @@
 
 SWIGINTERN PyObject *_wrap_delete__CameraFilesystem(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraFilesystem *arg1 = (struct _CameraFilesystem *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete__CameraFilesystem takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFilesystem, SWIG_POINTER_DISOWN |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete__CameraFilesystem" "', argument " "1"" of type '" "struct _CameraFilesystem *""'"); 
   }
   arg1 = (struct _CameraFilesystem *)(argp1);
   {
@@ -4019,14 +4343,15 @@
 SWIGINTERN PyObject *_wrap_CameraFileInfoFile_fields_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraFileInfoFile *arg1 = (struct _CameraFileInfoFile *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   CameraFileInfoFields result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraFileInfoFile_fields_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFileInfoFile, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraFileInfoFile_fields_get" "', argument " "1"" of type '" "struct _CameraFileInfoFile *""'"); 
   }
   arg1 = (struct _CameraFileInfoFile *)(argp1);
   result = (CameraFileInfoFields) ((arg1)->fields);
@@ -4040,14 +4365,15 @@
 SWIGINTERN PyObject *_wrap_CameraFileInfoFile_status_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraFileInfoFile *arg1 = (struct _CameraFileInfoFile *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   CameraFileStatus result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraFileInfoFile_status_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFileInfoFile, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraFileInfoFile_status_get" "', argument " "1"" of type '" "struct _CameraFileInfoFile *""'"); 
   }
   arg1 = (struct _CameraFileInfoFile *)(argp1);
   result = (CameraFileStatus) ((arg1)->status);
@@ -4061,14 +4387,15 @@
 SWIGINTERN PyObject *_wrap_CameraFileInfoFile_size_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraFileInfoFile *arg1 = (struct _CameraFileInfoFile *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   uint64_t result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraFileInfoFile_size_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFileInfoFile, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraFileInfoFile_size_get" "', argument " "1"" of type '" "struct _CameraFileInfoFile *""'"); 
   }
   arg1 = (struct _CameraFileInfoFile *)(argp1);
   result = (uint64_t) ((arg1)->size);
@@ -4082,14 +4409,15 @@
 SWIGINTERN PyObject *_wrap_CameraFileInfoFile_type_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraFileInfoFile *arg1 = (struct _CameraFileInfoFile *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   char *result = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraFileInfoFile_type_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFileInfoFile, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraFileInfoFile_type_get" "', argument " "1"" of type '" "struct _CameraFileInfoFile *""'"); 
   }
   arg1 = (struct _CameraFileInfoFile *)(argp1);
   result = (char *)(char *) ((arg1)->type);
@@ -4109,14 +4437,15 @@
 SWIGINTERN PyObject *_wrap_CameraFileInfoFile_width_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraFileInfoFile *arg1 = (struct _CameraFileInfoFile *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   uint32_t result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraFileInfoFile_width_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFileInfoFile, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraFileInfoFile_width_get" "', argument " "1"" of type '" "struct _CameraFileInfoFile *""'"); 
   }
   arg1 = (struct _CameraFileInfoFile *)(argp1);
   result = (uint32_t) ((arg1)->width);
@@ -4130,14 +4459,15 @@
 SWIGINTERN PyObject *_wrap_CameraFileInfoFile_height_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraFileInfoFile *arg1 = (struct _CameraFileInfoFile *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   uint32_t result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraFileInfoFile_height_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFileInfoFile, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraFileInfoFile_height_get" "', argument " "1"" of type '" "struct _CameraFileInfoFile *""'"); 
   }
   arg1 = (struct _CameraFileInfoFile *)(argp1);
   result = (uint32_t) ((arg1)->height);
@@ -4151,14 +4481,15 @@
 SWIGINTERN PyObject *_wrap_CameraFileInfoFile_permissions_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraFileInfoFile *arg1 = (struct _CameraFileInfoFile *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   CameraFilePermissions result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraFileInfoFile_permissions_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFileInfoFile, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraFileInfoFile_permissions_get" "', argument " "1"" of type '" "struct _CameraFileInfoFile *""'"); 
   }
   arg1 = (struct _CameraFileInfoFile *)(argp1);
   result = (CameraFilePermissions) ((arg1)->permissions);
@@ -4172,14 +4503,15 @@
 SWIGINTERN PyObject *_wrap_CameraFileInfoFile_mtime_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraFileInfoFile *arg1 = (struct _CameraFileInfoFile *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   time_t result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraFileInfoFile_mtime_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFileInfoFile, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraFileInfoFile_mtime_get" "', argument " "1"" of type '" "struct _CameraFileInfoFile *""'"); 
   }
   arg1 = (struct _CameraFileInfoFile *)(argp1);
   result = (time_t) ((arg1)->mtime);
@@ -4192,14 +4524,15 @@
 
 SWIGINTERN PyObject *_wrap_delete_CameraFileInfoFile(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraFileInfoFile *arg1 = (struct _CameraFileInfoFile *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_CameraFileInfoFile takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFileInfoFile, SWIG_POINTER_DISOWN |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CameraFileInfoFile" "', argument " "1"" of type '" "struct _CameraFileInfoFile *""'"); 
   }
   arg1 = (struct _CameraFileInfoFile *)(argp1);
   free((char *) arg1);
@@ -4215,14 +4548,15 @@
 SWIGINTERN PyObject *_wrap_CameraFileInfoPreview_fields_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraFileInfoPreview *arg1 = (struct _CameraFileInfoPreview *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   CameraFileInfoFields result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraFileInfoPreview_fields_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFileInfoPreview, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraFileInfoPreview_fields_get" "', argument " "1"" of type '" "struct _CameraFileInfoPreview *""'"); 
   }
   arg1 = (struct _CameraFileInfoPreview *)(argp1);
   result = (CameraFileInfoFields) ((arg1)->fields);
@@ -4236,14 +4570,15 @@
 SWIGINTERN PyObject *_wrap_CameraFileInfoPreview_status_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraFileInfoPreview *arg1 = (struct _CameraFileInfoPreview *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   CameraFileStatus result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraFileInfoPreview_status_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFileInfoPreview, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraFileInfoPreview_status_get" "', argument " "1"" of type '" "struct _CameraFileInfoPreview *""'"); 
   }
   arg1 = (struct _CameraFileInfoPreview *)(argp1);
   result = (CameraFileStatus) ((arg1)->status);
@@ -4257,14 +4592,15 @@
 SWIGINTERN PyObject *_wrap_CameraFileInfoPreview_size_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraFileInfoPreview *arg1 = (struct _CameraFileInfoPreview *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   uint64_t result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraFileInfoPreview_size_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFileInfoPreview, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraFileInfoPreview_size_get" "', argument " "1"" of type '" "struct _CameraFileInfoPreview *""'"); 
   }
   arg1 = (struct _CameraFileInfoPreview *)(argp1);
   result = (uint64_t) ((arg1)->size);
@@ -4278,14 +4614,15 @@
 SWIGINTERN PyObject *_wrap_CameraFileInfoPreview_type_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraFileInfoPreview *arg1 = (struct _CameraFileInfoPreview *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   char *result = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraFileInfoPreview_type_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFileInfoPreview, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraFileInfoPreview_type_get" "', argument " "1"" of type '" "struct _CameraFileInfoPreview *""'"); 
   }
   arg1 = (struct _CameraFileInfoPreview *)(argp1);
   result = (char *)(char *) ((arg1)->type);
@@ -4305,14 +4642,15 @@
 SWIGINTERN PyObject *_wrap_CameraFileInfoPreview_width_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraFileInfoPreview *arg1 = (struct _CameraFileInfoPreview *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   uint32_t result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraFileInfoPreview_width_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFileInfoPreview, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraFileInfoPreview_width_get" "', argument " "1"" of type '" "struct _CameraFileInfoPreview *""'"); 
   }
   arg1 = (struct _CameraFileInfoPreview *)(argp1);
   result = (uint32_t) ((arg1)->width);
@@ -4326,14 +4664,15 @@
 SWIGINTERN PyObject *_wrap_CameraFileInfoPreview_height_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraFileInfoPreview *arg1 = (struct _CameraFileInfoPreview *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   uint32_t result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraFileInfoPreview_height_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFileInfoPreview, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraFileInfoPreview_height_get" "', argument " "1"" of type '" "struct _CameraFileInfoPreview *""'"); 
   }
   arg1 = (struct _CameraFileInfoPreview *)(argp1);
   result = (uint32_t) ((arg1)->height);
@@ -4346,14 +4685,15 @@
 
 SWIGINTERN PyObject *_wrap_delete_CameraFileInfoPreview(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraFileInfoPreview *arg1 = (struct _CameraFileInfoPreview *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_CameraFileInfoPreview takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFileInfoPreview, SWIG_POINTER_DISOWN |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CameraFileInfoPreview" "', argument " "1"" of type '" "struct _CameraFileInfoPreview *""'"); 
   }
   arg1 = (struct _CameraFileInfoPreview *)(argp1);
   free((char *) arg1);
@@ -4369,14 +4709,15 @@
 SWIGINTERN PyObject *_wrap_CameraFileInfoAudio_fields_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraFileInfoAudio *arg1 = (struct _CameraFileInfoAudio *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   CameraFileInfoFields result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraFileInfoAudio_fields_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFileInfoAudio, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraFileInfoAudio_fields_get" "', argument " "1"" of type '" "struct _CameraFileInfoAudio *""'"); 
   }
   arg1 = (struct _CameraFileInfoAudio *)(argp1);
   result = (CameraFileInfoFields) ((arg1)->fields);
@@ -4390,14 +4731,15 @@
 SWIGINTERN PyObject *_wrap_CameraFileInfoAudio_status_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraFileInfoAudio *arg1 = (struct _CameraFileInfoAudio *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   CameraFileStatus result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraFileInfoAudio_status_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFileInfoAudio, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraFileInfoAudio_status_get" "', argument " "1"" of type '" "struct _CameraFileInfoAudio *""'"); 
   }
   arg1 = (struct _CameraFileInfoAudio *)(argp1);
   result = (CameraFileStatus) ((arg1)->status);
@@ -4411,14 +4753,15 @@
 SWIGINTERN PyObject *_wrap_CameraFileInfoAudio_size_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraFileInfoAudio *arg1 = (struct _CameraFileInfoAudio *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   uint64_t result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraFileInfoAudio_size_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFileInfoAudio, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraFileInfoAudio_size_get" "', argument " "1"" of type '" "struct _CameraFileInfoAudio *""'"); 
   }
   arg1 = (struct _CameraFileInfoAudio *)(argp1);
   result = (uint64_t) ((arg1)->size);
@@ -4432,14 +4775,15 @@
 SWIGINTERN PyObject *_wrap_CameraFileInfoAudio_type_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraFileInfoAudio *arg1 = (struct _CameraFileInfoAudio *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   char *result = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraFileInfoAudio_type_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFileInfoAudio, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraFileInfoAudio_type_get" "', argument " "1"" of type '" "struct _CameraFileInfoAudio *""'"); 
   }
   arg1 = (struct _CameraFileInfoAudio *)(argp1);
   result = (char *)(char *) ((arg1)->type);
@@ -4458,14 +4802,15 @@
 
 SWIGINTERN PyObject *_wrap_delete_CameraFileInfoAudio(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraFileInfoAudio *arg1 = (struct _CameraFileInfoAudio *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_CameraFileInfoAudio takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFileInfoAudio, SWIG_POINTER_DISOWN |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CameraFileInfoAudio" "', argument " "1"" of type '" "struct _CameraFileInfoAudio *""'"); 
   }
   arg1 = (struct _CameraFileInfoAudio *)(argp1);
   free((char *) arg1);
@@ -4481,14 +4826,15 @@
 SWIGINTERN PyObject *_wrap_CameraFileInfo_preview_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraFileInfo *arg1 = (struct _CameraFileInfo *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   CameraFileInfoPreview *result = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraFileInfo_preview_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFileInfo, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraFileInfo_preview_get" "', argument " "1"" of type '" "struct _CameraFileInfo *""'"); 
   }
   arg1 = (struct _CameraFileInfo *)(argp1);
   result = (CameraFileInfoPreview *)& ((arg1)->preview);
@@ -4502,14 +4848,15 @@
 SWIGINTERN PyObject *_wrap_CameraFileInfo_file_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraFileInfo *arg1 = (struct _CameraFileInfo *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   CameraFileInfoFile *result = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraFileInfo_file_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFileInfo, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraFileInfo_file_get" "', argument " "1"" of type '" "struct _CameraFileInfo *""'"); 
   }
   arg1 = (struct _CameraFileInfo *)(argp1);
   result = (CameraFileInfoFile *)& ((arg1)->file);
@@ -4523,14 +4870,15 @@
 SWIGINTERN PyObject *_wrap_CameraFileInfo_audio_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraFileInfo *arg1 = (struct _CameraFileInfo *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   CameraFileInfoAudio *result = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraFileInfo_audio_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFileInfo, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraFileInfo_audio_get" "', argument " "1"" of type '" "struct _CameraFileInfo *""'"); 
   }
   arg1 = (struct _CameraFileInfo *)(argp1);
   result = (CameraFileInfoAudio *)& ((arg1)->audio);
@@ -4543,14 +4891,15 @@
 
 SWIGINTERN PyObject *_wrap_delete_CameraFileInfo(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraFileInfo *arg1 = (struct _CameraFileInfo *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_CameraFileInfo takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFileInfo, SWIG_POINTER_DISOWN |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CameraFileInfo" "', argument " "1"" of type '" "struct _CameraFileInfo *""'"); 
   }
   arg1 = (struct _CameraFileInfo *)(argp1);
   free((char *) arg1);
@@ -4566,14 +4915,15 @@
 SWIGINTERN PyObject *_wrap_CameraStorageInformation_fields_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraStorageInformation *arg1 = (struct _CameraStorageInformation *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   CameraStorageInfoFields result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraStorageInformation_fields_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraStorageInformation, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraStorageInformation_fields_get" "', argument " "1"" of type '" "struct _CameraStorageInformation *""'"); 
   }
   arg1 = (struct _CameraStorageInformation *)(argp1);
   result = (CameraStorageInfoFields) ((arg1)->fields);
@@ -4587,14 +4937,15 @@
 SWIGINTERN PyObject *_wrap_CameraStorageInformation_basedir_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraStorageInformation *arg1 = (struct _CameraStorageInformation *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   char *result = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraStorageInformation_basedir_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraStorageInformation, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraStorageInformation_basedir_get" "', argument " "1"" of type '" "struct _CameraStorageInformation *""'"); 
   }
   arg1 = (struct _CameraStorageInformation *)(argp1);
   result = (char *)(char *) ((arg1)->basedir);
@@ -4614,14 +4965,15 @@
 SWIGINTERN PyObject *_wrap_CameraStorageInformation_label_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraStorageInformation *arg1 = (struct _CameraStorageInformation *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   char *result = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraStorageInformation_label_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraStorageInformation, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraStorageInformation_label_get" "', argument " "1"" of type '" "struct _CameraStorageInformation *""'"); 
   }
   arg1 = (struct _CameraStorageInformation *)(argp1);
   result = (char *)(char *) ((arg1)->label);
@@ -4641,14 +4993,15 @@
 SWIGINTERN PyObject *_wrap_CameraStorageInformation_description_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraStorageInformation *arg1 = (struct _CameraStorageInformation *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   char *result = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraStorageInformation_description_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraStorageInformation, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraStorageInformation_description_get" "', argument " "1"" of type '" "struct _CameraStorageInformation *""'"); 
   }
   arg1 = (struct _CameraStorageInformation *)(argp1);
   result = (char *)(char *) ((arg1)->description);
@@ -4668,14 +5021,15 @@
 SWIGINTERN PyObject *_wrap_CameraStorageInformation_type_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraStorageInformation *arg1 = (struct _CameraStorageInformation *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   CameraStorageType result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraStorageInformation_type_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraStorageInformation, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraStorageInformation_type_get" "', argument " "1"" of type '" "struct _CameraStorageInformation *""'"); 
   }
   arg1 = (struct _CameraStorageInformation *)(argp1);
   result = (CameraStorageType) ((arg1)->type);
@@ -4689,14 +5043,15 @@
 SWIGINTERN PyObject *_wrap_CameraStorageInformation_fstype_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraStorageInformation *arg1 = (struct _CameraStorageInformation *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   CameraStorageFilesystemType result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraStorageInformation_fstype_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraStorageInformation, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraStorageInformation_fstype_get" "', argument " "1"" of type '" "struct _CameraStorageInformation *""'"); 
   }
   arg1 = (struct _CameraStorageInformation *)(argp1);
   result = (CameraStorageFilesystemType) ((arg1)->fstype);
@@ -4710,14 +5065,15 @@
 SWIGINTERN PyObject *_wrap_CameraStorageInformation_access_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraStorageInformation *arg1 = (struct _CameraStorageInformation *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   CameraStorageAccessType result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraStorageInformation_access_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraStorageInformation, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraStorageInformation_access_get" "', argument " "1"" of type '" "struct _CameraStorageInformation *""'"); 
   }
   arg1 = (struct _CameraStorageInformation *)(argp1);
   result = (CameraStorageAccessType) ((arg1)->access);
@@ -4731,14 +5087,15 @@
 SWIGINTERN PyObject *_wrap_CameraStorageInformation_capacitykbytes_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraStorageInformation *arg1 = (struct _CameraStorageInformation *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   uint64_t result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraStorageInformation_capacitykbytes_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraStorageInformation, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraStorageInformation_capacitykbytes_get" "', argument " "1"" of type '" "struct _CameraStorageInformation *""'"); 
   }
   arg1 = (struct _CameraStorageInformation *)(argp1);
   result = (uint64_t) ((arg1)->capacitykbytes);
@@ -4752,14 +5109,15 @@
 SWIGINTERN PyObject *_wrap_CameraStorageInformation_freekbytes_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraStorageInformation *arg1 = (struct _CameraStorageInformation *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   uint64_t result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraStorageInformation_freekbytes_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraStorageInformation, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraStorageInformation_freekbytes_get" "', argument " "1"" of type '" "struct _CameraStorageInformation *""'"); 
   }
   arg1 = (struct _CameraStorageInformation *)(argp1);
   result = (uint64_t) ((arg1)->freekbytes);
@@ -4773,14 +5131,15 @@
 SWIGINTERN PyObject *_wrap_CameraStorageInformation_freeimages_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraStorageInformation *arg1 = (struct _CameraStorageInformation *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   uint64_t result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraStorageInformation_freeimages_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraStorageInformation, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraStorageInformation_freeimages_get" "', argument " "1"" of type '" "struct _CameraStorageInformation *""'"); 
   }
   arg1 = (struct _CameraStorageInformation *)(argp1);
   result = (uint64_t) ((arg1)->freeimages);
@@ -4793,14 +5152,15 @@
 
 SWIGINTERN PyObject *_wrap_delete_CameraStorageInformation(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraStorageInformation *arg1 = (struct _CameraStorageInformation *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_CameraStorageInformation takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraStorageInformation, SWIG_POINTER_DISOWN |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CameraStorageInformation" "', argument " "1"" of type '" "struct _CameraStorageInformation *""'"); 
   }
   arg1 = (struct _CameraStorageInformation *)(argp1);
   free((char *) arg1);
@@ -4819,14 +5179,15 @@
   CameraFilesystem *temp1 ;
   int result;
   
   {
     temp1 = NULL;
     arg1 = &temp1;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_filesystem_new", 0, 0)) SWIG_fail;
   result = (int)gp_filesystem_new(arg1);
   resultobj = SWIG_From_int((int)(result));
   {
     resultobj = SWIG_Python_AppendOutput(
       resultobj, SWIG_NewPointerObj(*arg1, SWIGTYPE_p__CameraFilesystem, SWIG_POINTER_OWN));
   }
@@ -4857,14 +5218,15 @@
   PyObject * obj2 = 0 ;
   PyObject * obj3 = 0 ;
   int result;
   
   {
     arg4 = NULL;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_filesystem_append", 3, 4, &obj0, &obj1, &obj2, &obj3)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraFilesystem, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_filesystem_append" "', argument " "1"" of type '" "CameraFilesystem *""'"); 
   }
   arg1 = (CameraFilesystem *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -4921,14 +5283,15 @@
   PyObject * obj3 = 0 ;
   PyObject * obj4 = 0 ;
   int result;
   
   {
     arg5 = NULL;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_filesystem_set_info_noop", 4, 5, &obj0, &obj1, &obj2, &obj3, &obj4)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraFilesystem, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_filesystem_set_info_noop" "', argument " "1"" of type '" "CameraFilesystem *""'"); 
   }
   arg1 = (CameraFilesystem *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -4992,14 +5355,15 @@
   PyObject * obj2 = 0 ;
   PyObject * obj3 = 0 ;
   int result;
   
   {
     arg4 = NULL;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_filesystem_delete_file_noop", 3, 4, &obj0, &obj1, &obj2, &obj3)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraFilesystem, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_filesystem_delete_file_noop" "', argument " "1"" of type '" "CameraFilesystem *""'"); 
   }
   arg1 = (CameraFilesystem *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -5035,14 +5399,15 @@
   PyObject *resultobj = 0;
   CameraFilesystem *arg1 = (CameraFilesystem *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   PyObject * obj0 = 0 ;
   int result;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_filesystem_reset", 1, 1, &obj0)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraFilesystem, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_filesystem_reset" "', argument " "1"" of type '" "CameraFilesystem *""'"); 
   }
   arg1 = (CameraFilesystem *)(argp1);
   result = (int)gp_filesystem_reset(arg1);
@@ -5069,14 +5434,15 @@
   PyObject * obj1 = 0 ;
   PyObject * obj2 = 0 ;
   int result;
   
   {
     arg3 = NULL;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_filesystem_count", 2, 3, &obj0, &obj1, &obj2)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraFilesystem, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_filesystem_count" "', argument " "1"" of type '" "CameraFilesystem *""'"); 
   }
   arg1 = (CameraFilesystem *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -5127,14 +5493,15 @@
   {
     arg5 = NULL;
   }
   {
     temp4 = NULL;
     arg4 = &temp4;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_filesystem_name", 3, 4, &obj0, &obj1, &obj2, &obj3)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraFilesystem, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_filesystem_name" "', argument " "1"" of type '" "CameraFilesystem *""'"); 
   }
   arg1 = (CameraFilesystem *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -5195,14 +5562,15 @@
   {
     arg4 = NULL;
   }
   {
     temp3 = NULL;
     arg3 = &temp3;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_filesystem_get_folder", 2, 3, &obj0, &obj1, &obj2)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraFilesystem, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_filesystem_get_folder" "', argument " "1"" of type '" "CameraFilesystem *""'"); 
   }
   arg1 = (CameraFilesystem *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -5257,14 +5625,15 @@
   PyObject * obj2 = 0 ;
   PyObject * obj3 = 0 ;
   int result;
   
   {
     arg4 = NULL;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_filesystem_number", 3, 4, &obj0, &obj1, &obj2, &obj3)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraFilesystem, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_filesystem_number" "', argument " "1"" of type '" "CameraFilesystem *""'"); 
   }
   arg1 = (CameraFilesystem *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -5323,14 +5692,15 @@
       arg3 = NULL;
       /*@SWIG:src/gphoto2/common/macros.i,25,GPHOTO2_ERROR@*/
       PyErr_SetObject(PyExc_GPhoto2Error, PyInt_FromLong(error));
       /*@SWIG@*/
       SWIG_fail;
     }
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_filesystem_list_files", 2, 3, &obj0, &obj1, &obj2)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraFilesystem, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_filesystem_list_files" "', argument " "1"" of type '" "CameraFilesystem *""'"); 
   }
   arg1 = (CameraFilesystem *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -5397,14 +5767,15 @@
       arg3 = NULL;
       /*@SWIG:src/gphoto2/common/macros.i,25,GPHOTO2_ERROR@*/
       PyErr_SetObject(PyExc_GPhoto2Error, PyInt_FromLong(error));
       /*@SWIG@*/
       SWIG_fail;
     }
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_filesystem_list_folders", 2, 3, &obj0, &obj1, &obj2)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraFilesystem, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_filesystem_list_folders" "', argument " "1"" of type '" "CameraFilesystem *""'"); 
   }
   arg1 = (CameraFilesystem *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -5473,14 +5844,15 @@
   {
     arg4 = (CameraFileInfo *)calloc(1, sizeof(CameraFileInfo));
     if (arg4 == NULL) {
       PyErr_SetString(PyExc_MemoryError, "Cannot allocate " "CameraFileInfo");
       SWIG_fail;
     }
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_filesystem_get_info", 3, 4, &obj0, &obj1, &obj2, &obj3)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraFilesystem, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_filesystem_get_info" "', argument " "1"" of type '" "CameraFilesystem *""'"); 
   }
   arg1 = (CameraFilesystem *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -5548,14 +5920,15 @@
   PyObject * obj3 = 0 ;
   PyObject * obj4 = 0 ;
   int result;
   
   {
     arg5 = NULL;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_filesystem_set_info", 4, 5, &obj0, &obj1, &obj2, &obj3, &obj4)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraFilesystem, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_filesystem_set_info" "', argument " "1"" of type '" "CameraFilesystem *""'"); 
   }
   arg1 = (CameraFilesystem *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -5627,14 +6000,15 @@
   PyObject * obj4 = 0 ;
   PyObject * obj5 = 0 ;
   int result;
   
   {
     arg6 = NULL;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_filesystem_get_file", 5, 6, &obj0, &obj1, &obj2, &obj3, &obj4, &obj5)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraFilesystem, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_filesystem_get_file" "', argument " "1"" of type '" "CameraFilesystem *""'"); 
   }
   arg1 = (CameraFilesystem *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -5714,14 +6088,15 @@
   PyObject * obj6 = 0 ;
   PyObject * obj7 = 0 ;
   int result;
   
   {
     arg8 = NULL;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_filesystem_read_file", 7, 8, &obj0, &obj1, &obj2, &obj3, &obj4, &obj5, &obj6, &obj7)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraFilesystem, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_filesystem_read_file" "', argument " "1"" of type '" "CameraFilesystem *""'"); 
   }
   arg1 = (CameraFilesystem *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -5796,14 +6171,15 @@
   PyObject * obj2 = 0 ;
   PyObject * obj3 = 0 ;
   int result;
   
   {
     arg4 = NULL;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_filesystem_delete_file", 3, 4, &obj0, &obj1, &obj2, &obj3)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraFilesystem, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_filesystem_delete_file" "', argument " "1"" of type '" "CameraFilesystem *""'"); 
   }
   arg1 = (CameraFilesystem *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -5838,14 +6214,15 @@
 SWIGINTERN PyObject *_wrap__CameraFilesystemFuncs_file_list_func_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraFilesystemFuncs *arg1 = (struct _CameraFilesystemFuncs *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   CameraFilesystemListFunc result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "_CameraFilesystemFuncs_file_list_func_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFilesystemFuncs, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_CameraFilesystemFuncs_file_list_func_get" "', argument " "1"" of type '" "struct _CameraFilesystemFuncs *""'"); 
   }
   arg1 = (struct _CameraFilesystemFuncs *)(argp1);
   result = (CameraFilesystemListFunc) ((arg1)->file_list_func);
@@ -5859,14 +6236,15 @@
 SWIGINTERN PyObject *_wrap__CameraFilesystemFuncs_folder_list_func_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraFilesystemFuncs *arg1 = (struct _CameraFilesystemFuncs *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   CameraFilesystemListFunc result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "_CameraFilesystemFuncs_folder_list_func_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFilesystemFuncs, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_CameraFilesystemFuncs_folder_list_func_get" "', argument " "1"" of type '" "struct _CameraFilesystemFuncs *""'"); 
   }
   arg1 = (struct _CameraFilesystemFuncs *)(argp1);
   result = (CameraFilesystemListFunc) ((arg1)->folder_list_func);
@@ -5880,14 +6258,15 @@
 SWIGINTERN PyObject *_wrap__CameraFilesystemFuncs_put_file_func_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraFilesystemFuncs *arg1 = (struct _CameraFilesystemFuncs *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   CameraFilesystemPutFileFunc result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "_CameraFilesystemFuncs_put_file_func_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFilesystemFuncs, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_CameraFilesystemFuncs_put_file_func_get" "', argument " "1"" of type '" "struct _CameraFilesystemFuncs *""'"); 
   }
   arg1 = (struct _CameraFilesystemFuncs *)(argp1);
   result = (CameraFilesystemPutFileFunc) ((arg1)->put_file_func);
@@ -5901,14 +6280,15 @@
 SWIGINTERN PyObject *_wrap__CameraFilesystemFuncs_delete_all_func_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraFilesystemFuncs *arg1 = (struct _CameraFilesystemFuncs *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   CameraFilesystemDeleteAllFunc result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "_CameraFilesystemFuncs_delete_all_func_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFilesystemFuncs, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_CameraFilesystemFuncs_delete_all_func_get" "', argument " "1"" of type '" "struct _CameraFilesystemFuncs *""'"); 
   }
   arg1 = (struct _CameraFilesystemFuncs *)(argp1);
   result = (CameraFilesystemDeleteAllFunc) ((arg1)->delete_all_func);
@@ -5922,14 +6302,15 @@
 SWIGINTERN PyObject *_wrap__CameraFilesystemFuncs_get_info_func_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraFilesystemFuncs *arg1 = (struct _CameraFilesystemFuncs *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   CameraFilesystemGetInfoFunc result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "_CameraFilesystemFuncs_get_info_func_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFilesystemFuncs, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_CameraFilesystemFuncs_get_info_func_get" "', argument " "1"" of type '" "struct _CameraFilesystemFuncs *""'"); 
   }
   arg1 = (struct _CameraFilesystemFuncs *)(argp1);
   result = (CameraFilesystemGetInfoFunc) ((arg1)->get_info_func);
@@ -5943,14 +6324,15 @@
 SWIGINTERN PyObject *_wrap__CameraFilesystemFuncs_set_info_func_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraFilesystemFuncs *arg1 = (struct _CameraFilesystemFuncs *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   CameraFilesystemSetInfoFunc result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "_CameraFilesystemFuncs_set_info_func_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFilesystemFuncs, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_CameraFilesystemFuncs_set_info_func_get" "', argument " "1"" of type '" "struct _CameraFilesystemFuncs *""'"); 
   }
   arg1 = (struct _CameraFilesystemFuncs *)(argp1);
   result = (CameraFilesystemSetInfoFunc) ((arg1)->set_info_func);
@@ -5964,14 +6346,15 @@
 SWIGINTERN PyObject *_wrap__CameraFilesystemFuncs_make_dir_func_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraFilesystemFuncs *arg1 = (struct _CameraFilesystemFuncs *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   CameraFilesystemDirFunc result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "_CameraFilesystemFuncs_make_dir_func_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFilesystemFuncs, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_CameraFilesystemFuncs_make_dir_func_get" "', argument " "1"" of type '" "struct _CameraFilesystemFuncs *""'"); 
   }
   arg1 = (struct _CameraFilesystemFuncs *)(argp1);
   result = (CameraFilesystemDirFunc) ((arg1)->make_dir_func);
@@ -5985,14 +6368,15 @@
 SWIGINTERN PyObject *_wrap__CameraFilesystemFuncs_remove_dir_func_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraFilesystemFuncs *arg1 = (struct _CameraFilesystemFuncs *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   CameraFilesystemDirFunc result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "_CameraFilesystemFuncs_remove_dir_func_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFilesystemFuncs, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_CameraFilesystemFuncs_remove_dir_func_get" "', argument " "1"" of type '" "struct _CameraFilesystemFuncs *""'"); 
   }
   arg1 = (struct _CameraFilesystemFuncs *)(argp1);
   result = (CameraFilesystemDirFunc) ((arg1)->remove_dir_func);
@@ -6006,14 +6390,15 @@
 SWIGINTERN PyObject *_wrap__CameraFilesystemFuncs_get_file_func_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraFilesystemFuncs *arg1 = (struct _CameraFilesystemFuncs *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   CameraFilesystemGetFileFunc result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "_CameraFilesystemFuncs_get_file_func_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFilesystemFuncs, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_CameraFilesystemFuncs_get_file_func_get" "', argument " "1"" of type '" "struct _CameraFilesystemFuncs *""'"); 
   }
   arg1 = (struct _CameraFilesystemFuncs *)(argp1);
   result = (CameraFilesystemGetFileFunc) ((arg1)->get_file_func);
@@ -6027,14 +6412,15 @@
 SWIGINTERN PyObject *_wrap__CameraFilesystemFuncs_read_file_func_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraFilesystemFuncs *arg1 = (struct _CameraFilesystemFuncs *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   CameraFilesystemReadFileFunc result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "_CameraFilesystemFuncs_read_file_func_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFilesystemFuncs, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_CameraFilesystemFuncs_read_file_func_get" "', argument " "1"" of type '" "struct _CameraFilesystemFuncs *""'"); 
   }
   arg1 = (struct _CameraFilesystemFuncs *)(argp1);
   result = (CameraFilesystemReadFileFunc) ((arg1)->read_file_func);
@@ -6048,14 +6434,15 @@
 SWIGINTERN PyObject *_wrap__CameraFilesystemFuncs_del_file_func_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraFilesystemFuncs *arg1 = (struct _CameraFilesystemFuncs *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   CameraFilesystemDeleteFileFunc result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "_CameraFilesystemFuncs_del_file_func_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFilesystemFuncs, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_CameraFilesystemFuncs_del_file_func_get" "', argument " "1"" of type '" "struct _CameraFilesystemFuncs *""'"); 
   }
   arg1 = (struct _CameraFilesystemFuncs *)(argp1);
   result = (CameraFilesystemDeleteFileFunc) ((arg1)->del_file_func);
@@ -6069,14 +6456,15 @@
 SWIGINTERN PyObject *_wrap__CameraFilesystemFuncs_storage_info_func_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraFilesystemFuncs *arg1 = (struct _CameraFilesystemFuncs *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   CameraFilesystemStorageInfoFunc result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "_CameraFilesystemFuncs_storage_info_func_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFilesystemFuncs, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_CameraFilesystemFuncs_storage_info_func_get" "', argument " "1"" of type '" "struct _CameraFilesystemFuncs *""'"); 
   }
   arg1 = (struct _CameraFilesystemFuncs *)(argp1);
   result = (CameraFilesystemStorageInfoFunc) ((arg1)->storage_info_func);
@@ -6090,14 +6478,15 @@
 SWIGINTERN PyObject *_wrap__CameraFilesystemFuncs_unused_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraFilesystemFuncs *arg1 = (struct _CameraFilesystemFuncs *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   void **result = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "_CameraFilesystemFuncs_unused_get takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFilesystemFuncs, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_CameraFilesystemFuncs_unused_get" "', argument " "1"" of type '" "struct _CameraFilesystemFuncs *""'"); 
   }
   arg1 = (struct _CameraFilesystemFuncs *)(argp1);
   result = (void **)(void **) ((arg1)->unused);
@@ -6110,14 +6499,15 @@
 
 SWIGINTERN PyObject *_wrap_delete__CameraFilesystemFuncs(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraFilesystemFuncs *arg1 = (struct _CameraFilesystemFuncs *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete__CameraFilesystemFuncs takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraFilesystemFuncs, SWIG_POINTER_DISOWN |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete__CameraFilesystemFuncs" "', argument " "1"" of type '" "struct _CameraFilesystemFuncs *""'"); 
   }
   arg1 = (struct _CameraFilesystemFuncs *)(argp1);
   free((char *) arg1);
@@ -6141,14 +6531,15 @@
   int res2 = 0 ;
   int res3 ;
   PyObject * obj0 = 0 ;
   PyObject * obj1 = 0 ;
   PyObject * obj2 = 0 ;
   int result;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_filesystem_set_funcs", 3, 3, &obj0, &obj1, &obj2)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraFilesystem, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_filesystem_set_funcs" "', argument " "1"" of type '" "CameraFilesystem *""'"); 
   }
   arg1 = (CameraFilesystem *)(argp1);
   res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p__CameraFilesystemFuncs, 0 |  0 );
@@ -6197,14 +6588,15 @@
   PyObject * obj4 = 0 ;
   PyObject * obj5 = 0 ;
   int result;
   
   {
     arg6 = NULL;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_filesystem_put_file", 5, 6, &obj0, &obj1, &obj2, &obj3, &obj4, &obj5)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraFilesystem, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_filesystem_put_file" "', argument " "1"" of type '" "CameraFilesystem *""'"); 
   }
   arg1 = (CameraFilesystem *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -6262,14 +6654,15 @@
   PyObject * obj1 = 0 ;
   PyObject * obj2 = 0 ;
   int result;
   
   {
     arg3 = NULL;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_filesystem_delete_all", 2, 3, &obj0, &obj1, &obj2)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraFilesystem, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_filesystem_delete_all" "', argument " "1"" of type '" "CameraFilesystem *""'"); 
   }
   arg1 = (CameraFilesystem *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -6315,14 +6708,15 @@
   PyObject * obj2 = 0 ;
   PyObject * obj3 = 0 ;
   int result;
   
   {
     arg4 = NULL;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_filesystem_make_dir", 3, 4, &obj0, &obj1, &obj2, &obj3)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraFilesystem, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_filesystem_make_dir" "', argument " "1"" of type '" "CameraFilesystem *""'"); 
   }
   arg1 = (CameraFilesystem *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -6375,14 +6769,15 @@
   PyObject * obj2 = 0 ;
   PyObject * obj3 = 0 ;
   int result;
   
   {
     arg4 = NULL;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_filesystem_remove_dir", 3, 4, &obj0, &obj1, &obj2, &obj3)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraFilesystem, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_filesystem_remove_dir" "', argument " "1"" of type '" "CameraFilesystem *""'"); 
   }
   arg1 = (CameraFilesystem *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -6418,14 +6813,15 @@
   PyObject *resultobj = 0;
   CameraFilesystem *arg1 = (CameraFilesystem *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   PyObject * obj0 = 0 ;
   int result;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_filesystem_dump", 1, 1, &obj0)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraFilesystem, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_filesystem_dump" "', argument " "1"" of type '" "CameraFilesystem *""'"); 
   }
   arg1 = (CameraFilesystem *)(argp1);
   result = (int)gp_filesystem_dump(arg1);
@@ -6433,663 +6829,14 @@
   return resultobj;
 fail:
   return NULL;
 }
 
 
 static PyMethodDef SwigMethods[] = {
-	 { "SWIG_PyInstanceMethod_New", SWIG_PyInstanceMethod_New, METH_O, NULL},
-	 { "SWIG_PyStaticMethod_New", SWIG_PyStaticMethod_New, METH_O, NULL},
-	 { "gp_filesystem_new", _wrap_gp_filesystem_new, METH_VARARGS, "\n"
-		"gp_filesystem_new() -> int\n"
-		"Create a new filesystem struct.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `fs` :  \n"
-		"    a pointer to a CameraFilesystem  \n"
-		"\n"
-		"Creates a new empty CameraFilesystem  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		""},
-	 { "gp_filesystem_append", _wrap_gp_filesystem_append, METH_VARARGS, "\n"
-		"gp_filesystem_append(fs, folder, filename, context) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"fs: gphoto2.CameraFilesystem\n"
-		"folder: str\n"
-		"filename: str\n"
-		"context: gphoto2.Context (default=None)\n"
-		"\n"
-		""},
-	 { "gp_filesystem_set_info_noop", _wrap_gp_filesystem_set_info_noop, METH_VARARGS, "\n"
-		"gp_filesystem_set_info_noop(fs, folder, filename, info, context) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"fs: gphoto2.CameraFilesystem\n"
-		"folder: str\n"
-		"filename: str\n"
-		"info: gphoto2.CameraFileInfo\n"
-		"context: gphoto2.Context (default=None)\n"
-		"\n"
-		"Store the file information in the virtual fs.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `fs` :  \n"
-		"    a CameraFilesystem  \n"
-		"* `folder` :  \n"
-		"    the foldername  \n"
-		"* `info` :  \n"
-		"    the CameraFileInfo to store  \n"
-		"* `context` :  \n"
-		"    a GPContext  \n"
-		"\n"
-		"In contrast to gp_filesystem_set_info, gp_filesystem_set_info_noop will\n"
-		"only change the file information in the fs. Typically, camera drivers\n"
-		"will use this function in case they get file information \"for free\" on\n"
-		"gp_camera_capture or gp_camera_folder_list_files.  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code\n"
-		""},
-	 { "gp_filesystem_delete_file_noop", _wrap_gp_filesystem_delete_file_noop, METH_VARARGS, "\n"
-		"gp_filesystem_delete_file_noop(fs, folder, filename, context) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"fs: gphoto2.CameraFilesystem\n"
-		"folder: str\n"
-		"filename: str\n"
-		"context: gphoto2.Context (default=None)\n"
-		"\n"
-		"Delete a virtal file from a folder in the filesystem.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `fs` :  \n"
-		"    a CameraFilesystem  \n"
-		"* `folder` :  \n"
-		"    a folder in which to delete the file  \n"
-		"* `filename` :  \n"
-		"    the name of the file to delete  \n"
-		"* `context` :  \n"
-		"    a GPContext  \n"
-		"\n"
-		"Remove a file from the filesystem. Compared to\n"
-		"gp_filesystem_delete_file() this just removes the file from the\n"
-		"libgphoto2 view of the filesystem, but does not call the camera driver\n"
-		"to delete it from the physical device.  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		""},
-	 { "gp_filesystem_reset", _wrap_gp_filesystem_reset, METH_VARARGS, "\n"
-		"gp_filesystem_reset(fs) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"fs: gphoto2.CameraFilesystem\n"
-		"\n"
-		"Clear the filesystem.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `fs` :  \n"
-		"    the filesystem to be cleared  \n"
-		"\n"
-		"Resets the filesystem. All cached information including the folder tree\n"
-		"will get lost and will be queried again on demand.  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		""},
-	 { "gp_filesystem_count", _wrap_gp_filesystem_count, METH_VARARGS, "\n"
-		"gp_filesystem_count(fs, folder, context) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"fs: gphoto2.CameraFilesystem\n"
-		"folder: str\n"
-		"context: gphoto2.Context (default=None)\n"
-		"\n"
-		"Count files a folder of a filesystem.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `fs` :  \n"
-		"    a CameraFilesystem  \n"
-		"* `folder` :  \n"
-		"    a folder in which to count the files  \n"
-		"* `context` :  \n"
-		"    a GPContext  \n"
-		"\n"
-		"Counts the files in the folder.  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"The number of files in the folder or a gphoto2 error code.\n"
-		""},
-	 { "gp_filesystem_name", _wrap_gp_filesystem_name, METH_VARARGS, "\n"
-		"gp_filesystem_name(fs, folder, filenumber, context) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"fs: gphoto2.CameraFilesystem\n"
-		"folder: str\n"
-		"filenumber: int\n"
-		"context: gphoto2.Context (default=None)\n"
-		"\n"
-		"Lookup the filename of an indexed file within a folder.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `fs` :  \n"
-		"    a CameraFilesystem  \n"
-		"* `folder` :  \n"
-		"    the folder where to look up the file with the filenumber  \n"
-		"* `filenumber` :  \n"
-		"    the number of the file  \n"
-		"* `filename` :  \n"
-		"    pointer to a filename where the result is stored  \n"
-		"* `context` :  \n"
-		"    a GPContext  \n"
-		"\n"
-		"Looks up the filename of file with given filenumber in given folder. See\n"
-		"gp_filesystem_number for exactly the opposite functionality.  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		""},
-	 { "gp_filesystem_get_folder", _wrap_gp_filesystem_get_folder, METH_VARARGS, "\n"
-		"gp_filesystem_get_folder(fs, filename, context) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"fs: gphoto2.CameraFilesystem\n"
-		"filename: str\n"
-		"context: gphoto2.Context (default=None)\n"
-		"\n"
-		"Search a folder that contains a given filename.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `fs` :  \n"
-		"    a CameraFilesystem  \n"
-		"* `filename` :  \n"
-		"    the name of the file to search in the fs  \n"
-		"* `folder` :  \n"
-		"    pointer to value where the string is stored in  \n"
-		"* `context` :  \n"
-		"    a GPContext  \n"
-		"\n"
-		"Searches a file called filename in the fs and returns the first\n"
-		"occurrency. This functionality is needed for camera drivers that cannot\n"
-		"figure out where a file gets created after capturing an image although\n"
-		"the name of the image is known. Usually, those drivers will call\n"
-		"gp_filesystem_reset in order to tell the fs that something has changed\n"
-		"and then gp_filesystem_get_folder in order to find the file.  \n"
-		"\n"
-		"Note that you get a reference to the string stored in the filesystem\n"
-		"structure, so do not free it yourself.  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		""},
-	 { "gp_filesystem_number", _wrap_gp_filesystem_number, METH_VARARGS, "\n"
-		"gp_filesystem_number(fs, folder, filename, context) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"fs: gphoto2.CameraFilesystem\n"
-		"folder: str\n"
-		"filename: str\n"
-		"context: gphoto2.Context (default=None)\n"
-		"\n"
-		"Get the index of a file in specified folder.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `fs` :  \n"
-		"    a CameraFilesystem  \n"
-		"* `folder` :  \n"
-		"    the folder where to look for file called filename  \n"
-		"* `filename` :  \n"
-		"    the file to look for  \n"
-		"* `context` :  \n"
-		"    a GPContext  \n"
-		"\n"
-		"Looks for a file called filename in the given folder. See\n"
-		"gp_filesystem_name for exactly the opposite functionality.  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		""},
-	 { "gp_filesystem_list_files", _wrap_gp_filesystem_list_files, METH_VARARGS, "\n"
-		"gp_filesystem_list_files(fs, folder, context) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"fs: gphoto2.CameraFilesystem\n"
-		"folder: str\n"
-		"context: gphoto2.Context (default=None)\n"
-		"\n"
-		"Get the list of files in a folder.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `fs` :  \n"
-		"    a CameraFilesystem  \n"
-		"* `folder` :  \n"
-		"    a folder of which a file list should be generated  \n"
-		"* `list` :  \n"
-		"    a CameraList where to put the list of files into  \n"
-		"* `context` :  \n"
-		"    a GPContext  \n"
-		"\n"
-		"Lists the files in folder using either cached values or (if there aren't\n"
-		"any) the file_list_func which (hopefully) has been previously supplied.  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		""},
-	 { "gp_filesystem_list_folders", _wrap_gp_filesystem_list_folders, METH_VARARGS, "\n"
-		"gp_filesystem_list_folders(fs, folder, context) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"fs: gphoto2.CameraFilesystem\n"
-		"folder: str\n"
-		"context: gphoto2.Context (default=None)\n"
-		"\n"
-		"List all subfolders within a filesystem folder.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `fs` :  \n"
-		"    a CameraFilesystem  \n"
-		"* `folder` :  \n"
-		"    a folder  \n"
-		"* `list` :  \n"
-		"    a CameraList where subfolders should be listed  \n"
-		"* `context` :  \n"
-		"    a GPContext  \n"
-		"\n"
-		"Generates a list of subfolders of the supplied folder either using\n"
-		"cached values (if there are any) or the folder_list_func if it has been\n"
-		"supplied previously. If not, it is assumed that only a root folder\n"
-		"exists (which is the case for many cameras).  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		""},
-	 { "gp_filesystem_get_info", _wrap_gp_filesystem_get_info, METH_VARARGS, "\n"
-		"gp_filesystem_get_info(fs, folder, filename, context) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"fs: gphoto2.CameraFilesystem\n"
-		"folder: str\n"
-		"filename: str\n"
-		"context: gphoto2.Context (default=None)\n"
-		"\n"
-		"Get information about the specified file.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `fs` :  \n"
-		"    a CameraFilesystem  \n"
-		"* `folder` :  \n"
-		"    the folder that contains the file  \n"
-		"* `filename` :  \n"
-		"    the filename  \n"
-		"* `info` :  \n"
-		"    pointer to CameraFileInfo that receives the information  \n"
-		"* `context` :  \n"
-		"    a GPContext  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		""},
-	 { "gp_filesystem_set_info", _wrap_gp_filesystem_set_info, METH_VARARGS, "\n"
-		"gp_filesystem_set_info(fs, folder, filename, info, context) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"fs: gphoto2.CameraFilesystem\n"
-		"folder: str\n"
-		"filename: str\n"
-		"info: gphoto2.CameraFileInfo\n"
-		"context: gphoto2.Context (default=None)\n"
-		"\n"
-		"Set information about a file.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `fs` :  \n"
-		"    a CameraFilesystem  \n"
-		"* `folder` :  \n"
-		"    foldername where the file resides  \n"
-		"* `filename` :  \n"
-		"    the files name  \n"
-		"* `info` :  \n"
-		"    the CameraFileInfo to set  \n"
-		"* `context` :  \n"
-		"    a GPContext  \n"
-		"\n"
-		"Sets information about a file in the camera.  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		""},
-	 { "gp_filesystem_get_file", _wrap_gp_filesystem_get_file, METH_VARARGS, "\n"
-		"gp_filesystem_get_file(fs, folder, filename, type, file, context) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"fs: gphoto2.CameraFilesystem\n"
-		"folder: str\n"
-		"filename: str\n"
-		"type: CameraFileType (gphoto2.GP_FILE_TYPE_PREVIEW etc.)\n"
-		"file: gphoto2.CameraFile\n"
-		"context: gphoto2.Context (default=None)\n"
-		"\n"
-		"Get file data from the filesystem.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `fs` :  \n"
-		"    a CameraFilesystem  \n"
-		"* `folder` :  \n"
-		"    the folder in which the file can be found  \n"
-		"* `filename` :  \n"
-		"    the name of the file to download  \n"
-		"* `type` :  \n"
-		"    the type of the file  \n"
-		"* `file` :  \n"
-		"    the file that receives the data  \n"
-		"* `context` :  \n"
-		"    a GPContext  \n"
-		"\n"
-		"Downloads the file called filename from the folder using the\n"
-		"get_file_func if such a function has been previously supplied. If the\n"
-		"file has been previously downloaded, the file is retrieved from cache.\n"
-		"The result is stored in the passed file structure.  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		""},
-	 { "gp_filesystem_read_file", _wrap_gp_filesystem_read_file, METH_VARARGS, "\n"
-		"gp_filesystem_read_file(fs, folder, filename, type, offset, buf, size, context) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"fs: gphoto2.CameraFilesystem\n"
-		"folder: str\n"
-		"filename: str\n"
-		"type: CameraFileType (gphoto2.GP_FILE_TYPE_PREVIEW etc.)\n"
-		"offset: int\n"
-		"buf: char *\n"
-		"size: uint64_t *\n"
-		"context: gphoto2.Context (default=None)\n"
-		"\n"
-		"Get partial file data from the filesystem.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `fs` :  \n"
-		"    a CameraFilesystem  \n"
-		"* `folder` :  \n"
-		"    the folder in which the file can be found  \n"
-		"* `filename` :  \n"
-		"    the name of the file to download  \n"
-		"* `type` :  \n"
-		"    the type of the file  \n"
-		"* `offset` :  \n"
-		"    the offset where the data starts  \n"
-		"* `buf` :  \n"
-		"    the targetbuffer where the data will be put  \n"
-		"* `size` :  \n"
-		"    the size to read and that was read into the buffer  \n"
-		"* `context` :  \n"
-		"    a GPContext  \n"
-		"\n"
-		"Downloads the file called filename from the folder using the\n"
-		"read_file_func if such a function has been previously supplied. If the\n"
-		"file has been previously downloaded, the file is retrieved from cache.  \n"
-		"\n"
-		"The file is read partially into the passed buffer. The read starts at\n"
-		"offset on the device and goes for at most size bytes. Reading over the\n"
-		"end of the file might give errors, so get the maximum file size via an\n"
-		"info function before.  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		""},
-	 { "gp_filesystem_delete_file", _wrap_gp_filesystem_delete_file, METH_VARARGS, "\n"
-		"gp_filesystem_delete_file(fs, folder, filename, context) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"fs: gphoto2.CameraFilesystem\n"
-		"folder: str\n"
-		"filename: str\n"
-		"context: gphoto2.Context (default=None)\n"
-		"\n"
-		"Delete a file from a folder.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `fs` :  \n"
-		"    a CameraFilesystem  \n"
-		"* `folder` :  \n"
-		"    a folder in which to delete the file  \n"
-		"* `filename` :  \n"
-		"    the name of the file to delete  \n"
-		"* `context` :  \n"
-		"    a GPContext  \n"
-		"\n"
-		"If a delete_file_func has been supplied to the fs, this function will be\n"
-		"called and, if this function returns without error, the file will be\n"
-		"removed from the fs.  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		""},
-	 { "gp_filesystem_set_funcs", _wrap_gp_filesystem_set_funcs, METH_VARARGS, "\n"
-		"gp_filesystem_set_funcs(fs, funcs, data) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"fs: gphoto2.CameraFilesystem\n"
-		"funcs: CameraFilesystemFuncs *\n"
-		"data: void *\n"
-		"\n"
-		"Set all filesystem related function pointers.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `fs` :  \n"
-		"    a CameraFilesystem  \n"
-		"* `funcs` :  \n"
-		"    pointer to a struct of filesystem functions  \n"
-		"* `data` :  \n"
-		"    private data  \n"
-		"\n"
-		"Tells the filesystem which functions to call for camera/filesystem\n"
-		"specific functions, like listing, retrieving, uploading files and so on.  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		""},
-	 { "gp_filesystem_put_file", _wrap_gp_filesystem_put_file, METH_VARARGS, "\n"
-		"gp_filesystem_put_file(fs, folder, filename, type, file, context) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"fs: gphoto2.CameraFilesystem\n"
-		"folder: str\n"
-		"filename: str\n"
-		"type: CameraFileType (gphoto2.GP_FILE_TYPE_PREVIEW etc.)\n"
-		"file: gphoto2.CameraFile\n"
-		"context: gphoto2.Context (default=None)\n"
-		"\n"
-		"Upload a file to a folder on the device filesystem.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `fs` :  \n"
-		"    a CameraFilesystem  \n"
-		"* `folder` :  \n"
-		"    the folder where to put the file into  \n"
-		"* `file` :  \n"
-		"    the file  \n"
-		"* `context` :  \n"
-		"    a GPContext  \n"
-		"\n"
-		"Uploads a file to the camera if a put_file_func has been previously\n"
-		"supplied to the fs. If the upload is successful, the file will get\n"
-		"cached in the fs.  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		""},
-	 { "gp_filesystem_delete_all", _wrap_gp_filesystem_delete_all, METH_VARARGS, "\n"
-		"gp_filesystem_delete_all(fs, folder, context) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"fs: gphoto2.CameraFilesystem\n"
-		"folder: str\n"
-		"context: gphoto2.Context (default=None)\n"
-		"\n"
-		"Delete all files in specified folder.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `fs` :  \n"
-		"    a CameraFilesystem  \n"
-		"* `folder` :  \n"
-		"    the folder in which to delete all files  \n"
-		"* `context` :  \n"
-		"    a GPContext  \n"
-		"\n"
-		"Deletes all files in the given folder from the fs. If the fs has not\n"
-		"been supplied with a delete_all_func, it tries to delete the files one\n"
-		"by one using the delete_file_func. If that function has not been\n"
-		"supplied neither, an error is returned.  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		""},
-	 { "gp_filesystem_make_dir", _wrap_gp_filesystem_make_dir, METH_VARARGS, "\n"
-		"gp_filesystem_make_dir(fs, folder, name, context) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"fs: gphoto2.CameraFilesystem\n"
-		"folder: str\n"
-		"name: str\n"
-		"context: gphoto2.Context (default=None)\n"
-		"\n"
-		"Create a subfolder within a folder.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `fs` :  \n"
-		"    a CameraFilesystem  \n"
-		"* `folder` :  \n"
-		"    the folder in which the directory should be created  \n"
-		"* `name` :  \n"
-		"    the name of the directory to be created  \n"
-		"* `context` :  \n"
-		"    a GPContext  \n"
-		"\n"
-		"Creates a new directory called name in given folder.  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code\n"
-		""},
-	 { "gp_filesystem_remove_dir", _wrap_gp_filesystem_remove_dir, METH_VARARGS, "\n"
-		"gp_filesystem_remove_dir(fs, folder, name, context) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"fs: gphoto2.CameraFilesystem\n"
-		"folder: str\n"
-		"name: str\n"
-		"context: gphoto2.Context (default=None)\n"
-		"\n"
-		"Remove a subfolder from within a folder.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `fs` :  \n"
-		"    a CameraFilesystem  \n"
-		"* `folder` :  \n"
-		"    the folder in which the directory should be created  \n"
-		"* `name` :  \n"
-		"    the name of the directory to be created  \n"
-		"* `context` :  \n"
-		"    a GPContext  \n"
-		"\n"
-		"Removes a directory called name from the given folder.  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code\n"
-		""},
-	 { "gp_filesystem_dump", _wrap_gp_filesystem_dump, METH_VARARGS, "\n"
-		"gp_filesystem_dump(fs) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"fs: gphoto2.CameraFilesystem\n"
-		"\n"
-		"Dump the current filesystem.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `fs` :  \n"
-		"    the CameraFilesystem  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto error code  \n"
-		"\n"
-		"Internal function to dump the current filesystem.\n"
-		""},
-	 { NULL, NULL, 0, NULL }
-};
-
-static PyMethodDef SwigMethods_proxydocs[] = {
-	 { "SWIG_PyInstanceMethod_New", SWIG_PyInstanceMethod_New, METH_O, NULL},
-	 { "SWIG_PyStaticMethod_New", SWIG_PyStaticMethod_New, METH_O, NULL},
 	 { "gp_filesystem_new", _wrap_gp_filesystem_new, METH_VARARGS, "\n"
 		"gp_filesystem_new() -> int\n"
 		"Create a new filesystem struct.  \n"
 		"\n"
 		"Parameters\n"
 		"----------\n"
 		"* `fs` :  \n"
@@ -7773,15 +7520,19 @@
     PyObject_HEAD_INIT(NULL)
     0,                                        /* ob_size */
 #endif
     "gphoto2.filesys._CameraFilesystem",      /* tp_name */
     sizeof(SwigPyObject),                     /* tp_basicsize */
     0,                                        /* tp_itemsize */
     _wrap_delete__CameraFilesystem_destructor_closure,            /* tp_dealloc */
+#if PY_VERSION_HEX < 0x030800b4
     (printfunc) 0,                            /* tp_print */
+#else
+    (Py_ssize_t) 0,                           /* tp_vectorcall_offset */
+#endif
     (getattrfunc) 0,                          /* tp_getattr */
     (setattrfunc) 0,                          /* tp_setattr */
 #if PY_VERSION_HEX >= 0x03000000
     0,                                        /* tp_compare */
 #else
     (cmpfunc) 0,                              /* tp_compare */
 #endif
@@ -7850,14 +7601,17 @@
 #endif
   },
 #if PY_VERSION_HEX >= 0x03050000
   {
     (unaryfunc) 0,                            /* am_await */
     (unaryfunc) 0,                            /* am_aiter */
     (unaryfunc) 0,                            /* am_anext */
+# if PY_VERSION_HEX >= 0x030a0000
+    (sendfunc) 0,                             /* am_send */
+# endif
   },
 #endif
   {
     (binaryfunc) 0,                           /* nb_add */
     (binaryfunc) 0,                           /* nb_subtract */
     (binaryfunc) 0,                           /* nb_multiply */
 #if PY_VERSION_HEX < 0x03000000
@@ -7950,37 +7704,46 @@
   },
     (PyObject *) 0,                           /* ht_name */
     (PyObject *) 0,                           /* ht_slots */
 #if PY_VERSION_HEX >= 0x03030000
     (PyObject *) 0,                           /* ht_qualname */
     0,                                        /* ht_cached_keys */
 #endif
+#if PY_VERSION_HEX >= 0x03090000
+    (PyObject *) 0,                           /* ht_module */
+#endif
+#if PY_VERSION_HEX >= 0x030b0000
+    (char *) 0,                               /* _ht_tpname */
+  {
+    (PyObject *) 0,                           /* getitem */
+  }
+#endif
 };
 
 SWIGINTERN SwigPyClientData SwigPyBuiltin___CameraFilesystem_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin___CameraFilesystem_type};
 
+static SwigPyGetSet CameraFileInfoFile_type_getset = { _wrap_CameraFileInfoFile_type_get, 0 };
+static SwigPyGetSet CameraFileInfoFile_size_getset = { _wrap_CameraFileInfoFile_size_get, 0 };
 static SwigPyGetSet CameraFileInfoFile_status_getset = { _wrap_CameraFileInfoFile_status_get, 0 };
 static SwigPyGetSet CameraFileInfoFile_permissions_getset = { _wrap_CameraFileInfoFile_permissions_get, 0 };
 static SwigPyGetSet CameraFileInfoFile___dict___getset = { SwigPyObject_get___dict__, 0 };
-static SwigPyGetSet CameraFileInfoFile_size_getset = { _wrap_CameraFileInfoFile_size_get, 0 };
-static SwigPyGetSet CameraFileInfoFile_type_getset = { _wrap_CameraFileInfoFile_type_get, 0 };
-static SwigPyGetSet CameraFileInfoFile_height_getset = { _wrap_CameraFileInfoFile_height_get, 0 };
-static SwigPyGetSet CameraFileInfoFile_mtime_getset = { _wrap_CameraFileInfoFile_mtime_get, 0 };
 static SwigPyGetSet CameraFileInfoFile_fields_getset = { _wrap_CameraFileInfoFile_fields_get, 0 };
 static SwigPyGetSet CameraFileInfoFile_width_getset = { _wrap_CameraFileInfoFile_width_get, 0 };
+static SwigPyGetSet CameraFileInfoFile_height_getset = { _wrap_CameraFileInfoFile_height_get, 0 };
+static SwigPyGetSet CameraFileInfoFile_mtime_getset = { _wrap_CameraFileInfoFile_mtime_get, 0 };
 SWIGINTERN PyGetSetDef SwigPyBuiltin___CameraFileInfoFile_getset[] = {
+    { (char *)"type", SwigPyBuiltin_GetterClosure, 0, (char *)"type", &CameraFileInfoFile_type_getset },
+    { (char *)"size", SwigPyBuiltin_GetterClosure, 0, (char *)"size", &CameraFileInfoFile_size_getset },
     { (char *)"status", SwigPyBuiltin_GetterClosure, 0, (char *)"status", &CameraFileInfoFile_status_getset },
     { (char *)"permissions", SwigPyBuiltin_GetterClosure, 0, (char *)"permissions", &CameraFileInfoFile_permissions_getset },
     { (char *)"__dict__", SwigPyBuiltin_GetterClosure, 0, (char *)"fields", &CameraFileInfoFile___dict___getset },
-    { (char *)"size", SwigPyBuiltin_GetterClosure, 0, (char *)"size", &CameraFileInfoFile_size_getset },
-    { (char *)"type", SwigPyBuiltin_GetterClosure, 0, (char *)"type", &CameraFileInfoFile_type_getset },
-    { (char *)"height", SwigPyBuiltin_GetterClosure, 0, (char *)"height", &CameraFileInfoFile_height_getset },
-    { (char *)"mtime", SwigPyBuiltin_GetterClosure, 0, (char *)"mtime", &CameraFileInfoFile_mtime_getset },
     { (char *)"fields", SwigPyBuiltin_GetterClosure, 0, (char *)"fields", &CameraFileInfoFile_fields_getset },
     { (char *)"width", SwigPyBuiltin_GetterClosure, 0, (char *)"width", &CameraFileInfoFile_width_getset },
+    { (char *)"height", SwigPyBuiltin_GetterClosure, 0, (char *)"height", &CameraFileInfoFile_height_getset },
+    { (char *)"mtime", SwigPyBuiltin_GetterClosure, 0, (char *)"mtime", &CameraFileInfoFile_mtime_getset },
     { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
 };
 
 SWIGINTERN PyObject *
 SwigPyBuiltin___CameraFileInfoFile_richcompare(PyObject *self, PyObject *other, int op) {
   PyObject *result = NULL;
   PyObject *tuple = PyTuple_New(1);
@@ -8011,15 +7774,19 @@
     PyObject_HEAD_INIT(NULL)
     0,                                        /* ob_size */
 #endif
     "gphoto2.filesys.CameraFileInfoFile",     /* tp_name */
     sizeof(SwigPyObject),                     /* tp_basicsize */
     0,                                        /* tp_itemsize */
     _wrap_delete_CameraFileInfoFile_destructor_closure,           /* tp_dealloc */
+#if PY_VERSION_HEX < 0x030800b4
     (printfunc) 0,                            /* tp_print */
+#else
+    (Py_ssize_t) 0,                           /* tp_vectorcall_offset */
+#endif
     (getattrfunc) 0,                          /* tp_getattr */
     (setattrfunc) 0,                          /* tp_setattr */
 #if PY_VERSION_HEX >= 0x03000000
     0,                                        /* tp_compare */
 #else
     (cmpfunc) 0,                              /* tp_compare */
 #endif
@@ -8090,14 +7857,17 @@
 #endif
   },
 #if PY_VERSION_HEX >= 0x03050000
   {
     (unaryfunc) 0,                            /* am_await */
     (unaryfunc) 0,                            /* am_aiter */
     (unaryfunc) 0,                            /* am_anext */
+# if PY_VERSION_HEX >= 0x030a0000
+    (sendfunc) 0,                             /* am_send */
+# endif
   },
 #endif
   {
     (binaryfunc) 0,                           /* nb_add */
     (binaryfunc) 0,                           /* nb_subtract */
     (binaryfunc) 0,                           /* nb_multiply */
 #if PY_VERSION_HEX < 0x03000000
@@ -8190,33 +7960,42 @@
   },
     (PyObject *) 0,                           /* ht_name */
     (PyObject *) 0,                           /* ht_slots */
 #if PY_VERSION_HEX >= 0x03030000
     (PyObject *) 0,                           /* ht_qualname */
     0,                                        /* ht_cached_keys */
 #endif
+#if PY_VERSION_HEX >= 0x03090000
+    (PyObject *) 0,                           /* ht_module */
+#endif
+#if PY_VERSION_HEX >= 0x030b0000
+    (char *) 0,                               /* _ht_tpname */
+  {
+    (PyObject *) 0,                           /* getitem */
+  }
+#endif
 };
 
 SWIGINTERN SwigPyClientData SwigPyBuiltin___CameraFileInfoFile_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin___CameraFileInfoFile_type};
 
+static SwigPyGetSet CameraFileInfoPreview_type_getset = { _wrap_CameraFileInfoPreview_type_get, 0 };
+static SwigPyGetSet CameraFileInfoPreview_size_getset = { _wrap_CameraFileInfoPreview_size_get, 0 };
 static SwigPyGetSet CameraFileInfoPreview_status_getset = { _wrap_CameraFileInfoPreview_status_get, 0 };
 static SwigPyGetSet CameraFileInfoPreview___dict___getset = { SwigPyObject_get___dict__, 0 };
-static SwigPyGetSet CameraFileInfoPreview_size_getset = { _wrap_CameraFileInfoPreview_size_get, 0 };
-static SwigPyGetSet CameraFileInfoPreview_type_getset = { _wrap_CameraFileInfoPreview_type_get, 0 };
-static SwigPyGetSet CameraFileInfoPreview_height_getset = { _wrap_CameraFileInfoPreview_height_get, 0 };
 static SwigPyGetSet CameraFileInfoPreview_fields_getset = { _wrap_CameraFileInfoPreview_fields_get, 0 };
 static SwigPyGetSet CameraFileInfoPreview_width_getset = { _wrap_CameraFileInfoPreview_width_get, 0 };
+static SwigPyGetSet CameraFileInfoPreview_height_getset = { _wrap_CameraFileInfoPreview_height_get, 0 };
 SWIGINTERN PyGetSetDef SwigPyBuiltin___CameraFileInfoPreview_getset[] = {
+    { (char *)"type", SwigPyBuiltin_GetterClosure, 0, (char *)"type", &CameraFileInfoPreview_type_getset },
+    { (char *)"size", SwigPyBuiltin_GetterClosure, 0, (char *)"size", &CameraFileInfoPreview_size_getset },
     { (char *)"status", SwigPyBuiltin_GetterClosure, 0, (char *)"status", &CameraFileInfoPreview_status_getset },
     { (char *)"__dict__", SwigPyBuiltin_GetterClosure, 0, (char *)"fields", &CameraFileInfoPreview___dict___getset },
-    { (char *)"size", SwigPyBuiltin_GetterClosure, 0, (char *)"size", &CameraFileInfoPreview_size_getset },
-    { (char *)"type", SwigPyBuiltin_GetterClosure, 0, (char *)"type", &CameraFileInfoPreview_type_getset },
-    { (char *)"height", SwigPyBuiltin_GetterClosure, 0, (char *)"height", &CameraFileInfoPreview_height_getset },
     { (char *)"fields", SwigPyBuiltin_GetterClosure, 0, (char *)"fields", &CameraFileInfoPreview_fields_getset },
     { (char *)"width", SwigPyBuiltin_GetterClosure, 0, (char *)"width", &CameraFileInfoPreview_width_getset },
+    { (char *)"height", SwigPyBuiltin_GetterClosure, 0, (char *)"height", &CameraFileInfoPreview_height_getset },
     { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
 };
 
 SWIGINTERN PyObject *
 SwigPyBuiltin___CameraFileInfoPreview_richcompare(PyObject *self, PyObject *other, int op) {
   PyObject *result = NULL;
   PyObject *tuple = PyTuple_New(1);
@@ -8247,15 +8026,19 @@
     PyObject_HEAD_INIT(NULL)
     0,                                        /* ob_size */
 #endif
     "gphoto2.filesys.CameraFileInfoPreview",  /* tp_name */
     sizeof(SwigPyObject),                     /* tp_basicsize */
     0,                                        /* tp_itemsize */
     _wrap_delete_CameraFileInfoPreview_destructor_closure,        /* tp_dealloc */
+#if PY_VERSION_HEX < 0x030800b4
     (printfunc) 0,                            /* tp_print */
+#else
+    (Py_ssize_t) 0,                           /* tp_vectorcall_offset */
+#endif
     (getattrfunc) 0,                          /* tp_getattr */
     (setattrfunc) 0,                          /* tp_setattr */
 #if PY_VERSION_HEX >= 0x03000000
     0,                                        /* tp_compare */
 #else
     (cmpfunc) 0,                              /* tp_compare */
 #endif
@@ -8326,14 +8109,17 @@
 #endif
   },
 #if PY_VERSION_HEX >= 0x03050000
   {
     (unaryfunc) 0,                            /* am_await */
     (unaryfunc) 0,                            /* am_aiter */
     (unaryfunc) 0,                            /* am_anext */
+# if PY_VERSION_HEX >= 0x030a0000
+    (sendfunc) 0,                             /* am_send */
+# endif
   },
 #endif
   {
     (binaryfunc) 0,                           /* nb_add */
     (binaryfunc) 0,                           /* nb_subtract */
     (binaryfunc) 0,                           /* nb_multiply */
 #if PY_VERSION_HEX < 0x03000000
@@ -8426,28 +8212,37 @@
   },
     (PyObject *) 0,                           /* ht_name */
     (PyObject *) 0,                           /* ht_slots */
 #if PY_VERSION_HEX >= 0x03030000
     (PyObject *) 0,                           /* ht_qualname */
     0,                                        /* ht_cached_keys */
 #endif
+#if PY_VERSION_HEX >= 0x03090000
+    (PyObject *) 0,                           /* ht_module */
+#endif
+#if PY_VERSION_HEX >= 0x030b0000
+    (char *) 0,                               /* _ht_tpname */
+  {
+    (PyObject *) 0,                           /* getitem */
+  }
+#endif
 };
 
 SWIGINTERN SwigPyClientData SwigPyBuiltin___CameraFileInfoPreview_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin___CameraFileInfoPreview_type};
 
+static SwigPyGetSet CameraFileInfoAudio_type_getset = { _wrap_CameraFileInfoAudio_type_get, 0 };
+static SwigPyGetSet CameraFileInfoAudio_size_getset = { _wrap_CameraFileInfoAudio_size_get, 0 };
 static SwigPyGetSet CameraFileInfoAudio_status_getset = { _wrap_CameraFileInfoAudio_status_get, 0 };
 static SwigPyGetSet CameraFileInfoAudio___dict___getset = { SwigPyObject_get___dict__, 0 };
-static SwigPyGetSet CameraFileInfoAudio_size_getset = { _wrap_CameraFileInfoAudio_size_get, 0 };
-static SwigPyGetSet CameraFileInfoAudio_type_getset = { _wrap_CameraFileInfoAudio_type_get, 0 };
 static SwigPyGetSet CameraFileInfoAudio_fields_getset = { _wrap_CameraFileInfoAudio_fields_get, 0 };
 SWIGINTERN PyGetSetDef SwigPyBuiltin___CameraFileInfoAudio_getset[] = {
+    { (char *)"type", SwigPyBuiltin_GetterClosure, 0, (char *)"type", &CameraFileInfoAudio_type_getset },
+    { (char *)"size", SwigPyBuiltin_GetterClosure, 0, (char *)"size", &CameraFileInfoAudio_size_getset },
     { (char *)"status", SwigPyBuiltin_GetterClosure, 0, (char *)"status", &CameraFileInfoAudio_status_getset },
     { (char *)"__dict__", SwigPyBuiltin_GetterClosure, 0, (char *)"fields", &CameraFileInfoAudio___dict___getset },
-    { (char *)"size", SwigPyBuiltin_GetterClosure, 0, (char *)"size", &CameraFileInfoAudio_size_getset },
-    { (char *)"type", SwigPyBuiltin_GetterClosure, 0, (char *)"type", &CameraFileInfoAudio_type_getset },
     { (char *)"fields", SwigPyBuiltin_GetterClosure, 0, (char *)"fields", &CameraFileInfoAudio_fields_getset },
     { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
 };
 
 SWIGINTERN PyObject *
 SwigPyBuiltin___CameraFileInfoAudio_richcompare(PyObject *self, PyObject *other, int op) {
   PyObject *result = NULL;
@@ -8479,15 +8274,19 @@
     PyObject_HEAD_INIT(NULL)
     0,                                        /* ob_size */
 #endif
     "gphoto2.filesys.CameraFileInfoAudio",    /* tp_name */
     sizeof(SwigPyObject),                     /* tp_basicsize */
     0,                                        /* tp_itemsize */
     _wrap_delete_CameraFileInfoAudio_destructor_closure,          /* tp_dealloc */
+#if PY_VERSION_HEX < 0x030800b4
     (printfunc) 0,                            /* tp_print */
+#else
+    (Py_ssize_t) 0,                           /* tp_vectorcall_offset */
+#endif
     (getattrfunc) 0,                          /* tp_getattr */
     (setattrfunc) 0,                          /* tp_setattr */
 #if PY_VERSION_HEX >= 0x03000000
     0,                                        /* tp_compare */
 #else
     (cmpfunc) 0,                              /* tp_compare */
 #endif
@@ -8558,14 +8357,17 @@
 #endif
   },
 #if PY_VERSION_HEX >= 0x03050000
   {
     (unaryfunc) 0,                            /* am_await */
     (unaryfunc) 0,                            /* am_aiter */
     (unaryfunc) 0,                            /* am_anext */
+# if PY_VERSION_HEX >= 0x030a0000
+    (sendfunc) 0,                             /* am_send */
+# endif
   },
 #endif
   {
     (binaryfunc) 0,                           /* nb_add */
     (binaryfunc) 0,                           /* nb_subtract */
     (binaryfunc) 0,                           /* nb_multiply */
 #if PY_VERSION_HEX < 0x03000000
@@ -8658,27 +8460,36 @@
   },
     (PyObject *) 0,                           /* ht_name */
     (PyObject *) 0,                           /* ht_slots */
 #if PY_VERSION_HEX >= 0x03030000
     (PyObject *) 0,                           /* ht_qualname */
     0,                                        /* ht_cached_keys */
 #endif
+#if PY_VERSION_HEX >= 0x03090000
+    (PyObject *) 0,                           /* ht_module */
+#endif
+#if PY_VERSION_HEX >= 0x030b0000
+    (char *) 0,                               /* _ht_tpname */
+  {
+    (PyObject *) 0,                           /* getitem */
+  }
+#endif
 };
 
 SWIGINTERN SwigPyClientData SwigPyBuiltin___CameraFileInfoAudio_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin___CameraFileInfoAudio_type};
 
-static SwigPyGetSet CameraFileInfo___dict___getset = { SwigPyObject_get___dict__, 0 };
-static SwigPyGetSet CameraFileInfo_preview_getset = { _wrap_CameraFileInfo_preview_get, 0 };
-static SwigPyGetSet CameraFileInfo_audio_getset = { _wrap_CameraFileInfo_audio_get, 0 };
 static SwigPyGetSet CameraFileInfo_file_getset = { _wrap_CameraFileInfo_file_get, 0 };
+static SwigPyGetSet CameraFileInfo_audio_getset = { _wrap_CameraFileInfo_audio_get, 0 };
+static SwigPyGetSet CameraFileInfo_preview_getset = { _wrap_CameraFileInfo_preview_get, 0 };
+static SwigPyGetSet CameraFileInfo___dict___getset = { SwigPyObject_get___dict__, 0 };
 SWIGINTERN PyGetSetDef SwigPyBuiltin___CameraFileInfo_getset[] = {
-    { (char *)"__dict__", SwigPyBuiltin_GetterClosure, 0, (char *)"preview", &CameraFileInfo___dict___getset },
-    { (char *)"preview", SwigPyBuiltin_GetterClosure, 0, (char *)"preview", &CameraFileInfo_preview_getset },
-    { (char *)"audio", SwigPyBuiltin_GetterClosure, 0, (char *)"audio", &CameraFileInfo_audio_getset },
     { (char *)"file", SwigPyBuiltin_GetterClosure, 0, (char *)"file", &CameraFileInfo_file_getset },
+    { (char *)"audio", SwigPyBuiltin_GetterClosure, 0, (char *)"audio", &CameraFileInfo_audio_getset },
+    { (char *)"preview", SwigPyBuiltin_GetterClosure, 0, (char *)"preview", &CameraFileInfo_preview_getset },
+    { (char *)"__dict__", SwigPyBuiltin_GetterClosure, 0, (char *)"preview", &CameraFileInfo___dict___getset },
     { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
 };
 
 SWIGINTERN PyObject *
 SwigPyBuiltin___CameraFileInfo_richcompare(PyObject *self, PyObject *other, int op) {
   PyObject *result = NULL;
   PyObject *tuple = PyTuple_New(1);
@@ -8709,15 +8520,19 @@
     PyObject_HEAD_INIT(NULL)
     0,                                        /* ob_size */
 #endif
     "gphoto2.filesys.CameraFileInfo",         /* tp_name */
     sizeof(SwigPyObject),                     /* tp_basicsize */
     0,                                        /* tp_itemsize */
     _wrap_delete_CameraFileInfo_destructor_closure,               /* tp_dealloc */
+#if PY_VERSION_HEX < 0x030800b4
     (printfunc) 0,                            /* tp_print */
+#else
+    (Py_ssize_t) 0,                           /* tp_vectorcall_offset */
+#endif
     (getattrfunc) 0,                          /* tp_getattr */
     (setattrfunc) 0,                          /* tp_setattr */
 #if PY_VERSION_HEX >= 0x03000000
     0,                                        /* tp_compare */
 #else
     (cmpfunc) 0,                              /* tp_compare */
 #endif
@@ -8788,14 +8603,17 @@
 #endif
   },
 #if PY_VERSION_HEX >= 0x03050000
   {
     (unaryfunc) 0,                            /* am_await */
     (unaryfunc) 0,                            /* am_aiter */
     (unaryfunc) 0,                            /* am_anext */
+# if PY_VERSION_HEX >= 0x030a0000
+    (sendfunc) 0,                             /* am_send */
+# endif
   },
 #endif
   {
     (binaryfunc) 0,                           /* nb_add */
     (binaryfunc) 0,                           /* nb_subtract */
     (binaryfunc) 0,                           /* nb_multiply */
 #if PY_VERSION_HEX < 0x03000000
@@ -8888,41 +8706,50 @@
   },
     (PyObject *) 0,                           /* ht_name */
     (PyObject *) 0,                           /* ht_slots */
 #if PY_VERSION_HEX >= 0x03030000
     (PyObject *) 0,                           /* ht_qualname */
     0,                                        /* ht_cached_keys */
 #endif
+#if PY_VERSION_HEX >= 0x03090000
+    (PyObject *) 0,                           /* ht_module */
+#endif
+#if PY_VERSION_HEX >= 0x030b0000
+    (char *) 0,                               /* _ht_tpname */
+  {
+    (PyObject *) 0,                           /* getitem */
+  }
+#endif
 };
 
 SWIGINTERN SwigPyClientData SwigPyBuiltin___CameraFileInfo_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin___CameraFileInfo_type};
 
+static SwigPyGetSet CameraStorageInformation_type_getset = { _wrap_CameraStorageInformation_type_get, 0 };
+static SwigPyGetSet CameraStorageInformation_basedir_getset = { _wrap_CameraStorageInformation_basedir_get, 0 };
 static SwigPyGetSet CameraStorageInformation_fstype_getset = { _wrap_CameraStorageInformation_fstype_get, 0 };
-static SwigPyGetSet CameraStorageInformation_access_getset = { _wrap_CameraStorageInformation_access_get, 0 };
+static SwigPyGetSet CameraStorageInformation_capacitykbytes_getset = { _wrap_CameraStorageInformation_capacitykbytes_get, 0 };
+static SwigPyGetSet CameraStorageInformation_freekbytes_getset = { _wrap_CameraStorageInformation_freekbytes_get, 0 };
 static SwigPyGetSet CameraStorageInformation___dict___getset = { SwigPyObject_get___dict__, 0 };
-static SwigPyGetSet CameraStorageInformation_freeimages_getset = { _wrap_CameraStorageInformation_freeimages_get, 0 };
-static SwigPyGetSet CameraStorageInformation_basedir_getset = { _wrap_CameraStorageInformation_basedir_get, 0 };
-static SwigPyGetSet CameraStorageInformation_description_getset = { _wrap_CameraStorageInformation_description_get, 0 };
-static SwigPyGetSet CameraStorageInformation_type_getset = { _wrap_CameraStorageInformation_type_get, 0 };
 static SwigPyGetSet CameraStorageInformation_fields_getset = { _wrap_CameraStorageInformation_fields_get, 0 };
 static SwigPyGetSet CameraStorageInformation_label_getset = { _wrap_CameraStorageInformation_label_get, 0 };
-static SwigPyGetSet CameraStorageInformation_capacitykbytes_getset = { _wrap_CameraStorageInformation_capacitykbytes_get, 0 };
-static SwigPyGetSet CameraStorageInformation_freekbytes_getset = { _wrap_CameraStorageInformation_freekbytes_get, 0 };
+static SwigPyGetSet CameraStorageInformation_description_getset = { _wrap_CameraStorageInformation_description_get, 0 };
+static SwigPyGetSet CameraStorageInformation_freeimages_getset = { _wrap_CameraStorageInformation_freeimages_get, 0 };
+static SwigPyGetSet CameraStorageInformation_access_getset = { _wrap_CameraStorageInformation_access_get, 0 };
 SWIGINTERN PyGetSetDef SwigPyBuiltin___CameraStorageInformation_getset[] = {
+    { (char *)"type", SwigPyBuiltin_GetterClosure, 0, (char *)"type", &CameraStorageInformation_type_getset },
+    { (char *)"basedir", SwigPyBuiltin_GetterClosure, 0, (char *)"basedir", &CameraStorageInformation_basedir_getset },
     { (char *)"fstype", SwigPyBuiltin_GetterClosure, 0, (char *)"fstype", &CameraStorageInformation_fstype_getset },
-    { (char *)"access", SwigPyBuiltin_GetterClosure, 0, (char *)"access", &CameraStorageInformation_access_getset },
+    { (char *)"capacitykbytes", SwigPyBuiltin_GetterClosure, 0, (char *)"capacitykbytes", &CameraStorageInformation_capacitykbytes_getset },
+    { (char *)"freekbytes", SwigPyBuiltin_GetterClosure, 0, (char *)"freekbytes", &CameraStorageInformation_freekbytes_getset },
     { (char *)"__dict__", SwigPyBuiltin_GetterClosure, 0, (char *)"fields", &CameraStorageInformation___dict___getset },
-    { (char *)"freeimages", SwigPyBuiltin_GetterClosure, 0, (char *)"freeimages", &CameraStorageInformation_freeimages_getset },
-    { (char *)"basedir", SwigPyBuiltin_GetterClosure, 0, (char *)"basedir", &CameraStorageInformation_basedir_getset },
-    { (char *)"description", SwigPyBuiltin_GetterClosure, 0, (char *)"description", &CameraStorageInformation_description_getset },
-    { (char *)"type", SwigPyBuiltin_GetterClosure, 0, (char *)"type", &CameraStorageInformation_type_getset },
     { (char *)"fields", SwigPyBuiltin_GetterClosure, 0, (char *)"fields", &CameraStorageInformation_fields_getset },
     { (char *)"label", SwigPyBuiltin_GetterClosure, 0, (char *)"label", &CameraStorageInformation_label_getset },
-    { (char *)"capacitykbytes", SwigPyBuiltin_GetterClosure, 0, (char *)"capacitykbytes", &CameraStorageInformation_capacitykbytes_getset },
-    { (char *)"freekbytes", SwigPyBuiltin_GetterClosure, 0, (char *)"freekbytes", &CameraStorageInformation_freekbytes_getset },
+    { (char *)"description", SwigPyBuiltin_GetterClosure, 0, (char *)"description", &CameraStorageInformation_description_getset },
+    { (char *)"freeimages", SwigPyBuiltin_GetterClosure, 0, (char *)"freeimages", &CameraStorageInformation_freeimages_getset },
+    { (char *)"access", SwigPyBuiltin_GetterClosure, 0, (char *)"access", &CameraStorageInformation_access_getset },
     { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
 };
 
 SWIGINTERN PyObject *
 SwigPyBuiltin___CameraStorageInformation_richcompare(PyObject *self, PyObject *other, int op) {
   PyObject *result = NULL;
   PyObject *tuple = PyTuple_New(1);
@@ -8953,15 +8780,19 @@
     PyObject_HEAD_INIT(NULL)
     0,                                        /* ob_size */
 #endif
     "gphoto2.filesys.CameraStorageInformation",                   /* tp_name */
     sizeof(SwigPyObject),                     /* tp_basicsize */
     0,                                        /* tp_itemsize */
     _wrap_delete_CameraStorageInformation_destructor_closure,     /* tp_dealloc */
+#if PY_VERSION_HEX < 0x030800b4
     (printfunc) 0,                            /* tp_print */
+#else
+    (Py_ssize_t) 0,                           /* tp_vectorcall_offset */
+#endif
     (getattrfunc) 0,                          /* tp_getattr */
     (setattrfunc) 0,                          /* tp_setattr */
 #if PY_VERSION_HEX >= 0x03000000
     0,                                        /* tp_compare */
 #else
     (cmpfunc) 0,                              /* tp_compare */
 #endif
@@ -9032,14 +8863,17 @@
 #endif
   },
 #if PY_VERSION_HEX >= 0x03050000
   {
     (unaryfunc) 0,                            /* am_await */
     (unaryfunc) 0,                            /* am_aiter */
     (unaryfunc) 0,                            /* am_anext */
+# if PY_VERSION_HEX >= 0x030a0000
+    (sendfunc) 0,                             /* am_send */
+# endif
   },
 #endif
   {
     (binaryfunc) 0,                           /* nb_add */
     (binaryfunc) 0,                           /* nb_subtract */
     (binaryfunc) 0,                           /* nb_multiply */
 #if PY_VERSION_HEX < 0x03000000
@@ -9132,106 +8966,115 @@
   },
     (PyObject *) 0,                           /* ht_name */
     (PyObject *) 0,                           /* ht_slots */
 #if PY_VERSION_HEX >= 0x03030000
     (PyObject *) 0,                           /* ht_qualname */
     0,                                        /* ht_cached_keys */
 #endif
+#if PY_VERSION_HEX >= 0x03090000
+    (PyObject *) 0,                           /* ht_module */
+#endif
+#if PY_VERSION_HEX >= 0x030b0000
+    (char *) 0,                               /* _ht_tpname */
+  {
+    (PyObject *) 0,                           /* getitem */
+  }
+#endif
 };
 
 SWIGINTERN SwigPyClientData SwigPyBuiltin___CameraStorageInformation_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin___CameraStorageInformation_type};
 
-static SwigPyGetSet _CameraFilesystemFuncs_delete_all_func_getset = { _wrap__CameraFilesystemFuncs_delete_all_func_get, 0 };
-static SwigPyGetSet _CameraFilesystemFuncs_del_file_func_getset = { _wrap__CameraFilesystemFuncs_del_file_func_get, 0 };
-static SwigPyGetSet _CameraFilesystemFuncs_read_file_func_getset = { _wrap__CameraFilesystemFuncs_read_file_func_get, 0 };
-static SwigPyGetSet _CameraFilesystemFuncs_get_file_func_getset = { _wrap__CameraFilesystemFuncs_get_file_func_get, 0 };
-static SwigPyGetSet _CameraFilesystemFuncs_put_file_func_getset = { _wrap__CameraFilesystemFuncs_put_file_func_get, 0 };
-static SwigPyGetSet _CameraFilesystemFuncs_folder_list_func_getset = { _wrap__CameraFilesystemFuncs_folder_list_func_get, 0 };
 static SwigPyGetSet _CameraFilesystemFuncs_file_list_func_getset = { _wrap__CameraFilesystemFuncs_file_list_func_get, 0 };
-static SwigPyGetSet _CameraFilesystemFuncs_storage_info_func_getset = { _wrap__CameraFilesystemFuncs_storage_info_func_get, 0 };
-static SwigPyGetSet _CameraFilesystemFuncs_set_info_func_getset = { _wrap__CameraFilesystemFuncs_set_info_func_get, 0 };
-static SwigPyGetSet _CameraFilesystemFuncs_get_info_func_getset = { _wrap__CameraFilesystemFuncs_get_info_func_get, 0 };
 static SwigPyGetSet _CameraFilesystemFuncs___dict___getset = { SwigPyObject_get___dict__, 0 };
+static SwigPyGetSet _CameraFilesystemFuncs_make_dir_func_getset = { _wrap__CameraFilesystemFuncs_make_dir_func_get, 0 };
+static SwigPyGetSet _CameraFilesystemFuncs_set_info_func_getset = { _wrap__CameraFilesystemFuncs_set_info_func_get, 0 };
+static SwigPyGetSet _CameraFilesystemFuncs_read_file_func_getset = { _wrap__CameraFilesystemFuncs_read_file_func_get, 0 };
 static SwigPyGetSet _CameraFilesystemFuncs_unused_getset = { _wrap__CameraFilesystemFuncs_unused_get, 0 };
+static SwigPyGetSet _CameraFilesystemFuncs_put_file_func_getset = { _wrap__CameraFilesystemFuncs_put_file_func_get, 0 };
+static SwigPyGetSet _CameraFilesystemFuncs_del_file_func_getset = { _wrap__CameraFilesystemFuncs_del_file_func_get, 0 };
+static SwigPyGetSet _CameraFilesystemFuncs_storage_info_func_getset = { _wrap__CameraFilesystemFuncs_storage_info_func_get, 0 };
+static SwigPyGetSet _CameraFilesystemFuncs_delete_all_func_getset = { _wrap__CameraFilesystemFuncs_delete_all_func_get, 0 };
 static SwigPyGetSet _CameraFilesystemFuncs_remove_dir_func_getset = { _wrap__CameraFilesystemFuncs_remove_dir_func_get, 0 };
-static SwigPyGetSet _CameraFilesystemFuncs_make_dir_func_getset = { _wrap__CameraFilesystemFuncs_make_dir_func_get, 0 };
+static SwigPyGetSet _CameraFilesystemFuncs_get_info_func_getset = { _wrap__CameraFilesystemFuncs_get_info_func_get, 0 };
+static SwigPyGetSet _CameraFilesystemFuncs_folder_list_func_getset = { _wrap__CameraFilesystemFuncs_folder_list_func_get, 0 };
+static SwigPyGetSet _CameraFilesystemFuncs_get_file_func_getset = { _wrap__CameraFilesystemFuncs_get_file_func_get, 0 };
 SWIGINTERN PyGetSetDef SwigPyBuiltin___CameraFilesystemFuncs_getset[] = {
-    { (char *)"delete_all_func", SwigPyBuiltin_GetterClosure, 0, (char *)"\n"
-		"delete_all_func\n"
-		"Delete all files from the camera.  \n"
+    { (char *)"file_list_func", SwigPyBuiltin_GetterClosure, 0, (char *)"\n"
+		"file_list_func\n"
+		"List available files in the specified folder.  \n"
 		"\n"
 		"This function is a CameraFilesystem method.\n"
-		"", &_CameraFilesystemFuncs_delete_all_func_getset },
-    { (char *)"del_file_func", SwigPyBuiltin_GetterClosure, 0, (char *)"del_file_func", &_CameraFilesystemFuncs_del_file_func_getset },
-    { (char *)"read_file_func", SwigPyBuiltin_GetterClosure, 0, (char *)"read_file_func", &_CameraFilesystemFuncs_read_file_func_getset },
-    { (char *)"get_file_func", SwigPyBuiltin_GetterClosure, 0, (char *)"\n"
-		"get_file_func\n"
-		"Get the file from the camera.  \n"
+		"", &_CameraFilesystemFuncs_file_list_func_getset },
+    { (char *)"__dict__", SwigPyBuiltin_GetterClosure, 0, (char *)"\n"
+		"gp_filesystem_new\n"
+		"Create a new filesystem struct.  \n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"* `fs` :  \n"
+		"    a pointer to a CameraFilesystem  \n"
+		"\n"
+		"Creates a new empty CameraFilesystem  \n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"a gphoto2 error code.\n"
+		"", &_CameraFilesystemFuncs___dict___getset },
+    { (char *)"make_dir_func", SwigPyBuiltin_GetterClosure, 0, (char *)"make_dir_func", &_CameraFilesystemFuncs_make_dir_func_getset },
+    { (char *)"set_info_func", SwigPyBuiltin_GetterClosure, 0, (char *)"\n"
+		"set_info_func\n"
+		"FIXME.  \n"
 		"\n"
 		"This function is a CameraFilesystem method.\n"
-		"", &_CameraFilesystemFuncs_get_file_func_getset },
+		"", &_CameraFilesystemFuncs_set_info_func_getset },
+    { (char *)"read_file_func", SwigPyBuiltin_GetterClosure, 0, (char *)"read_file_func", &_CameraFilesystemFuncs_read_file_func_getset },
+    { (char *)"unused", SwigPyBuiltin_GetterClosure, 0, (char *)"unused", &_CameraFilesystemFuncs_unused_getset },
     { (char *)"put_file_func", SwigPyBuiltin_GetterClosure, 0, (char *)"\n"
 		"put_file_func\n"
 		"Put a file onto the camera.  \n"
 		"\n"
 		"This function is a CameraFilesystem method.\n"
 		"", &_CameraFilesystemFuncs_put_file_func_getset },
-    { (char *)"folder_list_func", SwigPyBuiltin_GetterClosure, 0, (char *)"\n"
-		"folder_list_func\n"
-		"List available folders in the specified folder.  \n"
-		"\n"
-		"This function is a CameraFilesystem method.\n"
-		"", &_CameraFilesystemFuncs_folder_list_func_getset },
-    { (char *)"file_list_func", SwigPyBuiltin_GetterClosure, 0, (char *)"\n"
-		"file_list_func\n"
-		"List available files in the specified folder.  \n"
-		"\n"
-		"This function is a CameraFilesystem method.\n"
-		"", &_CameraFilesystemFuncs_file_list_func_getset },
+    { (char *)"del_file_func", SwigPyBuiltin_GetterClosure, 0, (char *)"del_file_func", &_CameraFilesystemFuncs_del_file_func_getset },
     { (char *)"storage_info_func", SwigPyBuiltin_GetterClosure, 0, (char *)"\n"
 		"storage_info_func\n"
 		"Get information on all available storages in the camera.  \n"
 		"\n"
 		"This function is a CameraFilesystem method.\n"
 		"", &_CameraFilesystemFuncs_storage_info_func_getset },
-    { (char *)"set_info_func", SwigPyBuiltin_GetterClosure, 0, (char *)"\n"
-		"set_info_func\n"
-		"FIXME.  \n"
+    { (char *)"delete_all_func", SwigPyBuiltin_GetterClosure, 0, (char *)"\n"
+		"delete_all_func\n"
+		"Delete all files from the camera.  \n"
 		"\n"
 		"This function is a CameraFilesystem method.\n"
-		"", &_CameraFilesystemFuncs_set_info_func_getset },
+		"", &_CameraFilesystemFuncs_delete_all_func_getset },
+    { (char *)"remove_dir_func", SwigPyBuiltin_GetterClosure, 0, (char *)"remove_dir_func", &_CameraFilesystemFuncs_remove_dir_func_getset },
     { (char *)"get_info_func", SwigPyBuiltin_GetterClosure, 0, (char *)"\n"
 		"get_info_func\n"
 		"Get the file info here and write it to space provided by caller.  \n"
 		"\n"
 		"Parameters\n"
 		"----------\n"
 		"* `info` :  \n"
 		"    Space provided by caller in which file info is written.  \n"
 		"\n"
 		"This function is a CameraFilesystem method.\n"
 		"", &_CameraFilesystemFuncs_get_info_func_getset },
-    { (char *)"__dict__", SwigPyBuiltin_GetterClosure, 0, (char *)"\n"
-		"gp_filesystem_new\n"
-		"Create a new filesystem struct.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `fs` :  \n"
-		"    a pointer to a CameraFilesystem  \n"
+    { (char *)"folder_list_func", SwigPyBuiltin_GetterClosure, 0, (char *)"\n"
+		"folder_list_func\n"
+		"List available folders in the specified folder.  \n"
 		"\n"
-		"Creates a new empty CameraFilesystem  \n"
+		"This function is a CameraFilesystem method.\n"
+		"", &_CameraFilesystemFuncs_folder_list_func_getset },
+    { (char *)"get_file_func", SwigPyBuiltin_GetterClosure, 0, (char *)"\n"
+		"get_file_func\n"
+		"Get the file from the camera.  \n"
 		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		"", &_CameraFilesystemFuncs___dict___getset },
-    { (char *)"unused", SwigPyBuiltin_GetterClosure, 0, (char *)"unused", &_CameraFilesystemFuncs_unused_getset },
-    { (char *)"remove_dir_func", SwigPyBuiltin_GetterClosure, 0, (char *)"remove_dir_func", &_CameraFilesystemFuncs_remove_dir_func_getset },
-    { (char *)"make_dir_func", SwigPyBuiltin_GetterClosure, 0, (char *)"make_dir_func", &_CameraFilesystemFuncs_make_dir_func_getset },
+		"This function is a CameraFilesystem method.\n"
+		"", &_CameraFilesystemFuncs_get_file_func_getset },
     { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
 };
 
 SWIGINTERN PyObject *
 SwigPyBuiltin___CameraFilesystemFuncs_richcompare(PyObject *self, PyObject *other, int op) {
   PyObject *result = NULL;
   PyObject *tuple = PyTuple_New(1);
@@ -9262,15 +9105,19 @@
     PyObject_HEAD_INIT(NULL)
     0,                                        /* ob_size */
 #endif
     "gphoto2.filesys._CameraFilesystemFuncs", /* tp_name */
     sizeof(SwigPyObject),                     /* tp_basicsize */
     0,                                        /* tp_itemsize */
     _wrap_delete__CameraFilesystemFuncs_destructor_closure,       /* tp_dealloc */
+#if PY_VERSION_HEX < 0x030800b4
     (printfunc) 0,                            /* tp_print */
+#else
+    (Py_ssize_t) 0,                           /* tp_vectorcall_offset */
+#endif
     (getattrfunc) 0,                          /* tp_getattr */
     (setattrfunc) 0,                          /* tp_setattr */
 #if PY_VERSION_HEX >= 0x03000000
     0,                                        /* tp_compare */
 #else
     (cmpfunc) 0,                              /* tp_compare */
 #endif
@@ -9334,14 +9181,17 @@
 #endif
   },
 #if PY_VERSION_HEX >= 0x03050000
   {
     (unaryfunc) 0,                            /* am_await */
     (unaryfunc) 0,                            /* am_aiter */
     (unaryfunc) 0,                            /* am_anext */
+# if PY_VERSION_HEX >= 0x030a0000
+    (sendfunc) 0,                             /* am_send */
+# endif
   },
 #endif
   {
     (binaryfunc) 0,                           /* nb_add */
     (binaryfunc) 0,                           /* nb_subtract */
     (binaryfunc) 0,                           /* nb_multiply */
 #if PY_VERSION_HEX < 0x03000000
@@ -9434,86 +9284,95 @@
   },
     (PyObject *) 0,                           /* ht_name */
     (PyObject *) 0,                           /* ht_slots */
 #if PY_VERSION_HEX >= 0x03030000
     (PyObject *) 0,                           /* ht_qualname */
     0,                                        /* ht_cached_keys */
 #endif
+#if PY_VERSION_HEX >= 0x03090000
+    (PyObject *) 0,                           /* ht_module */
+#endif
+#if PY_VERSION_HEX >= 0x030b0000
+    (char *) 0,                               /* _ht_tpname */
+  {
+    (PyObject *) 0,                           /* getitem */
+  }
+#endif
 };
 
 SWIGINTERN SwigPyClientData SwigPyBuiltin___CameraFilesystemFuncs_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin___CameraFilesystemFuncs_type};
 
 
 /* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */
 
 static swig_type_info _swigt__p_CameraAbilities = {"_p_CameraAbilities", "CameraAbilities *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraCaptureType = {"_p_CameraCaptureType", "enum CameraCaptureType *|CameraCaptureType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraDriverStatus = {"_p_CameraDriverStatus", "enum CameraDriverStatus *|CameraDriverStatus *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraEventType = {"_p_CameraEventType", "enum CameraEventType *|CameraEventType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileAccessType = {"_p_CameraFileAccessType", "enum CameraFileAccessType *|CameraFileAccessType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileInfoFields = {"_p_CameraFileInfoFields", "enum CameraFileInfoFields *|CameraFileInfoFields *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileOperation = {"_p_CameraFileOperation", "enum CameraFileOperation *|CameraFileOperation *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraCaptureType = {"_p_CameraCaptureType", "CameraCaptureType *|enum CameraCaptureType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraDriverStatus = {"_p_CameraDriverStatus", "CameraDriverStatus *|enum CameraDriverStatus *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraEventType = {"_p_CameraEventType", "CameraEventType *|enum CameraEventType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileAccessType = {"_p_CameraFileAccessType", "CameraFileAccessType *|enum CameraFileAccessType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileInfoFields = {"_p_CameraFileInfoFields", "CameraFileInfoFields *|enum CameraFileInfoFields *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileOperation = {"_p_CameraFileOperation", "CameraFileOperation *|enum CameraFileOperation *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_CameraFilePath = {"_p_CameraFilePath", "CameraFilePath *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFilePermissions = {"_p_CameraFilePermissions", "enum CameraFilePermissions *|CameraFilePermissions *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileStatus = {"_p_CameraFileStatus", "enum CameraFileStatus *|CameraFileStatus *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileType = {"_p_CameraFileType", "enum CameraFileType *|CameraFileType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFolderOperation = {"_p_CameraFolderOperation", "enum CameraFolderOperation *|CameraFolderOperation *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraOperation = {"_p_CameraOperation", "enum CameraOperation *|CameraOperation *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraStorageAccessType = {"_p_CameraStorageAccessType", "enum CameraStorageAccessType *|CameraStorageAccessType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraStorageFilesystemType = {"_p_CameraStorageFilesystemType", "enum CameraStorageFilesystemType *|CameraStorageFilesystemType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraStorageInfoFields = {"_p_CameraStorageInfoFields", "enum CameraStorageInfoFields *|CameraStorageInfoFields *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraStorageType = {"_p_CameraStorageType", "enum CameraStorageType *|CameraStorageType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFilePermissions = {"_p_CameraFilePermissions", "CameraFilePermissions *|enum CameraFilePermissions *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileStatus = {"_p_CameraFileStatus", "CameraFileStatus *|enum CameraFileStatus *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileType = {"_p_CameraFileType", "CameraFileType *|enum CameraFileType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFolderOperation = {"_p_CameraFolderOperation", "CameraFolderOperation *|enum CameraFolderOperation *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraOperation = {"_p_CameraOperation", "CameraOperation *|enum CameraOperation *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraStorageAccessType = {"_p_CameraStorageAccessType", "CameraStorageAccessType *|enum CameraStorageAccessType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraStorageFilesystemType = {"_p_CameraStorageFilesystemType", "CameraStorageFilesystemType *|enum CameraStorageFilesystemType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraStorageInfoFields = {"_p_CameraStorageInfoFields", "CameraStorageInfoFields *|enum CameraStorageInfoFields *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraStorageType = {"_p_CameraStorageType", "CameraStorageType *|enum CameraStorageType *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_CameraText = {"_p_CameraText", "CameraText *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraWidgetType = {"_p_CameraWidgetType", "enum CameraWidgetType *|CameraWidgetType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_GPLogLevel = {"_p_GPLogLevel", "enum GPLogLevel *|GPLogLevel *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_GPPortType = {"_p_GPPortType", "enum GPPortType *|GPPortType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_GPVersionVerbosity = {"_p_GPVersionVerbosity", "enum GPVersionVerbosity *|GPVersionVerbosity *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_GphotoDeviceType = {"_p_GphotoDeviceType", "enum GphotoDeviceType *|GphotoDeviceType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraWidgetType = {"_p_CameraWidgetType", "CameraWidgetType *|enum CameraWidgetType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GPLogLevel = {"_p_GPLogLevel", "GPLogLevel *|enum GPLogLevel *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GPPortType = {"_p_GPPortType", "GPPortType *|enum GPPortType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GPVersionVerbosity = {"_p_GPVersionVerbosity", "GPVersionVerbosity *|enum GPVersionVerbosity *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GphotoDeviceType = {"_p_GphotoDeviceType", "GphotoDeviceType *|enum GphotoDeviceType *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_SwigPyObject = {"_p_SwigPyObject", "SwigPyObject *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__Camera = {"_p__Camera", "struct _Camera *|Camera *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraAbilitiesList = {"_p__CameraAbilitiesList", "struct _CameraAbilitiesList *|CameraAbilitiesList *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFile = {"_p__CameraFile", "struct _CameraFile *|CameraFile *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFileHandler = {"_p__CameraFileHandler", "struct _CameraFileHandler *|CameraFileHandler *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFileInfo = {"_p__CameraFileInfo", "struct _CameraFileInfo *|_CameraFileInfo *|CameraFileInfo *", 0, 0, (void*)&SwigPyBuiltin___CameraFileInfo_clientdata, 0};
-static swig_type_info _swigt__p__CameraFileInfoAudio = {"_p__CameraFileInfoAudio", "struct _CameraFileInfoAudio *|_CameraFileInfoAudio *|CameraFileInfoAudio *", 0, 0, (void*)&SwigPyBuiltin___CameraFileInfoAudio_clientdata, 0};
-static swig_type_info _swigt__p__CameraFileInfoFile = {"_p__CameraFileInfoFile", "struct _CameraFileInfoFile *|_CameraFileInfoFile *|CameraFileInfoFile *", 0, 0, (void*)&SwigPyBuiltin___CameraFileInfoFile_clientdata, 0};
-static swig_type_info _swigt__p__CameraFileInfoPreview = {"_p__CameraFileInfoPreview", "struct _CameraFileInfoPreview *|_CameraFileInfoPreview *|CameraFileInfoPreview *", 0, 0, (void*)&SwigPyBuiltin___CameraFileInfoPreview_clientdata, 0};
-static swig_type_info _swigt__p__CameraFilesystem = {"_p__CameraFilesystem", "struct _CameraFilesystem *|_CameraFilesystem *|CameraFilesystem *", 0, 0, (void*)&SwigPyBuiltin___CameraFilesystem_clientdata, 0};
-static swig_type_info _swigt__p__CameraFilesystemFuncs = {"_p__CameraFilesystemFuncs", "struct _CameraFilesystemFuncs *|CameraFilesystemFuncs *|_CameraFilesystemFuncs *", 0, 0, (void*)&SwigPyBuiltin___CameraFilesystemFuncs_clientdata, 0};
-static swig_type_info _swigt__p__CameraFunctions = {"_p__CameraFunctions", "struct _CameraFunctions *|CameraFunctions *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraList = {"_p__CameraList", "struct _CameraList *|CameraList *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraPrivateCore = {"_p__CameraPrivateCore", "struct _CameraPrivateCore *|CameraPrivateCore *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraPrivateLibrary = {"_p__CameraPrivateLibrary", "struct _CameraPrivateLibrary *|CameraPrivateLibrary *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraStorageInformation = {"_p__CameraStorageInformation", "struct _CameraStorageInformation *|_CameraStorageInformation *|CameraStorageInformation *", 0, 0, (void*)&SwigPyBuiltin___CameraStorageInformation_clientdata, 0};
-static swig_type_info _swigt__p__CameraWidget = {"_p__CameraWidget", "struct _CameraWidget *|CameraWidget *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__GPContext = {"_p__GPContext", "struct _GPContext *|GPContext *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__GPContextFeedback = {"_p__GPContextFeedback", "enum _GPContextFeedback *|GPContextFeedback *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__Camera = {"_p__Camera", "Camera *|struct _Camera *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraAbilitiesList = {"_p__CameraAbilitiesList", "CameraAbilitiesList *|struct _CameraAbilitiesList *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFile = {"_p__CameraFile", "CameraFile *|struct _CameraFile *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFileHandler = {"_p__CameraFileHandler", "CameraFileHandler *|struct _CameraFileHandler *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFileInfo = {"_p__CameraFileInfo", "CameraFileInfo *|struct _CameraFileInfo *|_CameraFileInfo *", 0, 0, (void*)&SwigPyBuiltin___CameraFileInfo_clientdata, 0};
+static swig_type_info _swigt__p__CameraFileInfoAudio = {"_p__CameraFileInfoAudio", "CameraFileInfoAudio *|struct _CameraFileInfoAudio *|_CameraFileInfoAudio *", 0, 0, (void*)&SwigPyBuiltin___CameraFileInfoAudio_clientdata, 0};
+static swig_type_info _swigt__p__CameraFileInfoFile = {"_p__CameraFileInfoFile", "CameraFileInfoFile *|struct _CameraFileInfoFile *|_CameraFileInfoFile *", 0, 0, (void*)&SwigPyBuiltin___CameraFileInfoFile_clientdata, 0};
+static swig_type_info _swigt__p__CameraFileInfoPreview = {"_p__CameraFileInfoPreview", "CameraFileInfoPreview *|struct _CameraFileInfoPreview *|_CameraFileInfoPreview *", 0, 0, (void*)&SwigPyBuiltin___CameraFileInfoPreview_clientdata, 0};
+static swig_type_info _swigt__p__CameraFilesystem = {"_p__CameraFilesystem", "CameraFilesystem *|struct _CameraFilesystem *|_CameraFilesystem *", 0, 0, (void*)&SwigPyBuiltin___CameraFilesystem_clientdata, 0};
+static swig_type_info _swigt__p__CameraFilesystemFuncs = {"_p__CameraFilesystemFuncs", "CameraFilesystemFuncs *|struct _CameraFilesystemFuncs *|_CameraFilesystemFuncs *", 0, 0, (void*)&SwigPyBuiltin___CameraFilesystemFuncs_clientdata, 0};
+static swig_type_info _swigt__p__CameraFunctions = {"_p__CameraFunctions", "CameraFunctions *|struct _CameraFunctions *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraList = {"_p__CameraList", "CameraList *|struct _CameraList *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraPrivateCore = {"_p__CameraPrivateCore", "CameraPrivateCore *|struct _CameraPrivateCore *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraPrivateLibrary = {"_p__CameraPrivateLibrary", "CameraPrivateLibrary *|struct _CameraPrivateLibrary *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraStorageInformation = {"_p__CameraStorageInformation", "CameraStorageInformation *|struct _CameraStorageInformation *|_CameraStorageInformation *", 0, 0, (void*)&SwigPyBuiltin___CameraStorageInformation_clientdata, 0};
+static swig_type_info _swigt__p__CameraWidget = {"_p__CameraWidget", "CameraWidget *|struct _CameraWidget *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__GPContext = {"_p__GPContext", "GPContext *|struct _GPContext *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__GPContextFeedback = {"_p__GPContextFeedback", "GPContextFeedback *|enum _GPContextFeedback *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p__GPPortInfo = {"_p__GPPortInfo", "_GPPortInfo *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__GPPortInfoList = {"_p__GPPortInfoList", "struct _GPPortInfoList *|GPPortInfoList *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__GPPortInfoList = {"_p__GPPortInfoList", "GPPortInfoList *|struct _GPPortInfoList *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_f_p_struct__CameraFilesystem_p_p_struct__CameraStorageInformation_p_int_p_void_p_struct__GPContext__int = {"_p_f_p_struct__CameraFilesystem_p_p_struct__CameraStorageInformation_p_int_p_void_p_struct__GPContext__int", "CameraFilesystemStorageInfoFunc|int (*)(struct _CameraFilesystem *,struct _CameraStorageInformation **,int *,void *,struct _GPContext *)", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_f_p_struct__CameraFilesystem_p_q_const__char_p_q_const__char_enum_CameraFileType_p_struct__CameraFile_p_void_p_struct__GPContext__int = {"_p_f_p_struct__CameraFilesystem_p_q_const__char_p_q_const__char_enum_CameraFileType_p_struct__CameraFile_p_void_p_struct__GPContext__int", "int (*)(struct _CameraFilesystem *,char const *,char const *,enum CameraFileType,struct _CameraFile *,void *,struct _GPContext *)|CameraFilesystemPutFileFunc|CameraFilesystemGetFileFunc", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_f_p_struct__CameraFilesystem_p_q_const__char_p_q_const__char_enum_CameraFileType_unsigned_long_long_p_char_p_unsigned_long_long_p_void_p_struct__GPContext__int = {"_p_f_p_struct__CameraFilesystem_p_q_const__char_p_q_const__char_enum_CameraFileType_unsigned_long_long_p_char_p_unsigned_long_long_p_void_p_struct__GPContext__int", "int (*)(struct _CameraFilesystem *,char const *,char const *,enum CameraFileType,unsigned long long,char *,unsigned long long *,void *,struct _GPContext *)|CameraFilesystemReadFileFunc", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_f_p_struct__CameraFilesystem_p_q_const__char_p_q_const__char_p_struct__CameraFileInfo_p_void_p_struct__GPContext__int = {"_p_f_p_struct__CameraFilesystem_p_q_const__char_p_q_const__char_p_struct__CameraFileInfo_p_void_p_struct__GPContext__int", "int (*)(struct _CameraFilesystem *,char const *,char const *,struct _CameraFileInfo *,void *,struct _GPContext *)|CameraFilesystemGetInfoFunc", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_f_p_struct__CameraFilesystem_p_q_const__char_p_q_const__char_p_void_p_struct__GPContext__int = {"_p_f_p_struct__CameraFilesystem_p_q_const__char_p_q_const__char_p_void_p_struct__GPContext__int", "int (*)(struct _CameraFilesystem *,char const *,char const *,void *,struct _GPContext *)|CameraFilesystemDirFunc|CameraFilesystemDeleteFileFunc", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_f_p_struct__CameraFilesystem_p_q_const__char_p_q_const__char_struct__CameraFileInfo_p_void_p_struct__GPContext__int = {"_p_f_p_struct__CameraFilesystem_p_q_const__char_p_q_const__char_struct__CameraFileInfo_p_void_p_struct__GPContext__int", "int (*)(struct _CameraFilesystem *,char const *,char const *,struct _CameraFileInfo,void *,struct _GPContext *)|CameraFilesystemSetInfoFunc", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_f_p_struct__CameraFilesystem_p_q_const__char_p_q_const__char_enum_CameraFileType_p_struct__CameraFile_p_void_p_struct__GPContext__int = {"_p_f_p_struct__CameraFilesystem_p_q_const__char_p_q_const__char_enum_CameraFileType_p_struct__CameraFile_p_void_p_struct__GPContext__int", "CameraFilesystemGetFileFunc|CameraFilesystemPutFileFunc|int (*)(struct _CameraFilesystem *,char const *,char const *,enum CameraFileType,struct _CameraFile *,void *,struct _GPContext *)", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_f_p_struct__CameraFilesystem_p_q_const__char_p_q_const__char_enum_CameraFileType_unsigned_long_long_p_char_p_unsigned_long_long_p_void_p_struct__GPContext__int = {"_p_f_p_struct__CameraFilesystem_p_q_const__char_p_q_const__char_enum_CameraFileType_unsigned_long_long_p_char_p_unsigned_long_long_p_void_p_struct__GPContext__int", "CameraFilesystemReadFileFunc|int (*)(struct _CameraFilesystem *,char const *,char const *,enum CameraFileType,unsigned long long,char *,unsigned long long *,void *,struct _GPContext *)", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_f_p_struct__CameraFilesystem_p_q_const__char_p_q_const__char_p_struct__CameraFileInfo_p_void_p_struct__GPContext__int = {"_p_f_p_struct__CameraFilesystem_p_q_const__char_p_q_const__char_p_struct__CameraFileInfo_p_void_p_struct__GPContext__int", "CameraFilesystemGetInfoFunc|int (*)(struct _CameraFilesystem *,char const *,char const *,struct _CameraFileInfo *,void *,struct _GPContext *)", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_f_p_struct__CameraFilesystem_p_q_const__char_p_q_const__char_p_void_p_struct__GPContext__int = {"_p_f_p_struct__CameraFilesystem_p_q_const__char_p_q_const__char_p_void_p_struct__GPContext__int", "CameraFilesystemDeleteFileFunc|CameraFilesystemDirFunc|int (*)(struct _CameraFilesystem *,char const *,char const *,void *,struct _GPContext *)", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_f_p_struct__CameraFilesystem_p_q_const__char_p_q_const__char_struct__CameraFileInfo_p_void_p_struct__GPContext__int = {"_p_f_p_struct__CameraFilesystem_p_q_const__char_p_q_const__char_struct__CameraFileInfo_p_void_p_struct__GPContext__int", "CameraFilesystemSetInfoFunc|int (*)(struct _CameraFilesystem *,char const *,char const *,struct _CameraFileInfo,void *,struct _GPContext *)", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_f_p_struct__CameraFilesystem_p_q_const__char_p_struct__CameraList_p_void_p_struct__GPContext__int = {"_p_f_p_struct__CameraFilesystem_p_q_const__char_p_struct__CameraList_p_void_p_struct__GPContext__int", "CameraFilesystemListFunc|int (*)(struct _CameraFilesystem *,char const *,struct _CameraList *,void *,struct _GPContext *)", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_f_p_struct__CameraFilesystem_p_q_const__char_p_void_p_struct__GPContext__int = {"_p_f_p_struct__CameraFilesystem_p_q_const__char_p_void_p_struct__GPContext__int", "CameraFilesystemDeleteAllFunc|int (*)(struct _CameraFilesystem *,char const *,void *,struct _GPContext *)", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_int = {"_p_int", "intptr_t *|int *|int_least32_t *|int_fast32_t *|int32_t *|int_fast16_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_long = {"_p_long", "long *|time_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_long_long = {"_p_long_long", "int_least64_t *|int_fast64_t *|int64_t *|long long *|intmax_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_p__CameraFilesystem = {"_p_p__CameraFilesystem", "struct _CameraFilesystem **|CameraFilesystem **", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_int = {"_p_int", "int32_t *|int_fast16_t *|int_fast32_t *|int_least32_t *|intptr_t *|int *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_long = {"_p_long", "time_t *|long *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_long_long = {"_p_long_long", "int64_t *|int_fast64_t *|int_least64_t *|intmax_t *|long long *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_p__CameraFilesystem = {"_p_p__CameraFilesystem", "CameraFilesystem **|struct _CameraFilesystem **", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_p_char = {"_p_p_char", "char **", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_p_void = {"_p_p_void", "void **", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_short = {"_p_short", "short *|int_least16_t *|int16_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_signed_char = {"_p_signed_char", "signed char *|int_least8_t *|int_fast8_t *|int8_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_unsigned_char = {"_p_unsigned_char", "unsigned char *|uint_least8_t *|uint_fast8_t *|uint8_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_unsigned_int = {"_p_unsigned_int", "uintptr_t *|uint_least32_t *|uint_fast32_t *|uint32_t *|unsigned int *|uint_fast16_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_unsigned_long_long = {"_p_unsigned_long_long", "uint_least64_t *|uint_fast64_t *|uint64_t *|unsigned long long *|uintmax_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_unsigned_short = {"_p_unsigned_short", "unsigned short *|uint_least16_t *|uint16_t *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_short = {"_p_short", "int16_t *|int_least16_t *|short *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_signed_char = {"_p_signed_char", "int8_t *|int_fast8_t *|int_least8_t *|signed char *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_unsigned_char = {"_p_unsigned_char", "uint8_t *|uint_fast8_t *|uint_least8_t *|unsigned char *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_unsigned_int = {"_p_unsigned_int", "uint32_t *|uint_fast16_t *|uint_fast32_t *|uint_least32_t *|uintptr_t *|unsigned int *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_unsigned_long_long = {"_p_unsigned_long_long", "uint64_t *|uint_fast64_t *|uint_least64_t *|uintmax_t *|unsigned long long *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_unsigned_short = {"_p_unsigned_short", "uint16_t *|uint_least16_t *|unsigned short *", 0, 0, (void*)0, 0};
 
 static swig_type_info *swig_type_initial[] = {
   &_swigt__p_CameraAbilities,
   &_swigt__p_CameraCaptureType,
   &_swigt__p_CameraDriverStatus,
   &_swigt__p_CameraEventType,
   &_swigt__p_CameraFileAccessType,
@@ -9772,17 +9631,20 @@
 #endif
 #endif
 
 #if 0
 #define SWIGRUNTIME_DEBUG
 #endif
 
+#ifndef SWIG_INIT_CLIENT_DATA_TYPE
+#define SWIG_INIT_CLIENT_DATA_TYPE void *
+#endif
 
 SWIGRUNTIME void
-SWIG_InitializeModule(void *clientdata) {
+SWIG_InitializeModule(SWIG_INIT_CLIENT_DATA_TYPE clientdata) {
   size_t i;
   swig_module_info *module_head, *iter;
   int init;
   
   /* check to see if the circular list has been setup, if not, set it up */
   if (swig_module.next==0) {
     /* Initialize the swig_module */
@@ -9957,228 +9819,14 @@
 
 
 
 #ifdef __cplusplus
 extern "C" {
 #endif
   
-  /* Python-specific SWIG API */
-#define SWIG_newvarlink()                             SWIG_Python_newvarlink()
-#define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
-#define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)
-  
-  /* -----------------------------------------------------------------------------
-   * global variable support code.
-   * ----------------------------------------------------------------------------- */
-  
-  typedef struct swig_globalvar {
-    char       *name;                  /* Name of global variable */
-    PyObject *(*get_attr)(void);       /* Return the current value */
-    int       (*set_attr)(PyObject *); /* Set the value */
-    struct swig_globalvar *next;
-  } swig_globalvar;
-  
-  typedef struct swig_varlinkobject {
-    PyObject_HEAD
-    swig_globalvar *vars;
-  } swig_varlinkobject;
-  
-  SWIGINTERN PyObject *
-  swig_varlink_repr(swig_varlinkobject *SWIGUNUSEDPARM(v)) {
-#if PY_VERSION_HEX >= 0x03000000
-    return PyUnicode_InternFromString("<Swig global variables>");
-#else
-    return PyString_FromString("<Swig global variables>");
-#endif
-  }
-  
-  SWIGINTERN PyObject *
-  swig_varlink_str(swig_varlinkobject *v) {
-#if PY_VERSION_HEX >= 0x03000000
-    PyObject *str = PyUnicode_InternFromString("(");
-    PyObject *tail;
-    PyObject *joined;
-    swig_globalvar *var;
-    for (var = v->vars; var; var=var->next) {
-      tail = PyUnicode_FromString(var->name);
-      joined = PyUnicode_Concat(str, tail);
-      Py_DecRef(str);
-      Py_DecRef(tail);
-      str = joined;
-      if (var->next) {
-        tail = PyUnicode_InternFromString(", ");
-        joined = PyUnicode_Concat(str, tail);
-        Py_DecRef(str);
-        Py_DecRef(tail);
-        str = joined;
-      }
-    }
-    tail = PyUnicode_InternFromString(")");
-    joined = PyUnicode_Concat(str, tail);
-    Py_DecRef(str);
-    Py_DecRef(tail);
-    str = joined;
-#else
-    PyObject *str = PyString_FromString("(");
-    swig_globalvar *var;
-    for (var = v->vars; var; var=var->next) {
-      PyString_ConcatAndDel(&str,PyString_FromString(var->name));
-      if (var->next) PyString_ConcatAndDel(&str,PyString_FromString(", "));
-    }
-    PyString_ConcatAndDel(&str,PyString_FromString(")"));
-#endif
-    return str;
-  }
-  
-  SWIGINTERN void
-  swig_varlink_dealloc(swig_varlinkobject *v) {
-    swig_globalvar *var = v->vars;
-    while (var) {
-      swig_globalvar *n = var->next;
-      free(var->name);
-      free(var);
-      var = n;
-    }
-  }
-  
-  SWIGINTERN PyObject *
-  swig_varlink_getattr(swig_varlinkobject *v, char *n) {
-    PyObject *res = NULL;
-    swig_globalvar *var = v->vars;
-    while (var) {
-      if (strcmp(var->name,n) == 0) {
-        res = (*var->get_attr)();
-        break;
-      }
-      var = var->next;
-    }
-    if (res == NULL && !PyErr_Occurred()) {
-      PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
-    }
-    return res;
-  }
-  
-  SWIGINTERN int
-  swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
-    int res = 1;
-    swig_globalvar *var = v->vars;
-    while (var) {
-      if (strcmp(var->name,n) == 0) {
-        res = (*var->set_attr)(p);
-        break;
-      }
-      var = var->next;
-    }
-    if (res == 1 && !PyErr_Occurred()) {
-      PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
-    }
-    return res;
-  }
-  
-  SWIGINTERN PyTypeObject*
-  swig_varlink_type(void) {
-    static char varlink__doc__[] = "Swig var link object";
-    static PyTypeObject varlink_type;
-    static int type_init = 0;
-    if (!type_init) {
-      const PyTypeObject tmp = {
-#if PY_VERSION_HEX >= 0x03000000
-        PyVarObject_HEAD_INIT(NULL, 0)
-#else
-        PyObject_HEAD_INIT(NULL)
-        0,                                  /* ob_size */
-#endif
-        "swigvarlink",                      /* tp_name */
-        sizeof(swig_varlinkobject),         /* tp_basicsize */
-        0,                                  /* tp_itemsize */
-        (destructor) swig_varlink_dealloc,  /* tp_dealloc */
-        0,                                  /* tp_print */
-        (getattrfunc) swig_varlink_getattr, /* tp_getattr */
-        (setattrfunc) swig_varlink_setattr, /* tp_setattr */
-        0,                                  /* tp_compare */
-        (reprfunc) swig_varlink_repr,       /* tp_repr */
-        0,                                  /* tp_as_number */
-        0,                                  /* tp_as_sequence */
-        0,                                  /* tp_as_mapping */
-        0,                                  /* tp_hash */
-        0,                                  /* tp_call */
-        (reprfunc) swig_varlink_str,        /* tp_str */
-        0,                                  /* tp_getattro */
-        0,                                  /* tp_setattro */
-        0,                                  /* tp_as_buffer */
-        0,                                  /* tp_flags */
-        varlink__doc__,                     /* tp_doc */
-        0,                                  /* tp_traverse */
-        0,                                  /* tp_clear */
-        0,                                  /* tp_richcompare */
-        0,                                  /* tp_weaklistoffset */
-        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
-        0,                                  /* tp_del */
-        0,                                  /* tp_version_tag */
-#if PY_VERSION_HEX >= 0x03040000
-        0,                                  /* tp_finalize */
-#endif
-#if PY_VERSION_HEX >= 0x03080000
-        0,                                  /* tp_vectorcall */
-#endif
-#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
-        0,                                  /* tp_print */
-#endif
-#ifdef COUNT_ALLOCS
-        0,                                  /* tp_allocs */
-        0,                                  /* tp_frees */
-        0,                                  /* tp_maxalloc */
-        0,                                  /* tp_prev */
-        0                                   /* tp_next */
-#endif
-      };
-      varlink_type = tmp;
-      type_init = 1;
-      if (PyType_Ready(&varlink_type) < 0)
-      return NULL;
-    }
-    return &varlink_type;
-  }
-  
-  /* Create a variable linking object for use later */
-  SWIGINTERN PyObject *
-  SWIG_Python_newvarlink(void) {
-    swig_varlinkobject *result = PyObject_NEW(swig_varlinkobject, swig_varlink_type());
-    if (result) {
-      result->vars = 0;
-    }
-    return ((PyObject*) result);
-  }
-  
-  SWIGINTERN void 
-  SWIG_Python_addvarlink(PyObject *p, const char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
-    swig_varlinkobject *v = (swig_varlinkobject *) p;
-    swig_globalvar *gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
-    if (gv) {
-      size_t size = strlen(name)+1;
-      gv->name = (char *)malloc(size);
-      if (gv->name) {
-        memcpy(gv->name, name, size);
-        gv->get_attr = get_attr;
-        gv->set_attr = set_attr;
-        gv->next = v->vars;
-      }
-    }
-    v->vars = gv;
-  }
-  
-  SWIGINTERN PyObject *
-  SWIG_globals(void) {
-    static PyObject *globals = 0;
-    if (!globals) {
-      globals = SWIG_newvarlink();
-    }
-    return globals;
-  }
-  
   /* -----------------------------------------------------------------------------
    * constants/methods manipulation
    * ----------------------------------------------------------------------------- */
   
   /* Install Constants */
   SWIGINTERN void
   SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
@@ -10199,31 +9847,28 @@
       if (obj) {
         PyDict_SetItemString(d, constants[i].name, obj);
         Py_DECREF(obj);
       }
     }
   }
   
-  /* -----------------------------------------------------------------------------*/
-  /* Fix SwigMethods to carry the callback ptrs when needed */
-  /* -----------------------------------------------------------------------------*/
+  /* -----------------------------------------------------------------------------
+   * Patch %callback methods' docstrings to hold the callback ptrs
+   * -----------------------------------------------------------------------------*/
   
   SWIGINTERN void
-  SWIG_Python_FixMethods(PyMethodDef *methods,
-    swig_const_info *const_table,
-    swig_type_info **types,
-    swig_type_info **types_initial) {
+  SWIG_Python_FixMethods(PyMethodDef *methods, const swig_const_info *const_table, swig_type_info **types, swig_type_info **types_initial) {
     size_t i;
     for (i = 0; methods[i].ml_name; ++i) {
       const char *c = methods[i].ml_doc;
       if (!c) continue;
       c = strstr(c, "swig_ptr: ");
       if (c) {
         int j;
-        swig_const_info *ci = 0;
+        const swig_const_info *ci = 0;
         const char *name = c + 10;
         for (j = 0; const_table[j].type; ++j) {
           if (strncmp(const_table[j].name, name, 
               strlen(const_table[j].name)) == 0) {
             ci = &(const_table[j]);
             break;
           }
@@ -10247,76 +9892,21 @@
             }
           }
         }
       }
     }
   } 
   
-  /* -----------------------------------------------------------------------------
-   * Method creation and docstring support functions
-   * ----------------------------------------------------------------------------- */
-  
-  /* -----------------------------------------------------------------------------
-   * Function to find the method definition with the correct docstring for the
-   * proxy module as opposed to the low-level API
-   * ----------------------------------------------------------------------------- */
-  
-  SWIGINTERN PyMethodDef *SWIG_PythonGetProxyDoc(const char *name) {
-    /* Find the function in the modified method table */
-    size_t offset = 0;
-    int found = 0;
-    while (SwigMethods_proxydocs[offset].ml_meth != NULL) {
-      if (strcmp(SwigMethods_proxydocs[offset].ml_name, name) == 0) {
-        found = 1;
-        break;
-      }
-      offset++;
-    }
-    /* Use the copy with the modified docstring if available */
-    return found ? &SwigMethods_proxydocs[offset] : NULL;
-  }
-  
-  /* -----------------------------------------------------------------------------
-   * Wrapper of PyInstanceMethod_New() used in Python 3
-   * It is exported to the generated module, used for -fastproxy
-   * ----------------------------------------------------------------------------- */
-  
-  SWIGINTERN PyObject *SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func) {
-    if (PyCFunction_Check(func)) {
-      PyCFunctionObject *funcobj = (PyCFunctionObject *)func;
-      PyMethodDef *ml = SWIG_PythonGetProxyDoc(funcobj->m_ml->ml_name);
-      if (ml)
-      func = PyCFunction_NewEx(ml, funcobj->m_self, funcobj->m_module);
-    }
-#if PY_VERSION_HEX >= 0x03000000
-    return PyInstanceMethod_New(func);
-#else
-    return PyMethod_New(func, NULL, NULL);
-#endif
-  }
-  
-  /* -----------------------------------------------------------------------------
-   * Wrapper of PyStaticMethod_New()
-   * It is exported to the generated module, used for -fastproxy
-   * ----------------------------------------------------------------------------- */
-  
-  SWIGINTERN PyObject *SWIG_PyStaticMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func) {
-    if (PyCFunction_Check(func)) {
-      PyCFunctionObject *funcobj = (PyCFunctionObject *)func;
-      PyMethodDef *ml = SWIG_PythonGetProxyDoc(funcobj->m_ml->ml_name);
-      if (ml)
-      func = PyCFunction_NewEx(ml, funcobj->m_self, funcobj->m_module);
-    }
-    return PyStaticMethod_New(func);
-  }
-  
 #ifdef __cplusplus
 }
 #endif
 
+
+
+
 /* -----------------------------------------------------------------------------*
  *  Partial Init method
  * -----------------------------------------------------------------------------*/
 
 #ifdef __cplusplus
 extern "C"
 #endif
```

### Comparing `gphoto2-2.3.4/src/swig-gp2.5.30/list_wrap.c` & `gphoto2-2.3.5/src/swig-gp2_5_30/list_wrap.c`

 * *Files 3% similar despite different names*

```diff
@@ -1,24 +1,21 @@
 /* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 4.0.2
+ * This file was automatically generated by SWIG (https://www.swig.org).
+ * Version 4.1.1
  *
- * This file is not intended to be easily readable and contains a number of
- * coding conventions designed to improve portability and efficiency. Do not make
- * changes to this file unless you know what you are doing--modify the SWIG
- * interface file instead.
+ * Do not make changes to this file unless you know what you are doing - modify
+ * the SWIG interface file instead.
  * ----------------------------------------------------------------------------- */
 
 
-#ifndef SWIGPYTHON
+#define SWIG_VERSION 0x040101
 #define SWIGPYTHON
-#endif
-
 #define SWIG_PYTHON_DIRECTOR_NO_VTABLE
 #define SWIGPYTHON_BUILTIN
+#define SWIGPYTHON_FASTPROXY
 
 /* -----------------------------------------------------------------------------
  *  This section contains generic SWIG labels for method/variable
  *  declarations/attributes, and other compiler dependent labels.
  * ----------------------------------------------------------------------------- */
 
 /* template workaround for compilers that cannot correctly implement the C++ standard */
@@ -142,23 +139,45 @@
 
 
 #if defined(__GNUC__) && defined(_WIN32) && !defined(SWIG_PYTHON_NO_HYPOT_WORKAROUND)
 /* Workaround for '::hypot' has not been declared', see https://bugs.python.org/issue11566 */
 # include <math.h>
 #endif
 
+#if !defined(PY_SSIZE_T_CLEAN) && !defined(SWIG_NO_PY_SSIZE_T_CLEAN)
+#define PY_SSIZE_T_CLEAN
+#endif
+
+#if __GNUC__ >= 7
+#pragma GCC diagnostic push
+#if defined(__cplusplus) && __cplusplus >=201703L
+#pragma GCC diagnostic ignored "-Wregister" /* For python-2.7 headers that use register */
+#endif
+#endif
+
 #if defined(_DEBUG) && defined(SWIG_PYTHON_INTERPRETER_NO_DEBUG)
 /* Use debug wrappers with the Python release dll */
+
+#if defined(_MSC_VER) && _MSC_VER >= 1929
+/* Workaround compilation errors when redefining _DEBUG in MSVC 2019 version 16.10 and later
+ * See https://github.com/swig/swig/issues/2090 */
+# include <corecrt.h>
+#endif
+
 # undef _DEBUG
 # include <Python.h>
 # define _DEBUG 1
 #else
 # include <Python.h>
 #endif
 
+#if __GNUC__ >= 7
+#pragma GCC diagnostic pop
+#endif
+
 /* -----------------------------------------------------------------------------
  * swigrun.swg
  *
  * This file contains generic C API SWIG runtime support for pointer
  * type checking.
  * ----------------------------------------------------------------------------- */
 
@@ -197,14 +216,16 @@
 # define SWIG_BUFFER_SIZE 1024
 #endif
 
 /* Flags for pointer conversions */
 #define SWIG_POINTER_DISOWN        0x1
 #define SWIG_CAST_NEW_MEMORY       0x2
 #define SWIG_POINTER_NO_NULL       0x4
+#define SWIG_POINTER_CLEAR         0x8
+#define SWIG_POINTER_RELEASE       (SWIG_POINTER_CLEAR | SWIG_POINTER_DISOWN)
 
 /* Flags for new pointer objects */
 #define SWIG_POINTER_OWN           0x1
 
 
 /*
    Flags/methods for returning states.
@@ -268,44 +289,50 @@
       }
 
    Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
    more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
    SWIG errors code.
 
    Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
-   allows to return the 'cast rank', for example, if you have this
+   allows returning the 'cast rank', for example, if you have this
 
        int food(double)
        int fooi(int);
 
    and you call
 
       food(1)   // cast rank '1'  (1 -> 1.0)
       fooi(1)   // cast rank '0'
 
    just use the SWIG_AddCast()/SWIG_CheckState()
 */
 
 #define SWIG_OK                    (0)
+/* Runtime errors are < 0 */
 #define SWIG_ERROR                 (-1)
+/* Errors in range -1 to -99 are in swigerrors.swg (errors for all languages including those not using the runtime) */
+/* Errors in range -100 to -199 are language specific errors defined in *errors.swg */
+/* Errors < -200 are generic runtime specific errors */
+#define SWIG_ERROR_RELEASE_NOT_OWNED (-200)
+
 #define SWIG_IsOK(r)               (r >= 0)
 #define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)
 
 /* The CastRankLimit says how many bits are used for the cast rank */
 #define SWIG_CASTRANKLIMIT         (1 << 8)
 /* The NewMask denotes the object was created (using new/malloc) */
 #define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
 /* The TmpMask is for in/out typemaps that use temporal objects */
 #define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
 /* Simple returning values */
 #define SWIG_BADOBJ                (SWIG_ERROR)
 #define SWIG_OLDOBJ                (SWIG_OK)
 #define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
 #define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
-/* Check, add and del mask methods */
+/* Check, add and del object mask methods */
 #define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
 #define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
 #define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
 #define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
 #define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
 #define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))
 
@@ -443,15 +470,15 @@
   return 0;
 }
 
 /*
   Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
 */
 SWIGRUNTIME swig_cast_info *
-SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty) {
+SWIG_TypeCheckStruct(const swig_type_info *from, swig_type_info *ty) {
   if (ty) {
     swig_cast_info *iter = ty->cast;
     while (iter) {
       if (iter->type == from) {
         if (iter == ty->cast)
           return iter;
         /* Move iter to the top of the linked list */
@@ -503,17 +530,17 @@
 /*
   Return the pretty name associated with this type,
   that is an unmangled type name in a form presentable to the user.
 */
 SWIGRUNTIME const char *
 SWIG_TypePrettyName(const swig_type_info *type) {
   /* The "str" field contains the equivalent pretty names of the
-     type, separated by vertical-bar characters.  We choose
-     to print the last name, as it is often (?) the most
-     specific. */
+     type, separated by vertical-bar characters.  Choose the last
+     name. It should be the most specific; a fully resolved name
+     but not necessarily with default template parameters expanded. */
   if (!type) return NULL;
   if (type->str != NULL) {
     const char *last_name = type->str;
     const char *s;
     for (s = type->str; *s; s++)
       if (*s == '|') last_name = s+1;
     return last_name;
@@ -725,15 +752,15 @@
   return SWIG_UnpackData(++c,ptr,sz);
 }
 
 #ifdef __cplusplus
 }
 #endif
 
-/*  Errors in SWIG */
+/* SWIG Errors applicable to all language modules, values are reserved from -1 to -99 */
 #define  SWIG_UnknownError    	   -1
 #define  SWIG_IOError        	   -2
 #define  SWIG_RuntimeError   	   -3
 #define  SWIG_IndexError     	   -4
 #define  SWIG_TypeError      	   -5
 #define  SWIG_DivisionByZero 	   -6
 #define  SWIG_OverflowError  	   -7
@@ -741,15 +768,14 @@
 #define  SWIG_ValueError     	   -9
 #define  SWIG_SystemError    	   -10
 #define  SWIG_AttributeError 	   -11
 #define  SWIG_MemoryError    	   -12
 #define  SWIG_NullReferenceError   -13
 
 
-
 /* Compatibility macros for Python 3 */
 #if PY_VERSION_HEX >= 0x03000000
 
 #define PyClass_Check(obj) PyObject_IsInstance(obj, (PyObject *)&PyType_Type)
 #define PyInt_Check(x) PyLong_Check(x)
 #define PyInt_AsLong(x) PyLong_AsLong(x)
 #define PyInt_FromLong(x) PyLong_FromLong(x)
@@ -757,15 +783,14 @@
 #define PyString_Check(name) PyBytes_Check(name)
 #define PyString_FromString(x) PyUnicode_FromString(x)
 #define PyString_Format(fmt, args)  PyUnicode_Format(fmt, args)
 #define PyString_AsString(str) PyBytes_AsString(str)
 #define PyString_Size(str) PyBytes_Size(str)	
 #define PyString_InternFromString(key) PyUnicode_InternFromString(key)
 #define Py_TPFLAGS_HAVE_CLASS Py_TPFLAGS_BASETYPE
-#define PyString_AS_STRING(x) PyUnicode_AS_STRING(x)
 #define _PyLong_FromSsize_t(x) PyLong_FromSsize_t(x)
 
 #endif
 
 #ifndef Py_TYPE
 #  define Py_TYPE(op) ((op)->ob_type)
 #endif
@@ -775,46 +800,27 @@
 #if PY_VERSION_HEX >= 0x03000000
 #  define SWIG_Python_str_FromFormat PyUnicode_FromFormat
 #else
 #  define SWIG_Python_str_FromFormat PyString_FromFormat
 #endif
 
 
-/* Warning: This function will allocate a new string in Python 3,
- * so please call SWIG_Python_str_DelForPy3(x) to free the space.
- */
 SWIGINTERN char*
 SWIG_Python_str_AsChar(PyObject *str)
 {
 #if PY_VERSION_HEX >= 0x03030000
   return (char *)PyUnicode_AsUTF8(str);
-#elif PY_VERSION_HEX >= 0x03000000
-  char *newstr = 0;
-  str = PyUnicode_AsUTF8String(str);
-  if (str) {
-    char *cstr;
-    Py_ssize_t len;
-    if (PyBytes_AsStringAndSize(str, &cstr, &len) != -1) {
-      newstr = (char *) malloc(len+1);
-      if (newstr)
-        memcpy(newstr, cstr, len+1);
-    }
-    Py_XDECREF(str);
-  }
-  return newstr;
 #else
   return PyString_AsString(str);
 #endif
 }
 
-#if PY_VERSION_HEX >= 0x03030000 || PY_VERSION_HEX < 0x03000000
-#  define SWIG_Python_str_DelForPy3(x)
-#else
-#  define SWIG_Python_str_DelForPy3(x) free( (void*) (x) )
-#endif
+/* Was useful for Python 3.0.x-3.2.x - now provided only for compatibility
+ * with any uses in user interface files. */
+#define SWIG_Python_str_DelForPy3(x)
 
 
 SWIGINTERN PyObject*
 SWIG_Python_str_FromChar(const char *c)
 {
 #if PY_VERSION_HEX >= 0x03000000
   return PyUnicode_FromString(c); 
@@ -823,18 +829,22 @@
 #endif
 }
 
 #ifndef PyObject_DEL
 # define PyObject_DEL PyObject_Del
 #endif
 
-// SWIGPY_USE_CAPSULE is no longer used within SWIG itself, but some user
-// interface files check for it.
+/* SWIGPY_USE_CAPSULE is no longer used within SWIG itself, but some user interface files check for it. */
 # define SWIGPY_USE_CAPSULE
-# define SWIGPY_CAPSULE_NAME ("swig_runtime_data" SWIG_RUNTIME_VERSION ".type_pointer_capsule" SWIG_TYPE_TABLE_NAME)
+#ifdef SWIGPYTHON_BUILTIN
+# define SWIGPY_CAPSULE_ATTR_NAME "type_pointer_capsule_builtin" SWIG_TYPE_TABLE_NAME
+#else
+# define SWIGPY_CAPSULE_ATTR_NAME "type_pointer_capsule" SWIG_TYPE_TABLE_NAME
+#endif
+# define SWIGPY_CAPSULE_NAME ("swig_runtime_data" SWIG_RUNTIME_VERSION "." SWIGPY_CAPSULE_ATTR_NAME)
 
 #if PY_VERSION_HEX < 0x03020000
 #define PyDescr_TYPE(x) (((PyDescrObject *)(x))->d_type)
 #define PyDescr_NAME(x) (((PyDescrObject *)(x))->d_name)
 #define Py_hash_t long
 #endif
 
@@ -900,15 +910,14 @@
     const char *tmp = SWIG_Python_str_AsChar(old_str);
     PyErr_Clear();
     Py_XINCREF(type);
     if (tmp)
       PyErr_Format(type, "%s %s", tmp, mesg);
     else
       PyErr_Format(type, "%s", mesg);
-    SWIG_Python_str_DelForPy3(tmp);
     Py_DECREF(old_str);
     Py_DECREF(value);
   } else {
     PyErr_SetString(PyExc_RuntimeError, mesg);
   }
 }
 
@@ -931,16 +940,20 @@
     PyObject *type = NULL, *value = NULL, *traceback = NULL;
     PyErr_Fetch(&type, &value, &traceback);
 #if PY_VERSION_HEX >= 0x03000000
     newvalue = PyUnicode_FromFormat("%S\nAdditional information:\n%s", value, message);
 #else
     newvalue = PyString_FromFormat("%s\nAdditional information:\n%s", PyString_AsString(value), message);
 #endif
-    Py_XDECREF(value);
-    PyErr_Restore(type, newvalue, traceback);
+    if (newvalue) {
+      Py_XDECREF(value);
+      PyErr_Restore(type, newvalue, traceback);
+    } else {
+      PyErr_Restore(type, value, traceback);
+    }
   } else {
     /* Raise TypeError using given message */
     PyErr_SetString(PyExc_TypeError, message);
   }
 }
 
 #if defined(SWIG_PYTHON_NO_THREADS)
@@ -949,16 +962,20 @@
 #  endif
 #endif
 #if defined(SWIG_PYTHON_THREADS) /* Threading support is enabled */
 #  if !defined(SWIG_PYTHON_USE_GIL) && !defined(SWIG_PYTHON_NO_USE_GIL)
 #    define SWIG_PYTHON_USE_GIL
 #  endif
 #  if defined(SWIG_PYTHON_USE_GIL) /* Use PyGILState threads calls */
-#    ifndef SWIG_PYTHON_INITIALIZE_THREADS
-#     define SWIG_PYTHON_INITIALIZE_THREADS  PyEval_InitThreads() 
+#    if !defined(SWIG_PYTHON_INITIALIZE_THREADS)
+#      if PY_VERSION_HEX < 0x03070000
+#        define SWIG_PYTHON_INITIALIZE_THREADS PyEval_InitThreads()
+#      else
+#        define SWIG_PYTHON_INITIALIZE_THREADS
+#      endif
 #    endif
 #    ifdef __cplusplus /* C++ code */
        class SWIG_Python_Thread_Block {
          bool status;
          PyGILState_STATE state;
        public:
          void end() { if (status) { PyGILState_Release(state); status = false;} }
@@ -1048,16 +1065,16 @@
  *
  * ----------------------------------------------------------------------------- */
 
 #if PY_VERSION_HEX < 0x02070000 /* 2.7.0 */
 # error "This version of SWIG only supports Python >= 2.7"
 #endif
 
-#if PY_VERSION_HEX >= 0x03000000 && PY_VERSION_HEX < 0x03020000
-# error "This version of SWIG only supports Python 3 >= 3.2"
+#if PY_VERSION_HEX >= 0x03000000 && PY_VERSION_HEX < 0x03030000
+# error "This version of SWIG only supports Python 3 >= 3.3"
 #endif
 
 /* Common SWIG API */
 
 /* for raw pointers */
 #define SWIG_Python_ConvertPtr(obj, pptr, type, flags)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, 0)
 #define SWIG_ConvertPtr(obj, pptr, type, flags)         SWIG_Python_ConvertPtr(obj, pptr, type, flags)
@@ -1164,15 +1181,20 @@
   } else if (result == Py_None) {
     Py_DECREF(result);
     result = obj;
   } else {
     if (!PyList_Check(result)) {
       PyObject *o2 = result;
       result = PyList_New(1);
-      PyList_SetItem(result, 0, o2);
+      if (result) {
+        PyList_SET_ITEM(result, 0, o2);
+      } else {
+        Py_DECREF(obj);
+        return o2;
+      }
     }
     PyList_Append(result,obj);
     Py_DECREF(obj);
   }
   return result;
 }
 
@@ -1246,14 +1268,246 @@
 */
 #ifdef __cplusplus
 #define SWIG_STATIC_POINTER(var)  var
 #else
 #define SWIG_STATIC_POINTER(var)  var = 0; if (!var) var
 #endif
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Python-specific SWIG API */
+#define SWIG_newvarlink()                             SWIG_Python_newvarlink()
+#define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
+#define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)
+ 
+/* -----------------------------------------------------------------------------
+ * global variable support code.
+ * ----------------------------------------------------------------------------- */
+ 
+typedef struct swig_globalvar {   
+  char       *name;                  /* Name of global variable */
+  PyObject *(*get_attr)(void);       /* Return the current value */
+  int       (*set_attr)(PyObject *); /* Set the value */
+  struct swig_globalvar *next;
+} swig_globalvar;
+
+typedef struct swig_varlinkobject {
+  PyObject_HEAD
+  swig_globalvar *vars;
+} swig_varlinkobject;
+
+SWIGINTERN PyObject *
+swig_varlink_repr(PyObject *SWIGUNUSEDPARM(v)) {
+#if PY_VERSION_HEX >= 0x03000000
+  return PyUnicode_InternFromString("<Swig global variables>");
+#else
+  return PyString_FromString("<Swig global variables>");
+#endif
+}
+
+SWIGINTERN PyObject *
+swig_varlink_str(PyObject *o) {
+  swig_varlinkobject *v = (swig_varlinkobject *) o;
+#if PY_VERSION_HEX >= 0x03000000
+  PyObject *str = PyUnicode_InternFromString("(");
+  PyObject *tail;
+  PyObject *joined;
+  swig_globalvar *var;
+  for (var = v->vars; var; var=var->next) {
+    tail = PyUnicode_FromString(var->name);
+    joined = PyUnicode_Concat(str, tail);
+    Py_DecRef(str);
+    Py_DecRef(tail);
+    str = joined;
+    if (var->next) {
+        tail = PyUnicode_InternFromString(", ");
+        joined = PyUnicode_Concat(str, tail);
+        Py_DecRef(str);
+        Py_DecRef(tail);
+        str = joined;
+    }
+  }
+  tail = PyUnicode_InternFromString(")");
+  joined = PyUnicode_Concat(str, tail);
+  Py_DecRef(str);
+  Py_DecRef(tail);
+  str = joined;
+#else
+  PyObject *str = PyString_FromString("(");
+  swig_globalvar *var;
+  for (var = v->vars; var; var=var->next) {
+    PyString_ConcatAndDel(&str,PyString_FromString(var->name));
+    if (var->next) PyString_ConcatAndDel(&str,PyString_FromString(", "));
+  }
+  PyString_ConcatAndDel(&str,PyString_FromString(")"));
+#endif
+  return str;
+}
+
+SWIGINTERN void
+swig_varlink_dealloc(PyObject *o) {
+  swig_varlinkobject *v = (swig_varlinkobject *) o;
+  swig_globalvar *var = v->vars;
+  while (var) {
+    swig_globalvar *n = var->next;
+    free(var->name);
+    free(var);
+    var = n;
+  }
+}
+
+SWIGINTERN PyObject *
+swig_varlink_getattr(PyObject *o, char *n) {
+  swig_varlinkobject *v = (swig_varlinkobject *) o;
+  PyObject *res = NULL;
+  swig_globalvar *var = v->vars;
+  while (var) {
+    if (strcmp(var->name,n) == 0) {
+      res = (*var->get_attr)();
+      break;
+    }
+    var = var->next;
+  }
+  if (res == NULL && !PyErr_Occurred()) {
+    PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
+  }
+  return res;
+}
+
+SWIGINTERN int
+swig_varlink_setattr(PyObject *o, char *n, PyObject *p) {
+  swig_varlinkobject *v = (swig_varlinkobject *) o;
+  int res = 1;
+  swig_globalvar *var = v->vars;
+  while (var) {
+    if (strcmp(var->name,n) == 0) {
+      res = (*var->set_attr)(p);
+      break;
+    }
+    var = var->next;
+  }
+  if (res == 1 && !PyErr_Occurred()) {
+    PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
+  }
+  return res;
+}
+
+SWIGINTERN PyTypeObject*
+swig_varlink_type(void) {
+  static char varlink__doc__[] = "Swig var link object";
+  static PyTypeObject varlink_type;
+  static int type_init = 0;
+  if (!type_init) {
+    const PyTypeObject tmp = {
+#if PY_VERSION_HEX >= 0x03000000
+      PyVarObject_HEAD_INIT(NULL, 0)
+#else
+      PyObject_HEAD_INIT(NULL)
+      0,                                  /* ob_size */
+#endif
+      "swigvarlink",                      /* tp_name */
+      sizeof(swig_varlinkobject),         /* tp_basicsize */
+      0,                                  /* tp_itemsize */
+      (destructor) swig_varlink_dealloc,  /* tp_dealloc */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                       /*tp_print*/
+#else
+      (Py_ssize_t)0,                      /*tp_vectorcall_offset*/
+#endif
+      (getattrfunc) swig_varlink_getattr, /* tp_getattr */
+      (setattrfunc) swig_varlink_setattr, /* tp_setattr */
+      0,                                  /* tp_compare */
+      (reprfunc) swig_varlink_repr,       /* tp_repr */
+      0,                                  /* tp_as_number */
+      0,                                  /* tp_as_sequence */
+      0,                                  /* tp_as_mapping */
+      0,                                  /* tp_hash */
+      0,                                  /* tp_call */
+      (reprfunc) swig_varlink_str,        /* tp_str */
+      0,                                  /* tp_getattro */
+      0,                                  /* tp_setattro */
+      0,                                  /* tp_as_buffer */
+      0,                                  /* tp_flags */
+      varlink__doc__,                     /* tp_doc */
+      0,                                  /* tp_traverse */
+      0,                                  /* tp_clear */
+      0,                                  /* tp_richcompare */
+      0,                                  /* tp_weaklistoffset */
+      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
+      0,                                  /* tp_del */
+      0,                                  /* tp_version_tag */
+#if PY_VERSION_HEX >= 0x03040000
+      0,                                  /* tp_finalize */
+#endif
+#if PY_VERSION_HEX >= 0x03080000
+      0,                                  /* tp_vectorcall */
+#endif
+#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
+      0,                                  /* tp_print */
+#endif
+#ifdef COUNT_ALLOCS
+      0,                                  /* tp_allocs */
+      0,                                  /* tp_frees */
+      0,                                  /* tp_maxalloc */
+      0,                                  /* tp_prev */
+      0                                   /* tp_next */
+#endif
+    };
+    varlink_type = tmp;
+    type_init = 1;
+    if (PyType_Ready(&varlink_type) < 0)
+      return NULL;
+  }
+  return &varlink_type;
+}
+
+/* Create a variable linking object for use later */
+SWIGINTERN PyObject *
+SWIG_Python_newvarlink(void) {
+  swig_varlinkobject *result = PyObject_NEW(swig_varlinkobject, swig_varlink_type());
+  if (result) {
+    result->vars = 0;
+  }
+  return ((PyObject*) result);
+}
+
+SWIGINTERN void 
+SWIG_Python_addvarlink(PyObject *p, const char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
+  swig_varlinkobject *v = (swig_varlinkobject *) p;
+  swig_globalvar *gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
+  if (gv) {
+    size_t size = strlen(name)+1;
+    gv->name = (char *)malloc(size);
+    if (gv->name) {
+      memcpy(gv->name, name, size);
+      gv->get_attr = get_attr;
+      gv->set_attr = set_attr;
+      gv->next = v->vars;
+    }
+  }
+  v->vars = gv;
+}
+
+
+static PyObject *Swig_Globals_global = NULL;
+  
+SWIGINTERN PyObject *
+SWIG_globals(void) {
+  if (Swig_Globals_global == NULL) {
+    Swig_Globals_global = SWIG_newvarlink();
+  }
+  return Swig_Globals_global;
+}
+
+#ifdef __cplusplus
+}
+#endif
+
 /* -----------------------------------------------------------------------------
  * Pointer declarations
  * ----------------------------------------------------------------------------- */
 
 /* Flags for new pointer objects */
 #define SWIG_POINTER_NOSHADOW       (SWIG_POINTER_OWN      << 1)
 #define SWIG_POINTER_NEW            (SWIG_POINTER_NOSHADOW | SWIG_POINTER_OWN)
@@ -1316,52 +1570,59 @@
     SwigPyClientData *data = (SwigPyClientData *)malloc(sizeof(SwigPyClientData));
     /* the klass element */
     data->klass = obj;
     Py_INCREF(data->klass);
     /* the newraw method and newargs arguments used to create a new raw instance */
     if (PyClass_Check(obj)) {
       data->newraw = 0;
-      data->newargs = obj;
       Py_INCREF(obj);
+      data->newargs = obj;
     } else {
       data->newraw = PyObject_GetAttrString(data->klass, "__new__");
       if (data->newraw) {
-	Py_INCREF(data->newraw);
-	data->newargs = PyTuple_New(1);
-	PyTuple_SetItem(data->newargs, 0, obj);
+        data->newargs = PyTuple_New(1);
+        if (data->newargs) {
+          Py_INCREF(obj);
+          PyTuple_SET_ITEM(data->newargs, 0, obj);
+        } else {
+          Py_DECREF(data->newraw);
+          Py_DECREF(data->klass);
+          free(data);
+          return 0;
+        }
       } else {
-	data->newargs = obj;
+        Py_INCREF(obj);
+        data->newargs = obj;
       }
-      Py_INCREF(data->newargs);
     }
     /* the destroy method, aka as the C++ delete method */
     data->destroy = PyObject_GetAttrString(data->klass, "__swig_destroy__");
     if (PyErr_Occurred()) {
       PyErr_Clear();
       data->destroy = 0;
     }
     if (data->destroy) {
-      int flags;
-      Py_INCREF(data->destroy);
-      flags = PyCFunction_GET_FLAGS(data->destroy);
-      data->delargs = !(flags & (METH_O));
+      data->delargs = !(PyCFunction_GET_FLAGS(data->destroy) & METH_O);
     } else {
       data->delargs = 0;
     }
     data->implicitconv = 0;
     data->pytype = 0;
     return data;
   }
 }
 
 SWIGRUNTIME void 
-SwigPyClientData_Del(SwigPyClientData *data) {
+SwigPyClientData_Del(SwigPyClientData *data)
+{
+  Py_XDECREF(data->klass);
   Py_XDECREF(data->newraw);
   Py_XDECREF(data->newargs);
   Py_XDECREF(data->destroy);
+  free(data);
 }
 
 /* =============== SwigPyObject =====================*/
 
 typedef struct {
   PyObject_HEAD
   void *ptr;
@@ -1380,15 +1641,15 @@
 SwigPyObject_get___dict__(PyObject *v, PyObject *SWIGUNUSEDPARM(args))
 {
   SwigPyObject *sobj = (SwigPyObject *)v;
 
   if (!sobj->dict)
     sobj->dict = PyDict_New();
 
-  Py_INCREF(sobj->dict);
+  Py_XINCREF(sobj->dict);
   return sobj->dict;
 }
 
 #endif
 
 SWIGRUNTIME PyObject *
 SwigPyObject_long(SwigPyObject *v)
@@ -1398,26 +1659,29 @@
 
 SWIGRUNTIME PyObject *
 SwigPyObject_format(const char* fmt, SwigPyObject *v)
 {
   PyObject *res = NULL;
   PyObject *args = PyTuple_New(1);
   if (args) {
-    if (PyTuple_SetItem(args, 0, SwigPyObject_long(v)) == 0) {
-      PyObject *ofmt = SWIG_Python_str_FromChar(fmt);
+    PyObject *val = SwigPyObject_long(v);
+    if (val) {
+      PyObject *ofmt;
+      PyTuple_SET_ITEM(args, 0, val);
+      ofmt = SWIG_Python_str_FromChar(fmt);
       if (ofmt) {
 #if PY_VERSION_HEX >= 0x03000000
-	res = PyUnicode_Format(ofmt,args);
+        res = PyUnicode_Format(ofmt,args);
 #else
-	res = PyString_Format(ofmt,args);
+        res = PyString_Format(ofmt,args);
 #endif
-	Py_DECREF(ofmt);
+        Py_DECREF(ofmt);
       }
-      Py_DECREF(args);
     }
+    Py_DECREF(args);
   }
   return res;
 }
 
 SWIGRUNTIME PyObject *
 SwigPyObject_oct(SwigPyObject *v)
 {
@@ -1431,26 +1695,31 @@
 }
 
 SWIGRUNTIME PyObject *
 SwigPyObject_repr(SwigPyObject *v)
 {
   const char *name = SWIG_TypePrettyName(v->ty);
   PyObject *repr = SWIG_Python_str_FromFormat("<Swig Object of type '%s' at %p>", (name ? name : "unknown"), (void *)v);
-  if (v->next) {
+  if (repr && v->next) {
     PyObject *nrep = SwigPyObject_repr((SwigPyObject *)v->next);
+    if (nrep) {
 # if PY_VERSION_HEX >= 0x03000000
-    PyObject *joined = PyUnicode_Concat(repr, nrep);
-    Py_DecRef(repr);
-    Py_DecRef(nrep);
-    repr = joined;
+      PyObject *joined = PyUnicode_Concat(repr, nrep);
+      Py_DecRef(repr);
+      Py_DecRef(nrep);
+      repr = joined;
 # else
-    PyString_ConcatAndDel(&repr,nrep);
+      PyString_ConcatAndDel(&repr,nrep);
 # endif
+    } else {
+      Py_DecRef(repr);
+      repr = NULL;
+    }
   }
-  return repr;  
+  return repr;
 }
 
 /* We need a version taking two PyObject* parameters so it's a valid
  * PyCFunction to use in swigobject_methods[]. */
 SWIGRUNTIME PyObject *
 SwigPyObject_repr2(PyObject *v, PyObject *SWIGUNUSEDPARM(args))
 {
@@ -1512,14 +1781,16 @@
     || (strcmp(Py_TYPE(op)->tp_name,"SwigPyObject") == 0);
 #endif
 }
 
 SWIGRUNTIME PyObject *
 SwigPyObject_New(void *ptr, swig_type_info *ty, int own);
 
+static PyObject* Swig_Capsule_global = NULL;
+
 SWIGRUNTIME void
 SwigPyObject_dealloc(PyObject *v)
 {
   SwigPyObject *sobj = (SwigPyObject *) v;
   PyObject *next = sobj->next;
   if (sobj->own == SWIG_POINTER_OWN) {
     swig_type_info *ty = sobj->ty;
@@ -1538,16 +1809,20 @@
       
       PyObject *type = NULL, *value = NULL, *traceback = NULL;
       PyErr_Fetch(&type, &value, &traceback);
 
       if (data->delargs) {
         /* we need to create a temporary object to carry the destroy operation */
         PyObject *tmp = SwigPyObject_New(sobj->ptr, ty, 0);
-        res = SWIG_Python_CallFunctor(destroy, tmp);
-        Py_DECREF(tmp);
+        if (tmp) {
+          res = SWIG_Python_CallFunctor(destroy, tmp);
+        } else {
+          res = 0;
+        }
+        Py_XDECREF(tmp);
       } else {
         PyCFunction meth = PyCFunction_GET_FUNCTION(destroy);
         PyObject *mself = PyCFunction_GET_SELF(destroy);
         res = ((*meth)(mself, v));
       }
       if (!res)
         PyErr_WriteUnraisable(destroy);
@@ -1558,27 +1833,32 @@
     } 
 #if !defined(SWIG_PYTHON_SILENT_MEMLEAK)
     else {
       const char *name = SWIG_TypePrettyName(ty);
       printf("swig/python detected a memory leak of type '%s', no destructor found.\n", (name ? name : "unknown"));
     }
 #endif
-  } 
+    Py_XDECREF(Swig_Capsule_global);
+  }
   Py_XDECREF(next);
+#ifdef SWIGPYTHON_BUILTIN
+  Py_XDECREF(sobj->dict);
+#endif
   PyObject_DEL(v);
 }
 
 SWIGRUNTIME PyObject* 
 SwigPyObject_append(PyObject* v, PyObject* next)
 {
   SwigPyObject *sobj = (SwigPyObject *) v;
   if (!SwigPyObject_Check(next)) {
     PyErr_SetString(PyExc_TypeError, "Attempt to append a non SwigPyObject");
     return NULL;
   }
+  ((SwigPyObject *)next)->next = sobj->next;
   sobj->next = next;
   Py_INCREF(next);
   return SWIG_Py_Void();
 }
 
 SWIGRUNTIME PyObject* 
 SwigPyObject_next(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
@@ -1615,17 +1895,17 @@
   if (!PyArg_UnpackTuple(args, "own", 0, 1, &val)) {
     return NULL;
   } else {
     SwigPyObject *sobj = (SwigPyObject *)v;
     PyObject *obj = PyBool_FromLong(sobj->own);
     if (val) {
       if (PyObject_IsTrue(val)) {
-        SwigPyObject_acquire(v,args);
+        Py_DECREF(SwigPyObject_acquire(v,args));
       } else {
-        SwigPyObject_disown(v,args);
+        Py_DECREF(SwigPyObject_disown(v,args));
       }
     } 
     return obj;
   }
 }
 
 static PyMethodDef
@@ -1697,15 +1977,19 @@
       PyObject_HEAD_INIT(NULL)
       0,                                    /* ob_size */
 #endif
       "SwigPyObject",                       /* tp_name */
       sizeof(SwigPyObject),                 /* tp_basicsize */
       0,                                    /* tp_itemsize */
       (destructor)SwigPyObject_dealloc,     /* tp_dealloc */
-      0,                                    /* tp_print */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                         /*tp_print*/
+#else
+      (Py_ssize_t)0,                        /*tp_vectorcall_offset*/
+#endif
       (getattrfunc)0,                       /* tp_getattr */
       (setattrfunc)0,                       /* tp_setattr */
 #if PY_VERSION_HEX >= 0x03000000
       0, /* tp_reserved in 3.0.1, tp_compare in 3.0.0 but not used */
 #else
       (cmpfunc)SwigPyObject_compare,        /* tp_compare */
 #endif
@@ -1762,29 +2046,38 @@
       0,                                    /* tp_maxalloc */
       0,                                    /* tp_prev */
       0                                     /* tp_next */
 #endif
     };
     swigpyobject_type = tmp;
     type_init = 1;
-    if (PyType_Ready(&swigpyobject_type) < 0)
+    if (PyType_Ready(&swigpyobject_type) != 0)
       return NULL;
   }
   return &swigpyobject_type;
 }
 
 SWIGRUNTIME PyObject *
 SwigPyObject_New(void *ptr, swig_type_info *ty, int own)
 {
   SwigPyObject *sobj = PyObject_NEW(SwigPyObject, SwigPyObject_type());
   if (sobj) {
     sobj->ptr  = ptr;
     sobj->ty   = ty;
     sobj->own  = own;
     sobj->next = 0;
+#ifdef SWIGPYTHON_BUILTIN
+    sobj->dict = 0;
+#endif
+    if (own == SWIG_POINTER_OWN) {
+      /* Obtain a reference to the Python capsule wrapping the module information, so that the
+       * module information is correctly destroyed after all SWIG python objects have been freed
+       * by the GC (and corresponding destructors invoked) */
+      Py_XINCREF(Swig_Capsule_global);
+    }
   }
   return (PyObject *)sobj;
 }
 
 /* -----------------------------------------------------------------------------
  * Implements a simple Swig Packed type, and use it instead of string
  * ----------------------------------------------------------------------------- */
@@ -1864,15 +2157,19 @@
       PyObject_HEAD_INIT(NULL)
       0,                                    /* ob_size */
 #endif
       "SwigPyPacked",                       /* tp_name */
       sizeof(SwigPyPacked),                 /* tp_basicsize */
       0,                                    /* tp_itemsize */
       (destructor)SwigPyPacked_dealloc,     /* tp_dealloc */
-      0,                                    /* tp_print */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                         /*tp_print*/
+#else
+      (Py_ssize_t)0,                        /*tp_vectorcall_offset*/
+#endif
       (getattrfunc)0,                       /* tp_getattr */
       (setattrfunc)0,                       /* tp_setattr */
 #if PY_VERSION_HEX>=0x03000000
       0, /* tp_reserved in 3.0.1 */
 #else
       (cmpfunc)SwigPyPacked_compare,        /* tp_compare */
 #endif
@@ -1929,15 +2226,15 @@
       0,                                    /* tp_maxalloc */
       0,                                    /* tp_prev */
       0                                     /* tp_next */
 #endif
     };
     swigpypacked_type = tmp;
     type_init = 1;
-    if (PyType_Ready(&swigpypacked_type) < 0)
+    if (PyType_Ready(&swigpypacked_type) != 0)
       return NULL;
   }
   return &swigpypacked_type;
 }
 
 SWIGRUNTIME PyObject *
 SwigPyPacked_New(void *ptr, size_t size, swig_type_info *ty)
@@ -2119,20 +2416,27 @@
       }
     } else {
       if (ptr) *ptr = vptr;
       break;
     }
   }
   if (sobj) {
-    if (own)
-      *own = *own | sobj->own;
-    if (flags & SWIG_POINTER_DISOWN) {
-      sobj->own = 0;
+    if (((flags & SWIG_POINTER_RELEASE) == SWIG_POINTER_RELEASE) && !sobj->own) {
+      res = SWIG_ERROR_RELEASE_NOT_OWNED;
+    } else {
+      if (own)
+        *own = *own | sobj->own;
+      if (flags & SWIG_POINTER_DISOWN) {
+        sobj->own = 0;
+      }
+      if (flags & SWIG_POINTER_CLEAR) {
+        sobj->ptr = 0;
+      }
+      res = SWIG_OK;
     }
-    res = SWIG_OK;
   } else {
     if (implicit_conv) {
       SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
       if (data && !data->implicitconv) {
         PyObject *klass = data->klass;
         if (klass) {
           PyObject *impconv;
@@ -2237,20 +2541,25 @@
   PyObject *newraw = data->newraw;
   if (newraw) {
     inst = PyObject_Call(newraw, data->newargs, NULL);
     if (inst) {
 #if !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
       PyObject **dictptr = _PyObject_GetDictPtr(inst);
       if (dictptr != NULL) {
-	PyObject *dict = *dictptr;
-	if (dict == NULL) {
-	  dict = PyDict_New();
-	  *dictptr = dict;
-	  PyDict_SetItem(dict, SWIG_This(), swig_this);
-	}
+        PyObject *dict = *dictptr;
+        if (dict == NULL) {
+          dict = PyDict_New();
+          *dictptr = dict;
+        }
+        if (dict) {
+          PyDict_SetItem(dict, SWIG_This(), swig_this);
+        } else{
+          Py_DECREF(inst);
+          inst = 0;
+        }
       }
 #else
       if (PyObject_SetAttr(inst, SWIG_This(), swig_this) == -1) {
         Py_DECREF(inst);
         inst = 0;
       }
 #endif
@@ -2264,15 +2573,15 @@
         inst = ((PyTypeObject *)data->newargs)->tp_new((PyTypeObject *)data->newargs, empty_args, empty_kwargs);
         Py_DECREF(empty_kwargs);
         if (inst) {
           if (PyObject_SetAttr(inst, SWIG_This(), swig_this) == -1) {
             Py_DECREF(inst);
             inst = 0;
           } else {
-            Py_TYPE(inst)->tp_flags &= ~Py_TPFLAGS_VALID_VERSION_TAG;
+            PyType_Modified(Py_TYPE(inst));
           }
         }
       }
       Py_DECREF(empty_args);
     }
 #else
     PyObject *dict = PyDict_New();
@@ -2293,30 +2602,34 @@
   PyObject **dictptr = _PyObject_GetDictPtr(inst);
   if (dictptr != NULL) {
     PyObject *dict = *dictptr;
     if (dict == NULL) {
       dict = PyDict_New();
       *dictptr = dict;
     }
-    return PyDict_SetItem(dict, SWIG_This(), swig_this);
+    if (dict) {
+      return PyDict_SetItem(dict, SWIG_This(), swig_this);
+    } else{
+      return -1;
+    }
   }
 #endif
   return PyObject_SetAttr(inst, SWIG_This(), swig_this);
 } 
 
 
 SWIGINTERN PyObject *
 SWIG_Python_InitShadowInstance(PyObject *args) {
   PyObject *obj[2];
   if (!SWIG_Python_UnpackTuple(args, "swiginit", 2, 2, obj)) {
     return NULL;
   } else {
     SwigPyObject *sthis = SWIG_Python_GetSwigThis(obj[0]);
     if (sthis) {
-      SwigPyObject_append((PyObject*) sthis, obj[1]);
+      Py_DECREF(SwigPyObject_append((PyObject*) sthis, obj[1]));
     } else {
       if (SWIG_Python_SetSwigThis(obj[0], obj[1]) != 0)
         return NULL;
     }
     return SWIG_Py_Void();
   }
 }
@@ -2347,15 +2660,17 @@
 #ifdef SWIGPYTHON_BUILTIN
         newobj->dict = 0;
 #endif
       }
     } else {
       newobj = PyObject_New(SwigPyObject, clientdata->pytype);
 #ifdef SWIGPYTHON_BUILTIN
-      newobj->dict = 0;
+      if (newobj) {
+        newobj->dict = 0;
+      }
 #endif
     }
     if (newobj) {
       newobj->ptr = ptr;
       newobj->ty = type;
       newobj->own = own;
       newobj->next = 0;
@@ -2386,89 +2701,111 @@
  *  Get type list 
  * -----------------------------------------------------------------------------*/
 
 #ifdef SWIG_LINK_RUNTIME
 void *SWIG_ReturnGlobalTypeList(void *);
 #endif
 
+static PyObject *Swig_TypeCache_global = NULL;
+
+/* The python cached type query */
+SWIGRUNTIME PyObject *
+SWIG_Python_TypeCache(void) {
+  if (Swig_TypeCache_global == NULL) {
+    Swig_TypeCache_global = PyDict_New();
+  }
+  return Swig_TypeCache_global;
+}
+
 SWIGRUNTIME swig_module_info *
 SWIG_Python_GetModule(void *SWIGUNUSEDPARM(clientdata)) {
+#ifdef SWIG_LINK_RUNTIME
   static void *type_pointer = (void *)0;
   /* first check if module already created */
   if (!type_pointer) {
-#ifdef SWIG_LINK_RUNTIME
     type_pointer = SWIG_ReturnGlobalTypeList((void *)0);
+  }
 #else
-    type_pointer = PyCapsule_Import(SWIGPY_CAPSULE_NAME, 0);
-    if (PyErr_Occurred()) {
-      PyErr_Clear();
-      type_pointer = (void *)0;
-    }
-#endif
+  void *type_pointer = PyCapsule_Import(SWIGPY_CAPSULE_NAME, 0);
+  if (PyErr_Occurred()) {
+    PyErr_Clear();
+    type_pointer = (void *)0;
   }
+#endif
   return (swig_module_info *) type_pointer;
 }
 
+
+static int interpreter_counter = 0; // how many (sub-)interpreters are using swig_module's types
+
 SWIGRUNTIME void
 SWIG_Python_DestroyModule(PyObject *obj)
 {
   swig_module_info *swig_module = (swig_module_info *) PyCapsule_GetPointer(obj, SWIGPY_CAPSULE_NAME);
   swig_type_info **types = swig_module->types;
   size_t i;
+  if (--interpreter_counter != 0) // another sub-interpreter may still be using the swig_module's types
+    return;
   for (i =0; i < swig_module->size; ++i) {
     swig_type_info *ty = types[i];
     if (ty->owndata) {
       SwigPyClientData *data = (SwigPyClientData *) ty->clientdata;
+      ty->clientdata = 0;
       if (data) SwigPyClientData_Del(data);
     }
   }
   Py_DECREF(SWIG_This());
   Swig_This_global = NULL;
+  Py_DECREF(SWIG_globals());
+  Swig_Globals_global = NULL;
+  Py_DECREF(SWIG_Python_TypeCache());
+  Swig_TypeCache_global = NULL;
+  Swig_Capsule_global = NULL;
 }
 
 SWIGRUNTIME void
 SWIG_Python_SetModule(swig_module_info *swig_module) {
 #if PY_VERSION_HEX >= 0x03000000
  /* Add a dummy module object into sys.modules */
   PyObject *module = PyImport_AddModule("swig_runtime_data" SWIG_RUNTIME_VERSION);
 #else
   static PyMethodDef swig_empty_runtime_method_table[] = { {NULL, NULL, 0, NULL} }; /* Sentinel */
   PyObject *module = Py_InitModule("swig_runtime_data" SWIG_RUNTIME_VERSION, swig_empty_runtime_method_table);
 #endif
   PyObject *pointer = PyCapsule_New((void *) swig_module, SWIGPY_CAPSULE_NAME, SWIG_Python_DestroyModule);
   if (pointer && module) {
-    PyModule_AddObject(module, "type_pointer_capsule" SWIG_TYPE_TABLE_NAME, pointer);
+    if (PyModule_AddObject(module, SWIGPY_CAPSULE_ATTR_NAME, pointer) == 0) {
+      ++interpreter_counter;
+      Swig_Capsule_global = pointer;
+    } else {
+      Py_DECREF(pointer);
+    }
   } else {
     Py_XDECREF(pointer);
   }
 }
 
-/* The python cached type query */
-SWIGRUNTIME PyObject *
-SWIG_Python_TypeCache(void) {
-  static PyObject *SWIG_STATIC_POINTER(cache) = PyDict_New();
-  return cache;
-}
-
 SWIGRUNTIME swig_type_info *
 SWIG_Python_TypeQuery(const char *type)
 {
   PyObject *cache = SWIG_Python_TypeCache();
   PyObject *key = SWIG_Python_str_FromChar(type); 
   PyObject *obj = PyDict_GetItem(cache, key);
   swig_type_info *descriptor;
   if (obj) {
     descriptor = (swig_type_info *) PyCapsule_GetPointer(obj, NULL);
   } else {
     swig_module_info *swig_module = SWIG_GetModule(0);
     descriptor = SWIG_TypeQueryModule(swig_module, swig_module, type);
     if (descriptor) {
       obj = PyCapsule_New((void*) descriptor, NULL, NULL);
-      PyDict_SetItem(cache, key, obj);
-      Py_DECREF(obj);
+      if (obj) {
+        PyDict_SetItem(cache, key, obj);
+        Py_DECREF(obj);
+      }
     }
   }
   Py_DECREF(key);
   return descriptor;
 }
 
 /* 
@@ -2493,15 +2830,14 @@
       Py_XINCREF(type);
       PyErr_Clear();
       if (infront) {
 	PyErr_Format(type, "%s %s", mesg, errmesg);
       } else {
 	PyErr_Format(type, "%s %s", errmesg, mesg);
       }
-      SWIG_Python_str_DelForPy3(tmp);
       Py_DECREF(old_str);
     }
     return 1;
   } else {
     return 0;
   }
 }
@@ -2545,15 +2881,14 @@
       const char *otype = (obj ? obj->ob_type->tp_name : 0); 
       if (otype) {
 	PyObject *str = PyObject_Str(obj);
 	const char *cstr = str ? SWIG_Python_str_AsChar(str) : 0;
 	if (cstr) {
 	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s(%s)' is received",
 		       type, otype, cstr);
-          SWIG_Python_str_DelForPy3(cstr);
 	} else {
 	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s' is received",
 		       type, otype);
 	}
 	Py_XDECREF(str);
 	return;
       }
@@ -2567,20 +2902,14 @@
 
 /* Convert a pointer value, signal an exception on a type mismatch */
 SWIGRUNTIME void *
 SWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int SWIGUNUSEDPARM(argnum), int flags) {
   void *result;
   if (SWIG_Python_ConvertPtr(obj, &result, ty, flags) == -1) {
     PyErr_Clear();
-#if SWIG_POINTER_EXCEPTION
-    if (flags) {
-      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);
-      SWIG_Python_ArgFail(argnum);
-    }
-#endif
   }
   return result;
 }
 
 #ifdef SWIGPYTHON_BUILTIN
 SWIGRUNTIME int
 SWIG_Python_NonDynamicSetAttr(PyObject *obj, PyObject *name, PyObject *value) {
@@ -2603,30 +2932,30 @@
     PyErr_Format(PyExc_TypeError, "attribute name must be string, not '%.200s'", name->ob_type->tp_name);
     return -1;
   } else {
     Py_INCREF(name);
   }
 
   if (!tp->tp_dict) {
-    if (PyType_Ready(tp) < 0)
+    if (PyType_Ready(tp) != 0)
       goto done;
   }
 
   descr = _PyType_Lookup(tp, name);
   f = NULL;
   if (descr != NULL)
     f = descr->ob_type->tp_descr_set;
   if (!f) {
     if (PyString_Check(name)) {
       encoded_name = name;
       Py_INCREF(name);
     } else {
       encoded_name = PyUnicode_AsUTF8String(name);
       if (!encoded_name)
-        return -1;
+        goto done;
     }
     PyErr_Format(PyExc_AttributeError, "'%.100s' object has no attribute '%.200s'", tp->tp_name, PyString_AsString(encoded_name));
     Py_DECREF(encoded_name);
   } else {
     res = f(descr, obj, value);
   }
   
@@ -2645,15 +2974,19 @@
 extern "C" {
 #endif
 
 SWIGINTERN Py_hash_t
 SwigPyObject_hash(PyObject *obj) {
   SwigPyObject *sobj = (SwigPyObject *)obj;
   void *ptr = sobj->ptr;
+#if PY_VERSION_HEX < 0x03020000
+  return (Py_hash_t)(Py_ssize_t)ptr;
+#else
   return (Py_hash_t)ptr;
+#endif
 }
 
 SWIGINTERN Py_hash_t
 SWIG_PyNumber_AsPyHash(PyObject *obj) {
   Py_hash_t result = -1;
 #if PY_VERSION_HEX < 0x03020000
   if (PyInt_Check(obj))
@@ -2850,15 +3183,19 @@
       PyObject_HEAD_INIT(&PyType_Type)
       0,                                        /* ob_size */
 #endif
       "swig_static_var_getset_descriptor",      /* tp_name */
       sizeof(PyGetSetDescrObject),              /* tp_basicsize */
       0,                                        /* tp_itemsize */
       (destructor)SwigPyStaticVar_dealloc,      /* tp_dealloc */
-      0,                                        /* tp_print */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                             /* tp_print */
+#else
+      (Py_ssize_t)0,                            /* tp_vectorcall_offset */
+#endif
       0,                                        /* tp_getattr */
       0,                                        /* tp_setattr */
       0,                                        /* tp_compare */
       (reprfunc)SwigPyStaticVar_repr,           /* tp_repr */
       0,                                        /* tp_as_number */
       0,                                        /* tp_as_sequence */
       0,                                        /* tp_as_mapping */
@@ -2934,15 +3271,19 @@
       PyObject_HEAD_INIT(&PyType_Type)
       0,                                        /* ob_size */
 #endif
       "SwigPyObjectType",                       /* tp_name */
       PyType_Type.tp_basicsize,                 /* tp_basicsize */
       0,                                        /* tp_itemsize */
       0,                                        /* tp_dealloc */
-      0,                                        /* tp_print */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                             /* tp_print */
+#else
+      (Py_ssize_t)0,                            /* tp_vectorcall_offset */
+#endif
       0,                                        /* tp_getattr */
       0,                                        /* tp_setattr */
       0,                                        /* tp_compare */
       0,                                        /* tp_repr */
       0,                                        /* tp_as_number */
       0,                                        /* tp_as_sequence */
       0,                                        /* tp_as_mapping */
@@ -3053,18 +3394,18 @@
   Py_XINCREF(result);
   return result;
 }
 
 SWIGINTERN void
 SwigPyBuiltin_SetMetaType (PyTypeObject *type, PyTypeObject *metatype)
 {
-#if PY_VERSION_HEX >= 0x03000000
-    type->ob_base.ob_base.ob_type = metatype;
+#if PY_VERSION_HEX >= 0x030900a4
+    Py_SET_TYPE(type, metatype);
 #else
-    type->ob_type = metatype;
+    Py_TYPE(type) = metatype;
 #endif
 }
 
 
 /* Start of callback function macros for use in PyTypeObject */
 
 typedef PyObject *(*SwigPyWrapperFunction)(PyObject *, PyObject *);
@@ -3394,31 +3735,16 @@
 #endif
 
 
 
 
 #define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 
 
-#define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 
-
-
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* Method creation and docstring support functions */
+#define SWIG_contract_assert(expr, msg) do { if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } } while (0) 
 
-SWIGINTERN PyMethodDef *SWIG_PythonGetProxyDoc(const char *name);
-SWIGINTERN PyObject *SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func);
-SWIGINTERN PyObject *SWIG_PyStaticMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func);
-
-#ifdef __cplusplus
-}
-#endif
 
 
 /* -------- TYPES TABLE (BEGIN) -------- */
 
 #define SWIGTYPE_p_CameraAbilities swig_types[0]
 #define SWIGTYPE_p_CameraCaptureType swig_types[1]
 #define SWIGTYPE_p_CameraDriverStatus swig_types[2]
@@ -3495,18 +3821,14 @@
 
 #else
 #  define SWIG_init    init_list
 
 #endif
 #define SWIG_name    "_list"
 
-#define SWIGVERSION 0x040002 
-#define SWIG_VERSION SWIGVERSION
-
-
 #define SWIG_as_voidptr(a) (void *)((const void *)(a)) 
 #define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),(void**)(a)) 
 
 
 #include <stddef.h>
 
 
@@ -4021,14 +4343,15 @@
 #ifdef __cplusplus
 extern "C" {
 #endif
 SWIGINTERN int _wrap_new_CameraList(PyObject *self, PyObject *args, PyObject *kwargs) {
   PyObject *resultobj = 0;
   struct _CameraList *result = 0 ;
   
+  (void)self;
   if (!SWIG_Python_CheckNoKeywords(kwargs, "new_CameraList")) SWIG_fail;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "new_CameraList takes no arguments");
   {
     result = (struct _CameraList *)new__CameraList();
     if (PyErr_Occurred()) SWIG_fail;
   }
   resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p__CameraList, SWIG_BUILTIN_INIT |  0 );
@@ -4040,14 +4363,15 @@
 
 SWIGINTERN PyObject *_wrap_delete_CameraList(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraList *arg1 = (struct _CameraList *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_CameraList takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraList, SWIG_POINTER_DISOWN |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CameraList" "', argument " "1"" of type '" "struct _CameraList *""'"); 
   }
   arg1 = (struct _CameraList *)(argp1);
   {
@@ -4064,14 +4388,15 @@
 SWIGINTERN PyObject *_wrap_CameraList___len__(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraList *arg1 = (struct _CameraList *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   int result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraList___len__ takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraList___len__" "', argument " "1"" of type '" "struct _CameraList *""'"); 
   }
   arg1 = (struct _CameraList *)(argp1);
   {
@@ -4092,14 +4417,15 @@
   void *argp1 = 0 ;
   int res1 = 0 ;
   int val2 ;
   int ecode2 = 0 ;
   PyObject * obj1 = 0 ;
   PyObject *result = 0 ;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "CameraList___getitem__", 1, 1, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraList___getitem__" "', argument " "1"" of type '" "struct _CameraList *""'"); 
   }
   arg1 = (struct _CameraList *)(argp1);
   ecode2 = SWIG_AsVal_int(obj1, &val2);
@@ -4118,14 +4444,15 @@
 SWIGINTERN PyObject *_wrap_CameraList_count(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraList *arg1 = (struct _CameraList *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   int result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraList_count takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraList_count" "', argument " "1"" of type '" "struct _CameraList *""'"); 
   }
   arg1 = (struct _CameraList *)(argp1);
   {
@@ -4151,14 +4478,15 @@
   int alloc2 = 0 ;
   int res3 ;
   char *buf3 = 0 ;
   int alloc3 = 0 ;
   PyObject * obj1 = 0 ;
   PyObject * obj2 = 0 ;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "CameraList_append", 2, 2, &obj1, &obj2)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraList_append" "', argument " "1"" of type '" "struct _CameraList *""'"); 
   }
   arg1 = (struct _CameraList *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -4188,14 +4516,15 @@
 
 SWIGINTERN PyObject *_wrap_CameraList_reset(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraList *arg1 = (struct _CameraList *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraList_reset takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraList_reset" "', argument " "1"" of type '" "struct _CameraList *""'"); 
   }
   arg1 = (struct _CameraList *)(argp1);
   {
@@ -4211,14 +4540,15 @@
 
 SWIGINTERN PyObject *_wrap_CameraList_sort(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraList *arg1 = (struct _CameraList *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraList_sort takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraList_sort" "', argument " "1"" of type '" "struct _CameraList *""'"); 
   }
   arg1 = (struct _CameraList *)(argp1);
   {
@@ -4243,14 +4573,15 @@
   int res2 = 0 ;
   int res3 ;
   char *buf3 = 0 ;
   int alloc3 = 0 ;
   PyObject * obj1 = 0 ;
   PyObject * obj2 = 0 ;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "CameraList_find_by_name", 2, 2, &obj1, &obj2)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraList_find_by_name" "', argument " "1"" of type '" "struct _CameraList *""'"); 
   }
   arg1 = (struct _CameraList *)(argp1);
   res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_int, 0 |  0 );
@@ -4288,14 +4619,15 @@
   char *temp3 ;
   PyObject * obj1 = 0 ;
   
   {
     temp3 = NULL;
     arg3 = &temp3;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "CameraList_get_name", 1, 1, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraList_get_name" "', argument " "1"" of type '" "struct _CameraList *""'"); 
   }
   arg1 = (struct _CameraList *)(argp1);
   ecode2 = SWIG_AsVal_int(obj1, &val2);
@@ -4335,14 +4667,15 @@
   char *temp3 ;
   PyObject * obj1 = 0 ;
   
   {
     temp3 = NULL;
     arg3 = &temp3;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "CameraList_get_value", 1, 1, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraList_get_value" "', argument " "1"" of type '" "struct _CameraList *""'"); 
   }
   arg1 = (struct _CameraList *)(argp1);
   ecode2 = SWIG_AsVal_int(obj1, &val2);
@@ -4381,14 +4714,15 @@
   int ecode2 = 0 ;
   int res3 ;
   char *buf3 = 0 ;
   int alloc3 = 0 ;
   PyObject * obj1 = 0 ;
   PyObject * obj2 = 0 ;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "CameraList_set_name", 2, 2, &obj1, &obj2)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraList_set_name" "', argument " "1"" of type '" "struct _CameraList *""'"); 
   }
   arg1 = (struct _CameraList *)(argp1);
   ecode2 = SWIG_AsVal_int(obj1, &val2);
@@ -4425,14 +4759,15 @@
   int ecode2 = 0 ;
   int res3 ;
   char *buf3 = 0 ;
   int alloc3 = 0 ;
   PyObject * obj1 = 0 ;
   PyObject * obj2 = 0 ;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "CameraList_set_value", 2, 2, &obj1, &obj2)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraList_set_value" "', argument " "1"" of type '" "struct _CameraList *""'"); 
   }
   arg1 = (struct _CameraList *)(argp1);
   ecode2 = SWIG_AsVal_int(obj1, &val2);
@@ -4469,14 +4804,15 @@
   char *buf2 = 0 ;
   int alloc2 = 0 ;
   int val3 ;
   int ecode3 = 0 ;
   PyObject * obj1 = 0 ;
   PyObject * obj2 = 0 ;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "CameraList_populate", 2, 2, &obj1, &obj2)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraList_populate" "', argument " "1"" of type '" "struct _CameraList *""'"); 
   }
   arg1 = (struct _CameraList *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -4514,14 +4850,15 @@
   CameraList *temp1 ;
   int result;
   
   {
     temp1 = NULL;
     arg1 = &temp1;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_list_new", 0, 0)) SWIG_fail;
   result = (int)gp_list_new(arg1);
   resultobj = SWIG_From_int((int)(result));
   {
     resultobj = SWIG_Python_AppendOutput(
       resultobj, SWIG_NewPointerObj(*arg1, SWIGTYPE_p__CameraList, SWIG_POINTER_OWN));
   }
@@ -4535,14 +4872,15 @@
   PyObject *resultobj = 0;
   CameraList *arg1 = (CameraList *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   PyObject * obj0 = 0 ;
   int result;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_list_count", 1, 1, &obj0)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_list_count" "', argument " "1"" of type '" "CameraList *""'"); 
   }
   arg1 = (CameraList *)(argp1);
   result = (int)gp_list_count(arg1);
@@ -4567,14 +4905,15 @@
   char *buf3 = 0 ;
   int alloc3 = 0 ;
   PyObject * obj0 = 0 ;
   PyObject * obj1 = 0 ;
   PyObject * obj2 = 0 ;
   int result;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_list_append", 3, 3, &obj0, &obj1, &obj2)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_list_append" "', argument " "1"" of type '" "CameraList *""'"); 
   }
   arg1 = (CameraList *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -4603,14 +4942,15 @@
   PyObject *resultobj = 0;
   CameraList *arg1 = (CameraList *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   PyObject * obj0 = 0 ;
   int result;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_list_reset", 1, 1, &obj0)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_list_reset" "', argument " "1"" of type '" "CameraList *""'"); 
   }
   arg1 = (CameraList *)(argp1);
   result = (int)gp_list_reset(arg1);
@@ -4625,14 +4965,15 @@
   PyObject *resultobj = 0;
   CameraList *arg1 = (CameraList *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   PyObject * obj0 = 0 ;
   int result;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_list_sort", 1, 1, &obj0)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_list_sort" "', argument " "1"" of type '" "CameraList *""'"); 
   }
   arg1 = (CameraList *)(argp1);
   result = (int)gp_list_sort(arg1);
@@ -4656,14 +4997,15 @@
   char *buf3 = 0 ;
   int alloc3 = 0 ;
   PyObject * obj0 = 0 ;
   PyObject * obj1 = 0 ;
   PyObject * obj2 = 0 ;
   int result;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_list_find_by_name", 3, 3, &obj0, &obj1, &obj2)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_list_find_by_name" "', argument " "1"" of type '" "CameraList *""'"); 
   }
   arg1 = (CameraList *)(argp1);
   res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_int, 0 |  0 );
@@ -4700,14 +5042,15 @@
   PyObject * obj1 = 0 ;
   int result;
   
   {
     temp3 = NULL;
     arg3 = &temp3;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_list_get_name", 2, 2, &obj0, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_list_get_name" "', argument " "1"" of type '" "CameraList *""'"); 
   }
   arg1 = (CameraList *)(argp1);
   ecode2 = SWIG_AsVal_int(obj1, &val2);
@@ -4746,14 +5089,15 @@
   PyObject * obj1 = 0 ;
   int result;
   
   {
     temp3 = NULL;
     arg3 = &temp3;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_list_get_value", 2, 2, &obj0, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_list_get_value" "', argument " "1"" of type '" "CameraList *""'"); 
   }
   arg1 = (CameraList *)(argp1);
   ecode2 = SWIG_AsVal_int(obj1, &val2);
@@ -4791,14 +5135,15 @@
   char *buf3 = 0 ;
   int alloc3 = 0 ;
   PyObject * obj0 = 0 ;
   PyObject * obj1 = 0 ;
   PyObject * obj2 = 0 ;
   int result;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_list_set_name", 3, 3, &obj0, &obj1, &obj2)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_list_set_name" "', argument " "1"" of type '" "CameraList *""'"); 
   }
   arg1 = (CameraList *)(argp1);
   ecode2 = SWIG_AsVal_int(obj1, &val2);
@@ -4834,14 +5179,15 @@
   char *buf3 = 0 ;
   int alloc3 = 0 ;
   PyObject * obj0 = 0 ;
   PyObject * obj1 = 0 ;
   PyObject * obj2 = 0 ;
   int result;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_list_set_value", 3, 3, &obj0, &obj1, &obj2)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_list_set_value" "', argument " "1"" of type '" "CameraList *""'"); 
   }
   arg1 = (CameraList *)(argp1);
   ecode2 = SWIG_AsVal_int(obj1, &val2);
@@ -4877,14 +5223,15 @@
   int val3 ;
   int ecode3 = 0 ;
   PyObject * obj0 = 0 ;
   PyObject * obj1 = 0 ;
   PyObject * obj2 = 0 ;
   int result;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_list_populate", 3, 3, &obj0, &obj1, &obj2)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_list_populate" "', argument " "1"" of type '" "CameraList *""'"); 
   }
   arg1 = (CameraList *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -4904,279 +5251,14 @@
 fail:
   if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
   return NULL;
 }
 
 
 static PyMethodDef SwigMethods[] = {
-	 { "SWIG_PyInstanceMethod_New", SWIG_PyInstanceMethod_New, METH_O, NULL},
-	 { "SWIG_PyStaticMethod_New", SWIG_PyStaticMethod_New, METH_O, NULL},
-	 { "gp_list_new", _wrap_gp_list_new, METH_VARARGS, "\n"
-		"gp_list_new() -> int\n"
-		"Creates a new CameraList.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `list` :  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code\n"
-		"\n"
-		"See also gphoto2.CameraList\n"
-		""},
-	 { "gp_list_count", _wrap_gp_list_count, METH_VARARGS, "\n"
-		"gp_list_count(list) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"list: gphoto2.CameraList\n"
-		"\n"
-		"Counts the entries in the `list`.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `list` :  \n"
-		"    a CameraList  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code\n"
-		"\n"
-		"See also gphoto2.CameraList.count\n"
-		""},
-	 { "gp_list_append", _wrap_gp_list_append, METH_VARARGS, "\n"
-		"gp_list_append(list, name, value) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"list: gphoto2.CameraList\n"
-		"name: str\n"
-		"value: str\n"
-		"\n"
-		"Appends `name` and `value` to the `list`.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `list` :  \n"
-		"    a CameraList  \n"
-		"* `name` :  \n"
-		"    the name of the entry to append  \n"
-		"* `value` :  \n"
-		"    the value of the entry to append  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code\n"
-		"\n"
-		"See also gphoto2.CameraList.append\n"
-		""},
-	 { "gp_list_reset", _wrap_gp_list_reset, METH_VARARGS, "\n"
-		"gp_list_reset(list) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"list: gphoto2.CameraList\n"
-		"\n"
-		"Resets the `list` and removes all entries.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `list` :  \n"
-		"    a CameraList  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code\n"
-		"\n"
-		"See also gphoto2.CameraList.reset\n"
-		""},
-	 { "gp_list_sort", _wrap_gp_list_sort, METH_VARARGS, "\n"
-		"gp_list_sort(list) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"list: gphoto2.CameraList\n"
-		"\n"
-		"Sorts the `list` entries with respect to the names.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `list` :  \n"
-		"    a CameraList  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code\n"
-		"\n"
-		"See also gphoto2.CameraList.sort\n"
-		""},
-	 { "gp_list_find_by_name", _wrap_gp_list_find_by_name, METH_VARARGS, "\n"
-		"gp_list_find_by_name(list, index, name) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"list: gphoto2.CameraList\n"
-		"index: int *\n"
-		"name: str\n"
-		"\n"
-		"Retrieves the `index` of an arbitrary entry with `name`.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `list` :  \n"
-		"    a CameraList  \n"
-		"* `index` :  \n"
-		"    pointer to the result index (may be NULL, only set if found)  \n"
-		"* `name` :  \n"
-		"    name of the entry  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code: GP_OK if found.  \n"
-		"\n"
-		"No guarantees as to the speed of the search, or in what sequence the\n"
-		"list is searched.\n"
-		"\n"
-		"See also gphoto2.CameraList.find_by_name\n"
-		""},
-	 { "gp_list_get_name", _wrap_gp_list_get_name, METH_VARARGS, "\n"
-		"gp_list_get_name(list, index) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"list: gphoto2.CameraList\n"
-		"index: int\n"
-		"\n"
-		"Retrieves the `name` of entry with `index`.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `list` :  \n"
-		"    a CameraList  \n"
-		"* `index` :  \n"
-		"    index of the entry  \n"
-		"* `name` :  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		"\n"
-		"See also gphoto2.CameraList.get_name\n"
-		""},
-	 { "gp_list_get_value", _wrap_gp_list_get_value, METH_VARARGS, "\n"
-		"gp_list_get_value(list, index) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"list: gphoto2.CameraList\n"
-		"index: int\n"
-		"\n"
-		"Retrieves the value of entry with `index`.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `list` :  \n"
-		"    a CameraList  \n"
-		"* `index` :  \n"
-		"    index of the entry  \n"
-		"* `value` :  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code\n"
-		"\n"
-		"See also gphoto2.CameraList.get_value\n"
-		""},
-	 { "gp_list_set_name", _wrap_gp_list_set_name, METH_VARARGS, "\n"
-		"gp_list_set_name(list, index, name) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"list: gphoto2.CameraList\n"
-		"index: int\n"
-		"name: str\n"
-		"\n"
-		"Sets the name of an entry.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `list` :  \n"
-		"    a CameraList  \n"
-		"* `index` :  \n"
-		"    index of entry  \n"
-		"* `name` :  \n"
-		"    name to be set  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code\n"
-		"\n"
-		"See also gphoto2.CameraList.set_name\n"
-		""},
-	 { "gp_list_set_value", _wrap_gp_list_set_value, METH_VARARGS, "\n"
-		"gp_list_set_value(list, index, value) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"list: gphoto2.CameraList\n"
-		"index: int\n"
-		"value: str\n"
-		"\n"
-		"Sets the `value` of an entry.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `list` :  \n"
-		"    a CameraList  \n"
-		"* `index` :  \n"
-		"    index of the entry  \n"
-		"* `value` :  \n"
-		"    the value to be set  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code\n"
-		"\n"
-		"See also gphoto2.CameraList.set_value\n"
-		""},
-	 { "gp_list_populate", _wrap_gp_list_populate, METH_VARARGS, "\n"
-		"gp_list_populate(list, format, count) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"list: gphoto2.CameraList\n"
-		"format: str\n"
-		"count: int\n"
-		"\n"
-		"Adds `count` entries to the list.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `list` :  \n"
-		"    a CameraList  \n"
-		"* `format` :  \n"
-		"    the format  \n"
-		"* `count` :  \n"
-		"    number of entries to be added to the list return a gphoto2 error\n"
-		"    code  \n"
-		"\n"
-		"Typically, this function is called by a camera driver when there is no\n"
-		"way of retrieving the real name of a picture. In this case, when asked\n"
-		"for a file list (see #CameraFilesystemListFunc), the list is populated\n"
-		"with dummy names generated by this function.\n"
-		"\n"
-		"See also gphoto2.CameraList.populate\n"
-		""},
-	 { NULL, NULL, 0, NULL }
-};
-
-static PyMethodDef SwigMethods_proxydocs[] = {
-	 { "SWIG_PyInstanceMethod_New", SWIG_PyInstanceMethod_New, METH_O, NULL},
-	 { "SWIG_PyStaticMethod_New", SWIG_PyStaticMethod_New, METH_O, NULL},
 	 { "gp_list_new", _wrap_gp_list_new, METH_VARARGS, "\n"
 		"gp_list_new() -> int\n"
 		"Creates a new CameraList.  \n"
 		"\n"
 		"Parameters\n"
 		"----------\n"
 		"* `list` :  \n"
@@ -5700,15 +5782,19 @@
     PyObject_HEAD_INIT(NULL)
     0,                                        /* ob_size */
 #endif
     "gphoto2.list.CameraList",                /* tp_name */
     sizeof(SwigPyObject),                     /* tp_basicsize */
     0,                                        /* tp_itemsize */
     _wrap_delete_CameraList_destructor_closure,                   /* tp_dealloc */
+#if PY_VERSION_HEX < 0x030800b4
     (printfunc) 0,                            /* tp_print */
+#else
+    (Py_ssize_t) 0,                           /* tp_vectorcall_offset */
+#endif
     (getattrfunc) 0,                          /* tp_getattr */
     (setattrfunc) 0,                          /* tp_setattr */
 #if PY_VERSION_HEX >= 0x03000000
     0,                                        /* tp_compare */
 #else
     (cmpfunc) 0,                              /* tp_compare */
 #endif
@@ -5772,14 +5858,17 @@
 #endif
   },
 #if PY_VERSION_HEX >= 0x03050000
   {
     (unaryfunc) 0,                            /* am_await */
     (unaryfunc) 0,                            /* am_aiter */
     (unaryfunc) 0,                            /* am_anext */
+# if PY_VERSION_HEX >= 0x030a0000
+    (sendfunc) 0,                             /* am_send */
+# endif
   },
 #endif
   {
     (binaryfunc) 0,                           /* nb_add */
     (binaryfunc) 0,                           /* nb_subtract */
     (binaryfunc) 0,                           /* nb_multiply */
 #if PY_VERSION_HEX < 0x03000000
@@ -5872,77 +5961,86 @@
   },
     (PyObject *) 0,                           /* ht_name */
     (PyObject *) 0,                           /* ht_slots */
 #if PY_VERSION_HEX >= 0x03030000
     (PyObject *) 0,                           /* ht_qualname */
     0,                                        /* ht_cached_keys */
 #endif
+#if PY_VERSION_HEX >= 0x03090000
+    (PyObject *) 0,                           /* ht_module */
+#endif
+#if PY_VERSION_HEX >= 0x030b0000
+    (char *) 0,                               /* _ht_tpname */
+  {
+    (PyObject *) 0,                           /* getitem */
+  }
+#endif
 };
 
 SWIGINTERN SwigPyClientData SwigPyBuiltin___CameraList_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin___CameraList_type};
 
 
 /* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */
 
 static swig_type_info _swigt__p_CameraAbilities = {"_p_CameraAbilities", "CameraAbilities *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraCaptureType = {"_p_CameraCaptureType", "enum CameraCaptureType *|CameraCaptureType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraDriverStatus = {"_p_CameraDriverStatus", "enum CameraDriverStatus *|CameraDriverStatus *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraEventType = {"_p_CameraEventType", "enum CameraEventType *|CameraEventType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileAccessType = {"_p_CameraFileAccessType", "enum CameraFileAccessType *|CameraFileAccessType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileInfoFields = {"_p_CameraFileInfoFields", "enum CameraFileInfoFields *|CameraFileInfoFields *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileOperation = {"_p_CameraFileOperation", "enum CameraFileOperation *|CameraFileOperation *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraCaptureType = {"_p_CameraCaptureType", "CameraCaptureType *|enum CameraCaptureType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraDriverStatus = {"_p_CameraDriverStatus", "CameraDriverStatus *|enum CameraDriverStatus *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraEventType = {"_p_CameraEventType", "CameraEventType *|enum CameraEventType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileAccessType = {"_p_CameraFileAccessType", "CameraFileAccessType *|enum CameraFileAccessType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileInfoFields = {"_p_CameraFileInfoFields", "CameraFileInfoFields *|enum CameraFileInfoFields *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileOperation = {"_p_CameraFileOperation", "CameraFileOperation *|enum CameraFileOperation *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_CameraFilePath = {"_p_CameraFilePath", "CameraFilePath *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFilePermissions = {"_p_CameraFilePermissions", "enum CameraFilePermissions *|CameraFilePermissions *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileStatus = {"_p_CameraFileStatus", "enum CameraFileStatus *|CameraFileStatus *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileType = {"_p_CameraFileType", "enum CameraFileType *|CameraFileType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFolderOperation = {"_p_CameraFolderOperation", "enum CameraFolderOperation *|CameraFolderOperation *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraOperation = {"_p_CameraOperation", "enum CameraOperation *|CameraOperation *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraStorageAccessType = {"_p_CameraStorageAccessType", "enum CameraStorageAccessType *|CameraStorageAccessType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraStorageFilesystemType = {"_p_CameraStorageFilesystemType", "enum CameraStorageFilesystemType *|CameraStorageFilesystemType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraStorageInfoFields = {"_p_CameraStorageInfoFields", "enum CameraStorageInfoFields *|CameraStorageInfoFields *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraStorageType = {"_p_CameraStorageType", "enum CameraStorageType *|CameraStorageType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFilePermissions = {"_p_CameraFilePermissions", "CameraFilePermissions *|enum CameraFilePermissions *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileStatus = {"_p_CameraFileStatus", "CameraFileStatus *|enum CameraFileStatus *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileType = {"_p_CameraFileType", "CameraFileType *|enum CameraFileType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFolderOperation = {"_p_CameraFolderOperation", "CameraFolderOperation *|enum CameraFolderOperation *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraOperation = {"_p_CameraOperation", "CameraOperation *|enum CameraOperation *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraStorageAccessType = {"_p_CameraStorageAccessType", "CameraStorageAccessType *|enum CameraStorageAccessType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraStorageFilesystemType = {"_p_CameraStorageFilesystemType", "CameraStorageFilesystemType *|enum CameraStorageFilesystemType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraStorageInfoFields = {"_p_CameraStorageInfoFields", "CameraStorageInfoFields *|enum CameraStorageInfoFields *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraStorageType = {"_p_CameraStorageType", "CameraStorageType *|enum CameraStorageType *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_CameraText = {"_p_CameraText", "CameraText *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraWidgetType = {"_p_CameraWidgetType", "enum CameraWidgetType *|CameraWidgetType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_GPLogLevel = {"_p_GPLogLevel", "enum GPLogLevel *|GPLogLevel *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_GPPortType = {"_p_GPPortType", "enum GPPortType *|GPPortType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_GPVersionVerbosity = {"_p_GPVersionVerbosity", "enum GPVersionVerbosity *|GPVersionVerbosity *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_GphotoDeviceType = {"_p_GphotoDeviceType", "enum GphotoDeviceType *|GphotoDeviceType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraWidgetType = {"_p_CameraWidgetType", "CameraWidgetType *|enum CameraWidgetType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GPLogLevel = {"_p_GPLogLevel", "GPLogLevel *|enum GPLogLevel *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GPPortType = {"_p_GPPortType", "GPPortType *|enum GPPortType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GPVersionVerbosity = {"_p_GPVersionVerbosity", "GPVersionVerbosity *|enum GPVersionVerbosity *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GphotoDeviceType = {"_p_GphotoDeviceType", "GphotoDeviceType *|enum GphotoDeviceType *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_SwigPyObject = {"_p_SwigPyObject", "SwigPyObject *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__Camera = {"_p__Camera", "struct _Camera *|Camera *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraAbilitiesList = {"_p__CameraAbilitiesList", "struct _CameraAbilitiesList *|CameraAbilitiesList *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFile = {"_p__CameraFile", "struct _CameraFile *|CameraFile *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFileHandler = {"_p__CameraFileHandler", "struct _CameraFileHandler *|CameraFileHandler *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFileInfo = {"_p__CameraFileInfo", "struct _CameraFileInfo *|CameraFileInfo *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFileInfoAudio = {"_p__CameraFileInfoAudio", "struct _CameraFileInfoAudio *|CameraFileInfoAudio *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFileInfoFile = {"_p__CameraFileInfoFile", "struct _CameraFileInfoFile *|CameraFileInfoFile *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFileInfoPreview = {"_p__CameraFileInfoPreview", "struct _CameraFileInfoPreview *|CameraFileInfoPreview *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFilesystem = {"_p__CameraFilesystem", "struct _CameraFilesystem *|CameraFilesystem *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFilesystemFuncs = {"_p__CameraFilesystemFuncs", "struct _CameraFilesystemFuncs *|CameraFilesystemFuncs *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFunctions = {"_p__CameraFunctions", "struct _CameraFunctions *|CameraFunctions *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraList = {"_p__CameraList", "struct _CameraList *|_CameraList *|CameraList *", 0, 0, (void*)&SwigPyBuiltin___CameraList_clientdata, 0};
-static swig_type_info _swigt__p__CameraPrivateCore = {"_p__CameraPrivateCore", "struct _CameraPrivateCore *|CameraPrivateCore *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraPrivateLibrary = {"_p__CameraPrivateLibrary", "struct _CameraPrivateLibrary *|CameraPrivateLibrary *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraStorageInformation = {"_p__CameraStorageInformation", "struct _CameraStorageInformation *|CameraStorageInformation *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraWidget = {"_p__CameraWidget", "struct _CameraWidget *|CameraWidget *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__GPContext = {"_p__GPContext", "struct _GPContext *|GPContext *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__GPContextFeedback = {"_p__GPContextFeedback", "enum _GPContextFeedback *|GPContextFeedback *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__Camera = {"_p__Camera", "Camera *|struct _Camera *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraAbilitiesList = {"_p__CameraAbilitiesList", "CameraAbilitiesList *|struct _CameraAbilitiesList *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFile = {"_p__CameraFile", "CameraFile *|struct _CameraFile *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFileHandler = {"_p__CameraFileHandler", "CameraFileHandler *|struct _CameraFileHandler *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFileInfo = {"_p__CameraFileInfo", "CameraFileInfo *|struct _CameraFileInfo *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFileInfoAudio = {"_p__CameraFileInfoAudio", "CameraFileInfoAudio *|struct _CameraFileInfoAudio *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFileInfoFile = {"_p__CameraFileInfoFile", "CameraFileInfoFile *|struct _CameraFileInfoFile *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFileInfoPreview = {"_p__CameraFileInfoPreview", "CameraFileInfoPreview *|struct _CameraFileInfoPreview *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFilesystem = {"_p__CameraFilesystem", "CameraFilesystem *|struct _CameraFilesystem *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFilesystemFuncs = {"_p__CameraFilesystemFuncs", "CameraFilesystemFuncs *|struct _CameraFilesystemFuncs *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFunctions = {"_p__CameraFunctions", "CameraFunctions *|struct _CameraFunctions *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraList = {"_p__CameraList", "CameraList *|struct _CameraList *|_CameraList *", 0, 0, (void*)&SwigPyBuiltin___CameraList_clientdata, 0};
+static swig_type_info _swigt__p__CameraPrivateCore = {"_p__CameraPrivateCore", "CameraPrivateCore *|struct _CameraPrivateCore *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraPrivateLibrary = {"_p__CameraPrivateLibrary", "CameraPrivateLibrary *|struct _CameraPrivateLibrary *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraStorageInformation = {"_p__CameraStorageInformation", "CameraStorageInformation *|struct _CameraStorageInformation *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraWidget = {"_p__CameraWidget", "CameraWidget *|struct _CameraWidget *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__GPContext = {"_p__GPContext", "GPContext *|struct _GPContext *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__GPContextFeedback = {"_p__GPContextFeedback", "GPContextFeedback *|enum _GPContextFeedback *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p__GPPortInfo = {"_p__GPPortInfo", "_GPPortInfo *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__GPPortInfoList = {"_p__GPPortInfoList", "struct _GPPortInfoList *|GPPortInfoList *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__GPPortInfoList = {"_p__GPPortInfoList", "GPPortInfoList *|struct _GPPortInfoList *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_int = {"_p_int", "intptr_t *|int *|int_least32_t *|int_fast32_t *|int32_t *|int_fast16_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_long = {"_p_long", "long *|time_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_long_long = {"_p_long_long", "int_least64_t *|int_fast64_t *|int64_t *|long long *|intmax_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_p__CameraList = {"_p_p__CameraList", "struct _CameraList **|CameraList **", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_int = {"_p_int", "int32_t *|int_fast16_t *|int_fast32_t *|int_least32_t *|intptr_t *|int *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_long = {"_p_long", "time_t *|long *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_long_long = {"_p_long_long", "int64_t *|int_fast64_t *|int_least64_t *|intmax_t *|long long *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_p__CameraList = {"_p_p__CameraList", "CameraList **|struct _CameraList **", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_p_char = {"_p_p_char", "char **", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_short = {"_p_short", "short *|int_least16_t *|int16_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_signed_char = {"_p_signed_char", "signed char *|int_least8_t *|int_fast8_t *|int8_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_unsigned_char = {"_p_unsigned_char", "unsigned char *|uint_least8_t *|uint_fast8_t *|uint8_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_unsigned_int = {"_p_unsigned_int", "uintptr_t *|uint_least32_t *|uint_fast32_t *|uint32_t *|unsigned int *|uint_fast16_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_unsigned_long_long = {"_p_unsigned_long_long", "uint_least64_t *|uint_fast64_t *|uint64_t *|unsigned long long *|uintmax_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_unsigned_short = {"_p_unsigned_short", "unsigned short *|uint_least16_t *|uint16_t *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_short = {"_p_short", "int16_t *|int_least16_t *|short *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_signed_char = {"_p_signed_char", "int8_t *|int_fast8_t *|int_least8_t *|signed char *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_unsigned_char = {"_p_unsigned_char", "uint8_t *|uint_fast8_t *|uint_least8_t *|unsigned char *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_unsigned_int = {"_p_unsigned_int", "uint32_t *|uint_fast16_t *|uint_fast32_t *|uint_least32_t *|uintptr_t *|unsigned int *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_unsigned_long_long = {"_p_unsigned_long_long", "uint64_t *|uint_fast64_t *|uint_least64_t *|uintmax_t *|unsigned long long *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_unsigned_short = {"_p_unsigned_short", "uint16_t *|uint_least16_t *|unsigned short *", 0, 0, (void*)0, 0};
 
 static swig_type_info *swig_type_initial[] = {
   &_swigt__p_CameraAbilities,
   &_swigt__p_CameraCaptureType,
   &_swigt__p_CameraDriverStatus,
   &_swigt__p_CameraEventType,
   &_swigt__p_CameraFileAccessType,
@@ -6174,17 +6272,20 @@
 #endif
 #endif
 
 #if 0
 #define SWIGRUNTIME_DEBUG
 #endif
 
+#ifndef SWIG_INIT_CLIENT_DATA_TYPE
+#define SWIG_INIT_CLIENT_DATA_TYPE void *
+#endif
 
 SWIGRUNTIME void
-SWIG_InitializeModule(void *clientdata) {
+SWIG_InitializeModule(SWIG_INIT_CLIENT_DATA_TYPE clientdata) {
   size_t i;
   swig_module_info *module_head, *iter;
   int init;
   
   /* check to see if the circular list has been setup, if not, set it up */
   if (swig_module.next==0) {
     /* Initialize the swig_module */
@@ -6359,228 +6460,14 @@
 
 
 
 #ifdef __cplusplus
 extern "C" {
 #endif
   
-  /* Python-specific SWIG API */
-#define SWIG_newvarlink()                             SWIG_Python_newvarlink()
-#define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
-#define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)
-  
-  /* -----------------------------------------------------------------------------
-   * global variable support code.
-   * ----------------------------------------------------------------------------- */
-  
-  typedef struct swig_globalvar {
-    char       *name;                  /* Name of global variable */
-    PyObject *(*get_attr)(void);       /* Return the current value */
-    int       (*set_attr)(PyObject *); /* Set the value */
-    struct swig_globalvar *next;
-  } swig_globalvar;
-  
-  typedef struct swig_varlinkobject {
-    PyObject_HEAD
-    swig_globalvar *vars;
-  } swig_varlinkobject;
-  
-  SWIGINTERN PyObject *
-  swig_varlink_repr(swig_varlinkobject *SWIGUNUSEDPARM(v)) {
-#if PY_VERSION_HEX >= 0x03000000
-    return PyUnicode_InternFromString("<Swig global variables>");
-#else
-    return PyString_FromString("<Swig global variables>");
-#endif
-  }
-  
-  SWIGINTERN PyObject *
-  swig_varlink_str(swig_varlinkobject *v) {
-#if PY_VERSION_HEX >= 0x03000000
-    PyObject *str = PyUnicode_InternFromString("(");
-    PyObject *tail;
-    PyObject *joined;
-    swig_globalvar *var;
-    for (var = v->vars; var; var=var->next) {
-      tail = PyUnicode_FromString(var->name);
-      joined = PyUnicode_Concat(str, tail);
-      Py_DecRef(str);
-      Py_DecRef(tail);
-      str = joined;
-      if (var->next) {
-        tail = PyUnicode_InternFromString(", ");
-        joined = PyUnicode_Concat(str, tail);
-        Py_DecRef(str);
-        Py_DecRef(tail);
-        str = joined;
-      }
-    }
-    tail = PyUnicode_InternFromString(")");
-    joined = PyUnicode_Concat(str, tail);
-    Py_DecRef(str);
-    Py_DecRef(tail);
-    str = joined;
-#else
-    PyObject *str = PyString_FromString("(");
-    swig_globalvar *var;
-    for (var = v->vars; var; var=var->next) {
-      PyString_ConcatAndDel(&str,PyString_FromString(var->name));
-      if (var->next) PyString_ConcatAndDel(&str,PyString_FromString(", "));
-    }
-    PyString_ConcatAndDel(&str,PyString_FromString(")"));
-#endif
-    return str;
-  }
-  
-  SWIGINTERN void
-  swig_varlink_dealloc(swig_varlinkobject *v) {
-    swig_globalvar *var = v->vars;
-    while (var) {
-      swig_globalvar *n = var->next;
-      free(var->name);
-      free(var);
-      var = n;
-    }
-  }
-  
-  SWIGINTERN PyObject *
-  swig_varlink_getattr(swig_varlinkobject *v, char *n) {
-    PyObject *res = NULL;
-    swig_globalvar *var = v->vars;
-    while (var) {
-      if (strcmp(var->name,n) == 0) {
-        res = (*var->get_attr)();
-        break;
-      }
-      var = var->next;
-    }
-    if (res == NULL && !PyErr_Occurred()) {
-      PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
-    }
-    return res;
-  }
-  
-  SWIGINTERN int
-  swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
-    int res = 1;
-    swig_globalvar *var = v->vars;
-    while (var) {
-      if (strcmp(var->name,n) == 0) {
-        res = (*var->set_attr)(p);
-        break;
-      }
-      var = var->next;
-    }
-    if (res == 1 && !PyErr_Occurred()) {
-      PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
-    }
-    return res;
-  }
-  
-  SWIGINTERN PyTypeObject*
-  swig_varlink_type(void) {
-    static char varlink__doc__[] = "Swig var link object";
-    static PyTypeObject varlink_type;
-    static int type_init = 0;
-    if (!type_init) {
-      const PyTypeObject tmp = {
-#if PY_VERSION_HEX >= 0x03000000
-        PyVarObject_HEAD_INIT(NULL, 0)
-#else
-        PyObject_HEAD_INIT(NULL)
-        0,                                  /* ob_size */
-#endif
-        "swigvarlink",                      /* tp_name */
-        sizeof(swig_varlinkobject),         /* tp_basicsize */
-        0,                                  /* tp_itemsize */
-        (destructor) swig_varlink_dealloc,  /* tp_dealloc */
-        0,                                  /* tp_print */
-        (getattrfunc) swig_varlink_getattr, /* tp_getattr */
-        (setattrfunc) swig_varlink_setattr, /* tp_setattr */
-        0,                                  /* tp_compare */
-        (reprfunc) swig_varlink_repr,       /* tp_repr */
-        0,                                  /* tp_as_number */
-        0,                                  /* tp_as_sequence */
-        0,                                  /* tp_as_mapping */
-        0,                                  /* tp_hash */
-        0,                                  /* tp_call */
-        (reprfunc) swig_varlink_str,        /* tp_str */
-        0,                                  /* tp_getattro */
-        0,                                  /* tp_setattro */
-        0,                                  /* tp_as_buffer */
-        0,                                  /* tp_flags */
-        varlink__doc__,                     /* tp_doc */
-        0,                                  /* tp_traverse */
-        0,                                  /* tp_clear */
-        0,                                  /* tp_richcompare */
-        0,                                  /* tp_weaklistoffset */
-        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
-        0,                                  /* tp_del */
-        0,                                  /* tp_version_tag */
-#if PY_VERSION_HEX >= 0x03040000
-        0,                                  /* tp_finalize */
-#endif
-#if PY_VERSION_HEX >= 0x03080000
-        0,                                  /* tp_vectorcall */
-#endif
-#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
-        0,                                  /* tp_print */
-#endif
-#ifdef COUNT_ALLOCS
-        0,                                  /* tp_allocs */
-        0,                                  /* tp_frees */
-        0,                                  /* tp_maxalloc */
-        0,                                  /* tp_prev */
-        0                                   /* tp_next */
-#endif
-      };
-      varlink_type = tmp;
-      type_init = 1;
-      if (PyType_Ready(&varlink_type) < 0)
-      return NULL;
-    }
-    return &varlink_type;
-  }
-  
-  /* Create a variable linking object for use later */
-  SWIGINTERN PyObject *
-  SWIG_Python_newvarlink(void) {
-    swig_varlinkobject *result = PyObject_NEW(swig_varlinkobject, swig_varlink_type());
-    if (result) {
-      result->vars = 0;
-    }
-    return ((PyObject*) result);
-  }
-  
-  SWIGINTERN void 
-  SWIG_Python_addvarlink(PyObject *p, const char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
-    swig_varlinkobject *v = (swig_varlinkobject *) p;
-    swig_globalvar *gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
-    if (gv) {
-      size_t size = strlen(name)+1;
-      gv->name = (char *)malloc(size);
-      if (gv->name) {
-        memcpy(gv->name, name, size);
-        gv->get_attr = get_attr;
-        gv->set_attr = set_attr;
-        gv->next = v->vars;
-      }
-    }
-    v->vars = gv;
-  }
-  
-  SWIGINTERN PyObject *
-  SWIG_globals(void) {
-    static PyObject *globals = 0;
-    if (!globals) {
-      globals = SWIG_newvarlink();
-    }
-    return globals;
-  }
-  
   /* -----------------------------------------------------------------------------
    * constants/methods manipulation
    * ----------------------------------------------------------------------------- */
   
   /* Install Constants */
   SWIGINTERN void
   SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
@@ -6601,31 +6488,28 @@
       if (obj) {
         PyDict_SetItemString(d, constants[i].name, obj);
         Py_DECREF(obj);
       }
     }
   }
   
-  /* -----------------------------------------------------------------------------*/
-  /* Fix SwigMethods to carry the callback ptrs when needed */
-  /* -----------------------------------------------------------------------------*/
+  /* -----------------------------------------------------------------------------
+   * Patch %callback methods' docstrings to hold the callback ptrs
+   * -----------------------------------------------------------------------------*/
   
   SWIGINTERN void
-  SWIG_Python_FixMethods(PyMethodDef *methods,
-    swig_const_info *const_table,
-    swig_type_info **types,
-    swig_type_info **types_initial) {
+  SWIG_Python_FixMethods(PyMethodDef *methods, const swig_const_info *const_table, swig_type_info **types, swig_type_info **types_initial) {
     size_t i;
     for (i = 0; methods[i].ml_name; ++i) {
       const char *c = methods[i].ml_doc;
       if (!c) continue;
       c = strstr(c, "swig_ptr: ");
       if (c) {
         int j;
-        swig_const_info *ci = 0;
+        const swig_const_info *ci = 0;
         const char *name = c + 10;
         for (j = 0; const_table[j].type; ++j) {
           if (strncmp(const_table[j].name, name, 
               strlen(const_table[j].name)) == 0) {
             ci = &(const_table[j]);
             break;
           }
@@ -6649,76 +6533,21 @@
             }
           }
         }
       }
     }
   } 
   
-  /* -----------------------------------------------------------------------------
-   * Method creation and docstring support functions
-   * ----------------------------------------------------------------------------- */
-  
-  /* -----------------------------------------------------------------------------
-   * Function to find the method definition with the correct docstring for the
-   * proxy module as opposed to the low-level API
-   * ----------------------------------------------------------------------------- */
-  
-  SWIGINTERN PyMethodDef *SWIG_PythonGetProxyDoc(const char *name) {
-    /* Find the function in the modified method table */
-    size_t offset = 0;
-    int found = 0;
-    while (SwigMethods_proxydocs[offset].ml_meth != NULL) {
-      if (strcmp(SwigMethods_proxydocs[offset].ml_name, name) == 0) {
-        found = 1;
-        break;
-      }
-      offset++;
-    }
-    /* Use the copy with the modified docstring if available */
-    return found ? &SwigMethods_proxydocs[offset] : NULL;
-  }
-  
-  /* -----------------------------------------------------------------------------
-   * Wrapper of PyInstanceMethod_New() used in Python 3
-   * It is exported to the generated module, used for -fastproxy
-   * ----------------------------------------------------------------------------- */
-  
-  SWIGINTERN PyObject *SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func) {
-    if (PyCFunction_Check(func)) {
-      PyCFunctionObject *funcobj = (PyCFunctionObject *)func;
-      PyMethodDef *ml = SWIG_PythonGetProxyDoc(funcobj->m_ml->ml_name);
-      if (ml)
-      func = PyCFunction_NewEx(ml, funcobj->m_self, funcobj->m_module);
-    }
-#if PY_VERSION_HEX >= 0x03000000
-    return PyInstanceMethod_New(func);
-#else
-    return PyMethod_New(func, NULL, NULL);
-#endif
-  }
-  
-  /* -----------------------------------------------------------------------------
-   * Wrapper of PyStaticMethod_New()
-   * It is exported to the generated module, used for -fastproxy
-   * ----------------------------------------------------------------------------- */
-  
-  SWIGINTERN PyObject *SWIG_PyStaticMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func) {
-    if (PyCFunction_Check(func)) {
-      PyCFunctionObject *funcobj = (PyCFunctionObject *)func;
-      PyMethodDef *ml = SWIG_PythonGetProxyDoc(funcobj->m_ml->ml_name);
-      if (ml)
-      func = PyCFunction_NewEx(ml, funcobj->m_self, funcobj->m_module);
-    }
-    return PyStaticMethod_New(func);
-  }
-  
 #ifdef __cplusplus
 }
 #endif
 
+
+
+
 /* -----------------------------------------------------------------------------*
  *  Partial Init method
  * -----------------------------------------------------------------------------*/
 
 #ifdef __cplusplus
 extern "C"
 #endif
```

### Comparing `gphoto2-2.3.4/src/swig-gp2.5.30/port_info_list_wrap.c` & `gphoto2-2.3.5/src/swig-gp2_5_30/port_info_list_wrap.c`

 * *Files 2% similar despite different names*

```diff
@@ -1,24 +1,21 @@
 /* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 4.0.2
+ * This file was automatically generated by SWIG (https://www.swig.org).
+ * Version 4.1.1
  *
- * This file is not intended to be easily readable and contains a number of
- * coding conventions designed to improve portability and efficiency. Do not make
- * changes to this file unless you know what you are doing--modify the SWIG
- * interface file instead.
+ * Do not make changes to this file unless you know what you are doing - modify
+ * the SWIG interface file instead.
  * ----------------------------------------------------------------------------- */
 
 
-#ifndef SWIGPYTHON
+#define SWIG_VERSION 0x040101
 #define SWIGPYTHON
-#endif
-
 #define SWIG_PYTHON_DIRECTOR_NO_VTABLE
 #define SWIGPYTHON_BUILTIN
+#define SWIGPYTHON_FASTPROXY
 
 /* -----------------------------------------------------------------------------
  *  This section contains generic SWIG labels for method/variable
  *  declarations/attributes, and other compiler dependent labels.
  * ----------------------------------------------------------------------------- */
 
 /* template workaround for compilers that cannot correctly implement the C++ standard */
@@ -142,23 +139,45 @@
 
 
 #if defined(__GNUC__) && defined(_WIN32) && !defined(SWIG_PYTHON_NO_HYPOT_WORKAROUND)
 /* Workaround for '::hypot' has not been declared', see https://bugs.python.org/issue11566 */
 # include <math.h>
 #endif
 
+#if !defined(PY_SSIZE_T_CLEAN) && !defined(SWIG_NO_PY_SSIZE_T_CLEAN)
+#define PY_SSIZE_T_CLEAN
+#endif
+
+#if __GNUC__ >= 7
+#pragma GCC diagnostic push
+#if defined(__cplusplus) && __cplusplus >=201703L
+#pragma GCC diagnostic ignored "-Wregister" /* For python-2.7 headers that use register */
+#endif
+#endif
+
 #if defined(_DEBUG) && defined(SWIG_PYTHON_INTERPRETER_NO_DEBUG)
 /* Use debug wrappers with the Python release dll */
+
+#if defined(_MSC_VER) && _MSC_VER >= 1929
+/* Workaround compilation errors when redefining _DEBUG in MSVC 2019 version 16.10 and later
+ * See https://github.com/swig/swig/issues/2090 */
+# include <corecrt.h>
+#endif
+
 # undef _DEBUG
 # include <Python.h>
 # define _DEBUG 1
 #else
 # include <Python.h>
 #endif
 
+#if __GNUC__ >= 7
+#pragma GCC diagnostic pop
+#endif
+
 /* -----------------------------------------------------------------------------
  * swigrun.swg
  *
  * This file contains generic C API SWIG runtime support for pointer
  * type checking.
  * ----------------------------------------------------------------------------- */
 
@@ -197,14 +216,16 @@
 # define SWIG_BUFFER_SIZE 1024
 #endif
 
 /* Flags for pointer conversions */
 #define SWIG_POINTER_DISOWN        0x1
 #define SWIG_CAST_NEW_MEMORY       0x2
 #define SWIG_POINTER_NO_NULL       0x4
+#define SWIG_POINTER_CLEAR         0x8
+#define SWIG_POINTER_RELEASE       (SWIG_POINTER_CLEAR | SWIG_POINTER_DISOWN)
 
 /* Flags for new pointer objects */
 #define SWIG_POINTER_OWN           0x1
 
 
 /*
    Flags/methods for returning states.
@@ -268,44 +289,50 @@
       }
 
    Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
    more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
    SWIG errors code.
 
    Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
-   allows to return the 'cast rank', for example, if you have this
+   allows returning the 'cast rank', for example, if you have this
 
        int food(double)
        int fooi(int);
 
    and you call
 
       food(1)   // cast rank '1'  (1 -> 1.0)
       fooi(1)   // cast rank '0'
 
    just use the SWIG_AddCast()/SWIG_CheckState()
 */
 
 #define SWIG_OK                    (0)
+/* Runtime errors are < 0 */
 #define SWIG_ERROR                 (-1)
+/* Errors in range -1 to -99 are in swigerrors.swg (errors for all languages including those not using the runtime) */
+/* Errors in range -100 to -199 are language specific errors defined in *errors.swg */
+/* Errors < -200 are generic runtime specific errors */
+#define SWIG_ERROR_RELEASE_NOT_OWNED (-200)
+
 #define SWIG_IsOK(r)               (r >= 0)
 #define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)
 
 /* The CastRankLimit says how many bits are used for the cast rank */
 #define SWIG_CASTRANKLIMIT         (1 << 8)
 /* The NewMask denotes the object was created (using new/malloc) */
 #define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
 /* The TmpMask is for in/out typemaps that use temporal objects */
 #define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
 /* Simple returning values */
 #define SWIG_BADOBJ                (SWIG_ERROR)
 #define SWIG_OLDOBJ                (SWIG_OK)
 #define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
 #define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
-/* Check, add and del mask methods */
+/* Check, add and del object mask methods */
 #define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
 #define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
 #define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
 #define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
 #define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
 #define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))
 
@@ -443,15 +470,15 @@
   return 0;
 }
 
 /*
   Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
 */
 SWIGRUNTIME swig_cast_info *
-SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty) {
+SWIG_TypeCheckStruct(const swig_type_info *from, swig_type_info *ty) {
   if (ty) {
     swig_cast_info *iter = ty->cast;
     while (iter) {
       if (iter->type == from) {
         if (iter == ty->cast)
           return iter;
         /* Move iter to the top of the linked list */
@@ -503,17 +530,17 @@
 /*
   Return the pretty name associated with this type,
   that is an unmangled type name in a form presentable to the user.
 */
 SWIGRUNTIME const char *
 SWIG_TypePrettyName(const swig_type_info *type) {
   /* The "str" field contains the equivalent pretty names of the
-     type, separated by vertical-bar characters.  We choose
-     to print the last name, as it is often (?) the most
-     specific. */
+     type, separated by vertical-bar characters.  Choose the last
+     name. It should be the most specific; a fully resolved name
+     but not necessarily with default template parameters expanded. */
   if (!type) return NULL;
   if (type->str != NULL) {
     const char *last_name = type->str;
     const char *s;
     for (s = type->str; *s; s++)
       if (*s == '|') last_name = s+1;
     return last_name;
@@ -725,15 +752,15 @@
   return SWIG_UnpackData(++c,ptr,sz);
 }
 
 #ifdef __cplusplus
 }
 #endif
 
-/*  Errors in SWIG */
+/* SWIG Errors applicable to all language modules, values are reserved from -1 to -99 */
 #define  SWIG_UnknownError    	   -1
 #define  SWIG_IOError        	   -2
 #define  SWIG_RuntimeError   	   -3
 #define  SWIG_IndexError     	   -4
 #define  SWIG_TypeError      	   -5
 #define  SWIG_DivisionByZero 	   -6
 #define  SWIG_OverflowError  	   -7
@@ -741,15 +768,14 @@
 #define  SWIG_ValueError     	   -9
 #define  SWIG_SystemError    	   -10
 #define  SWIG_AttributeError 	   -11
 #define  SWIG_MemoryError    	   -12
 #define  SWIG_NullReferenceError   -13
 
 
-
 /* Compatibility macros for Python 3 */
 #if PY_VERSION_HEX >= 0x03000000
 
 #define PyClass_Check(obj) PyObject_IsInstance(obj, (PyObject *)&PyType_Type)
 #define PyInt_Check(x) PyLong_Check(x)
 #define PyInt_AsLong(x) PyLong_AsLong(x)
 #define PyInt_FromLong(x) PyLong_FromLong(x)
@@ -757,15 +783,14 @@
 #define PyString_Check(name) PyBytes_Check(name)
 #define PyString_FromString(x) PyUnicode_FromString(x)
 #define PyString_Format(fmt, args)  PyUnicode_Format(fmt, args)
 #define PyString_AsString(str) PyBytes_AsString(str)
 #define PyString_Size(str) PyBytes_Size(str)	
 #define PyString_InternFromString(key) PyUnicode_InternFromString(key)
 #define Py_TPFLAGS_HAVE_CLASS Py_TPFLAGS_BASETYPE
-#define PyString_AS_STRING(x) PyUnicode_AS_STRING(x)
 #define _PyLong_FromSsize_t(x) PyLong_FromSsize_t(x)
 
 #endif
 
 #ifndef Py_TYPE
 #  define Py_TYPE(op) ((op)->ob_type)
 #endif
@@ -775,46 +800,27 @@
 #if PY_VERSION_HEX >= 0x03000000
 #  define SWIG_Python_str_FromFormat PyUnicode_FromFormat
 #else
 #  define SWIG_Python_str_FromFormat PyString_FromFormat
 #endif
 
 
-/* Warning: This function will allocate a new string in Python 3,
- * so please call SWIG_Python_str_DelForPy3(x) to free the space.
- */
 SWIGINTERN char*
 SWIG_Python_str_AsChar(PyObject *str)
 {
 #if PY_VERSION_HEX >= 0x03030000
   return (char *)PyUnicode_AsUTF8(str);
-#elif PY_VERSION_HEX >= 0x03000000
-  char *newstr = 0;
-  str = PyUnicode_AsUTF8String(str);
-  if (str) {
-    char *cstr;
-    Py_ssize_t len;
-    if (PyBytes_AsStringAndSize(str, &cstr, &len) != -1) {
-      newstr = (char *) malloc(len+1);
-      if (newstr)
-        memcpy(newstr, cstr, len+1);
-    }
-    Py_XDECREF(str);
-  }
-  return newstr;
 #else
   return PyString_AsString(str);
 #endif
 }
 
-#if PY_VERSION_HEX >= 0x03030000 || PY_VERSION_HEX < 0x03000000
-#  define SWIG_Python_str_DelForPy3(x)
-#else
-#  define SWIG_Python_str_DelForPy3(x) free( (void*) (x) )
-#endif
+/* Was useful for Python 3.0.x-3.2.x - now provided only for compatibility
+ * with any uses in user interface files. */
+#define SWIG_Python_str_DelForPy3(x)
 
 
 SWIGINTERN PyObject*
 SWIG_Python_str_FromChar(const char *c)
 {
 #if PY_VERSION_HEX >= 0x03000000
   return PyUnicode_FromString(c); 
@@ -823,18 +829,22 @@
 #endif
 }
 
 #ifndef PyObject_DEL
 # define PyObject_DEL PyObject_Del
 #endif
 
-// SWIGPY_USE_CAPSULE is no longer used within SWIG itself, but some user
-// interface files check for it.
+/* SWIGPY_USE_CAPSULE is no longer used within SWIG itself, but some user interface files check for it. */
 # define SWIGPY_USE_CAPSULE
-# define SWIGPY_CAPSULE_NAME ("swig_runtime_data" SWIG_RUNTIME_VERSION ".type_pointer_capsule" SWIG_TYPE_TABLE_NAME)
+#ifdef SWIGPYTHON_BUILTIN
+# define SWIGPY_CAPSULE_ATTR_NAME "type_pointer_capsule_builtin" SWIG_TYPE_TABLE_NAME
+#else
+# define SWIGPY_CAPSULE_ATTR_NAME "type_pointer_capsule" SWIG_TYPE_TABLE_NAME
+#endif
+# define SWIGPY_CAPSULE_NAME ("swig_runtime_data" SWIG_RUNTIME_VERSION "." SWIGPY_CAPSULE_ATTR_NAME)
 
 #if PY_VERSION_HEX < 0x03020000
 #define PyDescr_TYPE(x) (((PyDescrObject *)(x))->d_type)
 #define PyDescr_NAME(x) (((PyDescrObject *)(x))->d_name)
 #define Py_hash_t long
 #endif
 
@@ -900,15 +910,14 @@
     const char *tmp = SWIG_Python_str_AsChar(old_str);
     PyErr_Clear();
     Py_XINCREF(type);
     if (tmp)
       PyErr_Format(type, "%s %s", tmp, mesg);
     else
       PyErr_Format(type, "%s", mesg);
-    SWIG_Python_str_DelForPy3(tmp);
     Py_DECREF(old_str);
     Py_DECREF(value);
   } else {
     PyErr_SetString(PyExc_RuntimeError, mesg);
   }
 }
 
@@ -931,16 +940,20 @@
     PyObject *type = NULL, *value = NULL, *traceback = NULL;
     PyErr_Fetch(&type, &value, &traceback);
 #if PY_VERSION_HEX >= 0x03000000
     newvalue = PyUnicode_FromFormat("%S\nAdditional information:\n%s", value, message);
 #else
     newvalue = PyString_FromFormat("%s\nAdditional information:\n%s", PyString_AsString(value), message);
 #endif
-    Py_XDECREF(value);
-    PyErr_Restore(type, newvalue, traceback);
+    if (newvalue) {
+      Py_XDECREF(value);
+      PyErr_Restore(type, newvalue, traceback);
+    } else {
+      PyErr_Restore(type, value, traceback);
+    }
   } else {
     /* Raise TypeError using given message */
     PyErr_SetString(PyExc_TypeError, message);
   }
 }
 
 #if defined(SWIG_PYTHON_NO_THREADS)
@@ -949,16 +962,20 @@
 #  endif
 #endif
 #if defined(SWIG_PYTHON_THREADS) /* Threading support is enabled */
 #  if !defined(SWIG_PYTHON_USE_GIL) && !defined(SWIG_PYTHON_NO_USE_GIL)
 #    define SWIG_PYTHON_USE_GIL
 #  endif
 #  if defined(SWIG_PYTHON_USE_GIL) /* Use PyGILState threads calls */
-#    ifndef SWIG_PYTHON_INITIALIZE_THREADS
-#     define SWIG_PYTHON_INITIALIZE_THREADS  PyEval_InitThreads() 
+#    if !defined(SWIG_PYTHON_INITIALIZE_THREADS)
+#      if PY_VERSION_HEX < 0x03070000
+#        define SWIG_PYTHON_INITIALIZE_THREADS PyEval_InitThreads()
+#      else
+#        define SWIG_PYTHON_INITIALIZE_THREADS
+#      endif
 #    endif
 #    ifdef __cplusplus /* C++ code */
        class SWIG_Python_Thread_Block {
          bool status;
          PyGILState_STATE state;
        public:
          void end() { if (status) { PyGILState_Release(state); status = false;} }
@@ -1048,16 +1065,16 @@
  *
  * ----------------------------------------------------------------------------- */
 
 #if PY_VERSION_HEX < 0x02070000 /* 2.7.0 */
 # error "This version of SWIG only supports Python >= 2.7"
 #endif
 
-#if PY_VERSION_HEX >= 0x03000000 && PY_VERSION_HEX < 0x03020000
-# error "This version of SWIG only supports Python 3 >= 3.2"
+#if PY_VERSION_HEX >= 0x03000000 && PY_VERSION_HEX < 0x03030000
+# error "This version of SWIG only supports Python 3 >= 3.3"
 #endif
 
 /* Common SWIG API */
 
 /* for raw pointers */
 #define SWIG_Python_ConvertPtr(obj, pptr, type, flags)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, 0)
 #define SWIG_ConvertPtr(obj, pptr, type, flags)         SWIG_Python_ConvertPtr(obj, pptr, type, flags)
@@ -1164,15 +1181,20 @@
   } else if (result == Py_None) {
     Py_DECREF(result);
     result = obj;
   } else {
     if (!PyList_Check(result)) {
       PyObject *o2 = result;
       result = PyList_New(1);
-      PyList_SetItem(result, 0, o2);
+      if (result) {
+        PyList_SET_ITEM(result, 0, o2);
+      } else {
+        Py_DECREF(obj);
+        return o2;
+      }
     }
     PyList_Append(result,obj);
     Py_DECREF(obj);
   }
   return result;
 }
 
@@ -1246,14 +1268,246 @@
 */
 #ifdef __cplusplus
 #define SWIG_STATIC_POINTER(var)  var
 #else
 #define SWIG_STATIC_POINTER(var)  var = 0; if (!var) var
 #endif
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Python-specific SWIG API */
+#define SWIG_newvarlink()                             SWIG_Python_newvarlink()
+#define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
+#define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)
+ 
+/* -----------------------------------------------------------------------------
+ * global variable support code.
+ * ----------------------------------------------------------------------------- */
+ 
+typedef struct swig_globalvar {   
+  char       *name;                  /* Name of global variable */
+  PyObject *(*get_attr)(void);       /* Return the current value */
+  int       (*set_attr)(PyObject *); /* Set the value */
+  struct swig_globalvar *next;
+} swig_globalvar;
+
+typedef struct swig_varlinkobject {
+  PyObject_HEAD
+  swig_globalvar *vars;
+} swig_varlinkobject;
+
+SWIGINTERN PyObject *
+swig_varlink_repr(PyObject *SWIGUNUSEDPARM(v)) {
+#if PY_VERSION_HEX >= 0x03000000
+  return PyUnicode_InternFromString("<Swig global variables>");
+#else
+  return PyString_FromString("<Swig global variables>");
+#endif
+}
+
+SWIGINTERN PyObject *
+swig_varlink_str(PyObject *o) {
+  swig_varlinkobject *v = (swig_varlinkobject *) o;
+#if PY_VERSION_HEX >= 0x03000000
+  PyObject *str = PyUnicode_InternFromString("(");
+  PyObject *tail;
+  PyObject *joined;
+  swig_globalvar *var;
+  for (var = v->vars; var; var=var->next) {
+    tail = PyUnicode_FromString(var->name);
+    joined = PyUnicode_Concat(str, tail);
+    Py_DecRef(str);
+    Py_DecRef(tail);
+    str = joined;
+    if (var->next) {
+        tail = PyUnicode_InternFromString(", ");
+        joined = PyUnicode_Concat(str, tail);
+        Py_DecRef(str);
+        Py_DecRef(tail);
+        str = joined;
+    }
+  }
+  tail = PyUnicode_InternFromString(")");
+  joined = PyUnicode_Concat(str, tail);
+  Py_DecRef(str);
+  Py_DecRef(tail);
+  str = joined;
+#else
+  PyObject *str = PyString_FromString("(");
+  swig_globalvar *var;
+  for (var = v->vars; var; var=var->next) {
+    PyString_ConcatAndDel(&str,PyString_FromString(var->name));
+    if (var->next) PyString_ConcatAndDel(&str,PyString_FromString(", "));
+  }
+  PyString_ConcatAndDel(&str,PyString_FromString(")"));
+#endif
+  return str;
+}
+
+SWIGINTERN void
+swig_varlink_dealloc(PyObject *o) {
+  swig_varlinkobject *v = (swig_varlinkobject *) o;
+  swig_globalvar *var = v->vars;
+  while (var) {
+    swig_globalvar *n = var->next;
+    free(var->name);
+    free(var);
+    var = n;
+  }
+}
+
+SWIGINTERN PyObject *
+swig_varlink_getattr(PyObject *o, char *n) {
+  swig_varlinkobject *v = (swig_varlinkobject *) o;
+  PyObject *res = NULL;
+  swig_globalvar *var = v->vars;
+  while (var) {
+    if (strcmp(var->name,n) == 0) {
+      res = (*var->get_attr)();
+      break;
+    }
+    var = var->next;
+  }
+  if (res == NULL && !PyErr_Occurred()) {
+    PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
+  }
+  return res;
+}
+
+SWIGINTERN int
+swig_varlink_setattr(PyObject *o, char *n, PyObject *p) {
+  swig_varlinkobject *v = (swig_varlinkobject *) o;
+  int res = 1;
+  swig_globalvar *var = v->vars;
+  while (var) {
+    if (strcmp(var->name,n) == 0) {
+      res = (*var->set_attr)(p);
+      break;
+    }
+    var = var->next;
+  }
+  if (res == 1 && !PyErr_Occurred()) {
+    PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
+  }
+  return res;
+}
+
+SWIGINTERN PyTypeObject*
+swig_varlink_type(void) {
+  static char varlink__doc__[] = "Swig var link object";
+  static PyTypeObject varlink_type;
+  static int type_init = 0;
+  if (!type_init) {
+    const PyTypeObject tmp = {
+#if PY_VERSION_HEX >= 0x03000000
+      PyVarObject_HEAD_INIT(NULL, 0)
+#else
+      PyObject_HEAD_INIT(NULL)
+      0,                                  /* ob_size */
+#endif
+      "swigvarlink",                      /* tp_name */
+      sizeof(swig_varlinkobject),         /* tp_basicsize */
+      0,                                  /* tp_itemsize */
+      (destructor) swig_varlink_dealloc,  /* tp_dealloc */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                       /*tp_print*/
+#else
+      (Py_ssize_t)0,                      /*tp_vectorcall_offset*/
+#endif
+      (getattrfunc) swig_varlink_getattr, /* tp_getattr */
+      (setattrfunc) swig_varlink_setattr, /* tp_setattr */
+      0,                                  /* tp_compare */
+      (reprfunc) swig_varlink_repr,       /* tp_repr */
+      0,                                  /* tp_as_number */
+      0,                                  /* tp_as_sequence */
+      0,                                  /* tp_as_mapping */
+      0,                                  /* tp_hash */
+      0,                                  /* tp_call */
+      (reprfunc) swig_varlink_str,        /* tp_str */
+      0,                                  /* tp_getattro */
+      0,                                  /* tp_setattro */
+      0,                                  /* tp_as_buffer */
+      0,                                  /* tp_flags */
+      varlink__doc__,                     /* tp_doc */
+      0,                                  /* tp_traverse */
+      0,                                  /* tp_clear */
+      0,                                  /* tp_richcompare */
+      0,                                  /* tp_weaklistoffset */
+      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
+      0,                                  /* tp_del */
+      0,                                  /* tp_version_tag */
+#if PY_VERSION_HEX >= 0x03040000
+      0,                                  /* tp_finalize */
+#endif
+#if PY_VERSION_HEX >= 0x03080000
+      0,                                  /* tp_vectorcall */
+#endif
+#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
+      0,                                  /* tp_print */
+#endif
+#ifdef COUNT_ALLOCS
+      0,                                  /* tp_allocs */
+      0,                                  /* tp_frees */
+      0,                                  /* tp_maxalloc */
+      0,                                  /* tp_prev */
+      0                                   /* tp_next */
+#endif
+    };
+    varlink_type = tmp;
+    type_init = 1;
+    if (PyType_Ready(&varlink_type) < 0)
+      return NULL;
+  }
+  return &varlink_type;
+}
+
+/* Create a variable linking object for use later */
+SWIGINTERN PyObject *
+SWIG_Python_newvarlink(void) {
+  swig_varlinkobject *result = PyObject_NEW(swig_varlinkobject, swig_varlink_type());
+  if (result) {
+    result->vars = 0;
+  }
+  return ((PyObject*) result);
+}
+
+SWIGINTERN void 
+SWIG_Python_addvarlink(PyObject *p, const char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
+  swig_varlinkobject *v = (swig_varlinkobject *) p;
+  swig_globalvar *gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
+  if (gv) {
+    size_t size = strlen(name)+1;
+    gv->name = (char *)malloc(size);
+    if (gv->name) {
+      memcpy(gv->name, name, size);
+      gv->get_attr = get_attr;
+      gv->set_attr = set_attr;
+      gv->next = v->vars;
+    }
+  }
+  v->vars = gv;
+}
+
+
+static PyObject *Swig_Globals_global = NULL;
+  
+SWIGINTERN PyObject *
+SWIG_globals(void) {
+  if (Swig_Globals_global == NULL) {
+    Swig_Globals_global = SWIG_newvarlink();
+  }
+  return Swig_Globals_global;
+}
+
+#ifdef __cplusplus
+}
+#endif
+
 /* -----------------------------------------------------------------------------
  * Pointer declarations
  * ----------------------------------------------------------------------------- */
 
 /* Flags for new pointer objects */
 #define SWIG_POINTER_NOSHADOW       (SWIG_POINTER_OWN      << 1)
 #define SWIG_POINTER_NEW            (SWIG_POINTER_NOSHADOW | SWIG_POINTER_OWN)
@@ -1316,52 +1570,59 @@
     SwigPyClientData *data = (SwigPyClientData *)malloc(sizeof(SwigPyClientData));
     /* the klass element */
     data->klass = obj;
     Py_INCREF(data->klass);
     /* the newraw method and newargs arguments used to create a new raw instance */
     if (PyClass_Check(obj)) {
       data->newraw = 0;
-      data->newargs = obj;
       Py_INCREF(obj);
+      data->newargs = obj;
     } else {
       data->newraw = PyObject_GetAttrString(data->klass, "__new__");
       if (data->newraw) {
-	Py_INCREF(data->newraw);
-	data->newargs = PyTuple_New(1);
-	PyTuple_SetItem(data->newargs, 0, obj);
+        data->newargs = PyTuple_New(1);
+        if (data->newargs) {
+          Py_INCREF(obj);
+          PyTuple_SET_ITEM(data->newargs, 0, obj);
+        } else {
+          Py_DECREF(data->newraw);
+          Py_DECREF(data->klass);
+          free(data);
+          return 0;
+        }
       } else {
-	data->newargs = obj;
+        Py_INCREF(obj);
+        data->newargs = obj;
       }
-      Py_INCREF(data->newargs);
     }
     /* the destroy method, aka as the C++ delete method */
     data->destroy = PyObject_GetAttrString(data->klass, "__swig_destroy__");
     if (PyErr_Occurred()) {
       PyErr_Clear();
       data->destroy = 0;
     }
     if (data->destroy) {
-      int flags;
-      Py_INCREF(data->destroy);
-      flags = PyCFunction_GET_FLAGS(data->destroy);
-      data->delargs = !(flags & (METH_O));
+      data->delargs = !(PyCFunction_GET_FLAGS(data->destroy) & METH_O);
     } else {
       data->delargs = 0;
     }
     data->implicitconv = 0;
     data->pytype = 0;
     return data;
   }
 }
 
 SWIGRUNTIME void 
-SwigPyClientData_Del(SwigPyClientData *data) {
+SwigPyClientData_Del(SwigPyClientData *data)
+{
+  Py_XDECREF(data->klass);
   Py_XDECREF(data->newraw);
   Py_XDECREF(data->newargs);
   Py_XDECREF(data->destroy);
+  free(data);
 }
 
 /* =============== SwigPyObject =====================*/
 
 typedef struct {
   PyObject_HEAD
   void *ptr;
@@ -1380,15 +1641,15 @@
 SwigPyObject_get___dict__(PyObject *v, PyObject *SWIGUNUSEDPARM(args))
 {
   SwigPyObject *sobj = (SwigPyObject *)v;
 
   if (!sobj->dict)
     sobj->dict = PyDict_New();
 
-  Py_INCREF(sobj->dict);
+  Py_XINCREF(sobj->dict);
   return sobj->dict;
 }
 
 #endif
 
 SWIGRUNTIME PyObject *
 SwigPyObject_long(SwigPyObject *v)
@@ -1398,26 +1659,29 @@
 
 SWIGRUNTIME PyObject *
 SwigPyObject_format(const char* fmt, SwigPyObject *v)
 {
   PyObject *res = NULL;
   PyObject *args = PyTuple_New(1);
   if (args) {
-    if (PyTuple_SetItem(args, 0, SwigPyObject_long(v)) == 0) {
-      PyObject *ofmt = SWIG_Python_str_FromChar(fmt);
+    PyObject *val = SwigPyObject_long(v);
+    if (val) {
+      PyObject *ofmt;
+      PyTuple_SET_ITEM(args, 0, val);
+      ofmt = SWIG_Python_str_FromChar(fmt);
       if (ofmt) {
 #if PY_VERSION_HEX >= 0x03000000
-	res = PyUnicode_Format(ofmt,args);
+        res = PyUnicode_Format(ofmt,args);
 #else
-	res = PyString_Format(ofmt,args);
+        res = PyString_Format(ofmt,args);
 #endif
-	Py_DECREF(ofmt);
+        Py_DECREF(ofmt);
       }
-      Py_DECREF(args);
     }
+    Py_DECREF(args);
   }
   return res;
 }
 
 SWIGRUNTIME PyObject *
 SwigPyObject_oct(SwigPyObject *v)
 {
@@ -1431,26 +1695,31 @@
 }
 
 SWIGRUNTIME PyObject *
 SwigPyObject_repr(SwigPyObject *v)
 {
   const char *name = SWIG_TypePrettyName(v->ty);
   PyObject *repr = SWIG_Python_str_FromFormat("<Swig Object of type '%s' at %p>", (name ? name : "unknown"), (void *)v);
-  if (v->next) {
+  if (repr && v->next) {
     PyObject *nrep = SwigPyObject_repr((SwigPyObject *)v->next);
+    if (nrep) {
 # if PY_VERSION_HEX >= 0x03000000
-    PyObject *joined = PyUnicode_Concat(repr, nrep);
-    Py_DecRef(repr);
-    Py_DecRef(nrep);
-    repr = joined;
+      PyObject *joined = PyUnicode_Concat(repr, nrep);
+      Py_DecRef(repr);
+      Py_DecRef(nrep);
+      repr = joined;
 # else
-    PyString_ConcatAndDel(&repr,nrep);
+      PyString_ConcatAndDel(&repr,nrep);
 # endif
+    } else {
+      Py_DecRef(repr);
+      repr = NULL;
+    }
   }
-  return repr;  
+  return repr;
 }
 
 /* We need a version taking two PyObject* parameters so it's a valid
  * PyCFunction to use in swigobject_methods[]. */
 SWIGRUNTIME PyObject *
 SwigPyObject_repr2(PyObject *v, PyObject *SWIGUNUSEDPARM(args))
 {
@@ -1512,14 +1781,16 @@
     || (strcmp(Py_TYPE(op)->tp_name,"SwigPyObject") == 0);
 #endif
 }
 
 SWIGRUNTIME PyObject *
 SwigPyObject_New(void *ptr, swig_type_info *ty, int own);
 
+static PyObject* Swig_Capsule_global = NULL;
+
 SWIGRUNTIME void
 SwigPyObject_dealloc(PyObject *v)
 {
   SwigPyObject *sobj = (SwigPyObject *) v;
   PyObject *next = sobj->next;
   if (sobj->own == SWIG_POINTER_OWN) {
     swig_type_info *ty = sobj->ty;
@@ -1538,16 +1809,20 @@
       
       PyObject *type = NULL, *value = NULL, *traceback = NULL;
       PyErr_Fetch(&type, &value, &traceback);
 
       if (data->delargs) {
         /* we need to create a temporary object to carry the destroy operation */
         PyObject *tmp = SwigPyObject_New(sobj->ptr, ty, 0);
-        res = SWIG_Python_CallFunctor(destroy, tmp);
-        Py_DECREF(tmp);
+        if (tmp) {
+          res = SWIG_Python_CallFunctor(destroy, tmp);
+        } else {
+          res = 0;
+        }
+        Py_XDECREF(tmp);
       } else {
         PyCFunction meth = PyCFunction_GET_FUNCTION(destroy);
         PyObject *mself = PyCFunction_GET_SELF(destroy);
         res = ((*meth)(mself, v));
       }
       if (!res)
         PyErr_WriteUnraisable(destroy);
@@ -1558,27 +1833,32 @@
     } 
 #if !defined(SWIG_PYTHON_SILENT_MEMLEAK)
     else {
       const char *name = SWIG_TypePrettyName(ty);
       printf("swig/python detected a memory leak of type '%s', no destructor found.\n", (name ? name : "unknown"));
     }
 #endif
-  } 
+    Py_XDECREF(Swig_Capsule_global);
+  }
   Py_XDECREF(next);
+#ifdef SWIGPYTHON_BUILTIN
+  Py_XDECREF(sobj->dict);
+#endif
   PyObject_DEL(v);
 }
 
 SWIGRUNTIME PyObject* 
 SwigPyObject_append(PyObject* v, PyObject* next)
 {
   SwigPyObject *sobj = (SwigPyObject *) v;
   if (!SwigPyObject_Check(next)) {
     PyErr_SetString(PyExc_TypeError, "Attempt to append a non SwigPyObject");
     return NULL;
   }
+  ((SwigPyObject *)next)->next = sobj->next;
   sobj->next = next;
   Py_INCREF(next);
   return SWIG_Py_Void();
 }
 
 SWIGRUNTIME PyObject* 
 SwigPyObject_next(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
@@ -1615,17 +1895,17 @@
   if (!PyArg_UnpackTuple(args, "own", 0, 1, &val)) {
     return NULL;
   } else {
     SwigPyObject *sobj = (SwigPyObject *)v;
     PyObject *obj = PyBool_FromLong(sobj->own);
     if (val) {
       if (PyObject_IsTrue(val)) {
-        SwigPyObject_acquire(v,args);
+        Py_DECREF(SwigPyObject_acquire(v,args));
       } else {
-        SwigPyObject_disown(v,args);
+        Py_DECREF(SwigPyObject_disown(v,args));
       }
     } 
     return obj;
   }
 }
 
 static PyMethodDef
@@ -1697,15 +1977,19 @@
       PyObject_HEAD_INIT(NULL)
       0,                                    /* ob_size */
 #endif
       "SwigPyObject",                       /* tp_name */
       sizeof(SwigPyObject),                 /* tp_basicsize */
       0,                                    /* tp_itemsize */
       (destructor)SwigPyObject_dealloc,     /* tp_dealloc */
-      0,                                    /* tp_print */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                         /*tp_print*/
+#else
+      (Py_ssize_t)0,                        /*tp_vectorcall_offset*/
+#endif
       (getattrfunc)0,                       /* tp_getattr */
       (setattrfunc)0,                       /* tp_setattr */
 #if PY_VERSION_HEX >= 0x03000000
       0, /* tp_reserved in 3.0.1, tp_compare in 3.0.0 but not used */
 #else
       (cmpfunc)SwigPyObject_compare,        /* tp_compare */
 #endif
@@ -1762,29 +2046,38 @@
       0,                                    /* tp_maxalloc */
       0,                                    /* tp_prev */
       0                                     /* tp_next */
 #endif
     };
     swigpyobject_type = tmp;
     type_init = 1;
-    if (PyType_Ready(&swigpyobject_type) < 0)
+    if (PyType_Ready(&swigpyobject_type) != 0)
       return NULL;
   }
   return &swigpyobject_type;
 }
 
 SWIGRUNTIME PyObject *
 SwigPyObject_New(void *ptr, swig_type_info *ty, int own)
 {
   SwigPyObject *sobj = PyObject_NEW(SwigPyObject, SwigPyObject_type());
   if (sobj) {
     sobj->ptr  = ptr;
     sobj->ty   = ty;
     sobj->own  = own;
     sobj->next = 0;
+#ifdef SWIGPYTHON_BUILTIN
+    sobj->dict = 0;
+#endif
+    if (own == SWIG_POINTER_OWN) {
+      /* Obtain a reference to the Python capsule wrapping the module information, so that the
+       * module information is correctly destroyed after all SWIG python objects have been freed
+       * by the GC (and corresponding destructors invoked) */
+      Py_XINCREF(Swig_Capsule_global);
+    }
   }
   return (PyObject *)sobj;
 }
 
 /* -----------------------------------------------------------------------------
  * Implements a simple Swig Packed type, and use it instead of string
  * ----------------------------------------------------------------------------- */
@@ -1864,15 +2157,19 @@
       PyObject_HEAD_INIT(NULL)
       0,                                    /* ob_size */
 #endif
       "SwigPyPacked",                       /* tp_name */
       sizeof(SwigPyPacked),                 /* tp_basicsize */
       0,                                    /* tp_itemsize */
       (destructor)SwigPyPacked_dealloc,     /* tp_dealloc */
-      0,                                    /* tp_print */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                         /*tp_print*/
+#else
+      (Py_ssize_t)0,                        /*tp_vectorcall_offset*/
+#endif
       (getattrfunc)0,                       /* tp_getattr */
       (setattrfunc)0,                       /* tp_setattr */
 #if PY_VERSION_HEX>=0x03000000
       0, /* tp_reserved in 3.0.1 */
 #else
       (cmpfunc)SwigPyPacked_compare,        /* tp_compare */
 #endif
@@ -1929,15 +2226,15 @@
       0,                                    /* tp_maxalloc */
       0,                                    /* tp_prev */
       0                                     /* tp_next */
 #endif
     };
     swigpypacked_type = tmp;
     type_init = 1;
-    if (PyType_Ready(&swigpypacked_type) < 0)
+    if (PyType_Ready(&swigpypacked_type) != 0)
       return NULL;
   }
   return &swigpypacked_type;
 }
 
 SWIGRUNTIME PyObject *
 SwigPyPacked_New(void *ptr, size_t size, swig_type_info *ty)
@@ -2119,20 +2416,27 @@
       }
     } else {
       if (ptr) *ptr = vptr;
       break;
     }
   }
   if (sobj) {
-    if (own)
-      *own = *own | sobj->own;
-    if (flags & SWIG_POINTER_DISOWN) {
-      sobj->own = 0;
+    if (((flags & SWIG_POINTER_RELEASE) == SWIG_POINTER_RELEASE) && !sobj->own) {
+      res = SWIG_ERROR_RELEASE_NOT_OWNED;
+    } else {
+      if (own)
+        *own = *own | sobj->own;
+      if (flags & SWIG_POINTER_DISOWN) {
+        sobj->own = 0;
+      }
+      if (flags & SWIG_POINTER_CLEAR) {
+        sobj->ptr = 0;
+      }
+      res = SWIG_OK;
     }
-    res = SWIG_OK;
   } else {
     if (implicit_conv) {
       SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
       if (data && !data->implicitconv) {
         PyObject *klass = data->klass;
         if (klass) {
           PyObject *impconv;
@@ -2237,20 +2541,25 @@
   PyObject *newraw = data->newraw;
   if (newraw) {
     inst = PyObject_Call(newraw, data->newargs, NULL);
     if (inst) {
 #if !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
       PyObject **dictptr = _PyObject_GetDictPtr(inst);
       if (dictptr != NULL) {
-	PyObject *dict = *dictptr;
-	if (dict == NULL) {
-	  dict = PyDict_New();
-	  *dictptr = dict;
-	  PyDict_SetItem(dict, SWIG_This(), swig_this);
-	}
+        PyObject *dict = *dictptr;
+        if (dict == NULL) {
+          dict = PyDict_New();
+          *dictptr = dict;
+        }
+        if (dict) {
+          PyDict_SetItem(dict, SWIG_This(), swig_this);
+        } else{
+          Py_DECREF(inst);
+          inst = 0;
+        }
       }
 #else
       if (PyObject_SetAttr(inst, SWIG_This(), swig_this) == -1) {
         Py_DECREF(inst);
         inst = 0;
       }
 #endif
@@ -2264,15 +2573,15 @@
         inst = ((PyTypeObject *)data->newargs)->tp_new((PyTypeObject *)data->newargs, empty_args, empty_kwargs);
         Py_DECREF(empty_kwargs);
         if (inst) {
           if (PyObject_SetAttr(inst, SWIG_This(), swig_this) == -1) {
             Py_DECREF(inst);
             inst = 0;
           } else {
-            Py_TYPE(inst)->tp_flags &= ~Py_TPFLAGS_VALID_VERSION_TAG;
+            PyType_Modified(Py_TYPE(inst));
           }
         }
       }
       Py_DECREF(empty_args);
     }
 #else
     PyObject *dict = PyDict_New();
@@ -2293,30 +2602,34 @@
   PyObject **dictptr = _PyObject_GetDictPtr(inst);
   if (dictptr != NULL) {
     PyObject *dict = *dictptr;
     if (dict == NULL) {
       dict = PyDict_New();
       *dictptr = dict;
     }
-    return PyDict_SetItem(dict, SWIG_This(), swig_this);
+    if (dict) {
+      return PyDict_SetItem(dict, SWIG_This(), swig_this);
+    } else{
+      return -1;
+    }
   }
 #endif
   return PyObject_SetAttr(inst, SWIG_This(), swig_this);
 } 
 
 
 SWIGINTERN PyObject *
 SWIG_Python_InitShadowInstance(PyObject *args) {
   PyObject *obj[2];
   if (!SWIG_Python_UnpackTuple(args, "swiginit", 2, 2, obj)) {
     return NULL;
   } else {
     SwigPyObject *sthis = SWIG_Python_GetSwigThis(obj[0]);
     if (sthis) {
-      SwigPyObject_append((PyObject*) sthis, obj[1]);
+      Py_DECREF(SwigPyObject_append((PyObject*) sthis, obj[1]));
     } else {
       if (SWIG_Python_SetSwigThis(obj[0], obj[1]) != 0)
         return NULL;
     }
     return SWIG_Py_Void();
   }
 }
@@ -2347,15 +2660,17 @@
 #ifdef SWIGPYTHON_BUILTIN
         newobj->dict = 0;
 #endif
       }
     } else {
       newobj = PyObject_New(SwigPyObject, clientdata->pytype);
 #ifdef SWIGPYTHON_BUILTIN
-      newobj->dict = 0;
+      if (newobj) {
+        newobj->dict = 0;
+      }
 #endif
     }
     if (newobj) {
       newobj->ptr = ptr;
       newobj->ty = type;
       newobj->own = own;
       newobj->next = 0;
@@ -2386,89 +2701,111 @@
  *  Get type list 
  * -----------------------------------------------------------------------------*/
 
 #ifdef SWIG_LINK_RUNTIME
 void *SWIG_ReturnGlobalTypeList(void *);
 #endif
 
+static PyObject *Swig_TypeCache_global = NULL;
+
+/* The python cached type query */
+SWIGRUNTIME PyObject *
+SWIG_Python_TypeCache(void) {
+  if (Swig_TypeCache_global == NULL) {
+    Swig_TypeCache_global = PyDict_New();
+  }
+  return Swig_TypeCache_global;
+}
+
 SWIGRUNTIME swig_module_info *
 SWIG_Python_GetModule(void *SWIGUNUSEDPARM(clientdata)) {
+#ifdef SWIG_LINK_RUNTIME
   static void *type_pointer = (void *)0;
   /* first check if module already created */
   if (!type_pointer) {
-#ifdef SWIG_LINK_RUNTIME
     type_pointer = SWIG_ReturnGlobalTypeList((void *)0);
+  }
 #else
-    type_pointer = PyCapsule_Import(SWIGPY_CAPSULE_NAME, 0);
-    if (PyErr_Occurred()) {
-      PyErr_Clear();
-      type_pointer = (void *)0;
-    }
-#endif
+  void *type_pointer = PyCapsule_Import(SWIGPY_CAPSULE_NAME, 0);
+  if (PyErr_Occurred()) {
+    PyErr_Clear();
+    type_pointer = (void *)0;
   }
+#endif
   return (swig_module_info *) type_pointer;
 }
 
+
+static int interpreter_counter = 0; // how many (sub-)interpreters are using swig_module's types
+
 SWIGRUNTIME void
 SWIG_Python_DestroyModule(PyObject *obj)
 {
   swig_module_info *swig_module = (swig_module_info *) PyCapsule_GetPointer(obj, SWIGPY_CAPSULE_NAME);
   swig_type_info **types = swig_module->types;
   size_t i;
+  if (--interpreter_counter != 0) // another sub-interpreter may still be using the swig_module's types
+    return;
   for (i =0; i < swig_module->size; ++i) {
     swig_type_info *ty = types[i];
     if (ty->owndata) {
       SwigPyClientData *data = (SwigPyClientData *) ty->clientdata;
+      ty->clientdata = 0;
       if (data) SwigPyClientData_Del(data);
     }
   }
   Py_DECREF(SWIG_This());
   Swig_This_global = NULL;
+  Py_DECREF(SWIG_globals());
+  Swig_Globals_global = NULL;
+  Py_DECREF(SWIG_Python_TypeCache());
+  Swig_TypeCache_global = NULL;
+  Swig_Capsule_global = NULL;
 }
 
 SWIGRUNTIME void
 SWIG_Python_SetModule(swig_module_info *swig_module) {
 #if PY_VERSION_HEX >= 0x03000000
  /* Add a dummy module object into sys.modules */
   PyObject *module = PyImport_AddModule("swig_runtime_data" SWIG_RUNTIME_VERSION);
 #else
   static PyMethodDef swig_empty_runtime_method_table[] = { {NULL, NULL, 0, NULL} }; /* Sentinel */
   PyObject *module = Py_InitModule("swig_runtime_data" SWIG_RUNTIME_VERSION, swig_empty_runtime_method_table);
 #endif
   PyObject *pointer = PyCapsule_New((void *) swig_module, SWIGPY_CAPSULE_NAME, SWIG_Python_DestroyModule);
   if (pointer && module) {
-    PyModule_AddObject(module, "type_pointer_capsule" SWIG_TYPE_TABLE_NAME, pointer);
+    if (PyModule_AddObject(module, SWIGPY_CAPSULE_ATTR_NAME, pointer) == 0) {
+      ++interpreter_counter;
+      Swig_Capsule_global = pointer;
+    } else {
+      Py_DECREF(pointer);
+    }
   } else {
     Py_XDECREF(pointer);
   }
 }
 
-/* The python cached type query */
-SWIGRUNTIME PyObject *
-SWIG_Python_TypeCache(void) {
-  static PyObject *SWIG_STATIC_POINTER(cache) = PyDict_New();
-  return cache;
-}
-
 SWIGRUNTIME swig_type_info *
 SWIG_Python_TypeQuery(const char *type)
 {
   PyObject *cache = SWIG_Python_TypeCache();
   PyObject *key = SWIG_Python_str_FromChar(type); 
   PyObject *obj = PyDict_GetItem(cache, key);
   swig_type_info *descriptor;
   if (obj) {
     descriptor = (swig_type_info *) PyCapsule_GetPointer(obj, NULL);
   } else {
     swig_module_info *swig_module = SWIG_GetModule(0);
     descriptor = SWIG_TypeQueryModule(swig_module, swig_module, type);
     if (descriptor) {
       obj = PyCapsule_New((void*) descriptor, NULL, NULL);
-      PyDict_SetItem(cache, key, obj);
-      Py_DECREF(obj);
+      if (obj) {
+        PyDict_SetItem(cache, key, obj);
+        Py_DECREF(obj);
+      }
     }
   }
   Py_DECREF(key);
   return descriptor;
 }
 
 /* 
@@ -2493,15 +2830,14 @@
       Py_XINCREF(type);
       PyErr_Clear();
       if (infront) {
 	PyErr_Format(type, "%s %s", mesg, errmesg);
       } else {
 	PyErr_Format(type, "%s %s", errmesg, mesg);
       }
-      SWIG_Python_str_DelForPy3(tmp);
       Py_DECREF(old_str);
     }
     return 1;
   } else {
     return 0;
   }
 }
@@ -2545,15 +2881,14 @@
       const char *otype = (obj ? obj->ob_type->tp_name : 0); 
       if (otype) {
 	PyObject *str = PyObject_Str(obj);
 	const char *cstr = str ? SWIG_Python_str_AsChar(str) : 0;
 	if (cstr) {
 	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s(%s)' is received",
 		       type, otype, cstr);
-          SWIG_Python_str_DelForPy3(cstr);
 	} else {
 	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s' is received",
 		       type, otype);
 	}
 	Py_XDECREF(str);
 	return;
       }
@@ -2567,20 +2902,14 @@
 
 /* Convert a pointer value, signal an exception on a type mismatch */
 SWIGRUNTIME void *
 SWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int SWIGUNUSEDPARM(argnum), int flags) {
   void *result;
   if (SWIG_Python_ConvertPtr(obj, &result, ty, flags) == -1) {
     PyErr_Clear();
-#if SWIG_POINTER_EXCEPTION
-    if (flags) {
-      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);
-      SWIG_Python_ArgFail(argnum);
-    }
-#endif
   }
   return result;
 }
 
 #ifdef SWIGPYTHON_BUILTIN
 SWIGRUNTIME int
 SWIG_Python_NonDynamicSetAttr(PyObject *obj, PyObject *name, PyObject *value) {
@@ -2603,30 +2932,30 @@
     PyErr_Format(PyExc_TypeError, "attribute name must be string, not '%.200s'", name->ob_type->tp_name);
     return -1;
   } else {
     Py_INCREF(name);
   }
 
   if (!tp->tp_dict) {
-    if (PyType_Ready(tp) < 0)
+    if (PyType_Ready(tp) != 0)
       goto done;
   }
 
   descr = _PyType_Lookup(tp, name);
   f = NULL;
   if (descr != NULL)
     f = descr->ob_type->tp_descr_set;
   if (!f) {
     if (PyString_Check(name)) {
       encoded_name = name;
       Py_INCREF(name);
     } else {
       encoded_name = PyUnicode_AsUTF8String(name);
       if (!encoded_name)
-        return -1;
+        goto done;
     }
     PyErr_Format(PyExc_AttributeError, "'%.100s' object has no attribute '%.200s'", tp->tp_name, PyString_AsString(encoded_name));
     Py_DECREF(encoded_name);
   } else {
     res = f(descr, obj, value);
   }
   
@@ -2645,15 +2974,19 @@
 extern "C" {
 #endif
 
 SWIGINTERN Py_hash_t
 SwigPyObject_hash(PyObject *obj) {
   SwigPyObject *sobj = (SwigPyObject *)obj;
   void *ptr = sobj->ptr;
+#if PY_VERSION_HEX < 0x03020000
+  return (Py_hash_t)(Py_ssize_t)ptr;
+#else
   return (Py_hash_t)ptr;
+#endif
 }
 
 SWIGINTERN Py_hash_t
 SWIG_PyNumber_AsPyHash(PyObject *obj) {
   Py_hash_t result = -1;
 #if PY_VERSION_HEX < 0x03020000
   if (PyInt_Check(obj))
@@ -2850,15 +3183,19 @@
       PyObject_HEAD_INIT(&PyType_Type)
       0,                                        /* ob_size */
 #endif
       "swig_static_var_getset_descriptor",      /* tp_name */
       sizeof(PyGetSetDescrObject),              /* tp_basicsize */
       0,                                        /* tp_itemsize */
       (destructor)SwigPyStaticVar_dealloc,      /* tp_dealloc */
-      0,                                        /* tp_print */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                             /* tp_print */
+#else
+      (Py_ssize_t)0,                            /* tp_vectorcall_offset */
+#endif
       0,                                        /* tp_getattr */
       0,                                        /* tp_setattr */
       0,                                        /* tp_compare */
       (reprfunc)SwigPyStaticVar_repr,           /* tp_repr */
       0,                                        /* tp_as_number */
       0,                                        /* tp_as_sequence */
       0,                                        /* tp_as_mapping */
@@ -2934,15 +3271,19 @@
       PyObject_HEAD_INIT(&PyType_Type)
       0,                                        /* ob_size */
 #endif
       "SwigPyObjectType",                       /* tp_name */
       PyType_Type.tp_basicsize,                 /* tp_basicsize */
       0,                                        /* tp_itemsize */
       0,                                        /* tp_dealloc */
-      0,                                        /* tp_print */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                             /* tp_print */
+#else
+      (Py_ssize_t)0,                            /* tp_vectorcall_offset */
+#endif
       0,                                        /* tp_getattr */
       0,                                        /* tp_setattr */
       0,                                        /* tp_compare */
       0,                                        /* tp_repr */
       0,                                        /* tp_as_number */
       0,                                        /* tp_as_sequence */
       0,                                        /* tp_as_mapping */
@@ -3053,18 +3394,18 @@
   Py_XINCREF(result);
   return result;
 }
 
 SWIGINTERN void
 SwigPyBuiltin_SetMetaType (PyTypeObject *type, PyTypeObject *metatype)
 {
-#if PY_VERSION_HEX >= 0x03000000
-    type->ob_base.ob_base.ob_type = metatype;
+#if PY_VERSION_HEX >= 0x030900a4
+    Py_SET_TYPE(type, metatype);
 #else
-    type->ob_type = metatype;
+    Py_TYPE(type) = metatype;
 #endif
 }
 
 
 /* Start of callback function macros for use in PyTypeObject */
 
 typedef PyObject *(*SwigPyWrapperFunction)(PyObject *, PyObject *);
@@ -3394,31 +3735,16 @@
 #endif
 
 
 
 
 #define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 
 
-#define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 
-
-
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* Method creation and docstring support functions */
-
-SWIGINTERN PyMethodDef *SWIG_PythonGetProxyDoc(const char *name);
-SWIGINTERN PyObject *SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func);
-SWIGINTERN PyObject *SWIG_PyStaticMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func);
+#define SWIG_contract_assert(expr, msg) do { if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } } while (0) 
 
-#ifdef __cplusplus
-}
-#endif
 
 
 /* -------- TYPES TABLE (BEGIN) -------- */
 
 #define SWIGTYPE_p_CameraAbilities swig_types[0]
 #define SWIGTYPE_p_CameraCaptureType swig_types[1]
 #define SWIGTYPE_p_CameraDriverStatus swig_types[2]
@@ -3496,18 +3822,14 @@
 
 #else
 #  define SWIG_init    init_port_info_list
 
 #endif
 #define SWIG_name    "_port_info_list"
 
-#define SWIGVERSION 0x040002 
-#define SWIG_VERSION SWIGVERSION
-
-
 #define SWIG_as_voidptr(a) (void *)((const void *)(a)) 
 #define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),(void**)(a)) 
 
 
 #include <stddef.h>
 
 
@@ -3976,16 +4298,16 @@
 PyErr_SetObject(PyExc_GPhoto2Error, PyInt_FromLong(result));
 /*@SWIG@*/
 
 
 
   }
 
-#if GPHOTO2_VERSION < 0x02051d01
-int gp_port_init_localedir(const char *localedir) {
+#if GPHOTO2_VERSION < 0x02051e00
+static int gp_port_init_localedir(const char *localedir) {
     return GP_ERROR_NOT_SUPPORTED;
 }
 #endif
 #if GPHOTO2_VERSION < 0x02051800
   int GP_PORT_IP = GP_PORT_USB_SCSI + 1;
 #endif
 
@@ -4032,14 +4354,15 @@
   int res1 = 0 ;
   char *temp2 ;
   
   {
     temp2 = NULL;
     arg2 = &temp2;
   }
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "_GPPortInfo_get_name takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__GPPortInfo, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_GPPortInfo_get_name" "', argument " "1"" of type '" "struct _GPPortInfo *""'"); 
   }
   arg1 = (struct _GPPortInfo *)(argp1);
   {
@@ -4070,14 +4393,15 @@
   int res1 = 0 ;
   char *temp2 ;
   
   {
     temp2 = NULL;
     arg2 = &temp2;
   }
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "_GPPortInfo_get_path takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__GPPortInfo, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_GPPortInfo_get_path" "', argument " "1"" of type '" "struct _GPPortInfo *""'"); 
   }
   arg1 = (struct _GPPortInfo *)(argp1);
   {
@@ -4106,14 +4430,15 @@
   GPPortType *arg2 = (GPPortType *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   GPPortType temp2 ;
   int res2 = SWIG_TMPOBJ ;
   
   arg2 = &temp2;
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "_GPPortInfo_get_type takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__GPPortInfo, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_GPPortInfo_get_type" "', argument " "1"" of type '" "struct _GPPortInfo *""'"); 
   }
   arg1 = (struct _GPPortInfo *)(argp1);
   {
@@ -4135,14 +4460,15 @@
 
 SWIGINTERN PyObject *_wrap_delete__GPPortInfo(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _GPPortInfo *arg1 = (struct _GPPortInfo *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete__GPPortInfo takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__GPPortInfo, SWIG_POINTER_DISOWN |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete__GPPortInfo" "', argument " "1"" of type '" "struct _GPPortInfo *""'"); 
   }
   arg1 = (struct _GPPortInfo *)(argp1);
   free((char *) arg1);
@@ -4158,14 +4484,15 @@
 SWIGINTERN PyObject *_wrap_PortInfoList___len__(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _GPPortInfoList *arg1 = (struct _GPPortInfoList *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   int result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "PortInfoList___len__ takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__GPPortInfoList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PortInfoList___len__" "', argument " "1"" of type '" "struct _GPPortInfoList *""'"); 
   }
   arg1 = (struct _GPPortInfoList *)(argp1);
   {
@@ -4191,14 +4518,15 @@
   GPPortInfo temp3 ;
   PyObject * obj1 = 0 ;
   
   {
     temp3 = NULL;
     arg3 = &temp3;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "PortInfoList___getitem__", 1, 1, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__GPPortInfoList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PortInfoList___getitem__" "', argument " "1"" of type '" "struct _GPPortInfoList *""'"); 
   }
   arg1 = (struct _GPPortInfoList *)(argp1);
   ecode2 = SWIG_AsVal_int(obj1, &val2);
@@ -4223,14 +4551,15 @@
 }
 
 
 SWIGINTERN int _wrap_new_PortInfoList(PyObject *self, PyObject *args, PyObject *kwargs) {
   PyObject *resultobj = 0;
   struct _GPPortInfoList *result = 0 ;
   
+  (void)self;
   if (!SWIG_Python_CheckNoKeywords(kwargs, "new_PortInfoList")) SWIG_fail;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "new_PortInfoList takes no arguments");
   {
     result = (struct _GPPortInfoList *)new__GPPortInfoList();
     if (PyErr_Occurred()) SWIG_fail;
   }
   resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p__GPPortInfoList, SWIG_BUILTIN_INIT |  0 );
@@ -4242,14 +4571,15 @@
 
 SWIGINTERN PyObject *_wrap_delete_PortInfoList(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _GPPortInfoList *arg1 = (struct _GPPortInfoList *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_PortInfoList takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__GPPortInfoList, SWIG_POINTER_DISOWN |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_PortInfoList" "', argument " "1"" of type '" "struct _GPPortInfoList *""'"); 
   }
   arg1 = (struct _GPPortInfoList *)(argp1);
   {
@@ -4269,14 +4599,15 @@
   GPPortInfo arg2 = (GPPortInfo) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   void *argp2 = 0 ;
   int res2 = 0 ;
   PyObject * obj1 = 0 ;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "PortInfoList_append", 1, 1, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__GPPortInfoList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PortInfoList_append" "', argument " "1"" of type '" "struct _GPPortInfoList *""'"); 
   }
   arg1 = (struct _GPPortInfoList *)(argp1);
   res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p__GPPortInfo, 0 |  0 );
@@ -4297,14 +4628,15 @@
 
 SWIGINTERN PyObject *_wrap_PortInfoList_load(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _GPPortInfoList *arg1 = (struct _GPPortInfoList *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "PortInfoList_load takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__GPPortInfoList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PortInfoList_load" "', argument " "1"" of type '" "struct _GPPortInfoList *""'"); 
   }
   arg1 = (struct _GPPortInfoList *)(argp1);
   {
@@ -4321,14 +4653,15 @@
 SWIGINTERN PyObject *_wrap_PortInfoList_count(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _GPPortInfoList *arg1 = (struct _GPPortInfoList *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   int result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "PortInfoList_count takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__GPPortInfoList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PortInfoList_count" "', argument " "1"" of type '" "struct _GPPortInfoList *""'"); 
   }
   arg1 = (struct _GPPortInfoList *)(argp1);
   {
@@ -4350,14 +4683,15 @@
   int res1 = 0 ;
   int res2 ;
   char *buf2 = 0 ;
   int alloc2 = 0 ;
   PyObject * obj1 = 0 ;
   int result;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "PortInfoList_lookup_path", 1, 1, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__GPPortInfoList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PortInfoList_lookup_path" "', argument " "1"" of type '" "struct _GPPortInfoList *""'"); 
   }
   arg1 = (struct _GPPortInfoList *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -4386,14 +4720,15 @@
   int res1 = 0 ;
   int res2 ;
   char *buf2 = 0 ;
   int alloc2 = 0 ;
   PyObject * obj1 = 0 ;
   int result;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "PortInfoList_lookup_name", 1, 1, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__GPPortInfoList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PortInfoList_lookup_name" "', argument " "1"" of type '" "struct _GPPortInfoList *""'"); 
   }
   arg1 = (struct _GPPortInfoList *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -4426,14 +4761,15 @@
   GPPortInfo temp3 ;
   PyObject * obj1 = 0 ;
   
   {
     temp3 = NULL;
     arg3 = &temp3;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "PortInfoList_get_info", 1, 1, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__GPPortInfoList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PortInfoList_get_info" "', argument " "1"" of type '" "struct _GPPortInfoList *""'"); 
   }
   arg1 = (struct _GPPortInfoList *)(argp1);
   ecode2 = SWIG_AsVal_int(obj1, &val2);
@@ -4472,14 +4808,15 @@
   PyObject * obj0 = 0 ;
   int result;
   
   {
     temp2 = NULL;
     arg2 = &temp2;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_port_info_get_name", 1, 1, &obj0)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__GPPortInfo, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_port_info_get_name" "', argument " "1"" of type '" "GPPortInfo""'"); 
   }
   arg1 = (GPPortInfo)(argp1);
   result = (int)gp_port_info_get_name(arg1,arg2);
@@ -4509,14 +4846,15 @@
   PyObject * obj0 = 0 ;
   int result;
   
   {
     temp2 = NULL;
     arg2 = &temp2;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_port_info_get_path", 1, 1, &obj0)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__GPPortInfo, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_port_info_get_path" "', argument " "1"" of type '" "GPPortInfo""'"); 
   }
   arg1 = (GPPortInfo)(argp1);
   result = (int)gp_port_info_get_path(arg1,arg2);
@@ -4544,14 +4882,15 @@
   int res1 = 0 ;
   GPPortType temp2 ;
   int res2 = SWIG_TMPOBJ ;
   PyObject * obj0 = 0 ;
   int result;
   
   arg2 = &temp2;
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_port_info_get_type", 1, 1, &obj0)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__GPPortInfo, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_port_info_get_type" "', argument " "1"" of type '" "GPPortInfo""'"); 
   }
   arg1 = (GPPortInfo)(argp1);
   result = (int)gp_port_info_get_type(arg1,arg2);
@@ -4574,14 +4913,15 @@
   GPPortInfoList *temp1 ;
   int result;
   
   {
     temp1 = NULL;
     arg1 = &temp1;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_port_info_list_new", 0, 0)) SWIG_fail;
   result = (int)gp_port_info_list_new(arg1);
   resultobj = SWIG_From_int((int)(result));
   {
     resultobj = SWIG_Python_AppendOutput(
       resultobj, SWIG_NewPointerObj(*arg1, SWIGTYPE_p__GPPortInfoList, SWIG_POINTER_OWN));
   }
@@ -4599,14 +4939,15 @@
   int res1 = 0 ;
   void *argp2 = 0 ;
   int res2 = 0 ;
   PyObject * obj0 = 0 ;
   PyObject * obj1 = 0 ;
   int result;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_port_info_list_append", 2, 2, &obj0, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__GPPortInfoList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_port_info_list_append" "', argument " "1"" of type '" "GPPortInfoList *""'"); 
   }
   arg1 = (GPPortInfoList *)(argp1);
   res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p__GPPortInfo, 0 |  0 );
@@ -4626,14 +4967,15 @@
   PyObject *resultobj = 0;
   GPPortInfoList *arg1 = (GPPortInfoList *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   PyObject * obj0 = 0 ;
   int result;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_port_info_list_load", 1, 1, &obj0)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__GPPortInfoList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_port_info_list_load" "', argument " "1"" of type '" "GPPortInfoList *""'"); 
   }
   arg1 = (GPPortInfoList *)(argp1);
   result = (int)gp_port_info_list_load(arg1);
@@ -4648,14 +4990,15 @@
   PyObject *resultobj = 0;
   GPPortInfoList *arg1 = (GPPortInfoList *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   PyObject * obj0 = 0 ;
   int result;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_port_info_list_count", 1, 1, &obj0)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__GPPortInfoList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_port_info_list_count" "', argument " "1"" of type '" "GPPortInfoList *""'"); 
   }
   arg1 = (GPPortInfoList *)(argp1);
   result = (int)gp_port_info_list_count(arg1);
@@ -4675,14 +5018,15 @@
   int res2 ;
   char *buf2 = 0 ;
   int alloc2 = 0 ;
   PyObject * obj0 = 0 ;
   PyObject * obj1 = 0 ;
   int result;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_port_info_list_lookup_path", 2, 2, &obj0, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__GPPortInfoList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_port_info_list_lookup_path" "', argument " "1"" of type '" "GPPortInfoList *""'"); 
   }
   arg1 = (GPPortInfoList *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -4709,14 +5053,15 @@
   int res2 ;
   char *buf2 = 0 ;
   int alloc2 = 0 ;
   PyObject * obj0 = 0 ;
   PyObject * obj1 = 0 ;
   int result;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_port_info_list_lookup_name", 2, 2, &obj0, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__GPPortInfoList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_port_info_list_lookup_name" "', argument " "1"" of type '" "GPPortInfoList *""'"); 
   }
   arg1 = (GPPortInfoList *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -4748,14 +5093,15 @@
   PyObject * obj1 = 0 ;
   int result;
   
   {
     temp3 = NULL;
     arg3 = &temp3;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_port_info_list_get_info", 2, 2, &obj0, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__GPPortInfoList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_port_info_list_get_info" "', argument " "1"" of type '" "GPPortInfoList *""'"); 
   }
   arg1 = (GPPortInfoList *)(argp1);
   ecode2 = SWIG_AsVal_int(obj1, &val2);
@@ -4780,14 +5126,15 @@
   char *arg1 = (char *) 0 ;
   int res1 ;
   char *buf1 = 0 ;
   int alloc1 = 0 ;
   PyObject * obj0 = 0 ;
   char *result = 0 ;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_port_message_codeset", 1, 1, &obj0)) SWIG_fail;
   res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_port_message_codeset" "', argument " "1"" of type '" "char const *""'");
   }
   arg1 = (char *)(buf1);
   result = (char *)gp_port_message_codeset((char const *)arg1);
@@ -4805,14 +5152,15 @@
   char *arg1 = (char *) 0 ;
   int res1 ;
   char *buf1 = 0 ;
   int alloc1 = 0 ;
   PyObject * obj0 = 0 ;
   int result;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_port_init_localedir", 1, 1, &obj0)) SWIG_fail;
   res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_port_init_localedir" "', argument " "1"" of type '" "char const *""'");
   }
   arg1 = (char *)(buf1);
   result = (int)gp_port_init_localedir((char const *)arg1);
@@ -4822,330 +5170,14 @@
 fail:
   if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
   return NULL;
 }
 
 
 static PyMethodDef SwigMethods[] = {
-	 { "SWIG_PyInstanceMethod_New", SWIG_PyInstanceMethod_New, METH_O, NULL},
-	 { "SWIG_PyStaticMethod_New", SWIG_PyStaticMethod_New, METH_O, NULL},
-	 { "gp_port_info_get_name", _wrap_gp_port_info_get_name, METH_VARARGS, "\n"
-		"gp_port_info_get_name(info) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"info: gphoto2.GPPortInfo\n"
-		"\n"
-		"Get name of a specific port entry.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `info` :  \n"
-		"    a #GPPortInfo  \n"
-		"* `name` :  \n"
-		"    a pointer to a char* which will receive the name  \n"
-		"\n"
-		"Retreives the name of the passed in GPPortInfo, by reference.  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code\n"
-		"\n"
-		"See also gphoto2.PortInfo.get_name\n"
-		""},
-	 { "gp_port_info_get_path", _wrap_gp_port_info_get_path, METH_VARARGS, "\n"
-		"gp_port_info_get_path(info) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"info: gphoto2.GPPortInfo\n"
-		"\n"
-		"Get path of a specific port entry.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `info` :  \n"
-		"    a #GPPortInfo  \n"
-		"* `path` :  \n"
-		"    a pointer to a char* which will receive the path  \n"
-		"\n"
-		"Retreives the path of the passed in GPPortInfo, by reference.  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code\n"
-		"\n"
-		"See also gphoto2.PortInfo.get_path\n"
-		""},
-	 { "gp_port_info_get_type", _wrap_gp_port_info_get_type, METH_VARARGS, "\n"
-		"gp_port_info_get_type(info) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"info: gphoto2.GPPortInfo\n"
-		"\n"
-		"Get type of a specific port entry.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `info` :  \n"
-		"    a #GPPortInfo  \n"
-		"* `type` :  \n"
-		"    a pointer to a GPPortType variable which will receive the type  \n"
-		"\n"
-		"Retreives the type of the passed in GPPortInfo  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code\n"
-		"\n"
-		"See also gphoto2.PortInfo.get_type\n"
-		""},
-	 { "gp_port_info_list_new", _wrap_gp_port_info_list_new, METH_VARARGS, "\n"
-		"gp_port_info_list_new() -> int\n"
-		"Create a new GPPortInfoList.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `list` :  \n"
-		"    pointer to a GPPortInfoList* which is allocated  \n"
-		"\n"
-		"Creates a new list which can later be filled with port infos\n"
-		"(#GPPortInfo) using gp_port_info_list_load.  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code\n"
-		"\n"
-		"See also gphoto2.PortInfoList\n"
-		""},
-	 { "gp_port_info_list_append", _wrap_gp_port_info_list_append, METH_VARARGS, "\n"
-		"gp_port_info_list_append(list, info) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"list: gphoto2.GPPortInfoList\n"
-		"info: gphoto2.GPPortInfo\n"
-		"\n"
-		"Append a portinfo to the port information list.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `list` :  \n"
-		"    a #GPPortInfoList  \n"
-		"* `info` :  \n"
-		"    the info to append  \n"
-		"\n"
-		"Appends an entry to the list. This function is typically called by an\n"
-		"io-driver during #gp_port_library_list. If you leave info.name blank,\n"
-		"gp_port_info_list_lookup_path will try to match non-existent paths\n"
-		"against info.path and - if successful - will append this entry to the\n"
-		"list.  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"A gphoto2 error code, or an index into the port list (excluding generic\n"
-		"entries). which can be used for gp_port_info_list_get_info.\n"
-		"\n"
-		"See also gphoto2.PortInfoList.append\n"
-		""},
-	 { "gp_port_info_list_load", _wrap_gp_port_info_list_load, METH_VARARGS, "\n"
-		"gp_port_info_list_load(list) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"list: gphoto2.GPPortInfoList\n"
-		"\n"
-		"Load system ports.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `list` :  \n"
-		"    a #GPPortInfoList  \n"
-		"\n"
-		"Searches the system for io-drivers and appends them to the list. You\n"
-		"would normally call this function once after gp_port_info_list_new and\n"
-		"then use this list in order to supply gp_port_set_info with parameters\n"
-		"or to do autodetection.  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code\n"
-		"\n"
-		"See also gphoto2.PortInfoList.load\n"
-		""},
-	 { "gp_port_info_list_count", _wrap_gp_port_info_list_count, METH_VARARGS, "\n"
-		"gp_port_info_list_count(list) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"list: gphoto2.GPPortInfoList\n"
-		"\n"
-		"Number of ports in the list.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `list` :  \n"
-		"    a #GPPortInfoList  \n"
-		"\n"
-		"Returns the number of entries in the passed list.  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"The number of entries or a gphoto2 error code\n"
-		"\n"
-		"See also gphoto2.PortInfoList.count\n"
-		""},
-	 { "gp_port_info_list_lookup_path", _wrap_gp_port_info_list_lookup_path, METH_VARARGS, "\n"
-		"gp_port_info_list_lookup_path(list, path) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"list: gphoto2.GPPortInfoList\n"
-		"path: str\n"
-		"\n"
-		"Lookup a specific path in the list.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `list` :  \n"
-		"    a #GPPortInfoList  \n"
-		"* `path` :  \n"
-		"    a path  \n"
-		"\n"
-		"Looks for an entry in the list with the supplied path. If no exact match\n"
-		"can be found, a regex search will be performed in the hope some driver\n"
-		"claimed ports like \"serial:*\".  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"The index of the entry or a gphoto2 error code\n"
-		"\n"
-		"See also gphoto2.PortInfoList.lookup_path\n"
-		""},
-	 { "gp_port_info_list_lookup_name", _wrap_gp_port_info_list_lookup_name, METH_VARARGS, "\n"
-		"gp_port_info_list_lookup_name(list, name) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"list: gphoto2.GPPortInfoList\n"
-		"name: str\n"
-		"\n"
-		"Look up a name in the list.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `list` :  \n"
-		"    a #GPPortInfoList  \n"
-		"* `name` :  \n"
-		"    a name  \n"
-		"\n"
-		"Looks for an entry in the list with the exact given name.  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"The index of the entry or a gphoto2 error code\n"
-		"\n"
-		"See also gphoto2.PortInfoList.lookup_name\n"
-		""},
-	 { "gp_port_info_list_get_info", _wrap_gp_port_info_list_get_info, METH_VARARGS, "\n"
-		"gp_port_info_list_get_info(list, n) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"list: gphoto2.GPPortInfoList\n"
-		"n: int\n"
-		"\n"
-		"Get port information of specific entry.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `list` :  \n"
-		"    a #GPPortInfoList  \n"
-		"* `n` :  \n"
-		"    the index of the entry  \n"
-		"* `info` :  \n"
-		"    the returned information  \n"
-		"\n"
-		"Returns a pointer to the current port entry.  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code\n"
-		"\n"
-		"See also gphoto2.PortInfoList.get_info\n"
-		""},
-	 { "gp_port_message_codeset", _wrap_gp_port_message_codeset, METH_VARARGS, "\n"
-		"gp_port_message_codeset(arg1) -> char const *\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"arg1: str\n"
-		"\n"
-		"Specify codeset for translations.  \n"
-		"\n"
-		"This function specifies the codeset that is used for the translated\n"
-		"strings that are passed back by the libgphoto2_port functions.  \n"
-		"\n"
-		"This function is called by the gp_message_codeset() function, so there\n"
-		"is no need to call it yourself.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `codeset` :  \n"
-		"    new codeset to use  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"the previous codeset\n"
-		""},
-	 { "gp_port_init_localedir", _wrap_gp_port_init_localedir, METH_VARARGS, "\n"
-		"gp_port_init_localedir(localedir) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"localedir: str\n"
-		"\n"
-		"Initialize the localedir directory for the libgphoto2_port gettext\n"
-		"domain.  \n"
-		"\n"
-		"Override the localedir directory libgphoto2_port uses for its message\n"
-		"translations.  \n"
-		"\n"
-		"This function is called by the gp_init_localedir() function, so if you\n"
-		"are calling that already, there is no need to call\n"
-		"gp_port_init_localedir() yourself.  \n"
-		"\n"
-		"You only need to call this if you have a non-standard installation where\n"
-		"the locale files are at a location which differs from the compiled in\n"
-		"default location.  \n"
-		"\n"
-		"If you need to call this function, call it before calling any non-\n"
-		"initialization function.  \n"
-		"\n"
-		"Internally, this will make sure bindtextdomain() is called for the\n"
-		"relevant gettext text domain(s).  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `localedir` :  \n"
-		"    Root directory of libgphoto2_port's localization files. If NULL, use\n"
-		"    the compiled in default value, which will be something like\n"
-		"    \"/usr/share/locale\".  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"gphoto2 error code.\n"
-		""},
-	 { NULL, NULL, 0, NULL }
-};
-
-static PyMethodDef SwigMethods_proxydocs[] = {
-	 { "SWIG_PyInstanceMethod_New", SWIG_PyInstanceMethod_New, METH_O, NULL},
-	 { "SWIG_PyStaticMethod_New", SWIG_PyStaticMethod_New, METH_O, NULL},
 	 { "gp_port_info_get_name", _wrap_gp_port_info_get_name, METH_VARARGS, "\n"
 		"gp_port_info_get_name(info) -> int\n"
 		"\n"
 		"Parameters\n"
 		"----------\n"
 		"info: gphoto2.GPPortInfo\n"
 		"\n"
@@ -5565,15 +5597,19 @@
     PyObject_HEAD_INIT(NULL)
     0,                                        /* ob_size */
 #endif
     "gphoto2.port_info_list._GPPortInfo",     /* tp_name */
     sizeof(SwigPyObject),                     /* tp_basicsize */
     0,                                        /* tp_itemsize */
     _wrap_delete__GPPortInfo_destructor_closure,                  /* tp_dealloc */
+#if PY_VERSION_HEX < 0x030800b4
     (printfunc) 0,                            /* tp_print */
+#else
+    (Py_ssize_t) 0,                           /* tp_vectorcall_offset */
+#endif
     (getattrfunc) 0,                          /* tp_getattr */
     (setattrfunc) 0,                          /* tp_setattr */
 #if PY_VERSION_HEX >= 0x03000000
     0,                                        /* tp_compare */
 #else
     (cmpfunc) 0,                              /* tp_compare */
 #endif
@@ -5637,14 +5673,17 @@
 #endif
   },
 #if PY_VERSION_HEX >= 0x03050000
   {
     (unaryfunc) 0,                            /* am_await */
     (unaryfunc) 0,                            /* am_aiter */
     (unaryfunc) 0,                            /* am_anext */
+# if PY_VERSION_HEX >= 0x030a0000
+    (sendfunc) 0,                             /* am_send */
+# endif
   },
 #endif
   {
     (binaryfunc) 0,                           /* nb_add */
     (binaryfunc) 0,                           /* nb_subtract */
     (binaryfunc) 0,                           /* nb_multiply */
 #if PY_VERSION_HEX < 0x03000000
@@ -5737,14 +5776,23 @@
   },
     (PyObject *) 0,                           /* ht_name */
     (PyObject *) 0,                           /* ht_slots */
 #if PY_VERSION_HEX >= 0x03030000
     (PyObject *) 0,                           /* ht_qualname */
     0,                                        /* ht_cached_keys */
 #endif
+#if PY_VERSION_HEX >= 0x03090000
+    (PyObject *) 0,                           /* ht_module */
+#endif
+#if PY_VERSION_HEX >= 0x030b0000
+    (char *) 0,                               /* _ht_tpname */
+  {
+    (PyObject *) 0,                           /* getitem */
+  }
+#endif
 };
 
 SWIGINTERN SwigPyClientData SwigPyBuiltin___GPPortInfo_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin___GPPortInfo_type};
 
 static SwigPyGetSet PortInfoList___dict___getset = { SwigPyObject_get___dict__, 0 };
 SWIGINTERN PyGetSetDef SwigPyBuiltin___GPPortInfoList_getset[] = {
     { (char *)"__dict__", SwigPyBuiltin_GetterClosure, 0, (char *)"__len__", &PortInfoList___dict___getset },
@@ -5933,15 +5981,19 @@
     PyObject_HEAD_INIT(NULL)
     0,                                        /* ob_size */
 #endif
     "gphoto2.port_info_list.PortInfoList",    /* tp_name */
     sizeof(SwigPyObject),                     /* tp_basicsize */
     0,                                        /* tp_itemsize */
     _wrap_delete_PortInfoList_destructor_closure,                 /* tp_dealloc */
+#if PY_VERSION_HEX < 0x030800b4
     (printfunc) 0,                            /* tp_print */
+#else
+    (Py_ssize_t) 0,                           /* tp_vectorcall_offset */
+#endif
     (getattrfunc) 0,                          /* tp_getattr */
     (setattrfunc) 0,                          /* tp_setattr */
 #if PY_VERSION_HEX >= 0x03000000
     0,                                        /* tp_compare */
 #else
     (cmpfunc) 0,                              /* tp_compare */
 #endif
@@ -6005,14 +6057,17 @@
 #endif
   },
 #if PY_VERSION_HEX >= 0x03050000
   {
     (unaryfunc) 0,                            /* am_await */
     (unaryfunc) 0,                            /* am_aiter */
     (unaryfunc) 0,                            /* am_anext */
+# if PY_VERSION_HEX >= 0x030a0000
+    (sendfunc) 0,                             /* am_send */
+# endif
   },
 #endif
   {
     (binaryfunc) 0,                           /* nb_add */
     (binaryfunc) 0,                           /* nb_subtract */
     (binaryfunc) 0,                           /* nb_multiply */
 #if PY_VERSION_HEX < 0x03000000
@@ -6105,78 +6160,87 @@
   },
     (PyObject *) 0,                           /* ht_name */
     (PyObject *) 0,                           /* ht_slots */
 #if PY_VERSION_HEX >= 0x03030000
     (PyObject *) 0,                           /* ht_qualname */
     0,                                        /* ht_cached_keys */
 #endif
+#if PY_VERSION_HEX >= 0x03090000
+    (PyObject *) 0,                           /* ht_module */
+#endif
+#if PY_VERSION_HEX >= 0x030b0000
+    (char *) 0,                               /* _ht_tpname */
+  {
+    (PyObject *) 0,                           /* getitem */
+  }
+#endif
 };
 
 SWIGINTERN SwigPyClientData SwigPyBuiltin___GPPortInfoList_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin___GPPortInfoList_type};
 
 
 /* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */
 
 static swig_type_info _swigt__p_CameraAbilities = {"_p_CameraAbilities", "CameraAbilities *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraCaptureType = {"_p_CameraCaptureType", "enum CameraCaptureType *|CameraCaptureType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraDriverStatus = {"_p_CameraDriverStatus", "enum CameraDriverStatus *|CameraDriverStatus *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraEventType = {"_p_CameraEventType", "enum CameraEventType *|CameraEventType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileAccessType = {"_p_CameraFileAccessType", "enum CameraFileAccessType *|CameraFileAccessType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileInfoFields = {"_p_CameraFileInfoFields", "enum CameraFileInfoFields *|CameraFileInfoFields *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileOperation = {"_p_CameraFileOperation", "enum CameraFileOperation *|CameraFileOperation *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraCaptureType = {"_p_CameraCaptureType", "CameraCaptureType *|enum CameraCaptureType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraDriverStatus = {"_p_CameraDriverStatus", "CameraDriverStatus *|enum CameraDriverStatus *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraEventType = {"_p_CameraEventType", "CameraEventType *|enum CameraEventType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileAccessType = {"_p_CameraFileAccessType", "CameraFileAccessType *|enum CameraFileAccessType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileInfoFields = {"_p_CameraFileInfoFields", "CameraFileInfoFields *|enum CameraFileInfoFields *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileOperation = {"_p_CameraFileOperation", "CameraFileOperation *|enum CameraFileOperation *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_CameraFilePath = {"_p_CameraFilePath", "CameraFilePath *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFilePermissions = {"_p_CameraFilePermissions", "enum CameraFilePermissions *|CameraFilePermissions *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileStatus = {"_p_CameraFileStatus", "enum CameraFileStatus *|CameraFileStatus *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileType = {"_p_CameraFileType", "enum CameraFileType *|CameraFileType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFolderOperation = {"_p_CameraFolderOperation", "enum CameraFolderOperation *|CameraFolderOperation *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraOperation = {"_p_CameraOperation", "enum CameraOperation *|CameraOperation *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraStorageAccessType = {"_p_CameraStorageAccessType", "enum CameraStorageAccessType *|CameraStorageAccessType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraStorageFilesystemType = {"_p_CameraStorageFilesystemType", "enum CameraStorageFilesystemType *|CameraStorageFilesystemType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraStorageInfoFields = {"_p_CameraStorageInfoFields", "enum CameraStorageInfoFields *|CameraStorageInfoFields *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraStorageType = {"_p_CameraStorageType", "enum CameraStorageType *|CameraStorageType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFilePermissions = {"_p_CameraFilePermissions", "CameraFilePermissions *|enum CameraFilePermissions *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileStatus = {"_p_CameraFileStatus", "CameraFileStatus *|enum CameraFileStatus *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileType = {"_p_CameraFileType", "CameraFileType *|enum CameraFileType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFolderOperation = {"_p_CameraFolderOperation", "CameraFolderOperation *|enum CameraFolderOperation *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraOperation = {"_p_CameraOperation", "CameraOperation *|enum CameraOperation *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraStorageAccessType = {"_p_CameraStorageAccessType", "CameraStorageAccessType *|enum CameraStorageAccessType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraStorageFilesystemType = {"_p_CameraStorageFilesystemType", "CameraStorageFilesystemType *|enum CameraStorageFilesystemType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraStorageInfoFields = {"_p_CameraStorageInfoFields", "CameraStorageInfoFields *|enum CameraStorageInfoFields *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraStorageType = {"_p_CameraStorageType", "CameraStorageType *|enum CameraStorageType *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_CameraText = {"_p_CameraText", "CameraText *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraWidgetType = {"_p_CameraWidgetType", "enum CameraWidgetType *|CameraWidgetType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_GPLogLevel = {"_p_GPLogLevel", "enum GPLogLevel *|GPLogLevel *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_GPPortType = {"_p_GPPortType", "enum GPPortType *|GPPortType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_GPVersionVerbosity = {"_p_GPVersionVerbosity", "enum GPVersionVerbosity *|GPVersionVerbosity *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_GphotoDeviceType = {"_p_GphotoDeviceType", "enum GphotoDeviceType *|GphotoDeviceType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraWidgetType = {"_p_CameraWidgetType", "CameraWidgetType *|enum CameraWidgetType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GPLogLevel = {"_p_GPLogLevel", "GPLogLevel *|enum GPLogLevel *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GPPortType = {"_p_GPPortType", "GPPortType *|enum GPPortType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GPVersionVerbosity = {"_p_GPVersionVerbosity", "GPVersionVerbosity *|enum GPVersionVerbosity *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GphotoDeviceType = {"_p_GphotoDeviceType", "GphotoDeviceType *|enum GphotoDeviceType *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_SwigPyObject = {"_p_SwigPyObject", "SwigPyObject *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__Camera = {"_p__Camera", "struct _Camera *|Camera *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraAbilitiesList = {"_p__CameraAbilitiesList", "struct _CameraAbilitiesList *|CameraAbilitiesList *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFile = {"_p__CameraFile", "struct _CameraFile *|CameraFile *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFileHandler = {"_p__CameraFileHandler", "struct _CameraFileHandler *|CameraFileHandler *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFileInfo = {"_p__CameraFileInfo", "struct _CameraFileInfo *|CameraFileInfo *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFileInfoAudio = {"_p__CameraFileInfoAudio", "struct _CameraFileInfoAudio *|CameraFileInfoAudio *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFileInfoFile = {"_p__CameraFileInfoFile", "struct _CameraFileInfoFile *|CameraFileInfoFile *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFileInfoPreview = {"_p__CameraFileInfoPreview", "struct _CameraFileInfoPreview *|CameraFileInfoPreview *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFilesystem = {"_p__CameraFilesystem", "struct _CameraFilesystem *|CameraFilesystem *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFilesystemFuncs = {"_p__CameraFilesystemFuncs", "struct _CameraFilesystemFuncs *|CameraFilesystemFuncs *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFunctions = {"_p__CameraFunctions", "struct _CameraFunctions *|CameraFunctions *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraList = {"_p__CameraList", "struct _CameraList *|CameraList *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraPrivateCore = {"_p__CameraPrivateCore", "struct _CameraPrivateCore *|CameraPrivateCore *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraPrivateLibrary = {"_p__CameraPrivateLibrary", "struct _CameraPrivateLibrary *|CameraPrivateLibrary *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraStorageInformation = {"_p__CameraStorageInformation", "struct _CameraStorageInformation *|CameraStorageInformation *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraWidget = {"_p__CameraWidget", "struct _CameraWidget *|CameraWidget *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__GPContext = {"_p__GPContext", "struct _GPContext *|GPContext *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__GPContextFeedback = {"_p__GPContextFeedback", "enum _GPContextFeedback *|GPContextFeedback *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__GPPortInfo = {"_p__GPPortInfo", "_GPPortInfo *|struct _GPPortInfo *|GPPortInfo", 0, 0, (void*)&SwigPyBuiltin___GPPortInfo_clientdata, 0};
-static swig_type_info _swigt__p__GPPortInfoList = {"_p__GPPortInfoList", "struct _GPPortInfoList *|_GPPortInfoList *|GPPortInfoList *", 0, 0, (void*)&SwigPyBuiltin___GPPortInfoList_clientdata, 0};
+static swig_type_info _swigt__p__Camera = {"_p__Camera", "Camera *|struct _Camera *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraAbilitiesList = {"_p__CameraAbilitiesList", "CameraAbilitiesList *|struct _CameraAbilitiesList *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFile = {"_p__CameraFile", "CameraFile *|struct _CameraFile *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFileHandler = {"_p__CameraFileHandler", "CameraFileHandler *|struct _CameraFileHandler *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFileInfo = {"_p__CameraFileInfo", "CameraFileInfo *|struct _CameraFileInfo *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFileInfoAudio = {"_p__CameraFileInfoAudio", "CameraFileInfoAudio *|struct _CameraFileInfoAudio *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFileInfoFile = {"_p__CameraFileInfoFile", "CameraFileInfoFile *|struct _CameraFileInfoFile *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFileInfoPreview = {"_p__CameraFileInfoPreview", "CameraFileInfoPreview *|struct _CameraFileInfoPreview *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFilesystem = {"_p__CameraFilesystem", "CameraFilesystem *|struct _CameraFilesystem *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFilesystemFuncs = {"_p__CameraFilesystemFuncs", "CameraFilesystemFuncs *|struct _CameraFilesystemFuncs *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFunctions = {"_p__CameraFunctions", "CameraFunctions *|struct _CameraFunctions *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraList = {"_p__CameraList", "CameraList *|struct _CameraList *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraPrivateCore = {"_p__CameraPrivateCore", "CameraPrivateCore *|struct _CameraPrivateCore *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraPrivateLibrary = {"_p__CameraPrivateLibrary", "CameraPrivateLibrary *|struct _CameraPrivateLibrary *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraStorageInformation = {"_p__CameraStorageInformation", "CameraStorageInformation *|struct _CameraStorageInformation *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraWidget = {"_p__CameraWidget", "CameraWidget *|struct _CameraWidget *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__GPContext = {"_p__GPContext", "GPContext *|struct _GPContext *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__GPContextFeedback = {"_p__GPContextFeedback", "GPContextFeedback *|enum _GPContextFeedback *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__GPPortInfo = {"_p__GPPortInfo", "GPPortInfo|struct _GPPortInfo *|_GPPortInfo *", 0, 0, (void*)&SwigPyBuiltin___GPPortInfo_clientdata, 0};
+static swig_type_info _swigt__p__GPPortInfoList = {"_p__GPPortInfoList", "GPPortInfoList *|struct _GPPortInfoList *|_GPPortInfoList *", 0, 0, (void*)&SwigPyBuiltin___GPPortInfoList_clientdata, 0};
 static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_int = {"_p_int", "intptr_t *|int *|int_least32_t *|int_fast32_t *|int32_t *|int_fast16_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_long = {"_p_long", "long *|time_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_long_long = {"_p_long_long", "int_least64_t *|int_fast64_t *|int64_t *|long long *|intmax_t *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_int = {"_p_int", "int32_t *|int_fast16_t *|int_fast32_t *|int_least32_t *|intptr_t *|int *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_long = {"_p_long", "time_t *|long *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_long_long = {"_p_long_long", "int64_t *|int_fast64_t *|int_least64_t *|intmax_t *|long long *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_p__GPPortInfo = {"_p_p__GPPortInfo", "GPPortInfo *|struct _GPPortInfo **", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_p__GPPortInfoList = {"_p_p__GPPortInfoList", "struct _GPPortInfoList **|GPPortInfoList **", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_p__GPPortInfoList = {"_p_p__GPPortInfoList", "GPPortInfoList **|struct _GPPortInfoList **", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_p_char = {"_p_p_char", "char **", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_short = {"_p_short", "short *|int_least16_t *|int16_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_signed_char = {"_p_signed_char", "signed char *|int_least8_t *|int_fast8_t *|int8_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_unsigned_char = {"_p_unsigned_char", "unsigned char *|uint_least8_t *|uint_fast8_t *|uint8_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_unsigned_int = {"_p_unsigned_int", "uintptr_t *|uint_least32_t *|uint_fast32_t *|uint32_t *|unsigned int *|uint_fast16_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_unsigned_long_long = {"_p_unsigned_long_long", "uint_least64_t *|uint_fast64_t *|uint64_t *|unsigned long long *|uintmax_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_unsigned_short = {"_p_unsigned_short", "unsigned short *|uint_least16_t *|uint16_t *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_short = {"_p_short", "int16_t *|int_least16_t *|short *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_signed_char = {"_p_signed_char", "int8_t *|int_fast8_t *|int_least8_t *|signed char *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_unsigned_char = {"_p_unsigned_char", "uint8_t *|uint_fast8_t *|uint_least8_t *|unsigned char *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_unsigned_int = {"_p_unsigned_int", "uint32_t *|uint_fast16_t *|uint_fast32_t *|uint_least32_t *|uintptr_t *|unsigned int *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_unsigned_long_long = {"_p_unsigned_long_long", "uint64_t *|uint_fast64_t *|uint_least64_t *|uintmax_t *|unsigned long long *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_unsigned_short = {"_p_unsigned_short", "uint16_t *|uint_least16_t *|unsigned short *", 0, 0, (void*)0, 0};
 
 static swig_type_info *swig_type_initial[] = {
   &_swigt__p_CameraAbilities,
   &_swigt__p_CameraCaptureType,
   &_swigt__p_CameraDriverStatus,
   &_swigt__p_CameraEventType,
   &_swigt__p_CameraFileAccessType,
@@ -6411,17 +6475,20 @@
 #endif
 #endif
 
 #if 0
 #define SWIGRUNTIME_DEBUG
 #endif
 
+#ifndef SWIG_INIT_CLIENT_DATA_TYPE
+#define SWIG_INIT_CLIENT_DATA_TYPE void *
+#endif
 
 SWIGRUNTIME void
-SWIG_InitializeModule(void *clientdata) {
+SWIG_InitializeModule(SWIG_INIT_CLIENT_DATA_TYPE clientdata) {
   size_t i;
   swig_module_info *module_head, *iter;
   int init;
   
   /* check to see if the circular list has been setup, if not, set it up */
   if (swig_module.next==0) {
     /* Initialize the swig_module */
@@ -6596,228 +6663,14 @@
 
 
 
 #ifdef __cplusplus
 extern "C" {
 #endif
   
-  /* Python-specific SWIG API */
-#define SWIG_newvarlink()                             SWIG_Python_newvarlink()
-#define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
-#define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)
-  
-  /* -----------------------------------------------------------------------------
-   * global variable support code.
-   * ----------------------------------------------------------------------------- */
-  
-  typedef struct swig_globalvar {
-    char       *name;                  /* Name of global variable */
-    PyObject *(*get_attr)(void);       /* Return the current value */
-    int       (*set_attr)(PyObject *); /* Set the value */
-    struct swig_globalvar *next;
-  } swig_globalvar;
-  
-  typedef struct swig_varlinkobject {
-    PyObject_HEAD
-    swig_globalvar *vars;
-  } swig_varlinkobject;
-  
-  SWIGINTERN PyObject *
-  swig_varlink_repr(swig_varlinkobject *SWIGUNUSEDPARM(v)) {
-#if PY_VERSION_HEX >= 0x03000000
-    return PyUnicode_InternFromString("<Swig global variables>");
-#else
-    return PyString_FromString("<Swig global variables>");
-#endif
-  }
-  
-  SWIGINTERN PyObject *
-  swig_varlink_str(swig_varlinkobject *v) {
-#if PY_VERSION_HEX >= 0x03000000
-    PyObject *str = PyUnicode_InternFromString("(");
-    PyObject *tail;
-    PyObject *joined;
-    swig_globalvar *var;
-    for (var = v->vars; var; var=var->next) {
-      tail = PyUnicode_FromString(var->name);
-      joined = PyUnicode_Concat(str, tail);
-      Py_DecRef(str);
-      Py_DecRef(tail);
-      str = joined;
-      if (var->next) {
-        tail = PyUnicode_InternFromString(", ");
-        joined = PyUnicode_Concat(str, tail);
-        Py_DecRef(str);
-        Py_DecRef(tail);
-        str = joined;
-      }
-    }
-    tail = PyUnicode_InternFromString(")");
-    joined = PyUnicode_Concat(str, tail);
-    Py_DecRef(str);
-    Py_DecRef(tail);
-    str = joined;
-#else
-    PyObject *str = PyString_FromString("(");
-    swig_globalvar *var;
-    for (var = v->vars; var; var=var->next) {
-      PyString_ConcatAndDel(&str,PyString_FromString(var->name));
-      if (var->next) PyString_ConcatAndDel(&str,PyString_FromString(", "));
-    }
-    PyString_ConcatAndDel(&str,PyString_FromString(")"));
-#endif
-    return str;
-  }
-  
-  SWIGINTERN void
-  swig_varlink_dealloc(swig_varlinkobject *v) {
-    swig_globalvar *var = v->vars;
-    while (var) {
-      swig_globalvar *n = var->next;
-      free(var->name);
-      free(var);
-      var = n;
-    }
-  }
-  
-  SWIGINTERN PyObject *
-  swig_varlink_getattr(swig_varlinkobject *v, char *n) {
-    PyObject *res = NULL;
-    swig_globalvar *var = v->vars;
-    while (var) {
-      if (strcmp(var->name,n) == 0) {
-        res = (*var->get_attr)();
-        break;
-      }
-      var = var->next;
-    }
-    if (res == NULL && !PyErr_Occurred()) {
-      PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
-    }
-    return res;
-  }
-  
-  SWIGINTERN int
-  swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
-    int res = 1;
-    swig_globalvar *var = v->vars;
-    while (var) {
-      if (strcmp(var->name,n) == 0) {
-        res = (*var->set_attr)(p);
-        break;
-      }
-      var = var->next;
-    }
-    if (res == 1 && !PyErr_Occurred()) {
-      PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
-    }
-    return res;
-  }
-  
-  SWIGINTERN PyTypeObject*
-  swig_varlink_type(void) {
-    static char varlink__doc__[] = "Swig var link object";
-    static PyTypeObject varlink_type;
-    static int type_init = 0;
-    if (!type_init) {
-      const PyTypeObject tmp = {
-#if PY_VERSION_HEX >= 0x03000000
-        PyVarObject_HEAD_INIT(NULL, 0)
-#else
-        PyObject_HEAD_INIT(NULL)
-        0,                                  /* ob_size */
-#endif
-        "swigvarlink",                      /* tp_name */
-        sizeof(swig_varlinkobject),         /* tp_basicsize */
-        0,                                  /* tp_itemsize */
-        (destructor) swig_varlink_dealloc,  /* tp_dealloc */
-        0,                                  /* tp_print */
-        (getattrfunc) swig_varlink_getattr, /* tp_getattr */
-        (setattrfunc) swig_varlink_setattr, /* tp_setattr */
-        0,                                  /* tp_compare */
-        (reprfunc) swig_varlink_repr,       /* tp_repr */
-        0,                                  /* tp_as_number */
-        0,                                  /* tp_as_sequence */
-        0,                                  /* tp_as_mapping */
-        0,                                  /* tp_hash */
-        0,                                  /* tp_call */
-        (reprfunc) swig_varlink_str,        /* tp_str */
-        0,                                  /* tp_getattro */
-        0,                                  /* tp_setattro */
-        0,                                  /* tp_as_buffer */
-        0,                                  /* tp_flags */
-        varlink__doc__,                     /* tp_doc */
-        0,                                  /* tp_traverse */
-        0,                                  /* tp_clear */
-        0,                                  /* tp_richcompare */
-        0,                                  /* tp_weaklistoffset */
-        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
-        0,                                  /* tp_del */
-        0,                                  /* tp_version_tag */
-#if PY_VERSION_HEX >= 0x03040000
-        0,                                  /* tp_finalize */
-#endif
-#if PY_VERSION_HEX >= 0x03080000
-        0,                                  /* tp_vectorcall */
-#endif
-#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
-        0,                                  /* tp_print */
-#endif
-#ifdef COUNT_ALLOCS
-        0,                                  /* tp_allocs */
-        0,                                  /* tp_frees */
-        0,                                  /* tp_maxalloc */
-        0,                                  /* tp_prev */
-        0                                   /* tp_next */
-#endif
-      };
-      varlink_type = tmp;
-      type_init = 1;
-      if (PyType_Ready(&varlink_type) < 0)
-      return NULL;
-    }
-    return &varlink_type;
-  }
-  
-  /* Create a variable linking object for use later */
-  SWIGINTERN PyObject *
-  SWIG_Python_newvarlink(void) {
-    swig_varlinkobject *result = PyObject_NEW(swig_varlinkobject, swig_varlink_type());
-    if (result) {
-      result->vars = 0;
-    }
-    return ((PyObject*) result);
-  }
-  
-  SWIGINTERN void 
-  SWIG_Python_addvarlink(PyObject *p, const char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
-    swig_varlinkobject *v = (swig_varlinkobject *) p;
-    swig_globalvar *gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
-    if (gv) {
-      size_t size = strlen(name)+1;
-      gv->name = (char *)malloc(size);
-      if (gv->name) {
-        memcpy(gv->name, name, size);
-        gv->get_attr = get_attr;
-        gv->set_attr = set_attr;
-        gv->next = v->vars;
-      }
-    }
-    v->vars = gv;
-  }
-  
-  SWIGINTERN PyObject *
-  SWIG_globals(void) {
-    static PyObject *globals = 0;
-    if (!globals) {
-      globals = SWIG_newvarlink();
-    }
-    return globals;
-  }
-  
   /* -----------------------------------------------------------------------------
    * constants/methods manipulation
    * ----------------------------------------------------------------------------- */
   
   /* Install Constants */
   SWIGINTERN void
   SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
@@ -6838,31 +6691,28 @@
       if (obj) {
         PyDict_SetItemString(d, constants[i].name, obj);
         Py_DECREF(obj);
       }
     }
   }
   
-  /* -----------------------------------------------------------------------------*/
-  /* Fix SwigMethods to carry the callback ptrs when needed */
-  /* -----------------------------------------------------------------------------*/
+  /* -----------------------------------------------------------------------------
+   * Patch %callback methods' docstrings to hold the callback ptrs
+   * -----------------------------------------------------------------------------*/
   
   SWIGINTERN void
-  SWIG_Python_FixMethods(PyMethodDef *methods,
-    swig_const_info *const_table,
-    swig_type_info **types,
-    swig_type_info **types_initial) {
+  SWIG_Python_FixMethods(PyMethodDef *methods, const swig_const_info *const_table, swig_type_info **types, swig_type_info **types_initial) {
     size_t i;
     for (i = 0; methods[i].ml_name; ++i) {
       const char *c = methods[i].ml_doc;
       if (!c) continue;
       c = strstr(c, "swig_ptr: ");
       if (c) {
         int j;
-        swig_const_info *ci = 0;
+        const swig_const_info *ci = 0;
         const char *name = c + 10;
         for (j = 0; const_table[j].type; ++j) {
           if (strncmp(const_table[j].name, name, 
               strlen(const_table[j].name)) == 0) {
             ci = &(const_table[j]);
             break;
           }
@@ -6886,76 +6736,21 @@
             }
           }
         }
       }
     }
   } 
   
-  /* -----------------------------------------------------------------------------
-   * Method creation and docstring support functions
-   * ----------------------------------------------------------------------------- */
-  
-  /* -----------------------------------------------------------------------------
-   * Function to find the method definition with the correct docstring for the
-   * proxy module as opposed to the low-level API
-   * ----------------------------------------------------------------------------- */
-  
-  SWIGINTERN PyMethodDef *SWIG_PythonGetProxyDoc(const char *name) {
-    /* Find the function in the modified method table */
-    size_t offset = 0;
-    int found = 0;
-    while (SwigMethods_proxydocs[offset].ml_meth != NULL) {
-      if (strcmp(SwigMethods_proxydocs[offset].ml_name, name) == 0) {
-        found = 1;
-        break;
-      }
-      offset++;
-    }
-    /* Use the copy with the modified docstring if available */
-    return found ? &SwigMethods_proxydocs[offset] : NULL;
-  }
-  
-  /* -----------------------------------------------------------------------------
-   * Wrapper of PyInstanceMethod_New() used in Python 3
-   * It is exported to the generated module, used for -fastproxy
-   * ----------------------------------------------------------------------------- */
-  
-  SWIGINTERN PyObject *SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func) {
-    if (PyCFunction_Check(func)) {
-      PyCFunctionObject *funcobj = (PyCFunctionObject *)func;
-      PyMethodDef *ml = SWIG_PythonGetProxyDoc(funcobj->m_ml->ml_name);
-      if (ml)
-      func = PyCFunction_NewEx(ml, funcobj->m_self, funcobj->m_module);
-    }
-#if PY_VERSION_HEX >= 0x03000000
-    return PyInstanceMethod_New(func);
-#else
-    return PyMethod_New(func, NULL, NULL);
-#endif
-  }
-  
-  /* -----------------------------------------------------------------------------
-   * Wrapper of PyStaticMethod_New()
-   * It is exported to the generated module, used for -fastproxy
-   * ----------------------------------------------------------------------------- */
-  
-  SWIGINTERN PyObject *SWIG_PyStaticMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func) {
-    if (PyCFunction_Check(func)) {
-      PyCFunctionObject *funcobj = (PyCFunctionObject *)func;
-      PyMethodDef *ml = SWIG_PythonGetProxyDoc(funcobj->m_ml->ml_name);
-      if (ml)
-      func = PyCFunction_NewEx(ml, funcobj->m_self, funcobj->m_module);
-    }
-    return PyStaticMethod_New(func);
-  }
-  
 #ifdef __cplusplus
 }
 #endif
 
+
+
+
 /* -----------------------------------------------------------------------------*
  *  Partial Init method
  * -----------------------------------------------------------------------------*/
 
 #ifdef __cplusplus
 extern "C"
 #endif
```

### Comparing `gphoto2-2.3.4/src/swig-gp2.5.30/port_log_wrap.c` & `gphoto2-2.3.5/src/swig-gp2_5_30/port_log_wrap.c`

 * *Files 2% similar despite different names*

```diff
@@ -1,24 +1,21 @@
 /* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 4.0.2
+ * This file was automatically generated by SWIG (https://www.swig.org).
+ * Version 4.1.1
  *
- * This file is not intended to be easily readable and contains a number of
- * coding conventions designed to improve portability and efficiency. Do not make
- * changes to this file unless you know what you are doing--modify the SWIG
- * interface file instead.
+ * Do not make changes to this file unless you know what you are doing - modify
+ * the SWIG interface file instead.
  * ----------------------------------------------------------------------------- */
 
 
-#ifndef SWIGPYTHON
+#define SWIG_VERSION 0x040101
 #define SWIGPYTHON
-#endif
-
 #define SWIG_PYTHON_DIRECTOR_NO_VTABLE
 #define SWIGPYTHON_BUILTIN
+#define SWIGPYTHON_FASTPROXY
 
 /* -----------------------------------------------------------------------------
  *  This section contains generic SWIG labels for method/variable
  *  declarations/attributes, and other compiler dependent labels.
  * ----------------------------------------------------------------------------- */
 
 /* template workaround for compilers that cannot correctly implement the C++ standard */
@@ -142,23 +139,45 @@
 
 
 #if defined(__GNUC__) && defined(_WIN32) && !defined(SWIG_PYTHON_NO_HYPOT_WORKAROUND)
 /* Workaround for '::hypot' has not been declared', see https://bugs.python.org/issue11566 */
 # include <math.h>
 #endif
 
+#if !defined(PY_SSIZE_T_CLEAN) && !defined(SWIG_NO_PY_SSIZE_T_CLEAN)
+#define PY_SSIZE_T_CLEAN
+#endif
+
+#if __GNUC__ >= 7
+#pragma GCC diagnostic push
+#if defined(__cplusplus) && __cplusplus >=201703L
+#pragma GCC diagnostic ignored "-Wregister" /* For python-2.7 headers that use register */
+#endif
+#endif
+
 #if defined(_DEBUG) && defined(SWIG_PYTHON_INTERPRETER_NO_DEBUG)
 /* Use debug wrappers with the Python release dll */
+
+#if defined(_MSC_VER) && _MSC_VER >= 1929
+/* Workaround compilation errors when redefining _DEBUG in MSVC 2019 version 16.10 and later
+ * See https://github.com/swig/swig/issues/2090 */
+# include <corecrt.h>
+#endif
+
 # undef _DEBUG
 # include <Python.h>
 # define _DEBUG 1
 #else
 # include <Python.h>
 #endif
 
+#if __GNUC__ >= 7
+#pragma GCC diagnostic pop
+#endif
+
 /* -----------------------------------------------------------------------------
  * swigrun.swg
  *
  * This file contains generic C API SWIG runtime support for pointer
  * type checking.
  * ----------------------------------------------------------------------------- */
 
@@ -197,14 +216,16 @@
 # define SWIG_BUFFER_SIZE 1024
 #endif
 
 /* Flags for pointer conversions */
 #define SWIG_POINTER_DISOWN        0x1
 #define SWIG_CAST_NEW_MEMORY       0x2
 #define SWIG_POINTER_NO_NULL       0x4
+#define SWIG_POINTER_CLEAR         0x8
+#define SWIG_POINTER_RELEASE       (SWIG_POINTER_CLEAR | SWIG_POINTER_DISOWN)
 
 /* Flags for new pointer objects */
 #define SWIG_POINTER_OWN           0x1
 
 
 /*
    Flags/methods for returning states.
@@ -268,44 +289,50 @@
       }
 
    Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
    more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
    SWIG errors code.
 
    Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
-   allows to return the 'cast rank', for example, if you have this
+   allows returning the 'cast rank', for example, if you have this
 
        int food(double)
        int fooi(int);
 
    and you call
 
       food(1)   // cast rank '1'  (1 -> 1.0)
       fooi(1)   // cast rank '0'
 
    just use the SWIG_AddCast()/SWIG_CheckState()
 */
 
 #define SWIG_OK                    (0)
+/* Runtime errors are < 0 */
 #define SWIG_ERROR                 (-1)
+/* Errors in range -1 to -99 are in swigerrors.swg (errors for all languages including those not using the runtime) */
+/* Errors in range -100 to -199 are language specific errors defined in *errors.swg */
+/* Errors < -200 are generic runtime specific errors */
+#define SWIG_ERROR_RELEASE_NOT_OWNED (-200)
+
 #define SWIG_IsOK(r)               (r >= 0)
 #define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)
 
 /* The CastRankLimit says how many bits are used for the cast rank */
 #define SWIG_CASTRANKLIMIT         (1 << 8)
 /* The NewMask denotes the object was created (using new/malloc) */
 #define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
 /* The TmpMask is for in/out typemaps that use temporal objects */
 #define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
 /* Simple returning values */
 #define SWIG_BADOBJ                (SWIG_ERROR)
 #define SWIG_OLDOBJ                (SWIG_OK)
 #define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
 #define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
-/* Check, add and del mask methods */
+/* Check, add and del object mask methods */
 #define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
 #define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
 #define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
 #define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
 #define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
 #define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))
 
@@ -443,15 +470,15 @@
   return 0;
 }
 
 /*
   Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
 */
 SWIGRUNTIME swig_cast_info *
-SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty) {
+SWIG_TypeCheckStruct(const swig_type_info *from, swig_type_info *ty) {
   if (ty) {
     swig_cast_info *iter = ty->cast;
     while (iter) {
       if (iter->type == from) {
         if (iter == ty->cast)
           return iter;
         /* Move iter to the top of the linked list */
@@ -503,17 +530,17 @@
 /*
   Return the pretty name associated with this type,
   that is an unmangled type name in a form presentable to the user.
 */
 SWIGRUNTIME const char *
 SWIG_TypePrettyName(const swig_type_info *type) {
   /* The "str" field contains the equivalent pretty names of the
-     type, separated by vertical-bar characters.  We choose
-     to print the last name, as it is often (?) the most
-     specific. */
+     type, separated by vertical-bar characters.  Choose the last
+     name. It should be the most specific; a fully resolved name
+     but not necessarily with default template parameters expanded. */
   if (!type) return NULL;
   if (type->str != NULL) {
     const char *last_name = type->str;
     const char *s;
     for (s = type->str; *s; s++)
       if (*s == '|') last_name = s+1;
     return last_name;
@@ -725,15 +752,15 @@
   return SWIG_UnpackData(++c,ptr,sz);
 }
 
 #ifdef __cplusplus
 }
 #endif
 
-/*  Errors in SWIG */
+/* SWIG Errors applicable to all language modules, values are reserved from -1 to -99 */
 #define  SWIG_UnknownError    	   -1
 #define  SWIG_IOError        	   -2
 #define  SWIG_RuntimeError   	   -3
 #define  SWIG_IndexError     	   -4
 #define  SWIG_TypeError      	   -5
 #define  SWIG_DivisionByZero 	   -6
 #define  SWIG_OverflowError  	   -7
@@ -741,15 +768,14 @@
 #define  SWIG_ValueError     	   -9
 #define  SWIG_SystemError    	   -10
 #define  SWIG_AttributeError 	   -11
 #define  SWIG_MemoryError    	   -12
 #define  SWIG_NullReferenceError   -13
 
 
-
 /* Compatibility macros for Python 3 */
 #if PY_VERSION_HEX >= 0x03000000
 
 #define PyClass_Check(obj) PyObject_IsInstance(obj, (PyObject *)&PyType_Type)
 #define PyInt_Check(x) PyLong_Check(x)
 #define PyInt_AsLong(x) PyLong_AsLong(x)
 #define PyInt_FromLong(x) PyLong_FromLong(x)
@@ -757,15 +783,14 @@
 #define PyString_Check(name) PyBytes_Check(name)
 #define PyString_FromString(x) PyUnicode_FromString(x)
 #define PyString_Format(fmt, args)  PyUnicode_Format(fmt, args)
 #define PyString_AsString(str) PyBytes_AsString(str)
 #define PyString_Size(str) PyBytes_Size(str)	
 #define PyString_InternFromString(key) PyUnicode_InternFromString(key)
 #define Py_TPFLAGS_HAVE_CLASS Py_TPFLAGS_BASETYPE
-#define PyString_AS_STRING(x) PyUnicode_AS_STRING(x)
 #define _PyLong_FromSsize_t(x) PyLong_FromSsize_t(x)
 
 #endif
 
 #ifndef Py_TYPE
 #  define Py_TYPE(op) ((op)->ob_type)
 #endif
@@ -775,46 +800,27 @@
 #if PY_VERSION_HEX >= 0x03000000
 #  define SWIG_Python_str_FromFormat PyUnicode_FromFormat
 #else
 #  define SWIG_Python_str_FromFormat PyString_FromFormat
 #endif
 
 
-/* Warning: This function will allocate a new string in Python 3,
- * so please call SWIG_Python_str_DelForPy3(x) to free the space.
- */
 SWIGINTERN char*
 SWIG_Python_str_AsChar(PyObject *str)
 {
 #if PY_VERSION_HEX >= 0x03030000
   return (char *)PyUnicode_AsUTF8(str);
-#elif PY_VERSION_HEX >= 0x03000000
-  char *newstr = 0;
-  str = PyUnicode_AsUTF8String(str);
-  if (str) {
-    char *cstr;
-    Py_ssize_t len;
-    if (PyBytes_AsStringAndSize(str, &cstr, &len) != -1) {
-      newstr = (char *) malloc(len+1);
-      if (newstr)
-        memcpy(newstr, cstr, len+1);
-    }
-    Py_XDECREF(str);
-  }
-  return newstr;
 #else
   return PyString_AsString(str);
 #endif
 }
 
-#if PY_VERSION_HEX >= 0x03030000 || PY_VERSION_HEX < 0x03000000
-#  define SWIG_Python_str_DelForPy3(x)
-#else
-#  define SWIG_Python_str_DelForPy3(x) free( (void*) (x) )
-#endif
+/* Was useful for Python 3.0.x-3.2.x - now provided only for compatibility
+ * with any uses in user interface files. */
+#define SWIG_Python_str_DelForPy3(x)
 
 
 SWIGINTERN PyObject*
 SWIG_Python_str_FromChar(const char *c)
 {
 #if PY_VERSION_HEX >= 0x03000000
   return PyUnicode_FromString(c); 
@@ -823,18 +829,22 @@
 #endif
 }
 
 #ifndef PyObject_DEL
 # define PyObject_DEL PyObject_Del
 #endif
 
-// SWIGPY_USE_CAPSULE is no longer used within SWIG itself, but some user
-// interface files check for it.
+/* SWIGPY_USE_CAPSULE is no longer used within SWIG itself, but some user interface files check for it. */
 # define SWIGPY_USE_CAPSULE
-# define SWIGPY_CAPSULE_NAME ("swig_runtime_data" SWIG_RUNTIME_VERSION ".type_pointer_capsule" SWIG_TYPE_TABLE_NAME)
+#ifdef SWIGPYTHON_BUILTIN
+# define SWIGPY_CAPSULE_ATTR_NAME "type_pointer_capsule_builtin" SWIG_TYPE_TABLE_NAME
+#else
+# define SWIGPY_CAPSULE_ATTR_NAME "type_pointer_capsule" SWIG_TYPE_TABLE_NAME
+#endif
+# define SWIGPY_CAPSULE_NAME ("swig_runtime_data" SWIG_RUNTIME_VERSION "." SWIGPY_CAPSULE_ATTR_NAME)
 
 #if PY_VERSION_HEX < 0x03020000
 #define PyDescr_TYPE(x) (((PyDescrObject *)(x))->d_type)
 #define PyDescr_NAME(x) (((PyDescrObject *)(x))->d_name)
 #define Py_hash_t long
 #endif
 
@@ -900,15 +910,14 @@
     const char *tmp = SWIG_Python_str_AsChar(old_str);
     PyErr_Clear();
     Py_XINCREF(type);
     if (tmp)
       PyErr_Format(type, "%s %s", tmp, mesg);
     else
       PyErr_Format(type, "%s", mesg);
-    SWIG_Python_str_DelForPy3(tmp);
     Py_DECREF(old_str);
     Py_DECREF(value);
   } else {
     PyErr_SetString(PyExc_RuntimeError, mesg);
   }
 }
 
@@ -931,16 +940,20 @@
     PyObject *type = NULL, *value = NULL, *traceback = NULL;
     PyErr_Fetch(&type, &value, &traceback);
 #if PY_VERSION_HEX >= 0x03000000
     newvalue = PyUnicode_FromFormat("%S\nAdditional information:\n%s", value, message);
 #else
     newvalue = PyString_FromFormat("%s\nAdditional information:\n%s", PyString_AsString(value), message);
 #endif
-    Py_XDECREF(value);
-    PyErr_Restore(type, newvalue, traceback);
+    if (newvalue) {
+      Py_XDECREF(value);
+      PyErr_Restore(type, newvalue, traceback);
+    } else {
+      PyErr_Restore(type, value, traceback);
+    }
   } else {
     /* Raise TypeError using given message */
     PyErr_SetString(PyExc_TypeError, message);
   }
 }
 
 #if defined(SWIG_PYTHON_NO_THREADS)
@@ -949,16 +962,20 @@
 #  endif
 #endif
 #if defined(SWIG_PYTHON_THREADS) /* Threading support is enabled */
 #  if !defined(SWIG_PYTHON_USE_GIL) && !defined(SWIG_PYTHON_NO_USE_GIL)
 #    define SWIG_PYTHON_USE_GIL
 #  endif
 #  if defined(SWIG_PYTHON_USE_GIL) /* Use PyGILState threads calls */
-#    ifndef SWIG_PYTHON_INITIALIZE_THREADS
-#     define SWIG_PYTHON_INITIALIZE_THREADS  PyEval_InitThreads() 
+#    if !defined(SWIG_PYTHON_INITIALIZE_THREADS)
+#      if PY_VERSION_HEX < 0x03070000
+#        define SWIG_PYTHON_INITIALIZE_THREADS PyEval_InitThreads()
+#      else
+#        define SWIG_PYTHON_INITIALIZE_THREADS
+#      endif
 #    endif
 #    ifdef __cplusplus /* C++ code */
        class SWIG_Python_Thread_Block {
          bool status;
          PyGILState_STATE state;
        public:
          void end() { if (status) { PyGILState_Release(state); status = false;} }
@@ -1048,16 +1065,16 @@
  *
  * ----------------------------------------------------------------------------- */
 
 #if PY_VERSION_HEX < 0x02070000 /* 2.7.0 */
 # error "This version of SWIG only supports Python >= 2.7"
 #endif
 
-#if PY_VERSION_HEX >= 0x03000000 && PY_VERSION_HEX < 0x03020000
-# error "This version of SWIG only supports Python 3 >= 3.2"
+#if PY_VERSION_HEX >= 0x03000000 && PY_VERSION_HEX < 0x03030000
+# error "This version of SWIG only supports Python 3 >= 3.3"
 #endif
 
 /* Common SWIG API */
 
 /* for raw pointers */
 #define SWIG_Python_ConvertPtr(obj, pptr, type, flags)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, 0)
 #define SWIG_ConvertPtr(obj, pptr, type, flags)         SWIG_Python_ConvertPtr(obj, pptr, type, flags)
@@ -1164,15 +1181,20 @@
   } else if (result == Py_None) {
     Py_DECREF(result);
     result = obj;
   } else {
     if (!PyList_Check(result)) {
       PyObject *o2 = result;
       result = PyList_New(1);
-      PyList_SetItem(result, 0, o2);
+      if (result) {
+        PyList_SET_ITEM(result, 0, o2);
+      } else {
+        Py_DECREF(obj);
+        return o2;
+      }
     }
     PyList_Append(result,obj);
     Py_DECREF(obj);
   }
   return result;
 }
 
@@ -1246,14 +1268,246 @@
 */
 #ifdef __cplusplus
 #define SWIG_STATIC_POINTER(var)  var
 #else
 #define SWIG_STATIC_POINTER(var)  var = 0; if (!var) var
 #endif
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Python-specific SWIG API */
+#define SWIG_newvarlink()                             SWIG_Python_newvarlink()
+#define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
+#define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)
+ 
+/* -----------------------------------------------------------------------------
+ * global variable support code.
+ * ----------------------------------------------------------------------------- */
+ 
+typedef struct swig_globalvar {   
+  char       *name;                  /* Name of global variable */
+  PyObject *(*get_attr)(void);       /* Return the current value */
+  int       (*set_attr)(PyObject *); /* Set the value */
+  struct swig_globalvar *next;
+} swig_globalvar;
+
+typedef struct swig_varlinkobject {
+  PyObject_HEAD
+  swig_globalvar *vars;
+} swig_varlinkobject;
+
+SWIGINTERN PyObject *
+swig_varlink_repr(PyObject *SWIGUNUSEDPARM(v)) {
+#if PY_VERSION_HEX >= 0x03000000
+  return PyUnicode_InternFromString("<Swig global variables>");
+#else
+  return PyString_FromString("<Swig global variables>");
+#endif
+}
+
+SWIGINTERN PyObject *
+swig_varlink_str(PyObject *o) {
+  swig_varlinkobject *v = (swig_varlinkobject *) o;
+#if PY_VERSION_HEX >= 0x03000000
+  PyObject *str = PyUnicode_InternFromString("(");
+  PyObject *tail;
+  PyObject *joined;
+  swig_globalvar *var;
+  for (var = v->vars; var; var=var->next) {
+    tail = PyUnicode_FromString(var->name);
+    joined = PyUnicode_Concat(str, tail);
+    Py_DecRef(str);
+    Py_DecRef(tail);
+    str = joined;
+    if (var->next) {
+        tail = PyUnicode_InternFromString(", ");
+        joined = PyUnicode_Concat(str, tail);
+        Py_DecRef(str);
+        Py_DecRef(tail);
+        str = joined;
+    }
+  }
+  tail = PyUnicode_InternFromString(")");
+  joined = PyUnicode_Concat(str, tail);
+  Py_DecRef(str);
+  Py_DecRef(tail);
+  str = joined;
+#else
+  PyObject *str = PyString_FromString("(");
+  swig_globalvar *var;
+  for (var = v->vars; var; var=var->next) {
+    PyString_ConcatAndDel(&str,PyString_FromString(var->name));
+    if (var->next) PyString_ConcatAndDel(&str,PyString_FromString(", "));
+  }
+  PyString_ConcatAndDel(&str,PyString_FromString(")"));
+#endif
+  return str;
+}
+
+SWIGINTERN void
+swig_varlink_dealloc(PyObject *o) {
+  swig_varlinkobject *v = (swig_varlinkobject *) o;
+  swig_globalvar *var = v->vars;
+  while (var) {
+    swig_globalvar *n = var->next;
+    free(var->name);
+    free(var);
+    var = n;
+  }
+}
+
+SWIGINTERN PyObject *
+swig_varlink_getattr(PyObject *o, char *n) {
+  swig_varlinkobject *v = (swig_varlinkobject *) o;
+  PyObject *res = NULL;
+  swig_globalvar *var = v->vars;
+  while (var) {
+    if (strcmp(var->name,n) == 0) {
+      res = (*var->get_attr)();
+      break;
+    }
+    var = var->next;
+  }
+  if (res == NULL && !PyErr_Occurred()) {
+    PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
+  }
+  return res;
+}
+
+SWIGINTERN int
+swig_varlink_setattr(PyObject *o, char *n, PyObject *p) {
+  swig_varlinkobject *v = (swig_varlinkobject *) o;
+  int res = 1;
+  swig_globalvar *var = v->vars;
+  while (var) {
+    if (strcmp(var->name,n) == 0) {
+      res = (*var->set_attr)(p);
+      break;
+    }
+    var = var->next;
+  }
+  if (res == 1 && !PyErr_Occurred()) {
+    PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
+  }
+  return res;
+}
+
+SWIGINTERN PyTypeObject*
+swig_varlink_type(void) {
+  static char varlink__doc__[] = "Swig var link object";
+  static PyTypeObject varlink_type;
+  static int type_init = 0;
+  if (!type_init) {
+    const PyTypeObject tmp = {
+#if PY_VERSION_HEX >= 0x03000000
+      PyVarObject_HEAD_INIT(NULL, 0)
+#else
+      PyObject_HEAD_INIT(NULL)
+      0,                                  /* ob_size */
+#endif
+      "swigvarlink",                      /* tp_name */
+      sizeof(swig_varlinkobject),         /* tp_basicsize */
+      0,                                  /* tp_itemsize */
+      (destructor) swig_varlink_dealloc,  /* tp_dealloc */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                       /*tp_print*/
+#else
+      (Py_ssize_t)0,                      /*tp_vectorcall_offset*/
+#endif
+      (getattrfunc) swig_varlink_getattr, /* tp_getattr */
+      (setattrfunc) swig_varlink_setattr, /* tp_setattr */
+      0,                                  /* tp_compare */
+      (reprfunc) swig_varlink_repr,       /* tp_repr */
+      0,                                  /* tp_as_number */
+      0,                                  /* tp_as_sequence */
+      0,                                  /* tp_as_mapping */
+      0,                                  /* tp_hash */
+      0,                                  /* tp_call */
+      (reprfunc) swig_varlink_str,        /* tp_str */
+      0,                                  /* tp_getattro */
+      0,                                  /* tp_setattro */
+      0,                                  /* tp_as_buffer */
+      0,                                  /* tp_flags */
+      varlink__doc__,                     /* tp_doc */
+      0,                                  /* tp_traverse */
+      0,                                  /* tp_clear */
+      0,                                  /* tp_richcompare */
+      0,                                  /* tp_weaklistoffset */
+      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
+      0,                                  /* tp_del */
+      0,                                  /* tp_version_tag */
+#if PY_VERSION_HEX >= 0x03040000
+      0,                                  /* tp_finalize */
+#endif
+#if PY_VERSION_HEX >= 0x03080000
+      0,                                  /* tp_vectorcall */
+#endif
+#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
+      0,                                  /* tp_print */
+#endif
+#ifdef COUNT_ALLOCS
+      0,                                  /* tp_allocs */
+      0,                                  /* tp_frees */
+      0,                                  /* tp_maxalloc */
+      0,                                  /* tp_prev */
+      0                                   /* tp_next */
+#endif
+    };
+    varlink_type = tmp;
+    type_init = 1;
+    if (PyType_Ready(&varlink_type) < 0)
+      return NULL;
+  }
+  return &varlink_type;
+}
+
+/* Create a variable linking object for use later */
+SWIGINTERN PyObject *
+SWIG_Python_newvarlink(void) {
+  swig_varlinkobject *result = PyObject_NEW(swig_varlinkobject, swig_varlink_type());
+  if (result) {
+    result->vars = 0;
+  }
+  return ((PyObject*) result);
+}
+
+SWIGINTERN void 
+SWIG_Python_addvarlink(PyObject *p, const char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
+  swig_varlinkobject *v = (swig_varlinkobject *) p;
+  swig_globalvar *gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
+  if (gv) {
+    size_t size = strlen(name)+1;
+    gv->name = (char *)malloc(size);
+    if (gv->name) {
+      memcpy(gv->name, name, size);
+      gv->get_attr = get_attr;
+      gv->set_attr = set_attr;
+      gv->next = v->vars;
+    }
+  }
+  v->vars = gv;
+}
+
+
+static PyObject *Swig_Globals_global = NULL;
+  
+SWIGINTERN PyObject *
+SWIG_globals(void) {
+  if (Swig_Globals_global == NULL) {
+    Swig_Globals_global = SWIG_newvarlink();
+  }
+  return Swig_Globals_global;
+}
+
+#ifdef __cplusplus
+}
+#endif
+
 /* -----------------------------------------------------------------------------
  * Pointer declarations
  * ----------------------------------------------------------------------------- */
 
 /* Flags for new pointer objects */
 #define SWIG_POINTER_NOSHADOW       (SWIG_POINTER_OWN      << 1)
 #define SWIG_POINTER_NEW            (SWIG_POINTER_NOSHADOW | SWIG_POINTER_OWN)
@@ -1316,52 +1570,59 @@
     SwigPyClientData *data = (SwigPyClientData *)malloc(sizeof(SwigPyClientData));
     /* the klass element */
     data->klass = obj;
     Py_INCREF(data->klass);
     /* the newraw method and newargs arguments used to create a new raw instance */
     if (PyClass_Check(obj)) {
       data->newraw = 0;
-      data->newargs = obj;
       Py_INCREF(obj);
+      data->newargs = obj;
     } else {
       data->newraw = PyObject_GetAttrString(data->klass, "__new__");
       if (data->newraw) {
-	Py_INCREF(data->newraw);
-	data->newargs = PyTuple_New(1);
-	PyTuple_SetItem(data->newargs, 0, obj);
+        data->newargs = PyTuple_New(1);
+        if (data->newargs) {
+          Py_INCREF(obj);
+          PyTuple_SET_ITEM(data->newargs, 0, obj);
+        } else {
+          Py_DECREF(data->newraw);
+          Py_DECREF(data->klass);
+          free(data);
+          return 0;
+        }
       } else {
-	data->newargs = obj;
+        Py_INCREF(obj);
+        data->newargs = obj;
       }
-      Py_INCREF(data->newargs);
     }
     /* the destroy method, aka as the C++ delete method */
     data->destroy = PyObject_GetAttrString(data->klass, "__swig_destroy__");
     if (PyErr_Occurred()) {
       PyErr_Clear();
       data->destroy = 0;
     }
     if (data->destroy) {
-      int flags;
-      Py_INCREF(data->destroy);
-      flags = PyCFunction_GET_FLAGS(data->destroy);
-      data->delargs = !(flags & (METH_O));
+      data->delargs = !(PyCFunction_GET_FLAGS(data->destroy) & METH_O);
     } else {
       data->delargs = 0;
     }
     data->implicitconv = 0;
     data->pytype = 0;
     return data;
   }
 }
 
 SWIGRUNTIME void 
-SwigPyClientData_Del(SwigPyClientData *data) {
+SwigPyClientData_Del(SwigPyClientData *data)
+{
+  Py_XDECREF(data->klass);
   Py_XDECREF(data->newraw);
   Py_XDECREF(data->newargs);
   Py_XDECREF(data->destroy);
+  free(data);
 }
 
 /* =============== SwigPyObject =====================*/
 
 typedef struct {
   PyObject_HEAD
   void *ptr;
@@ -1380,15 +1641,15 @@
 SwigPyObject_get___dict__(PyObject *v, PyObject *SWIGUNUSEDPARM(args))
 {
   SwigPyObject *sobj = (SwigPyObject *)v;
 
   if (!sobj->dict)
     sobj->dict = PyDict_New();
 
-  Py_INCREF(sobj->dict);
+  Py_XINCREF(sobj->dict);
   return sobj->dict;
 }
 
 #endif
 
 SWIGRUNTIME PyObject *
 SwigPyObject_long(SwigPyObject *v)
@@ -1398,26 +1659,29 @@
 
 SWIGRUNTIME PyObject *
 SwigPyObject_format(const char* fmt, SwigPyObject *v)
 {
   PyObject *res = NULL;
   PyObject *args = PyTuple_New(1);
   if (args) {
-    if (PyTuple_SetItem(args, 0, SwigPyObject_long(v)) == 0) {
-      PyObject *ofmt = SWIG_Python_str_FromChar(fmt);
+    PyObject *val = SwigPyObject_long(v);
+    if (val) {
+      PyObject *ofmt;
+      PyTuple_SET_ITEM(args, 0, val);
+      ofmt = SWIG_Python_str_FromChar(fmt);
       if (ofmt) {
 #if PY_VERSION_HEX >= 0x03000000
-	res = PyUnicode_Format(ofmt,args);
+        res = PyUnicode_Format(ofmt,args);
 #else
-	res = PyString_Format(ofmt,args);
+        res = PyString_Format(ofmt,args);
 #endif
-	Py_DECREF(ofmt);
+        Py_DECREF(ofmt);
       }
-      Py_DECREF(args);
     }
+    Py_DECREF(args);
   }
   return res;
 }
 
 SWIGRUNTIME PyObject *
 SwigPyObject_oct(SwigPyObject *v)
 {
@@ -1431,26 +1695,31 @@
 }
 
 SWIGRUNTIME PyObject *
 SwigPyObject_repr(SwigPyObject *v)
 {
   const char *name = SWIG_TypePrettyName(v->ty);
   PyObject *repr = SWIG_Python_str_FromFormat("<Swig Object of type '%s' at %p>", (name ? name : "unknown"), (void *)v);
-  if (v->next) {
+  if (repr && v->next) {
     PyObject *nrep = SwigPyObject_repr((SwigPyObject *)v->next);
+    if (nrep) {
 # if PY_VERSION_HEX >= 0x03000000
-    PyObject *joined = PyUnicode_Concat(repr, nrep);
-    Py_DecRef(repr);
-    Py_DecRef(nrep);
-    repr = joined;
+      PyObject *joined = PyUnicode_Concat(repr, nrep);
+      Py_DecRef(repr);
+      Py_DecRef(nrep);
+      repr = joined;
 # else
-    PyString_ConcatAndDel(&repr,nrep);
+      PyString_ConcatAndDel(&repr,nrep);
 # endif
+    } else {
+      Py_DecRef(repr);
+      repr = NULL;
+    }
   }
-  return repr;  
+  return repr;
 }
 
 /* We need a version taking two PyObject* parameters so it's a valid
  * PyCFunction to use in swigobject_methods[]. */
 SWIGRUNTIME PyObject *
 SwigPyObject_repr2(PyObject *v, PyObject *SWIGUNUSEDPARM(args))
 {
@@ -1512,14 +1781,16 @@
     || (strcmp(Py_TYPE(op)->tp_name,"SwigPyObject") == 0);
 #endif
 }
 
 SWIGRUNTIME PyObject *
 SwigPyObject_New(void *ptr, swig_type_info *ty, int own);
 
+static PyObject* Swig_Capsule_global = NULL;
+
 SWIGRUNTIME void
 SwigPyObject_dealloc(PyObject *v)
 {
   SwigPyObject *sobj = (SwigPyObject *) v;
   PyObject *next = sobj->next;
   if (sobj->own == SWIG_POINTER_OWN) {
     swig_type_info *ty = sobj->ty;
@@ -1538,16 +1809,20 @@
       
       PyObject *type = NULL, *value = NULL, *traceback = NULL;
       PyErr_Fetch(&type, &value, &traceback);
 
       if (data->delargs) {
         /* we need to create a temporary object to carry the destroy operation */
         PyObject *tmp = SwigPyObject_New(sobj->ptr, ty, 0);
-        res = SWIG_Python_CallFunctor(destroy, tmp);
-        Py_DECREF(tmp);
+        if (tmp) {
+          res = SWIG_Python_CallFunctor(destroy, tmp);
+        } else {
+          res = 0;
+        }
+        Py_XDECREF(tmp);
       } else {
         PyCFunction meth = PyCFunction_GET_FUNCTION(destroy);
         PyObject *mself = PyCFunction_GET_SELF(destroy);
         res = ((*meth)(mself, v));
       }
       if (!res)
         PyErr_WriteUnraisable(destroy);
@@ -1558,27 +1833,32 @@
     } 
 #if !defined(SWIG_PYTHON_SILENT_MEMLEAK)
     else {
       const char *name = SWIG_TypePrettyName(ty);
       printf("swig/python detected a memory leak of type '%s', no destructor found.\n", (name ? name : "unknown"));
     }
 #endif
-  } 
+    Py_XDECREF(Swig_Capsule_global);
+  }
   Py_XDECREF(next);
+#ifdef SWIGPYTHON_BUILTIN
+  Py_XDECREF(sobj->dict);
+#endif
   PyObject_DEL(v);
 }
 
 SWIGRUNTIME PyObject* 
 SwigPyObject_append(PyObject* v, PyObject* next)
 {
   SwigPyObject *sobj = (SwigPyObject *) v;
   if (!SwigPyObject_Check(next)) {
     PyErr_SetString(PyExc_TypeError, "Attempt to append a non SwigPyObject");
     return NULL;
   }
+  ((SwigPyObject *)next)->next = sobj->next;
   sobj->next = next;
   Py_INCREF(next);
   return SWIG_Py_Void();
 }
 
 SWIGRUNTIME PyObject* 
 SwigPyObject_next(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
@@ -1615,17 +1895,17 @@
   if (!PyArg_UnpackTuple(args, "own", 0, 1, &val)) {
     return NULL;
   } else {
     SwigPyObject *sobj = (SwigPyObject *)v;
     PyObject *obj = PyBool_FromLong(sobj->own);
     if (val) {
       if (PyObject_IsTrue(val)) {
-        SwigPyObject_acquire(v,args);
+        Py_DECREF(SwigPyObject_acquire(v,args));
       } else {
-        SwigPyObject_disown(v,args);
+        Py_DECREF(SwigPyObject_disown(v,args));
       }
     } 
     return obj;
   }
 }
 
 static PyMethodDef
@@ -1697,15 +1977,19 @@
       PyObject_HEAD_INIT(NULL)
       0,                                    /* ob_size */
 #endif
       "SwigPyObject",                       /* tp_name */
       sizeof(SwigPyObject),                 /* tp_basicsize */
       0,                                    /* tp_itemsize */
       (destructor)SwigPyObject_dealloc,     /* tp_dealloc */
-      0,                                    /* tp_print */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                         /*tp_print*/
+#else
+      (Py_ssize_t)0,                        /*tp_vectorcall_offset*/
+#endif
       (getattrfunc)0,                       /* tp_getattr */
       (setattrfunc)0,                       /* tp_setattr */
 #if PY_VERSION_HEX >= 0x03000000
       0, /* tp_reserved in 3.0.1, tp_compare in 3.0.0 but not used */
 #else
       (cmpfunc)SwigPyObject_compare,        /* tp_compare */
 #endif
@@ -1762,29 +2046,38 @@
       0,                                    /* tp_maxalloc */
       0,                                    /* tp_prev */
       0                                     /* tp_next */
 #endif
     };
     swigpyobject_type = tmp;
     type_init = 1;
-    if (PyType_Ready(&swigpyobject_type) < 0)
+    if (PyType_Ready(&swigpyobject_type) != 0)
       return NULL;
   }
   return &swigpyobject_type;
 }
 
 SWIGRUNTIME PyObject *
 SwigPyObject_New(void *ptr, swig_type_info *ty, int own)
 {
   SwigPyObject *sobj = PyObject_NEW(SwigPyObject, SwigPyObject_type());
   if (sobj) {
     sobj->ptr  = ptr;
     sobj->ty   = ty;
     sobj->own  = own;
     sobj->next = 0;
+#ifdef SWIGPYTHON_BUILTIN
+    sobj->dict = 0;
+#endif
+    if (own == SWIG_POINTER_OWN) {
+      /* Obtain a reference to the Python capsule wrapping the module information, so that the
+       * module information is correctly destroyed after all SWIG python objects have been freed
+       * by the GC (and corresponding destructors invoked) */
+      Py_XINCREF(Swig_Capsule_global);
+    }
   }
   return (PyObject *)sobj;
 }
 
 /* -----------------------------------------------------------------------------
  * Implements a simple Swig Packed type, and use it instead of string
  * ----------------------------------------------------------------------------- */
@@ -1864,15 +2157,19 @@
       PyObject_HEAD_INIT(NULL)
       0,                                    /* ob_size */
 #endif
       "SwigPyPacked",                       /* tp_name */
       sizeof(SwigPyPacked),                 /* tp_basicsize */
       0,                                    /* tp_itemsize */
       (destructor)SwigPyPacked_dealloc,     /* tp_dealloc */
-      0,                                    /* tp_print */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                         /*tp_print*/
+#else
+      (Py_ssize_t)0,                        /*tp_vectorcall_offset*/
+#endif
       (getattrfunc)0,                       /* tp_getattr */
       (setattrfunc)0,                       /* tp_setattr */
 #if PY_VERSION_HEX>=0x03000000
       0, /* tp_reserved in 3.0.1 */
 #else
       (cmpfunc)SwigPyPacked_compare,        /* tp_compare */
 #endif
@@ -1929,15 +2226,15 @@
       0,                                    /* tp_maxalloc */
       0,                                    /* tp_prev */
       0                                     /* tp_next */
 #endif
     };
     swigpypacked_type = tmp;
     type_init = 1;
-    if (PyType_Ready(&swigpypacked_type) < 0)
+    if (PyType_Ready(&swigpypacked_type) != 0)
       return NULL;
   }
   return &swigpypacked_type;
 }
 
 SWIGRUNTIME PyObject *
 SwigPyPacked_New(void *ptr, size_t size, swig_type_info *ty)
@@ -2119,20 +2416,27 @@
       }
     } else {
       if (ptr) *ptr = vptr;
       break;
     }
   }
   if (sobj) {
-    if (own)
-      *own = *own | sobj->own;
-    if (flags & SWIG_POINTER_DISOWN) {
-      sobj->own = 0;
+    if (((flags & SWIG_POINTER_RELEASE) == SWIG_POINTER_RELEASE) && !sobj->own) {
+      res = SWIG_ERROR_RELEASE_NOT_OWNED;
+    } else {
+      if (own)
+        *own = *own | sobj->own;
+      if (flags & SWIG_POINTER_DISOWN) {
+        sobj->own = 0;
+      }
+      if (flags & SWIG_POINTER_CLEAR) {
+        sobj->ptr = 0;
+      }
+      res = SWIG_OK;
     }
-    res = SWIG_OK;
   } else {
     if (implicit_conv) {
       SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
       if (data && !data->implicitconv) {
         PyObject *klass = data->klass;
         if (klass) {
           PyObject *impconv;
@@ -2237,20 +2541,25 @@
   PyObject *newraw = data->newraw;
   if (newraw) {
     inst = PyObject_Call(newraw, data->newargs, NULL);
     if (inst) {
 #if !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
       PyObject **dictptr = _PyObject_GetDictPtr(inst);
       if (dictptr != NULL) {
-	PyObject *dict = *dictptr;
-	if (dict == NULL) {
-	  dict = PyDict_New();
-	  *dictptr = dict;
-	  PyDict_SetItem(dict, SWIG_This(), swig_this);
-	}
+        PyObject *dict = *dictptr;
+        if (dict == NULL) {
+          dict = PyDict_New();
+          *dictptr = dict;
+        }
+        if (dict) {
+          PyDict_SetItem(dict, SWIG_This(), swig_this);
+        } else{
+          Py_DECREF(inst);
+          inst = 0;
+        }
       }
 #else
       if (PyObject_SetAttr(inst, SWIG_This(), swig_this) == -1) {
         Py_DECREF(inst);
         inst = 0;
       }
 #endif
@@ -2264,15 +2573,15 @@
         inst = ((PyTypeObject *)data->newargs)->tp_new((PyTypeObject *)data->newargs, empty_args, empty_kwargs);
         Py_DECREF(empty_kwargs);
         if (inst) {
           if (PyObject_SetAttr(inst, SWIG_This(), swig_this) == -1) {
             Py_DECREF(inst);
             inst = 0;
           } else {
-            Py_TYPE(inst)->tp_flags &= ~Py_TPFLAGS_VALID_VERSION_TAG;
+            PyType_Modified(Py_TYPE(inst));
           }
         }
       }
       Py_DECREF(empty_args);
     }
 #else
     PyObject *dict = PyDict_New();
@@ -2293,30 +2602,34 @@
   PyObject **dictptr = _PyObject_GetDictPtr(inst);
   if (dictptr != NULL) {
     PyObject *dict = *dictptr;
     if (dict == NULL) {
       dict = PyDict_New();
       *dictptr = dict;
     }
-    return PyDict_SetItem(dict, SWIG_This(), swig_this);
+    if (dict) {
+      return PyDict_SetItem(dict, SWIG_This(), swig_this);
+    } else{
+      return -1;
+    }
   }
 #endif
   return PyObject_SetAttr(inst, SWIG_This(), swig_this);
 } 
 
 
 SWIGINTERN PyObject *
 SWIG_Python_InitShadowInstance(PyObject *args) {
   PyObject *obj[2];
   if (!SWIG_Python_UnpackTuple(args, "swiginit", 2, 2, obj)) {
     return NULL;
   } else {
     SwigPyObject *sthis = SWIG_Python_GetSwigThis(obj[0]);
     if (sthis) {
-      SwigPyObject_append((PyObject*) sthis, obj[1]);
+      Py_DECREF(SwigPyObject_append((PyObject*) sthis, obj[1]));
     } else {
       if (SWIG_Python_SetSwigThis(obj[0], obj[1]) != 0)
         return NULL;
     }
     return SWIG_Py_Void();
   }
 }
@@ -2347,15 +2660,17 @@
 #ifdef SWIGPYTHON_BUILTIN
         newobj->dict = 0;
 #endif
       }
     } else {
       newobj = PyObject_New(SwigPyObject, clientdata->pytype);
 #ifdef SWIGPYTHON_BUILTIN
-      newobj->dict = 0;
+      if (newobj) {
+        newobj->dict = 0;
+      }
 #endif
     }
     if (newobj) {
       newobj->ptr = ptr;
       newobj->ty = type;
       newobj->own = own;
       newobj->next = 0;
@@ -2386,89 +2701,111 @@
  *  Get type list 
  * -----------------------------------------------------------------------------*/
 
 #ifdef SWIG_LINK_RUNTIME
 void *SWIG_ReturnGlobalTypeList(void *);
 #endif
 
+static PyObject *Swig_TypeCache_global = NULL;
+
+/* The python cached type query */
+SWIGRUNTIME PyObject *
+SWIG_Python_TypeCache(void) {
+  if (Swig_TypeCache_global == NULL) {
+    Swig_TypeCache_global = PyDict_New();
+  }
+  return Swig_TypeCache_global;
+}
+
 SWIGRUNTIME swig_module_info *
 SWIG_Python_GetModule(void *SWIGUNUSEDPARM(clientdata)) {
+#ifdef SWIG_LINK_RUNTIME
   static void *type_pointer = (void *)0;
   /* first check if module already created */
   if (!type_pointer) {
-#ifdef SWIG_LINK_RUNTIME
     type_pointer = SWIG_ReturnGlobalTypeList((void *)0);
+  }
 #else
-    type_pointer = PyCapsule_Import(SWIGPY_CAPSULE_NAME, 0);
-    if (PyErr_Occurred()) {
-      PyErr_Clear();
-      type_pointer = (void *)0;
-    }
-#endif
+  void *type_pointer = PyCapsule_Import(SWIGPY_CAPSULE_NAME, 0);
+  if (PyErr_Occurred()) {
+    PyErr_Clear();
+    type_pointer = (void *)0;
   }
+#endif
   return (swig_module_info *) type_pointer;
 }
 
+
+static int interpreter_counter = 0; // how many (sub-)interpreters are using swig_module's types
+
 SWIGRUNTIME void
 SWIG_Python_DestroyModule(PyObject *obj)
 {
   swig_module_info *swig_module = (swig_module_info *) PyCapsule_GetPointer(obj, SWIGPY_CAPSULE_NAME);
   swig_type_info **types = swig_module->types;
   size_t i;
+  if (--interpreter_counter != 0) // another sub-interpreter may still be using the swig_module's types
+    return;
   for (i =0; i < swig_module->size; ++i) {
     swig_type_info *ty = types[i];
     if (ty->owndata) {
       SwigPyClientData *data = (SwigPyClientData *) ty->clientdata;
+      ty->clientdata = 0;
       if (data) SwigPyClientData_Del(data);
     }
   }
   Py_DECREF(SWIG_This());
   Swig_This_global = NULL;
+  Py_DECREF(SWIG_globals());
+  Swig_Globals_global = NULL;
+  Py_DECREF(SWIG_Python_TypeCache());
+  Swig_TypeCache_global = NULL;
+  Swig_Capsule_global = NULL;
 }
 
 SWIGRUNTIME void
 SWIG_Python_SetModule(swig_module_info *swig_module) {
 #if PY_VERSION_HEX >= 0x03000000
  /* Add a dummy module object into sys.modules */
   PyObject *module = PyImport_AddModule("swig_runtime_data" SWIG_RUNTIME_VERSION);
 #else
   static PyMethodDef swig_empty_runtime_method_table[] = { {NULL, NULL, 0, NULL} }; /* Sentinel */
   PyObject *module = Py_InitModule("swig_runtime_data" SWIG_RUNTIME_VERSION, swig_empty_runtime_method_table);
 #endif
   PyObject *pointer = PyCapsule_New((void *) swig_module, SWIGPY_CAPSULE_NAME, SWIG_Python_DestroyModule);
   if (pointer && module) {
-    PyModule_AddObject(module, "type_pointer_capsule" SWIG_TYPE_TABLE_NAME, pointer);
+    if (PyModule_AddObject(module, SWIGPY_CAPSULE_ATTR_NAME, pointer) == 0) {
+      ++interpreter_counter;
+      Swig_Capsule_global = pointer;
+    } else {
+      Py_DECREF(pointer);
+    }
   } else {
     Py_XDECREF(pointer);
   }
 }
 
-/* The python cached type query */
-SWIGRUNTIME PyObject *
-SWIG_Python_TypeCache(void) {
-  static PyObject *SWIG_STATIC_POINTER(cache) = PyDict_New();
-  return cache;
-}
-
 SWIGRUNTIME swig_type_info *
 SWIG_Python_TypeQuery(const char *type)
 {
   PyObject *cache = SWIG_Python_TypeCache();
   PyObject *key = SWIG_Python_str_FromChar(type); 
   PyObject *obj = PyDict_GetItem(cache, key);
   swig_type_info *descriptor;
   if (obj) {
     descriptor = (swig_type_info *) PyCapsule_GetPointer(obj, NULL);
   } else {
     swig_module_info *swig_module = SWIG_GetModule(0);
     descriptor = SWIG_TypeQueryModule(swig_module, swig_module, type);
     if (descriptor) {
       obj = PyCapsule_New((void*) descriptor, NULL, NULL);
-      PyDict_SetItem(cache, key, obj);
-      Py_DECREF(obj);
+      if (obj) {
+        PyDict_SetItem(cache, key, obj);
+        Py_DECREF(obj);
+      }
     }
   }
   Py_DECREF(key);
   return descriptor;
 }
 
 /* 
@@ -2493,15 +2830,14 @@
       Py_XINCREF(type);
       PyErr_Clear();
       if (infront) {
 	PyErr_Format(type, "%s %s", mesg, errmesg);
       } else {
 	PyErr_Format(type, "%s %s", errmesg, mesg);
       }
-      SWIG_Python_str_DelForPy3(tmp);
       Py_DECREF(old_str);
     }
     return 1;
   } else {
     return 0;
   }
 }
@@ -2545,15 +2881,14 @@
       const char *otype = (obj ? obj->ob_type->tp_name : 0); 
       if (otype) {
 	PyObject *str = PyObject_Str(obj);
 	const char *cstr = str ? SWIG_Python_str_AsChar(str) : 0;
 	if (cstr) {
 	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s(%s)' is received",
 		       type, otype, cstr);
-          SWIG_Python_str_DelForPy3(cstr);
 	} else {
 	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s' is received",
 		       type, otype);
 	}
 	Py_XDECREF(str);
 	return;
       }
@@ -2567,20 +2902,14 @@
 
 /* Convert a pointer value, signal an exception on a type mismatch */
 SWIGRUNTIME void *
 SWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int SWIGUNUSEDPARM(argnum), int flags) {
   void *result;
   if (SWIG_Python_ConvertPtr(obj, &result, ty, flags) == -1) {
     PyErr_Clear();
-#if SWIG_POINTER_EXCEPTION
-    if (flags) {
-      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);
-      SWIG_Python_ArgFail(argnum);
-    }
-#endif
   }
   return result;
 }
 
 #ifdef SWIGPYTHON_BUILTIN
 SWIGRUNTIME int
 SWIG_Python_NonDynamicSetAttr(PyObject *obj, PyObject *name, PyObject *value) {
@@ -2603,30 +2932,30 @@
     PyErr_Format(PyExc_TypeError, "attribute name must be string, not '%.200s'", name->ob_type->tp_name);
     return -1;
   } else {
     Py_INCREF(name);
   }
 
   if (!tp->tp_dict) {
-    if (PyType_Ready(tp) < 0)
+    if (PyType_Ready(tp) != 0)
       goto done;
   }
 
   descr = _PyType_Lookup(tp, name);
   f = NULL;
   if (descr != NULL)
     f = descr->ob_type->tp_descr_set;
   if (!f) {
     if (PyString_Check(name)) {
       encoded_name = name;
       Py_INCREF(name);
     } else {
       encoded_name = PyUnicode_AsUTF8String(name);
       if (!encoded_name)
-        return -1;
+        goto done;
     }
     PyErr_Format(PyExc_AttributeError, "'%.100s' object has no attribute '%.200s'", tp->tp_name, PyString_AsString(encoded_name));
     Py_DECREF(encoded_name);
   } else {
     res = f(descr, obj, value);
   }
   
@@ -2645,15 +2974,19 @@
 extern "C" {
 #endif
 
 SWIGINTERN Py_hash_t
 SwigPyObject_hash(PyObject *obj) {
   SwigPyObject *sobj = (SwigPyObject *)obj;
   void *ptr = sobj->ptr;
+#if PY_VERSION_HEX < 0x03020000
+  return (Py_hash_t)(Py_ssize_t)ptr;
+#else
   return (Py_hash_t)ptr;
+#endif
 }
 
 SWIGINTERN Py_hash_t
 SWIG_PyNumber_AsPyHash(PyObject *obj) {
   Py_hash_t result = -1;
 #if PY_VERSION_HEX < 0x03020000
   if (PyInt_Check(obj))
@@ -2850,15 +3183,19 @@
       PyObject_HEAD_INIT(&PyType_Type)
       0,                                        /* ob_size */
 #endif
       "swig_static_var_getset_descriptor",      /* tp_name */
       sizeof(PyGetSetDescrObject),              /* tp_basicsize */
       0,                                        /* tp_itemsize */
       (destructor)SwigPyStaticVar_dealloc,      /* tp_dealloc */
-      0,                                        /* tp_print */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                             /* tp_print */
+#else
+      (Py_ssize_t)0,                            /* tp_vectorcall_offset */
+#endif
       0,                                        /* tp_getattr */
       0,                                        /* tp_setattr */
       0,                                        /* tp_compare */
       (reprfunc)SwigPyStaticVar_repr,           /* tp_repr */
       0,                                        /* tp_as_number */
       0,                                        /* tp_as_sequence */
       0,                                        /* tp_as_mapping */
@@ -2934,15 +3271,19 @@
       PyObject_HEAD_INIT(&PyType_Type)
       0,                                        /* ob_size */
 #endif
       "SwigPyObjectType",                       /* tp_name */
       PyType_Type.tp_basicsize,                 /* tp_basicsize */
       0,                                        /* tp_itemsize */
       0,                                        /* tp_dealloc */
-      0,                                        /* tp_print */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                             /* tp_print */
+#else
+      (Py_ssize_t)0,                            /* tp_vectorcall_offset */
+#endif
       0,                                        /* tp_getattr */
       0,                                        /* tp_setattr */
       0,                                        /* tp_compare */
       0,                                        /* tp_repr */
       0,                                        /* tp_as_number */
       0,                                        /* tp_as_sequence */
       0,                                        /* tp_as_mapping */
@@ -3053,18 +3394,18 @@
   Py_XINCREF(result);
   return result;
 }
 
 SWIGINTERN void
 SwigPyBuiltin_SetMetaType (PyTypeObject *type, PyTypeObject *metatype)
 {
-#if PY_VERSION_HEX >= 0x03000000
-    type->ob_base.ob_base.ob_type = metatype;
+#if PY_VERSION_HEX >= 0x030900a4
+    Py_SET_TYPE(type, metatype);
 #else
-    type->ob_type = metatype;
+    Py_TYPE(type) = metatype;
 #endif
 }
 
 
 /* Start of callback function macros for use in PyTypeObject */
 
 typedef PyObject *(*SwigPyWrapperFunction)(PyObject *, PyObject *);
@@ -3394,33 +3735,18 @@
 #endif
 
 
 
 
 #define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 
 
-#define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 
+#define SWIG_contract_assert(expr, msg) do { if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } } while (0) 
 
 
 
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* Method creation and docstring support functions */
-
-SWIGINTERN PyMethodDef *SWIG_PythonGetProxyDoc(const char *name);
-SWIGINTERN PyObject *SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func);
-SWIGINTERN PyObject *SWIG_PyStaticMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func);
-
-#ifdef __cplusplus
-}
-#endif
-
-
 /* -------- TYPES TABLE (BEGIN) -------- */
 
 #define SWIGTYPE_p_CameraAbilities swig_types[0]
 #define SWIGTYPE_p_CameraCaptureType swig_types[1]
 #define SWIGTYPE_p_CameraDriverStatus swig_types[2]
 #define SWIGTYPE_p_CameraEventType swig_types[3]
 #define SWIGTYPE_p_CameraFileAccessType swig_types[4]
@@ -3495,18 +3821,14 @@
 
 #else
 #  define SWIG_init    init_port_log
 
 #endif
 #define SWIG_name    "_port_log"
 
-#define SWIGVERSION 0x040002 
-#define SWIG_VERSION SWIGVERSION
-
-
 #define SWIG_as_voidptr(a) (void *)((const void *)(a)) 
 #define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),(void**)(a)) 
 
 
 #include <stddef.h>
 
 
@@ -3856,14 +4178,15 @@
 #endif
 SWIGINTERN PyObject *_wrap_delete_LogFuncItem(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct LogFuncItem *arg1 = (struct LogFuncItem *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_LogFuncItem takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_LogFuncItem, SWIG_POINTER_DISOWN |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_LogFuncItem" "', argument " "1"" of type '" "struct LogFuncItem *""'"); 
   }
   arg1 = (struct LogFuncItem *)(argp1);
   {
@@ -3901,14 +4224,15 @@
     _global_callback->id = -1;
     _global_callback->func = NULL;
     _global_callback->data = NULL;
   }
   {
     arg3 = _global_callback;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_log_add_func", 2, 3, &obj0, &obj1, &obj2)) SWIG_fail;
   ecode1 = SWIG_AsVal_int(obj0, &val1);
   if (!SWIG_IsOK(ecode1)) {
     SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "gp_log_add_func" "', argument " "1"" of type '" "GPLogLevel""'");
   } 
   arg1 = (GPLogLevel)(val1);
   {
@@ -3961,14 +4285,15 @@
   int res3 ;
   char *buf3 = 0 ;
   int alloc3 = 0 ;
   PyObject * obj0 = 0 ;
   PyObject * obj1 = 0 ;
   PyObject * obj2 = 0 ;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_log", 3, 3, &obj0, &obj1, &obj2)) SWIG_fail;
   ecode1 = SWIG_AsVal_int(obj0, &val1);
   if (!SWIG_IsOK(ecode1)) {
     SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "gp_log" "', argument " "1"" of type '" "GPLogLevel""'");
   } 
   arg1 = (GPLogLevel)(val1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -3994,87 +4319,24 @@
 
 
 SWIGINTERN PyObject *_wrap_gp_log(PyObject *self, PyObject *args) {
   PyObject *resultobj;
   PyObject *varargs;
   PyObject *newargs;
   
-  newargs = PyTuple_GetSlice(args,0,3);
-  varargs = PyTuple_GetSlice(args,3,PyTuple_Size(args));
-  resultobj = _wrap_gp_log__varargs__(self,newargs,varargs);
+  newargs = PyTuple_GetSlice(args, 0, 3);
+  varargs = PyTuple_GetSlice(args, 3, PyTuple_Size(args));
+  resultobj = _wrap_gp_log__varargs__(self, newargs, varargs);
   Py_XDECREF(newargs);
   Py_XDECREF(varargs);
   return resultobj;
 }
 
 
 static PyMethodDef SwigMethods[] = {
-	 { "SWIG_PyInstanceMethod_New", SWIG_PyInstanceMethod_New, METH_O, NULL},
-	 { "SWIG_PyStaticMethod_New", SWIG_PyStaticMethod_New, METH_O, NULL},
-	 { "gp_log_add_func", _wrap_gp_log_add_func, METH_VARARGS, "\n"
-		"gp_log_add_func(level, func, data) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"level: GPLogLevel (gphoto2.GP_LOG_ERROR etc.)\n"
-		"func: callable function\n"
-		"data: object (default=None)\n"
-		"\n"
-		"Add a function to get logging information.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `level` :  \n"
-		"    the maximum level of logging it will get, up to and including the\n"
-		"    passed value  \n"
-		"* `func` :  \n"
-		"    a GPLogFunc  \n"
-		"* `data` :  \n"
-		"    data  \n"
-		"\n"
-		"Adds a log function that will be called for each log message that is\n"
-		"flagged with a log level that appears in given log level. This function\n"
-		"returns an id that you can use for removing the log function again\n"
-		"(using gp_log_remove_func).  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"an id or a gphoto2 error code\n"
-		""},
-	 { "gp_log", _wrap_gp_log, METH_VARARGS, "\n"
-		"gp_log(level, domain, format)\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"level: GPLogLevel (gphoto2.GP_LOG_ERROR etc.)\n"
-		"domain: str\n"
-		"format: str\n"
-		"\n"
-		"Log a debug or error message.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `level` :  \n"
-		"    gphoto2 log level  \n"
-		"* `domain` :  \n"
-		"    the log domain  \n"
-		"* `format` :  \n"
-		"    a printf style format string  \n"
-		"* `...` :  \n"
-		"    the variable argumentlist for above format string  \n"
-		"\n"
-		"Logs a message at the given log level. You would normally use this\n"
-		"function to log general debug output in a printf way.\n"
-		""},
-	 { NULL, NULL, 0, NULL }
-};
-
-static PyMethodDef SwigMethods_proxydocs[] = {
-	 { "SWIG_PyInstanceMethod_New", SWIG_PyInstanceMethod_New, METH_O, NULL},
-	 { "SWIG_PyStaticMethod_New", SWIG_PyStaticMethod_New, METH_O, NULL},
 	 { "gp_log_add_func", _wrap_gp_log_add_func, METH_VARARGS, "\n"
 		"gp_log_add_func(level, func, data) -> int\n"
 		"\n"
 		"Parameters\n"
 		"----------\n"
 		"level: GPLogLevel (gphoto2.GP_LOG_ERROR etc.)\n"
 		"func: callable function\n"
@@ -4166,15 +4428,19 @@
     PyObject_HEAD_INIT(NULL)
     0,                                        /* ob_size */
 #endif
     "gphoto2.port_log.LogFuncItem",           /* tp_name */
     sizeof(SwigPyObject),                     /* tp_basicsize */
     0,                                        /* tp_itemsize */
     _wrap_delete_LogFuncItem_destructor_closure,                  /* tp_dealloc */
+#if PY_VERSION_HEX < 0x030800b4
     (printfunc) 0,                            /* tp_print */
+#else
+    (Py_ssize_t) 0,                           /* tp_vectorcall_offset */
+#endif
     (getattrfunc) 0,                          /* tp_getattr */
     (setattrfunc) 0,                          /* tp_setattr */
 #if PY_VERSION_HEX >= 0x03000000
     0,                                        /* tp_compare */
 #else
     (cmpfunc) 0,                              /* tp_compare */
 #endif
@@ -4238,14 +4504,17 @@
 #endif
   },
 #if PY_VERSION_HEX >= 0x03050000
   {
     (unaryfunc) 0,                            /* am_await */
     (unaryfunc) 0,                            /* am_aiter */
     (unaryfunc) 0,                            /* am_anext */
+# if PY_VERSION_HEX >= 0x030a0000
+    (sendfunc) 0,                             /* am_send */
+# endif
   },
 #endif
   {
     (binaryfunc) 0,                           /* nb_add */
     (binaryfunc) 0,                           /* nb_subtract */
     (binaryfunc) 0,                           /* nb_multiply */
 #if PY_VERSION_HEX < 0x03000000
@@ -4338,77 +4607,86 @@
   },
     (PyObject *) 0,                           /* ht_name */
     (PyObject *) 0,                           /* ht_slots */
 #if PY_VERSION_HEX >= 0x03030000
     (PyObject *) 0,                           /* ht_qualname */
     0,                                        /* ht_cached_keys */
 #endif
+#if PY_VERSION_HEX >= 0x03090000
+    (PyObject *) 0,                           /* ht_module */
+#endif
+#if PY_VERSION_HEX >= 0x030b0000
+    (char *) 0,                               /* _ht_tpname */
+  {
+    (PyObject *) 0,                           /* getitem */
+  }
+#endif
 };
 
 SWIGINTERN SwigPyClientData SwigPyBuiltin__LogFuncItem_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__LogFuncItem_type};
 
 
 /* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */
 
 static swig_type_info _swigt__p_CameraAbilities = {"_p_CameraAbilities", "CameraAbilities *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraCaptureType = {"_p_CameraCaptureType", "enum CameraCaptureType *|CameraCaptureType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraDriverStatus = {"_p_CameraDriverStatus", "enum CameraDriverStatus *|CameraDriverStatus *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraEventType = {"_p_CameraEventType", "enum CameraEventType *|CameraEventType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileAccessType = {"_p_CameraFileAccessType", "enum CameraFileAccessType *|CameraFileAccessType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileInfoFields = {"_p_CameraFileInfoFields", "enum CameraFileInfoFields *|CameraFileInfoFields *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileOperation = {"_p_CameraFileOperation", "enum CameraFileOperation *|CameraFileOperation *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraCaptureType = {"_p_CameraCaptureType", "CameraCaptureType *|enum CameraCaptureType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraDriverStatus = {"_p_CameraDriverStatus", "CameraDriverStatus *|enum CameraDriverStatus *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraEventType = {"_p_CameraEventType", "CameraEventType *|enum CameraEventType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileAccessType = {"_p_CameraFileAccessType", "CameraFileAccessType *|enum CameraFileAccessType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileInfoFields = {"_p_CameraFileInfoFields", "CameraFileInfoFields *|enum CameraFileInfoFields *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileOperation = {"_p_CameraFileOperation", "CameraFileOperation *|enum CameraFileOperation *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_CameraFilePath = {"_p_CameraFilePath", "CameraFilePath *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFilePermissions = {"_p_CameraFilePermissions", "enum CameraFilePermissions *|CameraFilePermissions *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileStatus = {"_p_CameraFileStatus", "enum CameraFileStatus *|CameraFileStatus *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileType = {"_p_CameraFileType", "enum CameraFileType *|CameraFileType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFolderOperation = {"_p_CameraFolderOperation", "enum CameraFolderOperation *|CameraFolderOperation *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraOperation = {"_p_CameraOperation", "enum CameraOperation *|CameraOperation *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraStorageAccessType = {"_p_CameraStorageAccessType", "enum CameraStorageAccessType *|CameraStorageAccessType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraStorageFilesystemType = {"_p_CameraStorageFilesystemType", "enum CameraStorageFilesystemType *|CameraStorageFilesystemType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraStorageInfoFields = {"_p_CameraStorageInfoFields", "enum CameraStorageInfoFields *|CameraStorageInfoFields *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraStorageType = {"_p_CameraStorageType", "enum CameraStorageType *|CameraStorageType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFilePermissions = {"_p_CameraFilePermissions", "CameraFilePermissions *|enum CameraFilePermissions *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileStatus = {"_p_CameraFileStatus", "CameraFileStatus *|enum CameraFileStatus *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileType = {"_p_CameraFileType", "CameraFileType *|enum CameraFileType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFolderOperation = {"_p_CameraFolderOperation", "CameraFolderOperation *|enum CameraFolderOperation *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraOperation = {"_p_CameraOperation", "CameraOperation *|enum CameraOperation *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraStorageAccessType = {"_p_CameraStorageAccessType", "CameraStorageAccessType *|enum CameraStorageAccessType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraStorageFilesystemType = {"_p_CameraStorageFilesystemType", "CameraStorageFilesystemType *|enum CameraStorageFilesystemType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraStorageInfoFields = {"_p_CameraStorageInfoFields", "CameraStorageInfoFields *|enum CameraStorageInfoFields *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraStorageType = {"_p_CameraStorageType", "CameraStorageType *|enum CameraStorageType *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_CameraText = {"_p_CameraText", "CameraText *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraWidgetType = {"_p_CameraWidgetType", "enum CameraWidgetType *|CameraWidgetType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_GPLogLevel = {"_p_GPLogLevel", "enum GPLogLevel *|GPLogLevel *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_GPPortType = {"_p_GPPortType", "enum GPPortType *|GPPortType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_GPVersionVerbosity = {"_p_GPVersionVerbosity", "enum GPVersionVerbosity *|GPVersionVerbosity *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_GphotoDeviceType = {"_p_GphotoDeviceType", "enum GphotoDeviceType *|GphotoDeviceType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_LogFuncItem = {"_p_LogFuncItem", "struct LogFuncItem *|LogFuncItem *", 0, 0, (void*)&SwigPyBuiltin__LogFuncItem_clientdata, 0};
+static swig_type_info _swigt__p_CameraWidgetType = {"_p_CameraWidgetType", "CameraWidgetType *|enum CameraWidgetType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GPLogLevel = {"_p_GPLogLevel", "GPLogLevel *|enum GPLogLevel *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GPPortType = {"_p_GPPortType", "GPPortType *|enum GPPortType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GPVersionVerbosity = {"_p_GPVersionVerbosity", "GPVersionVerbosity *|enum GPVersionVerbosity *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GphotoDeviceType = {"_p_GphotoDeviceType", "GphotoDeviceType *|enum GphotoDeviceType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_LogFuncItem = {"_p_LogFuncItem", "LogFuncItem *|struct LogFuncItem *", 0, 0, (void*)&SwigPyBuiltin__LogFuncItem_clientdata, 0};
 static swig_type_info _swigt__p_SwigPyObject = {"_p_SwigPyObject", "SwigPyObject *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__Camera = {"_p__Camera", "struct _Camera *|Camera *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraAbilitiesList = {"_p__CameraAbilitiesList", "struct _CameraAbilitiesList *|CameraAbilitiesList *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFile = {"_p__CameraFile", "struct _CameraFile *|CameraFile *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFileHandler = {"_p__CameraFileHandler", "struct _CameraFileHandler *|CameraFileHandler *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFileInfo = {"_p__CameraFileInfo", "struct _CameraFileInfo *|CameraFileInfo *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFileInfoAudio = {"_p__CameraFileInfoAudio", "struct _CameraFileInfoAudio *|CameraFileInfoAudio *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFileInfoFile = {"_p__CameraFileInfoFile", "struct _CameraFileInfoFile *|CameraFileInfoFile *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFileInfoPreview = {"_p__CameraFileInfoPreview", "struct _CameraFileInfoPreview *|CameraFileInfoPreview *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFilesystem = {"_p__CameraFilesystem", "struct _CameraFilesystem *|CameraFilesystem *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFilesystemFuncs = {"_p__CameraFilesystemFuncs", "struct _CameraFilesystemFuncs *|CameraFilesystemFuncs *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFunctions = {"_p__CameraFunctions", "struct _CameraFunctions *|CameraFunctions *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraList = {"_p__CameraList", "struct _CameraList *|CameraList *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraPrivateCore = {"_p__CameraPrivateCore", "struct _CameraPrivateCore *|CameraPrivateCore *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraPrivateLibrary = {"_p__CameraPrivateLibrary", "struct _CameraPrivateLibrary *|CameraPrivateLibrary *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraStorageInformation = {"_p__CameraStorageInformation", "struct _CameraStorageInformation *|CameraStorageInformation *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraWidget = {"_p__CameraWidget", "struct _CameraWidget *|CameraWidget *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__GPContext = {"_p__GPContext", "struct _GPContext *|GPContext *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__GPContextFeedback = {"_p__GPContextFeedback", "enum _GPContextFeedback *|GPContextFeedback *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__Camera = {"_p__Camera", "Camera *|struct _Camera *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraAbilitiesList = {"_p__CameraAbilitiesList", "CameraAbilitiesList *|struct _CameraAbilitiesList *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFile = {"_p__CameraFile", "CameraFile *|struct _CameraFile *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFileHandler = {"_p__CameraFileHandler", "CameraFileHandler *|struct _CameraFileHandler *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFileInfo = {"_p__CameraFileInfo", "CameraFileInfo *|struct _CameraFileInfo *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFileInfoAudio = {"_p__CameraFileInfoAudio", "CameraFileInfoAudio *|struct _CameraFileInfoAudio *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFileInfoFile = {"_p__CameraFileInfoFile", "CameraFileInfoFile *|struct _CameraFileInfoFile *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFileInfoPreview = {"_p__CameraFileInfoPreview", "CameraFileInfoPreview *|struct _CameraFileInfoPreview *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFilesystem = {"_p__CameraFilesystem", "CameraFilesystem *|struct _CameraFilesystem *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFilesystemFuncs = {"_p__CameraFilesystemFuncs", "CameraFilesystemFuncs *|struct _CameraFilesystemFuncs *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFunctions = {"_p__CameraFunctions", "CameraFunctions *|struct _CameraFunctions *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraList = {"_p__CameraList", "CameraList *|struct _CameraList *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraPrivateCore = {"_p__CameraPrivateCore", "CameraPrivateCore *|struct _CameraPrivateCore *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraPrivateLibrary = {"_p__CameraPrivateLibrary", "CameraPrivateLibrary *|struct _CameraPrivateLibrary *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraStorageInformation = {"_p__CameraStorageInformation", "CameraStorageInformation *|struct _CameraStorageInformation *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraWidget = {"_p__CameraWidget", "CameraWidget *|struct _CameraWidget *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__GPContext = {"_p__GPContext", "GPContext *|struct _GPContext *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__GPContextFeedback = {"_p__GPContextFeedback", "GPContextFeedback *|enum _GPContextFeedback *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p__GPPortInfo = {"_p__GPPortInfo", "_GPPortInfo *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__GPPortInfoList = {"_p__GPPortInfoList", "struct _GPPortInfoList *|GPPortInfoList *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__GPPortInfoList = {"_p__GPPortInfoList", "GPPortInfoList *|struct _GPPortInfoList *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_f_enum_GPLogLevel_p_q_const__char_p_q_const__char_p_void__void = {"_p_f_enum_GPLogLevel_p_q_const__char_p_q_const__char_p_void__void", "void (*)(enum GPLogLevel,char const *,char const *,void *)|GPLogFunc", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_int = {"_p_int", "intptr_t *|int *|int_least32_t *|int_fast32_t *|int32_t *|int_fast16_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_long = {"_p_long", "long *|time_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_long_long = {"_p_long_long", "int_least64_t *|int_fast64_t *|int64_t *|long long *|intmax_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_short = {"_p_short", "short *|int_least16_t *|int16_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_signed_char = {"_p_signed_char", "signed char *|int_least8_t *|int_fast8_t *|int8_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_unsigned_char = {"_p_unsigned_char", "unsigned char *|uint_least8_t *|uint_fast8_t *|uint8_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_unsigned_int = {"_p_unsigned_int", "uintptr_t *|uint_least32_t *|uint_fast32_t *|uint32_t *|unsigned int *|uint_fast16_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_unsigned_long_long = {"_p_unsigned_long_long", "uint_least64_t *|uint_fast64_t *|uint64_t *|unsigned long long *|uintmax_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_unsigned_short = {"_p_unsigned_short", "unsigned short *|uint_least16_t *|uint16_t *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_f_enum_GPLogLevel_p_q_const__char_p_q_const__char_p_void__void = {"_p_f_enum_GPLogLevel_p_q_const__char_p_q_const__char_p_void__void", "GPLogFunc|void (*)(enum GPLogLevel,char const *,char const *,void *)", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_int = {"_p_int", "int32_t *|int_fast16_t *|int_fast32_t *|int_least32_t *|intptr_t *|int *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_long = {"_p_long", "time_t *|long *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_long_long = {"_p_long_long", "int64_t *|int_fast64_t *|int_least64_t *|intmax_t *|long long *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_short = {"_p_short", "int16_t *|int_least16_t *|short *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_signed_char = {"_p_signed_char", "int8_t *|int_fast8_t *|int_least8_t *|signed char *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_unsigned_char = {"_p_unsigned_char", "uint8_t *|uint_fast8_t *|uint_least8_t *|unsigned char *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_unsigned_int = {"_p_unsigned_int", "uint32_t *|uint_fast16_t *|uint_fast32_t *|uint_least32_t *|uintptr_t *|unsigned int *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_unsigned_long_long = {"_p_unsigned_long_long", "uint64_t *|uint_fast64_t *|uint_least64_t *|uintmax_t *|unsigned long long *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_unsigned_short = {"_p_unsigned_short", "uint16_t *|uint_least16_t *|unsigned short *", 0, 0, (void*)0, 0};
 
 static swig_type_info *swig_type_initial[] = {
   &_swigt__p_CameraAbilities,
   &_swigt__p_CameraCaptureType,
   &_swigt__p_CameraDriverStatus,
   &_swigt__p_CameraEventType,
   &_swigt__p_CameraFileAccessType,
@@ -4640,17 +4918,20 @@
 #endif
 #endif
 
 #if 0
 #define SWIGRUNTIME_DEBUG
 #endif
 
+#ifndef SWIG_INIT_CLIENT_DATA_TYPE
+#define SWIG_INIT_CLIENT_DATA_TYPE void *
+#endif
 
 SWIGRUNTIME void
-SWIG_InitializeModule(void *clientdata) {
+SWIG_InitializeModule(SWIG_INIT_CLIENT_DATA_TYPE clientdata) {
   size_t i;
   swig_module_info *module_head, *iter;
   int init;
   
   /* check to see if the circular list has been setup, if not, set it up */
   if (swig_module.next==0) {
     /* Initialize the swig_module */
@@ -4825,228 +5106,14 @@
 
 
 
 #ifdef __cplusplus
 extern "C" {
 #endif
   
-  /* Python-specific SWIG API */
-#define SWIG_newvarlink()                             SWIG_Python_newvarlink()
-#define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
-#define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)
-  
-  /* -----------------------------------------------------------------------------
-   * global variable support code.
-   * ----------------------------------------------------------------------------- */
-  
-  typedef struct swig_globalvar {
-    char       *name;                  /* Name of global variable */
-    PyObject *(*get_attr)(void);       /* Return the current value */
-    int       (*set_attr)(PyObject *); /* Set the value */
-    struct swig_globalvar *next;
-  } swig_globalvar;
-  
-  typedef struct swig_varlinkobject {
-    PyObject_HEAD
-    swig_globalvar *vars;
-  } swig_varlinkobject;
-  
-  SWIGINTERN PyObject *
-  swig_varlink_repr(swig_varlinkobject *SWIGUNUSEDPARM(v)) {
-#if PY_VERSION_HEX >= 0x03000000
-    return PyUnicode_InternFromString("<Swig global variables>");
-#else
-    return PyString_FromString("<Swig global variables>");
-#endif
-  }
-  
-  SWIGINTERN PyObject *
-  swig_varlink_str(swig_varlinkobject *v) {
-#if PY_VERSION_HEX >= 0x03000000
-    PyObject *str = PyUnicode_InternFromString("(");
-    PyObject *tail;
-    PyObject *joined;
-    swig_globalvar *var;
-    for (var = v->vars; var; var=var->next) {
-      tail = PyUnicode_FromString(var->name);
-      joined = PyUnicode_Concat(str, tail);
-      Py_DecRef(str);
-      Py_DecRef(tail);
-      str = joined;
-      if (var->next) {
-        tail = PyUnicode_InternFromString(", ");
-        joined = PyUnicode_Concat(str, tail);
-        Py_DecRef(str);
-        Py_DecRef(tail);
-        str = joined;
-      }
-    }
-    tail = PyUnicode_InternFromString(")");
-    joined = PyUnicode_Concat(str, tail);
-    Py_DecRef(str);
-    Py_DecRef(tail);
-    str = joined;
-#else
-    PyObject *str = PyString_FromString("(");
-    swig_globalvar *var;
-    for (var = v->vars; var; var=var->next) {
-      PyString_ConcatAndDel(&str,PyString_FromString(var->name));
-      if (var->next) PyString_ConcatAndDel(&str,PyString_FromString(", "));
-    }
-    PyString_ConcatAndDel(&str,PyString_FromString(")"));
-#endif
-    return str;
-  }
-  
-  SWIGINTERN void
-  swig_varlink_dealloc(swig_varlinkobject *v) {
-    swig_globalvar *var = v->vars;
-    while (var) {
-      swig_globalvar *n = var->next;
-      free(var->name);
-      free(var);
-      var = n;
-    }
-  }
-  
-  SWIGINTERN PyObject *
-  swig_varlink_getattr(swig_varlinkobject *v, char *n) {
-    PyObject *res = NULL;
-    swig_globalvar *var = v->vars;
-    while (var) {
-      if (strcmp(var->name,n) == 0) {
-        res = (*var->get_attr)();
-        break;
-      }
-      var = var->next;
-    }
-    if (res == NULL && !PyErr_Occurred()) {
-      PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
-    }
-    return res;
-  }
-  
-  SWIGINTERN int
-  swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
-    int res = 1;
-    swig_globalvar *var = v->vars;
-    while (var) {
-      if (strcmp(var->name,n) == 0) {
-        res = (*var->set_attr)(p);
-        break;
-      }
-      var = var->next;
-    }
-    if (res == 1 && !PyErr_Occurred()) {
-      PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
-    }
-    return res;
-  }
-  
-  SWIGINTERN PyTypeObject*
-  swig_varlink_type(void) {
-    static char varlink__doc__[] = "Swig var link object";
-    static PyTypeObject varlink_type;
-    static int type_init = 0;
-    if (!type_init) {
-      const PyTypeObject tmp = {
-#if PY_VERSION_HEX >= 0x03000000
-        PyVarObject_HEAD_INIT(NULL, 0)
-#else
-        PyObject_HEAD_INIT(NULL)
-        0,                                  /* ob_size */
-#endif
-        "swigvarlink",                      /* tp_name */
-        sizeof(swig_varlinkobject),         /* tp_basicsize */
-        0,                                  /* tp_itemsize */
-        (destructor) swig_varlink_dealloc,  /* tp_dealloc */
-        0,                                  /* tp_print */
-        (getattrfunc) swig_varlink_getattr, /* tp_getattr */
-        (setattrfunc) swig_varlink_setattr, /* tp_setattr */
-        0,                                  /* tp_compare */
-        (reprfunc) swig_varlink_repr,       /* tp_repr */
-        0,                                  /* tp_as_number */
-        0,                                  /* tp_as_sequence */
-        0,                                  /* tp_as_mapping */
-        0,                                  /* tp_hash */
-        0,                                  /* tp_call */
-        (reprfunc) swig_varlink_str,        /* tp_str */
-        0,                                  /* tp_getattro */
-        0,                                  /* tp_setattro */
-        0,                                  /* tp_as_buffer */
-        0,                                  /* tp_flags */
-        varlink__doc__,                     /* tp_doc */
-        0,                                  /* tp_traverse */
-        0,                                  /* tp_clear */
-        0,                                  /* tp_richcompare */
-        0,                                  /* tp_weaklistoffset */
-        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
-        0,                                  /* tp_del */
-        0,                                  /* tp_version_tag */
-#if PY_VERSION_HEX >= 0x03040000
-        0,                                  /* tp_finalize */
-#endif
-#if PY_VERSION_HEX >= 0x03080000
-        0,                                  /* tp_vectorcall */
-#endif
-#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
-        0,                                  /* tp_print */
-#endif
-#ifdef COUNT_ALLOCS
-        0,                                  /* tp_allocs */
-        0,                                  /* tp_frees */
-        0,                                  /* tp_maxalloc */
-        0,                                  /* tp_prev */
-        0                                   /* tp_next */
-#endif
-      };
-      varlink_type = tmp;
-      type_init = 1;
-      if (PyType_Ready(&varlink_type) < 0)
-      return NULL;
-    }
-    return &varlink_type;
-  }
-  
-  /* Create a variable linking object for use later */
-  SWIGINTERN PyObject *
-  SWIG_Python_newvarlink(void) {
-    swig_varlinkobject *result = PyObject_NEW(swig_varlinkobject, swig_varlink_type());
-    if (result) {
-      result->vars = 0;
-    }
-    return ((PyObject*) result);
-  }
-  
-  SWIGINTERN void 
-  SWIG_Python_addvarlink(PyObject *p, const char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
-    swig_varlinkobject *v = (swig_varlinkobject *) p;
-    swig_globalvar *gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
-    if (gv) {
-      size_t size = strlen(name)+1;
-      gv->name = (char *)malloc(size);
-      if (gv->name) {
-        memcpy(gv->name, name, size);
-        gv->get_attr = get_attr;
-        gv->set_attr = set_attr;
-        gv->next = v->vars;
-      }
-    }
-    v->vars = gv;
-  }
-  
-  SWIGINTERN PyObject *
-  SWIG_globals(void) {
-    static PyObject *globals = 0;
-    if (!globals) {
-      globals = SWIG_newvarlink();
-    }
-    return globals;
-  }
-  
   /* -----------------------------------------------------------------------------
    * constants/methods manipulation
    * ----------------------------------------------------------------------------- */
   
   /* Install Constants */
   SWIGINTERN void
   SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
@@ -5067,31 +5134,28 @@
       if (obj) {
         PyDict_SetItemString(d, constants[i].name, obj);
         Py_DECREF(obj);
       }
     }
   }
   
-  /* -----------------------------------------------------------------------------*/
-  /* Fix SwigMethods to carry the callback ptrs when needed */
-  /* -----------------------------------------------------------------------------*/
+  /* -----------------------------------------------------------------------------
+   * Patch %callback methods' docstrings to hold the callback ptrs
+   * -----------------------------------------------------------------------------*/
   
   SWIGINTERN void
-  SWIG_Python_FixMethods(PyMethodDef *methods,
-    swig_const_info *const_table,
-    swig_type_info **types,
-    swig_type_info **types_initial) {
+  SWIG_Python_FixMethods(PyMethodDef *methods, const swig_const_info *const_table, swig_type_info **types, swig_type_info **types_initial) {
     size_t i;
     for (i = 0; methods[i].ml_name; ++i) {
       const char *c = methods[i].ml_doc;
       if (!c) continue;
       c = strstr(c, "swig_ptr: ");
       if (c) {
         int j;
-        swig_const_info *ci = 0;
+        const swig_const_info *ci = 0;
         const char *name = c + 10;
         for (j = 0; const_table[j].type; ++j) {
           if (strncmp(const_table[j].name, name, 
               strlen(const_table[j].name)) == 0) {
             ci = &(const_table[j]);
             break;
           }
@@ -5115,76 +5179,21 @@
             }
           }
         }
       }
     }
   } 
   
-  /* -----------------------------------------------------------------------------
-   * Method creation and docstring support functions
-   * ----------------------------------------------------------------------------- */
-  
-  /* -----------------------------------------------------------------------------
-   * Function to find the method definition with the correct docstring for the
-   * proxy module as opposed to the low-level API
-   * ----------------------------------------------------------------------------- */
-  
-  SWIGINTERN PyMethodDef *SWIG_PythonGetProxyDoc(const char *name) {
-    /* Find the function in the modified method table */
-    size_t offset = 0;
-    int found = 0;
-    while (SwigMethods_proxydocs[offset].ml_meth != NULL) {
-      if (strcmp(SwigMethods_proxydocs[offset].ml_name, name) == 0) {
-        found = 1;
-        break;
-      }
-      offset++;
-    }
-    /* Use the copy with the modified docstring if available */
-    return found ? &SwigMethods_proxydocs[offset] : NULL;
-  }
-  
-  /* -----------------------------------------------------------------------------
-   * Wrapper of PyInstanceMethod_New() used in Python 3
-   * It is exported to the generated module, used for -fastproxy
-   * ----------------------------------------------------------------------------- */
-  
-  SWIGINTERN PyObject *SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func) {
-    if (PyCFunction_Check(func)) {
-      PyCFunctionObject *funcobj = (PyCFunctionObject *)func;
-      PyMethodDef *ml = SWIG_PythonGetProxyDoc(funcobj->m_ml->ml_name);
-      if (ml)
-      func = PyCFunction_NewEx(ml, funcobj->m_self, funcobj->m_module);
-    }
-#if PY_VERSION_HEX >= 0x03000000
-    return PyInstanceMethod_New(func);
-#else
-    return PyMethod_New(func, NULL, NULL);
-#endif
-  }
-  
-  /* -----------------------------------------------------------------------------
-   * Wrapper of PyStaticMethod_New()
-   * It is exported to the generated module, used for -fastproxy
-   * ----------------------------------------------------------------------------- */
-  
-  SWIGINTERN PyObject *SWIG_PyStaticMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func) {
-    if (PyCFunction_Check(func)) {
-      PyCFunctionObject *funcobj = (PyCFunctionObject *)func;
-      PyMethodDef *ml = SWIG_PythonGetProxyDoc(funcobj->m_ml->ml_name);
-      if (ml)
-      func = PyCFunction_NewEx(ml, funcobj->m_self, funcobj->m_module);
-    }
-    return PyStaticMethod_New(func);
-  }
-  
 #ifdef __cplusplus
 }
 #endif
 
+
+
+
 /* -----------------------------------------------------------------------------*
  *  Partial Init method
  * -----------------------------------------------------------------------------*/
 
 #ifdef __cplusplus
 extern "C"
 #endif
```

### Comparing `gphoto2-2.3.4/src/swig-gp2.5.30/result_wrap.c` & `gphoto2-2.3.5/src/swig-gp2_5_30/result_wrap.c`

 * *Files 4% similar despite different names*

```diff
@@ -1,24 +1,21 @@
 /* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 4.0.2
+ * This file was automatically generated by SWIG (https://www.swig.org).
+ * Version 4.1.1
  *
- * This file is not intended to be easily readable and contains a number of
- * coding conventions designed to improve portability and efficiency. Do not make
- * changes to this file unless you know what you are doing--modify the SWIG
- * interface file instead.
+ * Do not make changes to this file unless you know what you are doing - modify
+ * the SWIG interface file instead.
  * ----------------------------------------------------------------------------- */
 
 
-#ifndef SWIGPYTHON
+#define SWIG_VERSION 0x040101
 #define SWIGPYTHON
-#endif
-
 #define SWIG_PYTHON_DIRECTOR_NO_VTABLE
 #define SWIGPYTHON_BUILTIN
+#define SWIGPYTHON_FASTPROXY
 
 /* -----------------------------------------------------------------------------
  *  This section contains generic SWIG labels for method/variable
  *  declarations/attributes, and other compiler dependent labels.
  * ----------------------------------------------------------------------------- */
 
 /* template workaround for compilers that cannot correctly implement the C++ standard */
@@ -142,23 +139,45 @@
 
 
 #if defined(__GNUC__) && defined(_WIN32) && !defined(SWIG_PYTHON_NO_HYPOT_WORKAROUND)
 /* Workaround for '::hypot' has not been declared', see https://bugs.python.org/issue11566 */
 # include <math.h>
 #endif
 
+#if !defined(PY_SSIZE_T_CLEAN) && !defined(SWIG_NO_PY_SSIZE_T_CLEAN)
+#define PY_SSIZE_T_CLEAN
+#endif
+
+#if __GNUC__ >= 7
+#pragma GCC diagnostic push
+#if defined(__cplusplus) && __cplusplus >=201703L
+#pragma GCC diagnostic ignored "-Wregister" /* For python-2.7 headers that use register */
+#endif
+#endif
+
 #if defined(_DEBUG) && defined(SWIG_PYTHON_INTERPRETER_NO_DEBUG)
 /* Use debug wrappers with the Python release dll */
+
+#if defined(_MSC_VER) && _MSC_VER >= 1929
+/* Workaround compilation errors when redefining _DEBUG in MSVC 2019 version 16.10 and later
+ * See https://github.com/swig/swig/issues/2090 */
+# include <corecrt.h>
+#endif
+
 # undef _DEBUG
 # include <Python.h>
 # define _DEBUG 1
 #else
 # include <Python.h>
 #endif
 
+#if __GNUC__ >= 7
+#pragma GCC diagnostic pop
+#endif
+
 /* -----------------------------------------------------------------------------
  * swigrun.swg
  *
  * This file contains generic C API SWIG runtime support for pointer
  * type checking.
  * ----------------------------------------------------------------------------- */
 
@@ -197,14 +216,16 @@
 # define SWIG_BUFFER_SIZE 1024
 #endif
 
 /* Flags for pointer conversions */
 #define SWIG_POINTER_DISOWN        0x1
 #define SWIG_CAST_NEW_MEMORY       0x2
 #define SWIG_POINTER_NO_NULL       0x4
+#define SWIG_POINTER_CLEAR         0x8
+#define SWIG_POINTER_RELEASE       (SWIG_POINTER_CLEAR | SWIG_POINTER_DISOWN)
 
 /* Flags for new pointer objects */
 #define SWIG_POINTER_OWN           0x1
 
 
 /*
    Flags/methods for returning states.
@@ -268,44 +289,50 @@
       }
 
    Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
    more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
    SWIG errors code.
 
    Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
-   allows to return the 'cast rank', for example, if you have this
+   allows returning the 'cast rank', for example, if you have this
 
        int food(double)
        int fooi(int);
 
    and you call
 
       food(1)   // cast rank '1'  (1 -> 1.0)
       fooi(1)   // cast rank '0'
 
    just use the SWIG_AddCast()/SWIG_CheckState()
 */
 
 #define SWIG_OK                    (0)
+/* Runtime errors are < 0 */
 #define SWIG_ERROR                 (-1)
+/* Errors in range -1 to -99 are in swigerrors.swg (errors for all languages including those not using the runtime) */
+/* Errors in range -100 to -199 are language specific errors defined in *errors.swg */
+/* Errors < -200 are generic runtime specific errors */
+#define SWIG_ERROR_RELEASE_NOT_OWNED (-200)
+
 #define SWIG_IsOK(r)               (r >= 0)
 #define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)
 
 /* The CastRankLimit says how many bits are used for the cast rank */
 #define SWIG_CASTRANKLIMIT         (1 << 8)
 /* The NewMask denotes the object was created (using new/malloc) */
 #define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
 /* The TmpMask is for in/out typemaps that use temporal objects */
 #define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
 /* Simple returning values */
 #define SWIG_BADOBJ                (SWIG_ERROR)
 #define SWIG_OLDOBJ                (SWIG_OK)
 #define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
 #define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
-/* Check, add and del mask methods */
+/* Check, add and del object mask methods */
 #define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
 #define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
 #define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
 #define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
 #define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
 #define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))
 
@@ -443,15 +470,15 @@
   return 0;
 }
 
 /*
   Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
 */
 SWIGRUNTIME swig_cast_info *
-SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty) {
+SWIG_TypeCheckStruct(const swig_type_info *from, swig_type_info *ty) {
   if (ty) {
     swig_cast_info *iter = ty->cast;
     while (iter) {
       if (iter->type == from) {
         if (iter == ty->cast)
           return iter;
         /* Move iter to the top of the linked list */
@@ -503,17 +530,17 @@
 /*
   Return the pretty name associated with this type,
   that is an unmangled type name in a form presentable to the user.
 */
 SWIGRUNTIME const char *
 SWIG_TypePrettyName(const swig_type_info *type) {
   /* The "str" field contains the equivalent pretty names of the
-     type, separated by vertical-bar characters.  We choose
-     to print the last name, as it is often (?) the most
-     specific. */
+     type, separated by vertical-bar characters.  Choose the last
+     name. It should be the most specific; a fully resolved name
+     but not necessarily with default template parameters expanded. */
   if (!type) return NULL;
   if (type->str != NULL) {
     const char *last_name = type->str;
     const char *s;
     for (s = type->str; *s; s++)
       if (*s == '|') last_name = s+1;
     return last_name;
@@ -725,15 +752,15 @@
   return SWIG_UnpackData(++c,ptr,sz);
 }
 
 #ifdef __cplusplus
 }
 #endif
 
-/*  Errors in SWIG */
+/* SWIG Errors applicable to all language modules, values are reserved from -1 to -99 */
 #define  SWIG_UnknownError    	   -1
 #define  SWIG_IOError        	   -2
 #define  SWIG_RuntimeError   	   -3
 #define  SWIG_IndexError     	   -4
 #define  SWIG_TypeError      	   -5
 #define  SWIG_DivisionByZero 	   -6
 #define  SWIG_OverflowError  	   -7
@@ -741,15 +768,14 @@
 #define  SWIG_ValueError     	   -9
 #define  SWIG_SystemError    	   -10
 #define  SWIG_AttributeError 	   -11
 #define  SWIG_MemoryError    	   -12
 #define  SWIG_NullReferenceError   -13
 
 
-
 /* Compatibility macros for Python 3 */
 #if PY_VERSION_HEX >= 0x03000000
 
 #define PyClass_Check(obj) PyObject_IsInstance(obj, (PyObject *)&PyType_Type)
 #define PyInt_Check(x) PyLong_Check(x)
 #define PyInt_AsLong(x) PyLong_AsLong(x)
 #define PyInt_FromLong(x) PyLong_FromLong(x)
@@ -757,15 +783,14 @@
 #define PyString_Check(name) PyBytes_Check(name)
 #define PyString_FromString(x) PyUnicode_FromString(x)
 #define PyString_Format(fmt, args)  PyUnicode_Format(fmt, args)
 #define PyString_AsString(str) PyBytes_AsString(str)
 #define PyString_Size(str) PyBytes_Size(str)	
 #define PyString_InternFromString(key) PyUnicode_InternFromString(key)
 #define Py_TPFLAGS_HAVE_CLASS Py_TPFLAGS_BASETYPE
-#define PyString_AS_STRING(x) PyUnicode_AS_STRING(x)
 #define _PyLong_FromSsize_t(x) PyLong_FromSsize_t(x)
 
 #endif
 
 #ifndef Py_TYPE
 #  define Py_TYPE(op) ((op)->ob_type)
 #endif
@@ -775,46 +800,27 @@
 #if PY_VERSION_HEX >= 0x03000000
 #  define SWIG_Python_str_FromFormat PyUnicode_FromFormat
 #else
 #  define SWIG_Python_str_FromFormat PyString_FromFormat
 #endif
 
 
-/* Warning: This function will allocate a new string in Python 3,
- * so please call SWIG_Python_str_DelForPy3(x) to free the space.
- */
 SWIGINTERN char*
 SWIG_Python_str_AsChar(PyObject *str)
 {
 #if PY_VERSION_HEX >= 0x03030000
   return (char *)PyUnicode_AsUTF8(str);
-#elif PY_VERSION_HEX >= 0x03000000
-  char *newstr = 0;
-  str = PyUnicode_AsUTF8String(str);
-  if (str) {
-    char *cstr;
-    Py_ssize_t len;
-    if (PyBytes_AsStringAndSize(str, &cstr, &len) != -1) {
-      newstr = (char *) malloc(len+1);
-      if (newstr)
-        memcpy(newstr, cstr, len+1);
-    }
-    Py_XDECREF(str);
-  }
-  return newstr;
 #else
   return PyString_AsString(str);
 #endif
 }
 
-#if PY_VERSION_HEX >= 0x03030000 || PY_VERSION_HEX < 0x03000000
-#  define SWIG_Python_str_DelForPy3(x)
-#else
-#  define SWIG_Python_str_DelForPy3(x) free( (void*) (x) )
-#endif
+/* Was useful for Python 3.0.x-3.2.x - now provided only for compatibility
+ * with any uses in user interface files. */
+#define SWIG_Python_str_DelForPy3(x)
 
 
 SWIGINTERN PyObject*
 SWIG_Python_str_FromChar(const char *c)
 {
 #if PY_VERSION_HEX >= 0x03000000
   return PyUnicode_FromString(c); 
@@ -823,18 +829,22 @@
 #endif
 }
 
 #ifndef PyObject_DEL
 # define PyObject_DEL PyObject_Del
 #endif
 
-// SWIGPY_USE_CAPSULE is no longer used within SWIG itself, but some user
-// interface files check for it.
+/* SWIGPY_USE_CAPSULE is no longer used within SWIG itself, but some user interface files check for it. */
 # define SWIGPY_USE_CAPSULE
-# define SWIGPY_CAPSULE_NAME ("swig_runtime_data" SWIG_RUNTIME_VERSION ".type_pointer_capsule" SWIG_TYPE_TABLE_NAME)
+#ifdef SWIGPYTHON_BUILTIN
+# define SWIGPY_CAPSULE_ATTR_NAME "type_pointer_capsule_builtin" SWIG_TYPE_TABLE_NAME
+#else
+# define SWIGPY_CAPSULE_ATTR_NAME "type_pointer_capsule" SWIG_TYPE_TABLE_NAME
+#endif
+# define SWIGPY_CAPSULE_NAME ("swig_runtime_data" SWIG_RUNTIME_VERSION "." SWIGPY_CAPSULE_ATTR_NAME)
 
 #if PY_VERSION_HEX < 0x03020000
 #define PyDescr_TYPE(x) (((PyDescrObject *)(x))->d_type)
 #define PyDescr_NAME(x) (((PyDescrObject *)(x))->d_name)
 #define Py_hash_t long
 #endif
 
@@ -900,15 +910,14 @@
     const char *tmp = SWIG_Python_str_AsChar(old_str);
     PyErr_Clear();
     Py_XINCREF(type);
     if (tmp)
       PyErr_Format(type, "%s %s", tmp, mesg);
     else
       PyErr_Format(type, "%s", mesg);
-    SWIG_Python_str_DelForPy3(tmp);
     Py_DECREF(old_str);
     Py_DECREF(value);
   } else {
     PyErr_SetString(PyExc_RuntimeError, mesg);
   }
 }
 
@@ -931,16 +940,20 @@
     PyObject *type = NULL, *value = NULL, *traceback = NULL;
     PyErr_Fetch(&type, &value, &traceback);
 #if PY_VERSION_HEX >= 0x03000000
     newvalue = PyUnicode_FromFormat("%S\nAdditional information:\n%s", value, message);
 #else
     newvalue = PyString_FromFormat("%s\nAdditional information:\n%s", PyString_AsString(value), message);
 #endif
-    Py_XDECREF(value);
-    PyErr_Restore(type, newvalue, traceback);
+    if (newvalue) {
+      Py_XDECREF(value);
+      PyErr_Restore(type, newvalue, traceback);
+    } else {
+      PyErr_Restore(type, value, traceback);
+    }
   } else {
     /* Raise TypeError using given message */
     PyErr_SetString(PyExc_TypeError, message);
   }
 }
 
 #if defined(SWIG_PYTHON_NO_THREADS)
@@ -949,16 +962,20 @@
 #  endif
 #endif
 #if defined(SWIG_PYTHON_THREADS) /* Threading support is enabled */
 #  if !defined(SWIG_PYTHON_USE_GIL) && !defined(SWIG_PYTHON_NO_USE_GIL)
 #    define SWIG_PYTHON_USE_GIL
 #  endif
 #  if defined(SWIG_PYTHON_USE_GIL) /* Use PyGILState threads calls */
-#    ifndef SWIG_PYTHON_INITIALIZE_THREADS
-#     define SWIG_PYTHON_INITIALIZE_THREADS  PyEval_InitThreads() 
+#    if !defined(SWIG_PYTHON_INITIALIZE_THREADS)
+#      if PY_VERSION_HEX < 0x03070000
+#        define SWIG_PYTHON_INITIALIZE_THREADS PyEval_InitThreads()
+#      else
+#        define SWIG_PYTHON_INITIALIZE_THREADS
+#      endif
 #    endif
 #    ifdef __cplusplus /* C++ code */
        class SWIG_Python_Thread_Block {
          bool status;
          PyGILState_STATE state;
        public:
          void end() { if (status) { PyGILState_Release(state); status = false;} }
@@ -1048,16 +1065,16 @@
  *
  * ----------------------------------------------------------------------------- */
 
 #if PY_VERSION_HEX < 0x02070000 /* 2.7.0 */
 # error "This version of SWIG only supports Python >= 2.7"
 #endif
 
-#if PY_VERSION_HEX >= 0x03000000 && PY_VERSION_HEX < 0x03020000
-# error "This version of SWIG only supports Python 3 >= 3.2"
+#if PY_VERSION_HEX >= 0x03000000 && PY_VERSION_HEX < 0x03030000
+# error "This version of SWIG only supports Python 3 >= 3.3"
 #endif
 
 /* Common SWIG API */
 
 /* for raw pointers */
 #define SWIG_Python_ConvertPtr(obj, pptr, type, flags)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, 0)
 #define SWIG_ConvertPtr(obj, pptr, type, flags)         SWIG_Python_ConvertPtr(obj, pptr, type, flags)
@@ -1164,15 +1181,20 @@
   } else if (result == Py_None) {
     Py_DECREF(result);
     result = obj;
   } else {
     if (!PyList_Check(result)) {
       PyObject *o2 = result;
       result = PyList_New(1);
-      PyList_SetItem(result, 0, o2);
+      if (result) {
+        PyList_SET_ITEM(result, 0, o2);
+      } else {
+        Py_DECREF(obj);
+        return o2;
+      }
     }
     PyList_Append(result,obj);
     Py_DECREF(obj);
   }
   return result;
 }
 
@@ -1246,14 +1268,246 @@
 */
 #ifdef __cplusplus
 #define SWIG_STATIC_POINTER(var)  var
 #else
 #define SWIG_STATIC_POINTER(var)  var = 0; if (!var) var
 #endif
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Python-specific SWIG API */
+#define SWIG_newvarlink()                             SWIG_Python_newvarlink()
+#define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
+#define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)
+ 
+/* -----------------------------------------------------------------------------
+ * global variable support code.
+ * ----------------------------------------------------------------------------- */
+ 
+typedef struct swig_globalvar {   
+  char       *name;                  /* Name of global variable */
+  PyObject *(*get_attr)(void);       /* Return the current value */
+  int       (*set_attr)(PyObject *); /* Set the value */
+  struct swig_globalvar *next;
+} swig_globalvar;
+
+typedef struct swig_varlinkobject {
+  PyObject_HEAD
+  swig_globalvar *vars;
+} swig_varlinkobject;
+
+SWIGINTERN PyObject *
+swig_varlink_repr(PyObject *SWIGUNUSEDPARM(v)) {
+#if PY_VERSION_HEX >= 0x03000000
+  return PyUnicode_InternFromString("<Swig global variables>");
+#else
+  return PyString_FromString("<Swig global variables>");
+#endif
+}
+
+SWIGINTERN PyObject *
+swig_varlink_str(PyObject *o) {
+  swig_varlinkobject *v = (swig_varlinkobject *) o;
+#if PY_VERSION_HEX >= 0x03000000
+  PyObject *str = PyUnicode_InternFromString("(");
+  PyObject *tail;
+  PyObject *joined;
+  swig_globalvar *var;
+  for (var = v->vars; var; var=var->next) {
+    tail = PyUnicode_FromString(var->name);
+    joined = PyUnicode_Concat(str, tail);
+    Py_DecRef(str);
+    Py_DecRef(tail);
+    str = joined;
+    if (var->next) {
+        tail = PyUnicode_InternFromString(", ");
+        joined = PyUnicode_Concat(str, tail);
+        Py_DecRef(str);
+        Py_DecRef(tail);
+        str = joined;
+    }
+  }
+  tail = PyUnicode_InternFromString(")");
+  joined = PyUnicode_Concat(str, tail);
+  Py_DecRef(str);
+  Py_DecRef(tail);
+  str = joined;
+#else
+  PyObject *str = PyString_FromString("(");
+  swig_globalvar *var;
+  for (var = v->vars; var; var=var->next) {
+    PyString_ConcatAndDel(&str,PyString_FromString(var->name));
+    if (var->next) PyString_ConcatAndDel(&str,PyString_FromString(", "));
+  }
+  PyString_ConcatAndDel(&str,PyString_FromString(")"));
+#endif
+  return str;
+}
+
+SWIGINTERN void
+swig_varlink_dealloc(PyObject *o) {
+  swig_varlinkobject *v = (swig_varlinkobject *) o;
+  swig_globalvar *var = v->vars;
+  while (var) {
+    swig_globalvar *n = var->next;
+    free(var->name);
+    free(var);
+    var = n;
+  }
+}
+
+SWIGINTERN PyObject *
+swig_varlink_getattr(PyObject *o, char *n) {
+  swig_varlinkobject *v = (swig_varlinkobject *) o;
+  PyObject *res = NULL;
+  swig_globalvar *var = v->vars;
+  while (var) {
+    if (strcmp(var->name,n) == 0) {
+      res = (*var->get_attr)();
+      break;
+    }
+    var = var->next;
+  }
+  if (res == NULL && !PyErr_Occurred()) {
+    PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
+  }
+  return res;
+}
+
+SWIGINTERN int
+swig_varlink_setattr(PyObject *o, char *n, PyObject *p) {
+  swig_varlinkobject *v = (swig_varlinkobject *) o;
+  int res = 1;
+  swig_globalvar *var = v->vars;
+  while (var) {
+    if (strcmp(var->name,n) == 0) {
+      res = (*var->set_attr)(p);
+      break;
+    }
+    var = var->next;
+  }
+  if (res == 1 && !PyErr_Occurred()) {
+    PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
+  }
+  return res;
+}
+
+SWIGINTERN PyTypeObject*
+swig_varlink_type(void) {
+  static char varlink__doc__[] = "Swig var link object";
+  static PyTypeObject varlink_type;
+  static int type_init = 0;
+  if (!type_init) {
+    const PyTypeObject tmp = {
+#if PY_VERSION_HEX >= 0x03000000
+      PyVarObject_HEAD_INIT(NULL, 0)
+#else
+      PyObject_HEAD_INIT(NULL)
+      0,                                  /* ob_size */
+#endif
+      "swigvarlink",                      /* tp_name */
+      sizeof(swig_varlinkobject),         /* tp_basicsize */
+      0,                                  /* tp_itemsize */
+      (destructor) swig_varlink_dealloc,  /* tp_dealloc */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                       /*tp_print*/
+#else
+      (Py_ssize_t)0,                      /*tp_vectorcall_offset*/
+#endif
+      (getattrfunc) swig_varlink_getattr, /* tp_getattr */
+      (setattrfunc) swig_varlink_setattr, /* tp_setattr */
+      0,                                  /* tp_compare */
+      (reprfunc) swig_varlink_repr,       /* tp_repr */
+      0,                                  /* tp_as_number */
+      0,                                  /* tp_as_sequence */
+      0,                                  /* tp_as_mapping */
+      0,                                  /* tp_hash */
+      0,                                  /* tp_call */
+      (reprfunc) swig_varlink_str,        /* tp_str */
+      0,                                  /* tp_getattro */
+      0,                                  /* tp_setattro */
+      0,                                  /* tp_as_buffer */
+      0,                                  /* tp_flags */
+      varlink__doc__,                     /* tp_doc */
+      0,                                  /* tp_traverse */
+      0,                                  /* tp_clear */
+      0,                                  /* tp_richcompare */
+      0,                                  /* tp_weaklistoffset */
+      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
+      0,                                  /* tp_del */
+      0,                                  /* tp_version_tag */
+#if PY_VERSION_HEX >= 0x03040000
+      0,                                  /* tp_finalize */
+#endif
+#if PY_VERSION_HEX >= 0x03080000
+      0,                                  /* tp_vectorcall */
+#endif
+#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
+      0,                                  /* tp_print */
+#endif
+#ifdef COUNT_ALLOCS
+      0,                                  /* tp_allocs */
+      0,                                  /* tp_frees */
+      0,                                  /* tp_maxalloc */
+      0,                                  /* tp_prev */
+      0                                   /* tp_next */
+#endif
+    };
+    varlink_type = tmp;
+    type_init = 1;
+    if (PyType_Ready(&varlink_type) < 0)
+      return NULL;
+  }
+  return &varlink_type;
+}
+
+/* Create a variable linking object for use later */
+SWIGINTERN PyObject *
+SWIG_Python_newvarlink(void) {
+  swig_varlinkobject *result = PyObject_NEW(swig_varlinkobject, swig_varlink_type());
+  if (result) {
+    result->vars = 0;
+  }
+  return ((PyObject*) result);
+}
+
+SWIGINTERN void 
+SWIG_Python_addvarlink(PyObject *p, const char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
+  swig_varlinkobject *v = (swig_varlinkobject *) p;
+  swig_globalvar *gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
+  if (gv) {
+    size_t size = strlen(name)+1;
+    gv->name = (char *)malloc(size);
+    if (gv->name) {
+      memcpy(gv->name, name, size);
+      gv->get_attr = get_attr;
+      gv->set_attr = set_attr;
+      gv->next = v->vars;
+    }
+  }
+  v->vars = gv;
+}
+
+
+static PyObject *Swig_Globals_global = NULL;
+  
+SWIGINTERN PyObject *
+SWIG_globals(void) {
+  if (Swig_Globals_global == NULL) {
+    Swig_Globals_global = SWIG_newvarlink();
+  }
+  return Swig_Globals_global;
+}
+
+#ifdef __cplusplus
+}
+#endif
+
 /* -----------------------------------------------------------------------------
  * Pointer declarations
  * ----------------------------------------------------------------------------- */
 
 /* Flags for new pointer objects */
 #define SWIG_POINTER_NOSHADOW       (SWIG_POINTER_OWN      << 1)
 #define SWIG_POINTER_NEW            (SWIG_POINTER_NOSHADOW | SWIG_POINTER_OWN)
@@ -1316,52 +1570,59 @@
     SwigPyClientData *data = (SwigPyClientData *)malloc(sizeof(SwigPyClientData));
     /* the klass element */
     data->klass = obj;
     Py_INCREF(data->klass);
     /* the newraw method and newargs arguments used to create a new raw instance */
     if (PyClass_Check(obj)) {
       data->newraw = 0;
-      data->newargs = obj;
       Py_INCREF(obj);
+      data->newargs = obj;
     } else {
       data->newraw = PyObject_GetAttrString(data->klass, "__new__");
       if (data->newraw) {
-	Py_INCREF(data->newraw);
-	data->newargs = PyTuple_New(1);
-	PyTuple_SetItem(data->newargs, 0, obj);
+        data->newargs = PyTuple_New(1);
+        if (data->newargs) {
+          Py_INCREF(obj);
+          PyTuple_SET_ITEM(data->newargs, 0, obj);
+        } else {
+          Py_DECREF(data->newraw);
+          Py_DECREF(data->klass);
+          free(data);
+          return 0;
+        }
       } else {
-	data->newargs = obj;
+        Py_INCREF(obj);
+        data->newargs = obj;
       }
-      Py_INCREF(data->newargs);
     }
     /* the destroy method, aka as the C++ delete method */
     data->destroy = PyObject_GetAttrString(data->klass, "__swig_destroy__");
     if (PyErr_Occurred()) {
       PyErr_Clear();
       data->destroy = 0;
     }
     if (data->destroy) {
-      int flags;
-      Py_INCREF(data->destroy);
-      flags = PyCFunction_GET_FLAGS(data->destroy);
-      data->delargs = !(flags & (METH_O));
+      data->delargs = !(PyCFunction_GET_FLAGS(data->destroy) & METH_O);
     } else {
       data->delargs = 0;
     }
     data->implicitconv = 0;
     data->pytype = 0;
     return data;
   }
 }
 
 SWIGRUNTIME void 
-SwigPyClientData_Del(SwigPyClientData *data) {
+SwigPyClientData_Del(SwigPyClientData *data)
+{
+  Py_XDECREF(data->klass);
   Py_XDECREF(data->newraw);
   Py_XDECREF(data->newargs);
   Py_XDECREF(data->destroy);
+  free(data);
 }
 
 /* =============== SwigPyObject =====================*/
 
 typedef struct {
   PyObject_HEAD
   void *ptr;
@@ -1380,15 +1641,15 @@
 SwigPyObject_get___dict__(PyObject *v, PyObject *SWIGUNUSEDPARM(args))
 {
   SwigPyObject *sobj = (SwigPyObject *)v;
 
   if (!sobj->dict)
     sobj->dict = PyDict_New();
 
-  Py_INCREF(sobj->dict);
+  Py_XINCREF(sobj->dict);
   return sobj->dict;
 }
 
 #endif
 
 SWIGRUNTIME PyObject *
 SwigPyObject_long(SwigPyObject *v)
@@ -1398,26 +1659,29 @@
 
 SWIGRUNTIME PyObject *
 SwigPyObject_format(const char* fmt, SwigPyObject *v)
 {
   PyObject *res = NULL;
   PyObject *args = PyTuple_New(1);
   if (args) {
-    if (PyTuple_SetItem(args, 0, SwigPyObject_long(v)) == 0) {
-      PyObject *ofmt = SWIG_Python_str_FromChar(fmt);
+    PyObject *val = SwigPyObject_long(v);
+    if (val) {
+      PyObject *ofmt;
+      PyTuple_SET_ITEM(args, 0, val);
+      ofmt = SWIG_Python_str_FromChar(fmt);
       if (ofmt) {
 #if PY_VERSION_HEX >= 0x03000000
-	res = PyUnicode_Format(ofmt,args);
+        res = PyUnicode_Format(ofmt,args);
 #else
-	res = PyString_Format(ofmt,args);
+        res = PyString_Format(ofmt,args);
 #endif
-	Py_DECREF(ofmt);
+        Py_DECREF(ofmt);
       }
-      Py_DECREF(args);
     }
+    Py_DECREF(args);
   }
   return res;
 }
 
 SWIGRUNTIME PyObject *
 SwigPyObject_oct(SwigPyObject *v)
 {
@@ -1431,26 +1695,31 @@
 }
 
 SWIGRUNTIME PyObject *
 SwigPyObject_repr(SwigPyObject *v)
 {
   const char *name = SWIG_TypePrettyName(v->ty);
   PyObject *repr = SWIG_Python_str_FromFormat("<Swig Object of type '%s' at %p>", (name ? name : "unknown"), (void *)v);
-  if (v->next) {
+  if (repr && v->next) {
     PyObject *nrep = SwigPyObject_repr((SwigPyObject *)v->next);
+    if (nrep) {
 # if PY_VERSION_HEX >= 0x03000000
-    PyObject *joined = PyUnicode_Concat(repr, nrep);
-    Py_DecRef(repr);
-    Py_DecRef(nrep);
-    repr = joined;
+      PyObject *joined = PyUnicode_Concat(repr, nrep);
+      Py_DecRef(repr);
+      Py_DecRef(nrep);
+      repr = joined;
 # else
-    PyString_ConcatAndDel(&repr,nrep);
+      PyString_ConcatAndDel(&repr,nrep);
 # endif
+    } else {
+      Py_DecRef(repr);
+      repr = NULL;
+    }
   }
-  return repr;  
+  return repr;
 }
 
 /* We need a version taking two PyObject* parameters so it's a valid
  * PyCFunction to use in swigobject_methods[]. */
 SWIGRUNTIME PyObject *
 SwigPyObject_repr2(PyObject *v, PyObject *SWIGUNUSEDPARM(args))
 {
@@ -1512,14 +1781,16 @@
     || (strcmp(Py_TYPE(op)->tp_name,"SwigPyObject") == 0);
 #endif
 }
 
 SWIGRUNTIME PyObject *
 SwigPyObject_New(void *ptr, swig_type_info *ty, int own);
 
+static PyObject* Swig_Capsule_global = NULL;
+
 SWIGRUNTIME void
 SwigPyObject_dealloc(PyObject *v)
 {
   SwigPyObject *sobj = (SwigPyObject *) v;
   PyObject *next = sobj->next;
   if (sobj->own == SWIG_POINTER_OWN) {
     swig_type_info *ty = sobj->ty;
@@ -1538,16 +1809,20 @@
       
       PyObject *type = NULL, *value = NULL, *traceback = NULL;
       PyErr_Fetch(&type, &value, &traceback);
 
       if (data->delargs) {
         /* we need to create a temporary object to carry the destroy operation */
         PyObject *tmp = SwigPyObject_New(sobj->ptr, ty, 0);
-        res = SWIG_Python_CallFunctor(destroy, tmp);
-        Py_DECREF(tmp);
+        if (tmp) {
+          res = SWIG_Python_CallFunctor(destroy, tmp);
+        } else {
+          res = 0;
+        }
+        Py_XDECREF(tmp);
       } else {
         PyCFunction meth = PyCFunction_GET_FUNCTION(destroy);
         PyObject *mself = PyCFunction_GET_SELF(destroy);
         res = ((*meth)(mself, v));
       }
       if (!res)
         PyErr_WriteUnraisable(destroy);
@@ -1558,27 +1833,32 @@
     } 
 #if !defined(SWIG_PYTHON_SILENT_MEMLEAK)
     else {
       const char *name = SWIG_TypePrettyName(ty);
       printf("swig/python detected a memory leak of type '%s', no destructor found.\n", (name ? name : "unknown"));
     }
 #endif
-  } 
+    Py_XDECREF(Swig_Capsule_global);
+  }
   Py_XDECREF(next);
+#ifdef SWIGPYTHON_BUILTIN
+  Py_XDECREF(sobj->dict);
+#endif
   PyObject_DEL(v);
 }
 
 SWIGRUNTIME PyObject* 
 SwigPyObject_append(PyObject* v, PyObject* next)
 {
   SwigPyObject *sobj = (SwigPyObject *) v;
   if (!SwigPyObject_Check(next)) {
     PyErr_SetString(PyExc_TypeError, "Attempt to append a non SwigPyObject");
     return NULL;
   }
+  ((SwigPyObject *)next)->next = sobj->next;
   sobj->next = next;
   Py_INCREF(next);
   return SWIG_Py_Void();
 }
 
 SWIGRUNTIME PyObject* 
 SwigPyObject_next(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
@@ -1615,17 +1895,17 @@
   if (!PyArg_UnpackTuple(args, "own", 0, 1, &val)) {
     return NULL;
   } else {
     SwigPyObject *sobj = (SwigPyObject *)v;
     PyObject *obj = PyBool_FromLong(sobj->own);
     if (val) {
       if (PyObject_IsTrue(val)) {
-        SwigPyObject_acquire(v,args);
+        Py_DECREF(SwigPyObject_acquire(v,args));
       } else {
-        SwigPyObject_disown(v,args);
+        Py_DECREF(SwigPyObject_disown(v,args));
       }
     } 
     return obj;
   }
 }
 
 static PyMethodDef
@@ -1697,15 +1977,19 @@
       PyObject_HEAD_INIT(NULL)
       0,                                    /* ob_size */
 #endif
       "SwigPyObject",                       /* tp_name */
       sizeof(SwigPyObject),                 /* tp_basicsize */
       0,                                    /* tp_itemsize */
       (destructor)SwigPyObject_dealloc,     /* tp_dealloc */
-      0,                                    /* tp_print */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                         /*tp_print*/
+#else
+      (Py_ssize_t)0,                        /*tp_vectorcall_offset*/
+#endif
       (getattrfunc)0,                       /* tp_getattr */
       (setattrfunc)0,                       /* tp_setattr */
 #if PY_VERSION_HEX >= 0x03000000
       0, /* tp_reserved in 3.0.1, tp_compare in 3.0.0 but not used */
 #else
       (cmpfunc)SwigPyObject_compare,        /* tp_compare */
 #endif
@@ -1762,29 +2046,38 @@
       0,                                    /* tp_maxalloc */
       0,                                    /* tp_prev */
       0                                     /* tp_next */
 #endif
     };
     swigpyobject_type = tmp;
     type_init = 1;
-    if (PyType_Ready(&swigpyobject_type) < 0)
+    if (PyType_Ready(&swigpyobject_type) != 0)
       return NULL;
   }
   return &swigpyobject_type;
 }
 
 SWIGRUNTIME PyObject *
 SwigPyObject_New(void *ptr, swig_type_info *ty, int own)
 {
   SwigPyObject *sobj = PyObject_NEW(SwigPyObject, SwigPyObject_type());
   if (sobj) {
     sobj->ptr  = ptr;
     sobj->ty   = ty;
     sobj->own  = own;
     sobj->next = 0;
+#ifdef SWIGPYTHON_BUILTIN
+    sobj->dict = 0;
+#endif
+    if (own == SWIG_POINTER_OWN) {
+      /* Obtain a reference to the Python capsule wrapping the module information, so that the
+       * module information is correctly destroyed after all SWIG python objects have been freed
+       * by the GC (and corresponding destructors invoked) */
+      Py_XINCREF(Swig_Capsule_global);
+    }
   }
   return (PyObject *)sobj;
 }
 
 /* -----------------------------------------------------------------------------
  * Implements a simple Swig Packed type, and use it instead of string
  * ----------------------------------------------------------------------------- */
@@ -1864,15 +2157,19 @@
       PyObject_HEAD_INIT(NULL)
       0,                                    /* ob_size */
 #endif
       "SwigPyPacked",                       /* tp_name */
       sizeof(SwigPyPacked),                 /* tp_basicsize */
       0,                                    /* tp_itemsize */
       (destructor)SwigPyPacked_dealloc,     /* tp_dealloc */
-      0,                                    /* tp_print */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                         /*tp_print*/
+#else
+      (Py_ssize_t)0,                        /*tp_vectorcall_offset*/
+#endif
       (getattrfunc)0,                       /* tp_getattr */
       (setattrfunc)0,                       /* tp_setattr */
 #if PY_VERSION_HEX>=0x03000000
       0, /* tp_reserved in 3.0.1 */
 #else
       (cmpfunc)SwigPyPacked_compare,        /* tp_compare */
 #endif
@@ -1929,15 +2226,15 @@
       0,                                    /* tp_maxalloc */
       0,                                    /* tp_prev */
       0                                     /* tp_next */
 #endif
     };
     swigpypacked_type = tmp;
     type_init = 1;
-    if (PyType_Ready(&swigpypacked_type) < 0)
+    if (PyType_Ready(&swigpypacked_type) != 0)
       return NULL;
   }
   return &swigpypacked_type;
 }
 
 SWIGRUNTIME PyObject *
 SwigPyPacked_New(void *ptr, size_t size, swig_type_info *ty)
@@ -2119,20 +2416,27 @@
       }
     } else {
       if (ptr) *ptr = vptr;
       break;
     }
   }
   if (sobj) {
-    if (own)
-      *own = *own | sobj->own;
-    if (flags & SWIG_POINTER_DISOWN) {
-      sobj->own = 0;
+    if (((flags & SWIG_POINTER_RELEASE) == SWIG_POINTER_RELEASE) && !sobj->own) {
+      res = SWIG_ERROR_RELEASE_NOT_OWNED;
+    } else {
+      if (own)
+        *own = *own | sobj->own;
+      if (flags & SWIG_POINTER_DISOWN) {
+        sobj->own = 0;
+      }
+      if (flags & SWIG_POINTER_CLEAR) {
+        sobj->ptr = 0;
+      }
+      res = SWIG_OK;
     }
-    res = SWIG_OK;
   } else {
     if (implicit_conv) {
       SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
       if (data && !data->implicitconv) {
         PyObject *klass = data->klass;
         if (klass) {
           PyObject *impconv;
@@ -2237,20 +2541,25 @@
   PyObject *newraw = data->newraw;
   if (newraw) {
     inst = PyObject_Call(newraw, data->newargs, NULL);
     if (inst) {
 #if !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
       PyObject **dictptr = _PyObject_GetDictPtr(inst);
       if (dictptr != NULL) {
-	PyObject *dict = *dictptr;
-	if (dict == NULL) {
-	  dict = PyDict_New();
-	  *dictptr = dict;
-	  PyDict_SetItem(dict, SWIG_This(), swig_this);
-	}
+        PyObject *dict = *dictptr;
+        if (dict == NULL) {
+          dict = PyDict_New();
+          *dictptr = dict;
+        }
+        if (dict) {
+          PyDict_SetItem(dict, SWIG_This(), swig_this);
+        } else{
+          Py_DECREF(inst);
+          inst = 0;
+        }
       }
 #else
       if (PyObject_SetAttr(inst, SWIG_This(), swig_this) == -1) {
         Py_DECREF(inst);
         inst = 0;
       }
 #endif
@@ -2264,15 +2573,15 @@
         inst = ((PyTypeObject *)data->newargs)->tp_new((PyTypeObject *)data->newargs, empty_args, empty_kwargs);
         Py_DECREF(empty_kwargs);
         if (inst) {
           if (PyObject_SetAttr(inst, SWIG_This(), swig_this) == -1) {
             Py_DECREF(inst);
             inst = 0;
           } else {
-            Py_TYPE(inst)->tp_flags &= ~Py_TPFLAGS_VALID_VERSION_TAG;
+            PyType_Modified(Py_TYPE(inst));
           }
         }
       }
       Py_DECREF(empty_args);
     }
 #else
     PyObject *dict = PyDict_New();
@@ -2293,30 +2602,34 @@
   PyObject **dictptr = _PyObject_GetDictPtr(inst);
   if (dictptr != NULL) {
     PyObject *dict = *dictptr;
     if (dict == NULL) {
       dict = PyDict_New();
       *dictptr = dict;
     }
-    return PyDict_SetItem(dict, SWIG_This(), swig_this);
+    if (dict) {
+      return PyDict_SetItem(dict, SWIG_This(), swig_this);
+    } else{
+      return -1;
+    }
   }
 #endif
   return PyObject_SetAttr(inst, SWIG_This(), swig_this);
 } 
 
 
 SWIGINTERN PyObject *
 SWIG_Python_InitShadowInstance(PyObject *args) {
   PyObject *obj[2];
   if (!SWIG_Python_UnpackTuple(args, "swiginit", 2, 2, obj)) {
     return NULL;
   } else {
     SwigPyObject *sthis = SWIG_Python_GetSwigThis(obj[0]);
     if (sthis) {
-      SwigPyObject_append((PyObject*) sthis, obj[1]);
+      Py_DECREF(SwigPyObject_append((PyObject*) sthis, obj[1]));
     } else {
       if (SWIG_Python_SetSwigThis(obj[0], obj[1]) != 0)
         return NULL;
     }
     return SWIG_Py_Void();
   }
 }
@@ -2347,15 +2660,17 @@
 #ifdef SWIGPYTHON_BUILTIN
         newobj->dict = 0;
 #endif
       }
     } else {
       newobj = PyObject_New(SwigPyObject, clientdata->pytype);
 #ifdef SWIGPYTHON_BUILTIN
-      newobj->dict = 0;
+      if (newobj) {
+        newobj->dict = 0;
+      }
 #endif
     }
     if (newobj) {
       newobj->ptr = ptr;
       newobj->ty = type;
       newobj->own = own;
       newobj->next = 0;
@@ -2386,89 +2701,111 @@
  *  Get type list 
  * -----------------------------------------------------------------------------*/
 
 #ifdef SWIG_LINK_RUNTIME
 void *SWIG_ReturnGlobalTypeList(void *);
 #endif
 
+static PyObject *Swig_TypeCache_global = NULL;
+
+/* The python cached type query */
+SWIGRUNTIME PyObject *
+SWIG_Python_TypeCache(void) {
+  if (Swig_TypeCache_global == NULL) {
+    Swig_TypeCache_global = PyDict_New();
+  }
+  return Swig_TypeCache_global;
+}
+
 SWIGRUNTIME swig_module_info *
 SWIG_Python_GetModule(void *SWIGUNUSEDPARM(clientdata)) {
+#ifdef SWIG_LINK_RUNTIME
   static void *type_pointer = (void *)0;
   /* first check if module already created */
   if (!type_pointer) {
-#ifdef SWIG_LINK_RUNTIME
     type_pointer = SWIG_ReturnGlobalTypeList((void *)0);
+  }
 #else
-    type_pointer = PyCapsule_Import(SWIGPY_CAPSULE_NAME, 0);
-    if (PyErr_Occurred()) {
-      PyErr_Clear();
-      type_pointer = (void *)0;
-    }
-#endif
+  void *type_pointer = PyCapsule_Import(SWIGPY_CAPSULE_NAME, 0);
+  if (PyErr_Occurred()) {
+    PyErr_Clear();
+    type_pointer = (void *)0;
   }
+#endif
   return (swig_module_info *) type_pointer;
 }
 
+
+static int interpreter_counter = 0; // how many (sub-)interpreters are using swig_module's types
+
 SWIGRUNTIME void
 SWIG_Python_DestroyModule(PyObject *obj)
 {
   swig_module_info *swig_module = (swig_module_info *) PyCapsule_GetPointer(obj, SWIGPY_CAPSULE_NAME);
   swig_type_info **types = swig_module->types;
   size_t i;
+  if (--interpreter_counter != 0) // another sub-interpreter may still be using the swig_module's types
+    return;
   for (i =0; i < swig_module->size; ++i) {
     swig_type_info *ty = types[i];
     if (ty->owndata) {
       SwigPyClientData *data = (SwigPyClientData *) ty->clientdata;
+      ty->clientdata = 0;
       if (data) SwigPyClientData_Del(data);
     }
   }
   Py_DECREF(SWIG_This());
   Swig_This_global = NULL;
+  Py_DECREF(SWIG_globals());
+  Swig_Globals_global = NULL;
+  Py_DECREF(SWIG_Python_TypeCache());
+  Swig_TypeCache_global = NULL;
+  Swig_Capsule_global = NULL;
 }
 
 SWIGRUNTIME void
 SWIG_Python_SetModule(swig_module_info *swig_module) {
 #if PY_VERSION_HEX >= 0x03000000
  /* Add a dummy module object into sys.modules */
   PyObject *module = PyImport_AddModule("swig_runtime_data" SWIG_RUNTIME_VERSION);
 #else
   static PyMethodDef swig_empty_runtime_method_table[] = { {NULL, NULL, 0, NULL} }; /* Sentinel */
   PyObject *module = Py_InitModule("swig_runtime_data" SWIG_RUNTIME_VERSION, swig_empty_runtime_method_table);
 #endif
   PyObject *pointer = PyCapsule_New((void *) swig_module, SWIGPY_CAPSULE_NAME, SWIG_Python_DestroyModule);
   if (pointer && module) {
-    PyModule_AddObject(module, "type_pointer_capsule" SWIG_TYPE_TABLE_NAME, pointer);
+    if (PyModule_AddObject(module, SWIGPY_CAPSULE_ATTR_NAME, pointer) == 0) {
+      ++interpreter_counter;
+      Swig_Capsule_global = pointer;
+    } else {
+      Py_DECREF(pointer);
+    }
   } else {
     Py_XDECREF(pointer);
   }
 }
 
-/* The python cached type query */
-SWIGRUNTIME PyObject *
-SWIG_Python_TypeCache(void) {
-  static PyObject *SWIG_STATIC_POINTER(cache) = PyDict_New();
-  return cache;
-}
-
 SWIGRUNTIME swig_type_info *
 SWIG_Python_TypeQuery(const char *type)
 {
   PyObject *cache = SWIG_Python_TypeCache();
   PyObject *key = SWIG_Python_str_FromChar(type); 
   PyObject *obj = PyDict_GetItem(cache, key);
   swig_type_info *descriptor;
   if (obj) {
     descriptor = (swig_type_info *) PyCapsule_GetPointer(obj, NULL);
   } else {
     swig_module_info *swig_module = SWIG_GetModule(0);
     descriptor = SWIG_TypeQueryModule(swig_module, swig_module, type);
     if (descriptor) {
       obj = PyCapsule_New((void*) descriptor, NULL, NULL);
-      PyDict_SetItem(cache, key, obj);
-      Py_DECREF(obj);
+      if (obj) {
+        PyDict_SetItem(cache, key, obj);
+        Py_DECREF(obj);
+      }
     }
   }
   Py_DECREF(key);
   return descriptor;
 }
 
 /* 
@@ -2493,15 +2830,14 @@
       Py_XINCREF(type);
       PyErr_Clear();
       if (infront) {
 	PyErr_Format(type, "%s %s", mesg, errmesg);
       } else {
 	PyErr_Format(type, "%s %s", errmesg, mesg);
       }
-      SWIG_Python_str_DelForPy3(tmp);
       Py_DECREF(old_str);
     }
     return 1;
   } else {
     return 0;
   }
 }
@@ -2545,15 +2881,14 @@
       const char *otype = (obj ? obj->ob_type->tp_name : 0); 
       if (otype) {
 	PyObject *str = PyObject_Str(obj);
 	const char *cstr = str ? SWIG_Python_str_AsChar(str) : 0;
 	if (cstr) {
 	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s(%s)' is received",
 		       type, otype, cstr);
-          SWIG_Python_str_DelForPy3(cstr);
 	} else {
 	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s' is received",
 		       type, otype);
 	}
 	Py_XDECREF(str);
 	return;
       }
@@ -2567,20 +2902,14 @@
 
 /* Convert a pointer value, signal an exception on a type mismatch */
 SWIGRUNTIME void *
 SWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int SWIGUNUSEDPARM(argnum), int flags) {
   void *result;
   if (SWIG_Python_ConvertPtr(obj, &result, ty, flags) == -1) {
     PyErr_Clear();
-#if SWIG_POINTER_EXCEPTION
-    if (flags) {
-      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);
-      SWIG_Python_ArgFail(argnum);
-    }
-#endif
   }
   return result;
 }
 
 #ifdef SWIGPYTHON_BUILTIN
 SWIGRUNTIME int
 SWIG_Python_NonDynamicSetAttr(PyObject *obj, PyObject *name, PyObject *value) {
@@ -2603,30 +2932,30 @@
     PyErr_Format(PyExc_TypeError, "attribute name must be string, not '%.200s'", name->ob_type->tp_name);
     return -1;
   } else {
     Py_INCREF(name);
   }
 
   if (!tp->tp_dict) {
-    if (PyType_Ready(tp) < 0)
+    if (PyType_Ready(tp) != 0)
       goto done;
   }
 
   descr = _PyType_Lookup(tp, name);
   f = NULL;
   if (descr != NULL)
     f = descr->ob_type->tp_descr_set;
   if (!f) {
     if (PyString_Check(name)) {
       encoded_name = name;
       Py_INCREF(name);
     } else {
       encoded_name = PyUnicode_AsUTF8String(name);
       if (!encoded_name)
-        return -1;
+        goto done;
     }
     PyErr_Format(PyExc_AttributeError, "'%.100s' object has no attribute '%.200s'", tp->tp_name, PyString_AsString(encoded_name));
     Py_DECREF(encoded_name);
   } else {
     res = f(descr, obj, value);
   }
   
@@ -2645,15 +2974,19 @@
 extern "C" {
 #endif
 
 SWIGINTERN Py_hash_t
 SwigPyObject_hash(PyObject *obj) {
   SwigPyObject *sobj = (SwigPyObject *)obj;
   void *ptr = sobj->ptr;
+#if PY_VERSION_HEX < 0x03020000
+  return (Py_hash_t)(Py_ssize_t)ptr;
+#else
   return (Py_hash_t)ptr;
+#endif
 }
 
 SWIGINTERN Py_hash_t
 SWIG_PyNumber_AsPyHash(PyObject *obj) {
   Py_hash_t result = -1;
 #if PY_VERSION_HEX < 0x03020000
   if (PyInt_Check(obj))
@@ -2850,15 +3183,19 @@
       PyObject_HEAD_INIT(&PyType_Type)
       0,                                        /* ob_size */
 #endif
       "swig_static_var_getset_descriptor",      /* tp_name */
       sizeof(PyGetSetDescrObject),              /* tp_basicsize */
       0,                                        /* tp_itemsize */
       (destructor)SwigPyStaticVar_dealloc,      /* tp_dealloc */
-      0,                                        /* tp_print */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                             /* tp_print */
+#else
+      (Py_ssize_t)0,                            /* tp_vectorcall_offset */
+#endif
       0,                                        /* tp_getattr */
       0,                                        /* tp_setattr */
       0,                                        /* tp_compare */
       (reprfunc)SwigPyStaticVar_repr,           /* tp_repr */
       0,                                        /* tp_as_number */
       0,                                        /* tp_as_sequence */
       0,                                        /* tp_as_mapping */
@@ -2934,15 +3271,19 @@
       PyObject_HEAD_INIT(&PyType_Type)
       0,                                        /* ob_size */
 #endif
       "SwigPyObjectType",                       /* tp_name */
       PyType_Type.tp_basicsize,                 /* tp_basicsize */
       0,                                        /* tp_itemsize */
       0,                                        /* tp_dealloc */
-      0,                                        /* tp_print */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                             /* tp_print */
+#else
+      (Py_ssize_t)0,                            /* tp_vectorcall_offset */
+#endif
       0,                                        /* tp_getattr */
       0,                                        /* tp_setattr */
       0,                                        /* tp_compare */
       0,                                        /* tp_repr */
       0,                                        /* tp_as_number */
       0,                                        /* tp_as_sequence */
       0,                                        /* tp_as_mapping */
@@ -3053,18 +3394,18 @@
   Py_XINCREF(result);
   return result;
 }
 
 SWIGINTERN void
 SwigPyBuiltin_SetMetaType (PyTypeObject *type, PyTypeObject *metatype)
 {
-#if PY_VERSION_HEX >= 0x03000000
-    type->ob_base.ob_base.ob_type = metatype;
+#if PY_VERSION_HEX >= 0x030900a4
+    Py_SET_TYPE(type, metatype);
 #else
-    type->ob_type = metatype;
+    Py_TYPE(type) = metatype;
 #endif
 }
 
 
 /* Start of callback function macros for use in PyTypeObject */
 
 typedef PyObject *(*SwigPyWrapperFunction)(PyObject *, PyObject *);
@@ -3394,31 +3735,16 @@
 #endif
 
 
 
 
 #define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 
 
-#define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 
-
-
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* Method creation and docstring support functions */
-
-SWIGINTERN PyMethodDef *SWIG_PythonGetProxyDoc(const char *name);
-SWIGINTERN PyObject *SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func);
-SWIGINTERN PyObject *SWIG_PyStaticMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func);
+#define SWIG_contract_assert(expr, msg) do { if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } } while (0) 
 
-#ifdef __cplusplus
-}
-#endif
 
 
 /* -------- TYPES TABLE (BEGIN) -------- */
 
 #define SWIGTYPE_p_CameraAbilities swig_types[0]
 #define SWIGTYPE_p_CameraCaptureType swig_types[1]
 #define SWIGTYPE_p_CameraDriverStatus swig_types[2]
@@ -3493,18 +3819,14 @@
 
 #else
 #  define SWIG_init    init_result
 
 #endif
 #define SWIG_name    "_result"
 
-#define SWIGVERSION 0x040002 
-#define SWIG_VERSION SWIGVERSION
-
-
 #define SWIG_as_voidptr(a) (void *)((const void *)(a)) 
 #define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),(void**)(a)) 
 
 
 #include <stddef.h>
 
 
@@ -3723,14 +4045,15 @@
   PyObject *resultobj = 0;
   int arg1 ;
   int val1 ;
   int ecode1 = 0 ;
   PyObject * obj0 = 0 ;
   char *result = 0 ;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_port_result_as_string", 1, 1, &obj0)) SWIG_fail;
   ecode1 = SWIG_AsVal_int(obj0, &val1);
   if (!SWIG_IsOK(ecode1)) {
     SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "gp_port_result_as_string" "', argument " "1"" of type '" "int""'");
   } 
   arg1 = (int)(val1);
   result = (char *)gp_port_result_as_string(arg1);
@@ -3745,14 +4068,15 @@
   PyObject *resultobj = 0;
   int arg1 ;
   int val1 ;
   int ecode1 = 0 ;
   PyObject * obj0 = 0 ;
   char *result = 0 ;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_result_as_string", 1, 1, &obj0)) SWIG_fail;
   ecode1 = SWIG_AsVal_int(obj0, &val1);
   if (!SWIG_IsOK(ecode1)) {
     SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "gp_result_as_string" "', argument " "1"" of type '" "int""'");
   } 
   arg1 = (int)(val1);
   result = (char *)gp_result_as_string(arg1);
@@ -3760,63 +4084,14 @@
   return resultobj;
 fail:
   return NULL;
 }
 
 
 static PyMethodDef SwigMethods[] = {
-	 { "SWIG_PyInstanceMethod_New", SWIG_PyInstanceMethod_New, METH_O, NULL},
-	 { "SWIG_PyStaticMethod_New", SWIG_PyStaticMethod_New, METH_O, NULL},
-	 { "gp_port_result_as_string", _wrap_gp_port_result_as_string, METH_VARARGS, "\n"
-		"gp_port_result_as_string(result) -> char const *\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"result: int\n"
-		"\n"
-		"gp_port_result_as_string:  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		": a gphoto2 error code  \n"
-		"\n"
-		"Returns a string representation of a gphoto2 error code. Those are\n"
-		"static error descriptions. You can get dynamic ones that explain the\n"
-		"error more in depth using gp_port_get_error.  \n"
-		"\n"
-		"Return value: a string representation of a gphoto2 error code\n"
-		""},
-	 { "gp_result_as_string", _wrap_gp_result_as_string, METH_VARARGS, "\n"
-		"gp_result_as_string(result) -> char const *\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"result: int\n"
-		"\n"
-		"Translate a gphoto error code into a localized string.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `result` :  \n"
-		"    a gphoto2 error code  \n"
-		"\n"
-		"Translates a gphoto2 error code into a human readable string. If the\n"
-		"error occurred in combination with a camera,\n"
-		"gp_camera_get_result_as_string() should be used instead.  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"A string representation of a gphoto2 error code\n"
-		""},
-	 { NULL, NULL, 0, NULL }
-};
-
-static PyMethodDef SwigMethods_proxydocs[] = {
-	 { "SWIG_PyInstanceMethod_New", SWIG_PyInstanceMethod_New, METH_O, NULL},
-	 { "SWIG_PyStaticMethod_New", SWIG_PyStaticMethod_New, METH_O, NULL},
 	 { "gp_port_result_as_string", _wrap_gp_port_result_as_string, METH_VARARGS, "\n"
 		"gp_port_result_as_string(result) -> char const *\n"
 		"\n"
 		"Parameters\n"
 		"----------\n"
 		"result: int\n"
 		"\n"
@@ -3857,67 +4132,67 @@
 	 { NULL, NULL, 0, NULL }
 };
 
 
 /* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */
 
 static swig_type_info _swigt__p_CameraAbilities = {"_p_CameraAbilities", "CameraAbilities *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraCaptureType = {"_p_CameraCaptureType", "enum CameraCaptureType *|CameraCaptureType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraDriverStatus = {"_p_CameraDriverStatus", "enum CameraDriverStatus *|CameraDriverStatus *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraEventType = {"_p_CameraEventType", "enum CameraEventType *|CameraEventType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileAccessType = {"_p_CameraFileAccessType", "enum CameraFileAccessType *|CameraFileAccessType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileInfoFields = {"_p_CameraFileInfoFields", "enum CameraFileInfoFields *|CameraFileInfoFields *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileOperation = {"_p_CameraFileOperation", "enum CameraFileOperation *|CameraFileOperation *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraCaptureType = {"_p_CameraCaptureType", "CameraCaptureType *|enum CameraCaptureType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraDriverStatus = {"_p_CameraDriverStatus", "CameraDriverStatus *|enum CameraDriverStatus *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraEventType = {"_p_CameraEventType", "CameraEventType *|enum CameraEventType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileAccessType = {"_p_CameraFileAccessType", "CameraFileAccessType *|enum CameraFileAccessType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileInfoFields = {"_p_CameraFileInfoFields", "CameraFileInfoFields *|enum CameraFileInfoFields *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileOperation = {"_p_CameraFileOperation", "CameraFileOperation *|enum CameraFileOperation *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_CameraFilePath = {"_p_CameraFilePath", "CameraFilePath *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFilePermissions = {"_p_CameraFilePermissions", "enum CameraFilePermissions *|CameraFilePermissions *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileStatus = {"_p_CameraFileStatus", "enum CameraFileStatus *|CameraFileStatus *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileType = {"_p_CameraFileType", "enum CameraFileType *|CameraFileType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFolderOperation = {"_p_CameraFolderOperation", "enum CameraFolderOperation *|CameraFolderOperation *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraOperation = {"_p_CameraOperation", "enum CameraOperation *|CameraOperation *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraStorageAccessType = {"_p_CameraStorageAccessType", "enum CameraStorageAccessType *|CameraStorageAccessType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraStorageFilesystemType = {"_p_CameraStorageFilesystemType", "enum CameraStorageFilesystemType *|CameraStorageFilesystemType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraStorageInfoFields = {"_p_CameraStorageInfoFields", "enum CameraStorageInfoFields *|CameraStorageInfoFields *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraStorageType = {"_p_CameraStorageType", "enum CameraStorageType *|CameraStorageType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFilePermissions = {"_p_CameraFilePermissions", "CameraFilePermissions *|enum CameraFilePermissions *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileStatus = {"_p_CameraFileStatus", "CameraFileStatus *|enum CameraFileStatus *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileType = {"_p_CameraFileType", "CameraFileType *|enum CameraFileType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFolderOperation = {"_p_CameraFolderOperation", "CameraFolderOperation *|enum CameraFolderOperation *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraOperation = {"_p_CameraOperation", "CameraOperation *|enum CameraOperation *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraStorageAccessType = {"_p_CameraStorageAccessType", "CameraStorageAccessType *|enum CameraStorageAccessType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraStorageFilesystemType = {"_p_CameraStorageFilesystemType", "CameraStorageFilesystemType *|enum CameraStorageFilesystemType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraStorageInfoFields = {"_p_CameraStorageInfoFields", "CameraStorageInfoFields *|enum CameraStorageInfoFields *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraStorageType = {"_p_CameraStorageType", "CameraStorageType *|enum CameraStorageType *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_CameraText = {"_p_CameraText", "CameraText *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraWidgetType = {"_p_CameraWidgetType", "enum CameraWidgetType *|CameraWidgetType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_GPLogLevel = {"_p_GPLogLevel", "enum GPLogLevel *|GPLogLevel *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_GPPortType = {"_p_GPPortType", "enum GPPortType *|GPPortType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_GPVersionVerbosity = {"_p_GPVersionVerbosity", "enum GPVersionVerbosity *|GPVersionVerbosity *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_GphotoDeviceType = {"_p_GphotoDeviceType", "enum GphotoDeviceType *|GphotoDeviceType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraWidgetType = {"_p_CameraWidgetType", "CameraWidgetType *|enum CameraWidgetType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GPLogLevel = {"_p_GPLogLevel", "GPLogLevel *|enum GPLogLevel *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GPPortType = {"_p_GPPortType", "GPPortType *|enum GPPortType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GPVersionVerbosity = {"_p_GPVersionVerbosity", "GPVersionVerbosity *|enum GPVersionVerbosity *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GphotoDeviceType = {"_p_GphotoDeviceType", "GphotoDeviceType *|enum GphotoDeviceType *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_SwigPyObject = {"_p_SwigPyObject", "SwigPyObject *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__Camera = {"_p__Camera", "struct _Camera *|Camera *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraAbilitiesList = {"_p__CameraAbilitiesList", "struct _CameraAbilitiesList *|CameraAbilitiesList *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFile = {"_p__CameraFile", "struct _CameraFile *|CameraFile *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFileHandler = {"_p__CameraFileHandler", "struct _CameraFileHandler *|CameraFileHandler *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFileInfo = {"_p__CameraFileInfo", "struct _CameraFileInfo *|CameraFileInfo *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFileInfoAudio = {"_p__CameraFileInfoAudio", "struct _CameraFileInfoAudio *|CameraFileInfoAudio *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFileInfoFile = {"_p__CameraFileInfoFile", "struct _CameraFileInfoFile *|CameraFileInfoFile *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFileInfoPreview = {"_p__CameraFileInfoPreview", "struct _CameraFileInfoPreview *|CameraFileInfoPreview *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFilesystem = {"_p__CameraFilesystem", "struct _CameraFilesystem *|CameraFilesystem *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFilesystemFuncs = {"_p__CameraFilesystemFuncs", "struct _CameraFilesystemFuncs *|CameraFilesystemFuncs *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFunctions = {"_p__CameraFunctions", "struct _CameraFunctions *|CameraFunctions *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraList = {"_p__CameraList", "struct _CameraList *|CameraList *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraPrivateCore = {"_p__CameraPrivateCore", "struct _CameraPrivateCore *|CameraPrivateCore *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraPrivateLibrary = {"_p__CameraPrivateLibrary", "struct _CameraPrivateLibrary *|CameraPrivateLibrary *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraStorageInformation = {"_p__CameraStorageInformation", "struct _CameraStorageInformation *|CameraStorageInformation *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraWidget = {"_p__CameraWidget", "struct _CameraWidget *|CameraWidget *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__GPContext = {"_p__GPContext", "struct _GPContext *|GPContext *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__GPContextFeedback = {"_p__GPContextFeedback", "enum _GPContextFeedback *|GPContextFeedback *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__Camera = {"_p__Camera", "Camera *|struct _Camera *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraAbilitiesList = {"_p__CameraAbilitiesList", "CameraAbilitiesList *|struct _CameraAbilitiesList *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFile = {"_p__CameraFile", "CameraFile *|struct _CameraFile *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFileHandler = {"_p__CameraFileHandler", "CameraFileHandler *|struct _CameraFileHandler *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFileInfo = {"_p__CameraFileInfo", "CameraFileInfo *|struct _CameraFileInfo *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFileInfoAudio = {"_p__CameraFileInfoAudio", "CameraFileInfoAudio *|struct _CameraFileInfoAudio *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFileInfoFile = {"_p__CameraFileInfoFile", "CameraFileInfoFile *|struct _CameraFileInfoFile *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFileInfoPreview = {"_p__CameraFileInfoPreview", "CameraFileInfoPreview *|struct _CameraFileInfoPreview *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFilesystem = {"_p__CameraFilesystem", "CameraFilesystem *|struct _CameraFilesystem *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFilesystemFuncs = {"_p__CameraFilesystemFuncs", "CameraFilesystemFuncs *|struct _CameraFilesystemFuncs *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFunctions = {"_p__CameraFunctions", "CameraFunctions *|struct _CameraFunctions *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraList = {"_p__CameraList", "CameraList *|struct _CameraList *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraPrivateCore = {"_p__CameraPrivateCore", "CameraPrivateCore *|struct _CameraPrivateCore *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraPrivateLibrary = {"_p__CameraPrivateLibrary", "CameraPrivateLibrary *|struct _CameraPrivateLibrary *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraStorageInformation = {"_p__CameraStorageInformation", "CameraStorageInformation *|struct _CameraStorageInformation *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraWidget = {"_p__CameraWidget", "CameraWidget *|struct _CameraWidget *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__GPContext = {"_p__GPContext", "GPContext *|struct _GPContext *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__GPContextFeedback = {"_p__GPContextFeedback", "GPContextFeedback *|enum _GPContextFeedback *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p__GPPortInfo = {"_p__GPPortInfo", "_GPPortInfo *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__GPPortInfoList = {"_p__GPPortInfoList", "struct _GPPortInfoList *|GPPortInfoList *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__GPPortInfoList = {"_p__GPPortInfoList", "GPPortInfoList *|struct _GPPortInfoList *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_int = {"_p_int", "intptr_t *|int *|int_least32_t *|int_fast32_t *|int32_t *|int_fast16_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_long = {"_p_long", "long *|time_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_long_long = {"_p_long_long", "int_least64_t *|int_fast64_t *|int64_t *|long long *|intmax_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_short = {"_p_short", "short *|int_least16_t *|int16_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_signed_char = {"_p_signed_char", "signed char *|int_least8_t *|int_fast8_t *|int8_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_unsigned_char = {"_p_unsigned_char", "unsigned char *|uint_least8_t *|uint_fast8_t *|uint8_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_unsigned_int = {"_p_unsigned_int", "uintptr_t *|uint_least32_t *|uint_fast32_t *|uint32_t *|unsigned int *|uint_fast16_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_unsigned_long_long = {"_p_unsigned_long_long", "uint_least64_t *|uint_fast64_t *|uint64_t *|unsigned long long *|uintmax_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_unsigned_short = {"_p_unsigned_short", "unsigned short *|uint_least16_t *|uint16_t *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_int = {"_p_int", "int32_t *|int_fast16_t *|int_fast32_t *|int_least32_t *|intptr_t *|int *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_long = {"_p_long", "time_t *|long *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_long_long = {"_p_long_long", "int64_t *|int_fast64_t *|int_least64_t *|intmax_t *|long long *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_short = {"_p_short", "int16_t *|int_least16_t *|short *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_signed_char = {"_p_signed_char", "int8_t *|int_fast8_t *|int_least8_t *|signed char *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_unsigned_char = {"_p_unsigned_char", "uint8_t *|uint_fast8_t *|uint_least8_t *|unsigned char *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_unsigned_int = {"_p_unsigned_int", "uint32_t *|uint_fast16_t *|uint_fast32_t *|uint_least32_t *|uintptr_t *|unsigned int *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_unsigned_long_long = {"_p_unsigned_long_long", "uint64_t *|uint_fast64_t *|uint_least64_t *|uintmax_t *|unsigned long long *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_unsigned_short = {"_p_unsigned_short", "uint16_t *|uint_least16_t *|unsigned short *", 0, 0, (void*)0, 0};
 
 static swig_type_info *swig_type_initial[] = {
   &_swigt__p_CameraAbilities,
   &_swigt__p_CameraCaptureType,
   &_swigt__p_CameraDriverStatus,
   &_swigt__p_CameraEventType,
   &_swigt__p_CameraFileAccessType,
@@ -4141,17 +4416,20 @@
 #endif
 #endif
 
 #if 0
 #define SWIGRUNTIME_DEBUG
 #endif
 
+#ifndef SWIG_INIT_CLIENT_DATA_TYPE
+#define SWIG_INIT_CLIENT_DATA_TYPE void *
+#endif
 
 SWIGRUNTIME void
-SWIG_InitializeModule(void *clientdata) {
+SWIG_InitializeModule(SWIG_INIT_CLIENT_DATA_TYPE clientdata) {
   size_t i;
   swig_module_info *module_head, *iter;
   int init;
   
   /* check to see if the circular list has been setup, if not, set it up */
   if (swig_module.next==0) {
     /* Initialize the swig_module */
@@ -4326,228 +4604,14 @@
 
 
 
 #ifdef __cplusplus
 extern "C" {
 #endif
   
-  /* Python-specific SWIG API */
-#define SWIG_newvarlink()                             SWIG_Python_newvarlink()
-#define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
-#define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)
-  
-  /* -----------------------------------------------------------------------------
-   * global variable support code.
-   * ----------------------------------------------------------------------------- */
-  
-  typedef struct swig_globalvar {
-    char       *name;                  /* Name of global variable */
-    PyObject *(*get_attr)(void);       /* Return the current value */
-    int       (*set_attr)(PyObject *); /* Set the value */
-    struct swig_globalvar *next;
-  } swig_globalvar;
-  
-  typedef struct swig_varlinkobject {
-    PyObject_HEAD
-    swig_globalvar *vars;
-  } swig_varlinkobject;
-  
-  SWIGINTERN PyObject *
-  swig_varlink_repr(swig_varlinkobject *SWIGUNUSEDPARM(v)) {
-#if PY_VERSION_HEX >= 0x03000000
-    return PyUnicode_InternFromString("<Swig global variables>");
-#else
-    return PyString_FromString("<Swig global variables>");
-#endif
-  }
-  
-  SWIGINTERN PyObject *
-  swig_varlink_str(swig_varlinkobject *v) {
-#if PY_VERSION_HEX >= 0x03000000
-    PyObject *str = PyUnicode_InternFromString("(");
-    PyObject *tail;
-    PyObject *joined;
-    swig_globalvar *var;
-    for (var = v->vars; var; var=var->next) {
-      tail = PyUnicode_FromString(var->name);
-      joined = PyUnicode_Concat(str, tail);
-      Py_DecRef(str);
-      Py_DecRef(tail);
-      str = joined;
-      if (var->next) {
-        tail = PyUnicode_InternFromString(", ");
-        joined = PyUnicode_Concat(str, tail);
-        Py_DecRef(str);
-        Py_DecRef(tail);
-        str = joined;
-      }
-    }
-    tail = PyUnicode_InternFromString(")");
-    joined = PyUnicode_Concat(str, tail);
-    Py_DecRef(str);
-    Py_DecRef(tail);
-    str = joined;
-#else
-    PyObject *str = PyString_FromString("(");
-    swig_globalvar *var;
-    for (var = v->vars; var; var=var->next) {
-      PyString_ConcatAndDel(&str,PyString_FromString(var->name));
-      if (var->next) PyString_ConcatAndDel(&str,PyString_FromString(", "));
-    }
-    PyString_ConcatAndDel(&str,PyString_FromString(")"));
-#endif
-    return str;
-  }
-  
-  SWIGINTERN void
-  swig_varlink_dealloc(swig_varlinkobject *v) {
-    swig_globalvar *var = v->vars;
-    while (var) {
-      swig_globalvar *n = var->next;
-      free(var->name);
-      free(var);
-      var = n;
-    }
-  }
-  
-  SWIGINTERN PyObject *
-  swig_varlink_getattr(swig_varlinkobject *v, char *n) {
-    PyObject *res = NULL;
-    swig_globalvar *var = v->vars;
-    while (var) {
-      if (strcmp(var->name,n) == 0) {
-        res = (*var->get_attr)();
-        break;
-      }
-      var = var->next;
-    }
-    if (res == NULL && !PyErr_Occurred()) {
-      PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
-    }
-    return res;
-  }
-  
-  SWIGINTERN int
-  swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
-    int res = 1;
-    swig_globalvar *var = v->vars;
-    while (var) {
-      if (strcmp(var->name,n) == 0) {
-        res = (*var->set_attr)(p);
-        break;
-      }
-      var = var->next;
-    }
-    if (res == 1 && !PyErr_Occurred()) {
-      PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
-    }
-    return res;
-  }
-  
-  SWIGINTERN PyTypeObject*
-  swig_varlink_type(void) {
-    static char varlink__doc__[] = "Swig var link object";
-    static PyTypeObject varlink_type;
-    static int type_init = 0;
-    if (!type_init) {
-      const PyTypeObject tmp = {
-#if PY_VERSION_HEX >= 0x03000000
-        PyVarObject_HEAD_INIT(NULL, 0)
-#else
-        PyObject_HEAD_INIT(NULL)
-        0,                                  /* ob_size */
-#endif
-        "swigvarlink",                      /* tp_name */
-        sizeof(swig_varlinkobject),         /* tp_basicsize */
-        0,                                  /* tp_itemsize */
-        (destructor) swig_varlink_dealloc,  /* tp_dealloc */
-        0,                                  /* tp_print */
-        (getattrfunc) swig_varlink_getattr, /* tp_getattr */
-        (setattrfunc) swig_varlink_setattr, /* tp_setattr */
-        0,                                  /* tp_compare */
-        (reprfunc) swig_varlink_repr,       /* tp_repr */
-        0,                                  /* tp_as_number */
-        0,                                  /* tp_as_sequence */
-        0,                                  /* tp_as_mapping */
-        0,                                  /* tp_hash */
-        0,                                  /* tp_call */
-        (reprfunc) swig_varlink_str,        /* tp_str */
-        0,                                  /* tp_getattro */
-        0,                                  /* tp_setattro */
-        0,                                  /* tp_as_buffer */
-        0,                                  /* tp_flags */
-        varlink__doc__,                     /* tp_doc */
-        0,                                  /* tp_traverse */
-        0,                                  /* tp_clear */
-        0,                                  /* tp_richcompare */
-        0,                                  /* tp_weaklistoffset */
-        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
-        0,                                  /* tp_del */
-        0,                                  /* tp_version_tag */
-#if PY_VERSION_HEX >= 0x03040000
-        0,                                  /* tp_finalize */
-#endif
-#if PY_VERSION_HEX >= 0x03080000
-        0,                                  /* tp_vectorcall */
-#endif
-#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
-        0,                                  /* tp_print */
-#endif
-#ifdef COUNT_ALLOCS
-        0,                                  /* tp_allocs */
-        0,                                  /* tp_frees */
-        0,                                  /* tp_maxalloc */
-        0,                                  /* tp_prev */
-        0                                   /* tp_next */
-#endif
-      };
-      varlink_type = tmp;
-      type_init = 1;
-      if (PyType_Ready(&varlink_type) < 0)
-      return NULL;
-    }
-    return &varlink_type;
-  }
-  
-  /* Create a variable linking object for use later */
-  SWIGINTERN PyObject *
-  SWIG_Python_newvarlink(void) {
-    swig_varlinkobject *result = PyObject_NEW(swig_varlinkobject, swig_varlink_type());
-    if (result) {
-      result->vars = 0;
-    }
-    return ((PyObject*) result);
-  }
-  
-  SWIGINTERN void 
-  SWIG_Python_addvarlink(PyObject *p, const char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
-    swig_varlinkobject *v = (swig_varlinkobject *) p;
-    swig_globalvar *gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
-    if (gv) {
-      size_t size = strlen(name)+1;
-      gv->name = (char *)malloc(size);
-      if (gv->name) {
-        memcpy(gv->name, name, size);
-        gv->get_attr = get_attr;
-        gv->set_attr = set_attr;
-        gv->next = v->vars;
-      }
-    }
-    v->vars = gv;
-  }
-  
-  SWIGINTERN PyObject *
-  SWIG_globals(void) {
-    static PyObject *globals = 0;
-    if (!globals) {
-      globals = SWIG_newvarlink();
-    }
-    return globals;
-  }
-  
   /* -----------------------------------------------------------------------------
    * constants/methods manipulation
    * ----------------------------------------------------------------------------- */
   
   /* Install Constants */
   SWIGINTERN void
   SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
@@ -4568,31 +4632,28 @@
       if (obj) {
         PyDict_SetItemString(d, constants[i].name, obj);
         Py_DECREF(obj);
       }
     }
   }
   
-  /* -----------------------------------------------------------------------------*/
-  /* Fix SwigMethods to carry the callback ptrs when needed */
-  /* -----------------------------------------------------------------------------*/
+  /* -----------------------------------------------------------------------------
+   * Patch %callback methods' docstrings to hold the callback ptrs
+   * -----------------------------------------------------------------------------*/
   
   SWIGINTERN void
-  SWIG_Python_FixMethods(PyMethodDef *methods,
-    swig_const_info *const_table,
-    swig_type_info **types,
-    swig_type_info **types_initial) {
+  SWIG_Python_FixMethods(PyMethodDef *methods, const swig_const_info *const_table, swig_type_info **types, swig_type_info **types_initial) {
     size_t i;
     for (i = 0; methods[i].ml_name; ++i) {
       const char *c = methods[i].ml_doc;
       if (!c) continue;
       c = strstr(c, "swig_ptr: ");
       if (c) {
         int j;
-        swig_const_info *ci = 0;
+        const swig_const_info *ci = 0;
         const char *name = c + 10;
         for (j = 0; const_table[j].type; ++j) {
           if (strncmp(const_table[j].name, name, 
               strlen(const_table[j].name)) == 0) {
             ci = &(const_table[j]);
             break;
           }
@@ -4616,76 +4677,21 @@
             }
           }
         }
       }
     }
   } 
   
-  /* -----------------------------------------------------------------------------
-   * Method creation and docstring support functions
-   * ----------------------------------------------------------------------------- */
-  
-  /* -----------------------------------------------------------------------------
-   * Function to find the method definition with the correct docstring for the
-   * proxy module as opposed to the low-level API
-   * ----------------------------------------------------------------------------- */
-  
-  SWIGINTERN PyMethodDef *SWIG_PythonGetProxyDoc(const char *name) {
-    /* Find the function in the modified method table */
-    size_t offset = 0;
-    int found = 0;
-    while (SwigMethods_proxydocs[offset].ml_meth != NULL) {
-      if (strcmp(SwigMethods_proxydocs[offset].ml_name, name) == 0) {
-        found = 1;
-        break;
-      }
-      offset++;
-    }
-    /* Use the copy with the modified docstring if available */
-    return found ? &SwigMethods_proxydocs[offset] : NULL;
-  }
-  
-  /* -----------------------------------------------------------------------------
-   * Wrapper of PyInstanceMethod_New() used in Python 3
-   * It is exported to the generated module, used for -fastproxy
-   * ----------------------------------------------------------------------------- */
-  
-  SWIGINTERN PyObject *SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func) {
-    if (PyCFunction_Check(func)) {
-      PyCFunctionObject *funcobj = (PyCFunctionObject *)func;
-      PyMethodDef *ml = SWIG_PythonGetProxyDoc(funcobj->m_ml->ml_name);
-      if (ml)
-      func = PyCFunction_NewEx(ml, funcobj->m_self, funcobj->m_module);
-    }
-#if PY_VERSION_HEX >= 0x03000000
-    return PyInstanceMethod_New(func);
-#else
-    return PyMethod_New(func, NULL, NULL);
-#endif
-  }
-  
-  /* -----------------------------------------------------------------------------
-   * Wrapper of PyStaticMethod_New()
-   * It is exported to the generated module, used for -fastproxy
-   * ----------------------------------------------------------------------------- */
-  
-  SWIGINTERN PyObject *SWIG_PyStaticMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func) {
-    if (PyCFunction_Check(func)) {
-      PyCFunctionObject *funcobj = (PyCFunctionObject *)func;
-      PyMethodDef *ml = SWIG_PythonGetProxyDoc(funcobj->m_ml->ml_name);
-      if (ml)
-      func = PyCFunction_NewEx(ml, funcobj->m_self, funcobj->m_module);
-    }
-    return PyStaticMethod_New(func);
-  }
-  
 #ifdef __cplusplus
 }
 #endif
 
+
+
+
 /* -----------------------------------------------------------------------------*
  *  Partial Init method
  * -----------------------------------------------------------------------------*/
 
 #ifdef __cplusplus
 extern "C"
 #endif
```

### Comparing `gphoto2-2.3.4/src/swig-gp2.5.30/version_wrap.c` & `gphoto2-2.3.5/src/swig-gp2_5_30/version_wrap.c`

 * *Files 4% similar despite different names*

```diff
@@ -1,24 +1,21 @@
 /* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 4.0.2
+ * This file was automatically generated by SWIG (https://www.swig.org).
+ * Version 4.1.1
  *
- * This file is not intended to be easily readable and contains a number of
- * coding conventions designed to improve portability and efficiency. Do not make
- * changes to this file unless you know what you are doing--modify the SWIG
- * interface file instead.
+ * Do not make changes to this file unless you know what you are doing - modify
+ * the SWIG interface file instead.
  * ----------------------------------------------------------------------------- */
 
 
-#ifndef SWIGPYTHON
+#define SWIG_VERSION 0x040101
 #define SWIGPYTHON
-#endif
-
 #define SWIG_PYTHON_DIRECTOR_NO_VTABLE
 #define SWIGPYTHON_BUILTIN
+#define SWIGPYTHON_FASTPROXY
 
 /* -----------------------------------------------------------------------------
  *  This section contains generic SWIG labels for method/variable
  *  declarations/attributes, and other compiler dependent labels.
  * ----------------------------------------------------------------------------- */
 
 /* template workaround for compilers that cannot correctly implement the C++ standard */
@@ -142,23 +139,45 @@
 
 
 #if defined(__GNUC__) && defined(_WIN32) && !defined(SWIG_PYTHON_NO_HYPOT_WORKAROUND)
 /* Workaround for '::hypot' has not been declared', see https://bugs.python.org/issue11566 */
 # include <math.h>
 #endif
 
+#if !defined(PY_SSIZE_T_CLEAN) && !defined(SWIG_NO_PY_SSIZE_T_CLEAN)
+#define PY_SSIZE_T_CLEAN
+#endif
+
+#if __GNUC__ >= 7
+#pragma GCC diagnostic push
+#if defined(__cplusplus) && __cplusplus >=201703L
+#pragma GCC diagnostic ignored "-Wregister" /* For python-2.7 headers that use register */
+#endif
+#endif
+
 #if defined(_DEBUG) && defined(SWIG_PYTHON_INTERPRETER_NO_DEBUG)
 /* Use debug wrappers with the Python release dll */
+
+#if defined(_MSC_VER) && _MSC_VER >= 1929
+/* Workaround compilation errors when redefining _DEBUG in MSVC 2019 version 16.10 and later
+ * See https://github.com/swig/swig/issues/2090 */
+# include <corecrt.h>
+#endif
+
 # undef _DEBUG
 # include <Python.h>
 # define _DEBUG 1
 #else
 # include <Python.h>
 #endif
 
+#if __GNUC__ >= 7
+#pragma GCC diagnostic pop
+#endif
+
 /* -----------------------------------------------------------------------------
  * swigrun.swg
  *
  * This file contains generic C API SWIG runtime support for pointer
  * type checking.
  * ----------------------------------------------------------------------------- */
 
@@ -197,14 +216,16 @@
 # define SWIG_BUFFER_SIZE 1024
 #endif
 
 /* Flags for pointer conversions */
 #define SWIG_POINTER_DISOWN        0x1
 #define SWIG_CAST_NEW_MEMORY       0x2
 #define SWIG_POINTER_NO_NULL       0x4
+#define SWIG_POINTER_CLEAR         0x8
+#define SWIG_POINTER_RELEASE       (SWIG_POINTER_CLEAR | SWIG_POINTER_DISOWN)
 
 /* Flags for new pointer objects */
 #define SWIG_POINTER_OWN           0x1
 
 
 /*
    Flags/methods for returning states.
@@ -268,44 +289,50 @@
       }
 
    Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
    more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
    SWIG errors code.
 
    Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
-   allows to return the 'cast rank', for example, if you have this
+   allows returning the 'cast rank', for example, if you have this
 
        int food(double)
        int fooi(int);
 
    and you call
 
       food(1)   // cast rank '1'  (1 -> 1.0)
       fooi(1)   // cast rank '0'
 
    just use the SWIG_AddCast()/SWIG_CheckState()
 */
 
 #define SWIG_OK                    (0)
+/* Runtime errors are < 0 */
 #define SWIG_ERROR                 (-1)
+/* Errors in range -1 to -99 are in swigerrors.swg (errors for all languages including those not using the runtime) */
+/* Errors in range -100 to -199 are language specific errors defined in *errors.swg */
+/* Errors < -200 are generic runtime specific errors */
+#define SWIG_ERROR_RELEASE_NOT_OWNED (-200)
+
 #define SWIG_IsOK(r)               (r >= 0)
 #define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)
 
 /* The CastRankLimit says how many bits are used for the cast rank */
 #define SWIG_CASTRANKLIMIT         (1 << 8)
 /* The NewMask denotes the object was created (using new/malloc) */
 #define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
 /* The TmpMask is for in/out typemaps that use temporal objects */
 #define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
 /* Simple returning values */
 #define SWIG_BADOBJ                (SWIG_ERROR)
 #define SWIG_OLDOBJ                (SWIG_OK)
 #define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
 #define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
-/* Check, add and del mask methods */
+/* Check, add and del object mask methods */
 #define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
 #define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
 #define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
 #define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
 #define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
 #define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))
 
@@ -443,15 +470,15 @@
   return 0;
 }
 
 /*
   Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
 */
 SWIGRUNTIME swig_cast_info *
-SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty) {
+SWIG_TypeCheckStruct(const swig_type_info *from, swig_type_info *ty) {
   if (ty) {
     swig_cast_info *iter = ty->cast;
     while (iter) {
       if (iter->type == from) {
         if (iter == ty->cast)
           return iter;
         /* Move iter to the top of the linked list */
@@ -503,17 +530,17 @@
 /*
   Return the pretty name associated with this type,
   that is an unmangled type name in a form presentable to the user.
 */
 SWIGRUNTIME const char *
 SWIG_TypePrettyName(const swig_type_info *type) {
   /* The "str" field contains the equivalent pretty names of the
-     type, separated by vertical-bar characters.  We choose
-     to print the last name, as it is often (?) the most
-     specific. */
+     type, separated by vertical-bar characters.  Choose the last
+     name. It should be the most specific; a fully resolved name
+     but not necessarily with default template parameters expanded. */
   if (!type) return NULL;
   if (type->str != NULL) {
     const char *last_name = type->str;
     const char *s;
     for (s = type->str; *s; s++)
       if (*s == '|') last_name = s+1;
     return last_name;
@@ -725,15 +752,15 @@
   return SWIG_UnpackData(++c,ptr,sz);
 }
 
 #ifdef __cplusplus
 }
 #endif
 
-/*  Errors in SWIG */
+/* SWIG Errors applicable to all language modules, values are reserved from -1 to -99 */
 #define  SWIG_UnknownError    	   -1
 #define  SWIG_IOError        	   -2
 #define  SWIG_RuntimeError   	   -3
 #define  SWIG_IndexError     	   -4
 #define  SWIG_TypeError      	   -5
 #define  SWIG_DivisionByZero 	   -6
 #define  SWIG_OverflowError  	   -7
@@ -741,15 +768,14 @@
 #define  SWIG_ValueError     	   -9
 #define  SWIG_SystemError    	   -10
 #define  SWIG_AttributeError 	   -11
 #define  SWIG_MemoryError    	   -12
 #define  SWIG_NullReferenceError   -13
 
 
-
 /* Compatibility macros for Python 3 */
 #if PY_VERSION_HEX >= 0x03000000
 
 #define PyClass_Check(obj) PyObject_IsInstance(obj, (PyObject *)&PyType_Type)
 #define PyInt_Check(x) PyLong_Check(x)
 #define PyInt_AsLong(x) PyLong_AsLong(x)
 #define PyInt_FromLong(x) PyLong_FromLong(x)
@@ -757,15 +783,14 @@
 #define PyString_Check(name) PyBytes_Check(name)
 #define PyString_FromString(x) PyUnicode_FromString(x)
 #define PyString_Format(fmt, args)  PyUnicode_Format(fmt, args)
 #define PyString_AsString(str) PyBytes_AsString(str)
 #define PyString_Size(str) PyBytes_Size(str)	
 #define PyString_InternFromString(key) PyUnicode_InternFromString(key)
 #define Py_TPFLAGS_HAVE_CLASS Py_TPFLAGS_BASETYPE
-#define PyString_AS_STRING(x) PyUnicode_AS_STRING(x)
 #define _PyLong_FromSsize_t(x) PyLong_FromSsize_t(x)
 
 #endif
 
 #ifndef Py_TYPE
 #  define Py_TYPE(op) ((op)->ob_type)
 #endif
@@ -775,46 +800,27 @@
 #if PY_VERSION_HEX >= 0x03000000
 #  define SWIG_Python_str_FromFormat PyUnicode_FromFormat
 #else
 #  define SWIG_Python_str_FromFormat PyString_FromFormat
 #endif
 
 
-/* Warning: This function will allocate a new string in Python 3,
- * so please call SWIG_Python_str_DelForPy3(x) to free the space.
- */
 SWIGINTERN char*
 SWIG_Python_str_AsChar(PyObject *str)
 {
 #if PY_VERSION_HEX >= 0x03030000
   return (char *)PyUnicode_AsUTF8(str);
-#elif PY_VERSION_HEX >= 0x03000000
-  char *newstr = 0;
-  str = PyUnicode_AsUTF8String(str);
-  if (str) {
-    char *cstr;
-    Py_ssize_t len;
-    if (PyBytes_AsStringAndSize(str, &cstr, &len) != -1) {
-      newstr = (char *) malloc(len+1);
-      if (newstr)
-        memcpy(newstr, cstr, len+1);
-    }
-    Py_XDECREF(str);
-  }
-  return newstr;
 #else
   return PyString_AsString(str);
 #endif
 }
 
-#if PY_VERSION_HEX >= 0x03030000 || PY_VERSION_HEX < 0x03000000
-#  define SWIG_Python_str_DelForPy3(x)
-#else
-#  define SWIG_Python_str_DelForPy3(x) free( (void*) (x) )
-#endif
+/* Was useful for Python 3.0.x-3.2.x - now provided only for compatibility
+ * with any uses in user interface files. */
+#define SWIG_Python_str_DelForPy3(x)
 
 
 SWIGINTERN PyObject*
 SWIG_Python_str_FromChar(const char *c)
 {
 #if PY_VERSION_HEX >= 0x03000000
   return PyUnicode_FromString(c); 
@@ -823,18 +829,22 @@
 #endif
 }
 
 #ifndef PyObject_DEL
 # define PyObject_DEL PyObject_Del
 #endif
 
-// SWIGPY_USE_CAPSULE is no longer used within SWIG itself, but some user
-// interface files check for it.
+/* SWIGPY_USE_CAPSULE is no longer used within SWIG itself, but some user interface files check for it. */
 # define SWIGPY_USE_CAPSULE
-# define SWIGPY_CAPSULE_NAME ("swig_runtime_data" SWIG_RUNTIME_VERSION ".type_pointer_capsule" SWIG_TYPE_TABLE_NAME)
+#ifdef SWIGPYTHON_BUILTIN
+# define SWIGPY_CAPSULE_ATTR_NAME "type_pointer_capsule_builtin" SWIG_TYPE_TABLE_NAME
+#else
+# define SWIGPY_CAPSULE_ATTR_NAME "type_pointer_capsule" SWIG_TYPE_TABLE_NAME
+#endif
+# define SWIGPY_CAPSULE_NAME ("swig_runtime_data" SWIG_RUNTIME_VERSION "." SWIGPY_CAPSULE_ATTR_NAME)
 
 #if PY_VERSION_HEX < 0x03020000
 #define PyDescr_TYPE(x) (((PyDescrObject *)(x))->d_type)
 #define PyDescr_NAME(x) (((PyDescrObject *)(x))->d_name)
 #define Py_hash_t long
 #endif
 
@@ -900,15 +910,14 @@
     const char *tmp = SWIG_Python_str_AsChar(old_str);
     PyErr_Clear();
     Py_XINCREF(type);
     if (tmp)
       PyErr_Format(type, "%s %s", tmp, mesg);
     else
       PyErr_Format(type, "%s", mesg);
-    SWIG_Python_str_DelForPy3(tmp);
     Py_DECREF(old_str);
     Py_DECREF(value);
   } else {
     PyErr_SetString(PyExc_RuntimeError, mesg);
   }
 }
 
@@ -931,16 +940,20 @@
     PyObject *type = NULL, *value = NULL, *traceback = NULL;
     PyErr_Fetch(&type, &value, &traceback);
 #if PY_VERSION_HEX >= 0x03000000
     newvalue = PyUnicode_FromFormat("%S\nAdditional information:\n%s", value, message);
 #else
     newvalue = PyString_FromFormat("%s\nAdditional information:\n%s", PyString_AsString(value), message);
 #endif
-    Py_XDECREF(value);
-    PyErr_Restore(type, newvalue, traceback);
+    if (newvalue) {
+      Py_XDECREF(value);
+      PyErr_Restore(type, newvalue, traceback);
+    } else {
+      PyErr_Restore(type, value, traceback);
+    }
   } else {
     /* Raise TypeError using given message */
     PyErr_SetString(PyExc_TypeError, message);
   }
 }
 
 #if defined(SWIG_PYTHON_NO_THREADS)
@@ -949,16 +962,20 @@
 #  endif
 #endif
 #if defined(SWIG_PYTHON_THREADS) /* Threading support is enabled */
 #  if !defined(SWIG_PYTHON_USE_GIL) && !defined(SWIG_PYTHON_NO_USE_GIL)
 #    define SWIG_PYTHON_USE_GIL
 #  endif
 #  if defined(SWIG_PYTHON_USE_GIL) /* Use PyGILState threads calls */
-#    ifndef SWIG_PYTHON_INITIALIZE_THREADS
-#     define SWIG_PYTHON_INITIALIZE_THREADS  PyEval_InitThreads() 
+#    if !defined(SWIG_PYTHON_INITIALIZE_THREADS)
+#      if PY_VERSION_HEX < 0x03070000
+#        define SWIG_PYTHON_INITIALIZE_THREADS PyEval_InitThreads()
+#      else
+#        define SWIG_PYTHON_INITIALIZE_THREADS
+#      endif
 #    endif
 #    ifdef __cplusplus /* C++ code */
        class SWIG_Python_Thread_Block {
          bool status;
          PyGILState_STATE state;
        public:
          void end() { if (status) { PyGILState_Release(state); status = false;} }
@@ -1048,16 +1065,16 @@
  *
  * ----------------------------------------------------------------------------- */
 
 #if PY_VERSION_HEX < 0x02070000 /* 2.7.0 */
 # error "This version of SWIG only supports Python >= 2.7"
 #endif
 
-#if PY_VERSION_HEX >= 0x03000000 && PY_VERSION_HEX < 0x03020000
-# error "This version of SWIG only supports Python 3 >= 3.2"
+#if PY_VERSION_HEX >= 0x03000000 && PY_VERSION_HEX < 0x03030000
+# error "This version of SWIG only supports Python 3 >= 3.3"
 #endif
 
 /* Common SWIG API */
 
 /* for raw pointers */
 #define SWIG_Python_ConvertPtr(obj, pptr, type, flags)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, 0)
 #define SWIG_ConvertPtr(obj, pptr, type, flags)         SWIG_Python_ConvertPtr(obj, pptr, type, flags)
@@ -1164,15 +1181,20 @@
   } else if (result == Py_None) {
     Py_DECREF(result);
     result = obj;
   } else {
     if (!PyList_Check(result)) {
       PyObject *o2 = result;
       result = PyList_New(1);
-      PyList_SetItem(result, 0, o2);
+      if (result) {
+        PyList_SET_ITEM(result, 0, o2);
+      } else {
+        Py_DECREF(obj);
+        return o2;
+      }
     }
     PyList_Append(result,obj);
     Py_DECREF(obj);
   }
   return result;
 }
 
@@ -1246,14 +1268,246 @@
 */
 #ifdef __cplusplus
 #define SWIG_STATIC_POINTER(var)  var
 #else
 #define SWIG_STATIC_POINTER(var)  var = 0; if (!var) var
 #endif
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Python-specific SWIG API */
+#define SWIG_newvarlink()                             SWIG_Python_newvarlink()
+#define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
+#define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)
+ 
+/* -----------------------------------------------------------------------------
+ * global variable support code.
+ * ----------------------------------------------------------------------------- */
+ 
+typedef struct swig_globalvar {   
+  char       *name;                  /* Name of global variable */
+  PyObject *(*get_attr)(void);       /* Return the current value */
+  int       (*set_attr)(PyObject *); /* Set the value */
+  struct swig_globalvar *next;
+} swig_globalvar;
+
+typedef struct swig_varlinkobject {
+  PyObject_HEAD
+  swig_globalvar *vars;
+} swig_varlinkobject;
+
+SWIGINTERN PyObject *
+swig_varlink_repr(PyObject *SWIGUNUSEDPARM(v)) {
+#if PY_VERSION_HEX >= 0x03000000
+  return PyUnicode_InternFromString("<Swig global variables>");
+#else
+  return PyString_FromString("<Swig global variables>");
+#endif
+}
+
+SWIGINTERN PyObject *
+swig_varlink_str(PyObject *o) {
+  swig_varlinkobject *v = (swig_varlinkobject *) o;
+#if PY_VERSION_HEX >= 0x03000000
+  PyObject *str = PyUnicode_InternFromString("(");
+  PyObject *tail;
+  PyObject *joined;
+  swig_globalvar *var;
+  for (var = v->vars; var; var=var->next) {
+    tail = PyUnicode_FromString(var->name);
+    joined = PyUnicode_Concat(str, tail);
+    Py_DecRef(str);
+    Py_DecRef(tail);
+    str = joined;
+    if (var->next) {
+        tail = PyUnicode_InternFromString(", ");
+        joined = PyUnicode_Concat(str, tail);
+        Py_DecRef(str);
+        Py_DecRef(tail);
+        str = joined;
+    }
+  }
+  tail = PyUnicode_InternFromString(")");
+  joined = PyUnicode_Concat(str, tail);
+  Py_DecRef(str);
+  Py_DecRef(tail);
+  str = joined;
+#else
+  PyObject *str = PyString_FromString("(");
+  swig_globalvar *var;
+  for (var = v->vars; var; var=var->next) {
+    PyString_ConcatAndDel(&str,PyString_FromString(var->name));
+    if (var->next) PyString_ConcatAndDel(&str,PyString_FromString(", "));
+  }
+  PyString_ConcatAndDel(&str,PyString_FromString(")"));
+#endif
+  return str;
+}
+
+SWIGINTERN void
+swig_varlink_dealloc(PyObject *o) {
+  swig_varlinkobject *v = (swig_varlinkobject *) o;
+  swig_globalvar *var = v->vars;
+  while (var) {
+    swig_globalvar *n = var->next;
+    free(var->name);
+    free(var);
+    var = n;
+  }
+}
+
+SWIGINTERN PyObject *
+swig_varlink_getattr(PyObject *o, char *n) {
+  swig_varlinkobject *v = (swig_varlinkobject *) o;
+  PyObject *res = NULL;
+  swig_globalvar *var = v->vars;
+  while (var) {
+    if (strcmp(var->name,n) == 0) {
+      res = (*var->get_attr)();
+      break;
+    }
+    var = var->next;
+  }
+  if (res == NULL && !PyErr_Occurred()) {
+    PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
+  }
+  return res;
+}
+
+SWIGINTERN int
+swig_varlink_setattr(PyObject *o, char *n, PyObject *p) {
+  swig_varlinkobject *v = (swig_varlinkobject *) o;
+  int res = 1;
+  swig_globalvar *var = v->vars;
+  while (var) {
+    if (strcmp(var->name,n) == 0) {
+      res = (*var->set_attr)(p);
+      break;
+    }
+    var = var->next;
+  }
+  if (res == 1 && !PyErr_Occurred()) {
+    PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
+  }
+  return res;
+}
+
+SWIGINTERN PyTypeObject*
+swig_varlink_type(void) {
+  static char varlink__doc__[] = "Swig var link object";
+  static PyTypeObject varlink_type;
+  static int type_init = 0;
+  if (!type_init) {
+    const PyTypeObject tmp = {
+#if PY_VERSION_HEX >= 0x03000000
+      PyVarObject_HEAD_INIT(NULL, 0)
+#else
+      PyObject_HEAD_INIT(NULL)
+      0,                                  /* ob_size */
+#endif
+      "swigvarlink",                      /* tp_name */
+      sizeof(swig_varlinkobject),         /* tp_basicsize */
+      0,                                  /* tp_itemsize */
+      (destructor) swig_varlink_dealloc,  /* tp_dealloc */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                       /*tp_print*/
+#else
+      (Py_ssize_t)0,                      /*tp_vectorcall_offset*/
+#endif
+      (getattrfunc) swig_varlink_getattr, /* tp_getattr */
+      (setattrfunc) swig_varlink_setattr, /* tp_setattr */
+      0,                                  /* tp_compare */
+      (reprfunc) swig_varlink_repr,       /* tp_repr */
+      0,                                  /* tp_as_number */
+      0,                                  /* tp_as_sequence */
+      0,                                  /* tp_as_mapping */
+      0,                                  /* tp_hash */
+      0,                                  /* tp_call */
+      (reprfunc) swig_varlink_str,        /* tp_str */
+      0,                                  /* tp_getattro */
+      0,                                  /* tp_setattro */
+      0,                                  /* tp_as_buffer */
+      0,                                  /* tp_flags */
+      varlink__doc__,                     /* tp_doc */
+      0,                                  /* tp_traverse */
+      0,                                  /* tp_clear */
+      0,                                  /* tp_richcompare */
+      0,                                  /* tp_weaklistoffset */
+      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
+      0,                                  /* tp_del */
+      0,                                  /* tp_version_tag */
+#if PY_VERSION_HEX >= 0x03040000
+      0,                                  /* tp_finalize */
+#endif
+#if PY_VERSION_HEX >= 0x03080000
+      0,                                  /* tp_vectorcall */
+#endif
+#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
+      0,                                  /* tp_print */
+#endif
+#ifdef COUNT_ALLOCS
+      0,                                  /* tp_allocs */
+      0,                                  /* tp_frees */
+      0,                                  /* tp_maxalloc */
+      0,                                  /* tp_prev */
+      0                                   /* tp_next */
+#endif
+    };
+    varlink_type = tmp;
+    type_init = 1;
+    if (PyType_Ready(&varlink_type) < 0)
+      return NULL;
+  }
+  return &varlink_type;
+}
+
+/* Create a variable linking object for use later */
+SWIGINTERN PyObject *
+SWIG_Python_newvarlink(void) {
+  swig_varlinkobject *result = PyObject_NEW(swig_varlinkobject, swig_varlink_type());
+  if (result) {
+    result->vars = 0;
+  }
+  return ((PyObject*) result);
+}
+
+SWIGINTERN void 
+SWIG_Python_addvarlink(PyObject *p, const char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
+  swig_varlinkobject *v = (swig_varlinkobject *) p;
+  swig_globalvar *gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
+  if (gv) {
+    size_t size = strlen(name)+1;
+    gv->name = (char *)malloc(size);
+    if (gv->name) {
+      memcpy(gv->name, name, size);
+      gv->get_attr = get_attr;
+      gv->set_attr = set_attr;
+      gv->next = v->vars;
+    }
+  }
+  v->vars = gv;
+}
+
+
+static PyObject *Swig_Globals_global = NULL;
+  
+SWIGINTERN PyObject *
+SWIG_globals(void) {
+  if (Swig_Globals_global == NULL) {
+    Swig_Globals_global = SWIG_newvarlink();
+  }
+  return Swig_Globals_global;
+}
+
+#ifdef __cplusplus
+}
+#endif
+
 /* -----------------------------------------------------------------------------
  * Pointer declarations
  * ----------------------------------------------------------------------------- */
 
 /* Flags for new pointer objects */
 #define SWIG_POINTER_NOSHADOW       (SWIG_POINTER_OWN      << 1)
 #define SWIG_POINTER_NEW            (SWIG_POINTER_NOSHADOW | SWIG_POINTER_OWN)
@@ -1316,52 +1570,59 @@
     SwigPyClientData *data = (SwigPyClientData *)malloc(sizeof(SwigPyClientData));
     /* the klass element */
     data->klass = obj;
     Py_INCREF(data->klass);
     /* the newraw method and newargs arguments used to create a new raw instance */
     if (PyClass_Check(obj)) {
       data->newraw = 0;
-      data->newargs = obj;
       Py_INCREF(obj);
+      data->newargs = obj;
     } else {
       data->newraw = PyObject_GetAttrString(data->klass, "__new__");
       if (data->newraw) {
-	Py_INCREF(data->newraw);
-	data->newargs = PyTuple_New(1);
-	PyTuple_SetItem(data->newargs, 0, obj);
+        data->newargs = PyTuple_New(1);
+        if (data->newargs) {
+          Py_INCREF(obj);
+          PyTuple_SET_ITEM(data->newargs, 0, obj);
+        } else {
+          Py_DECREF(data->newraw);
+          Py_DECREF(data->klass);
+          free(data);
+          return 0;
+        }
       } else {
-	data->newargs = obj;
+        Py_INCREF(obj);
+        data->newargs = obj;
       }
-      Py_INCREF(data->newargs);
     }
     /* the destroy method, aka as the C++ delete method */
     data->destroy = PyObject_GetAttrString(data->klass, "__swig_destroy__");
     if (PyErr_Occurred()) {
       PyErr_Clear();
       data->destroy = 0;
     }
     if (data->destroy) {
-      int flags;
-      Py_INCREF(data->destroy);
-      flags = PyCFunction_GET_FLAGS(data->destroy);
-      data->delargs = !(flags & (METH_O));
+      data->delargs = !(PyCFunction_GET_FLAGS(data->destroy) & METH_O);
     } else {
       data->delargs = 0;
     }
     data->implicitconv = 0;
     data->pytype = 0;
     return data;
   }
 }
 
 SWIGRUNTIME void 
-SwigPyClientData_Del(SwigPyClientData *data) {
+SwigPyClientData_Del(SwigPyClientData *data)
+{
+  Py_XDECREF(data->klass);
   Py_XDECREF(data->newraw);
   Py_XDECREF(data->newargs);
   Py_XDECREF(data->destroy);
+  free(data);
 }
 
 /* =============== SwigPyObject =====================*/
 
 typedef struct {
   PyObject_HEAD
   void *ptr;
@@ -1380,15 +1641,15 @@
 SwigPyObject_get___dict__(PyObject *v, PyObject *SWIGUNUSEDPARM(args))
 {
   SwigPyObject *sobj = (SwigPyObject *)v;
 
   if (!sobj->dict)
     sobj->dict = PyDict_New();
 
-  Py_INCREF(sobj->dict);
+  Py_XINCREF(sobj->dict);
   return sobj->dict;
 }
 
 #endif
 
 SWIGRUNTIME PyObject *
 SwigPyObject_long(SwigPyObject *v)
@@ -1398,26 +1659,29 @@
 
 SWIGRUNTIME PyObject *
 SwigPyObject_format(const char* fmt, SwigPyObject *v)
 {
   PyObject *res = NULL;
   PyObject *args = PyTuple_New(1);
   if (args) {
-    if (PyTuple_SetItem(args, 0, SwigPyObject_long(v)) == 0) {
-      PyObject *ofmt = SWIG_Python_str_FromChar(fmt);
+    PyObject *val = SwigPyObject_long(v);
+    if (val) {
+      PyObject *ofmt;
+      PyTuple_SET_ITEM(args, 0, val);
+      ofmt = SWIG_Python_str_FromChar(fmt);
       if (ofmt) {
 #if PY_VERSION_HEX >= 0x03000000
-	res = PyUnicode_Format(ofmt,args);
+        res = PyUnicode_Format(ofmt,args);
 #else
-	res = PyString_Format(ofmt,args);
+        res = PyString_Format(ofmt,args);
 #endif
-	Py_DECREF(ofmt);
+        Py_DECREF(ofmt);
       }
-      Py_DECREF(args);
     }
+    Py_DECREF(args);
   }
   return res;
 }
 
 SWIGRUNTIME PyObject *
 SwigPyObject_oct(SwigPyObject *v)
 {
@@ -1431,26 +1695,31 @@
 }
 
 SWIGRUNTIME PyObject *
 SwigPyObject_repr(SwigPyObject *v)
 {
   const char *name = SWIG_TypePrettyName(v->ty);
   PyObject *repr = SWIG_Python_str_FromFormat("<Swig Object of type '%s' at %p>", (name ? name : "unknown"), (void *)v);
-  if (v->next) {
+  if (repr && v->next) {
     PyObject *nrep = SwigPyObject_repr((SwigPyObject *)v->next);
+    if (nrep) {
 # if PY_VERSION_HEX >= 0x03000000
-    PyObject *joined = PyUnicode_Concat(repr, nrep);
-    Py_DecRef(repr);
-    Py_DecRef(nrep);
-    repr = joined;
+      PyObject *joined = PyUnicode_Concat(repr, nrep);
+      Py_DecRef(repr);
+      Py_DecRef(nrep);
+      repr = joined;
 # else
-    PyString_ConcatAndDel(&repr,nrep);
+      PyString_ConcatAndDel(&repr,nrep);
 # endif
+    } else {
+      Py_DecRef(repr);
+      repr = NULL;
+    }
   }
-  return repr;  
+  return repr;
 }
 
 /* We need a version taking two PyObject* parameters so it's a valid
  * PyCFunction to use in swigobject_methods[]. */
 SWIGRUNTIME PyObject *
 SwigPyObject_repr2(PyObject *v, PyObject *SWIGUNUSEDPARM(args))
 {
@@ -1512,14 +1781,16 @@
     || (strcmp(Py_TYPE(op)->tp_name,"SwigPyObject") == 0);
 #endif
 }
 
 SWIGRUNTIME PyObject *
 SwigPyObject_New(void *ptr, swig_type_info *ty, int own);
 
+static PyObject* Swig_Capsule_global = NULL;
+
 SWIGRUNTIME void
 SwigPyObject_dealloc(PyObject *v)
 {
   SwigPyObject *sobj = (SwigPyObject *) v;
   PyObject *next = sobj->next;
   if (sobj->own == SWIG_POINTER_OWN) {
     swig_type_info *ty = sobj->ty;
@@ -1538,16 +1809,20 @@
       
       PyObject *type = NULL, *value = NULL, *traceback = NULL;
       PyErr_Fetch(&type, &value, &traceback);
 
       if (data->delargs) {
         /* we need to create a temporary object to carry the destroy operation */
         PyObject *tmp = SwigPyObject_New(sobj->ptr, ty, 0);
-        res = SWIG_Python_CallFunctor(destroy, tmp);
-        Py_DECREF(tmp);
+        if (tmp) {
+          res = SWIG_Python_CallFunctor(destroy, tmp);
+        } else {
+          res = 0;
+        }
+        Py_XDECREF(tmp);
       } else {
         PyCFunction meth = PyCFunction_GET_FUNCTION(destroy);
         PyObject *mself = PyCFunction_GET_SELF(destroy);
         res = ((*meth)(mself, v));
       }
       if (!res)
         PyErr_WriteUnraisable(destroy);
@@ -1558,27 +1833,32 @@
     } 
 #if !defined(SWIG_PYTHON_SILENT_MEMLEAK)
     else {
       const char *name = SWIG_TypePrettyName(ty);
       printf("swig/python detected a memory leak of type '%s', no destructor found.\n", (name ? name : "unknown"));
     }
 #endif
-  } 
+    Py_XDECREF(Swig_Capsule_global);
+  }
   Py_XDECREF(next);
+#ifdef SWIGPYTHON_BUILTIN
+  Py_XDECREF(sobj->dict);
+#endif
   PyObject_DEL(v);
 }
 
 SWIGRUNTIME PyObject* 
 SwigPyObject_append(PyObject* v, PyObject* next)
 {
   SwigPyObject *sobj = (SwigPyObject *) v;
   if (!SwigPyObject_Check(next)) {
     PyErr_SetString(PyExc_TypeError, "Attempt to append a non SwigPyObject");
     return NULL;
   }
+  ((SwigPyObject *)next)->next = sobj->next;
   sobj->next = next;
   Py_INCREF(next);
   return SWIG_Py_Void();
 }
 
 SWIGRUNTIME PyObject* 
 SwigPyObject_next(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
@@ -1615,17 +1895,17 @@
   if (!PyArg_UnpackTuple(args, "own", 0, 1, &val)) {
     return NULL;
   } else {
     SwigPyObject *sobj = (SwigPyObject *)v;
     PyObject *obj = PyBool_FromLong(sobj->own);
     if (val) {
       if (PyObject_IsTrue(val)) {
-        SwigPyObject_acquire(v,args);
+        Py_DECREF(SwigPyObject_acquire(v,args));
       } else {
-        SwigPyObject_disown(v,args);
+        Py_DECREF(SwigPyObject_disown(v,args));
       }
     } 
     return obj;
   }
 }
 
 static PyMethodDef
@@ -1697,15 +1977,19 @@
       PyObject_HEAD_INIT(NULL)
       0,                                    /* ob_size */
 #endif
       "SwigPyObject",                       /* tp_name */
       sizeof(SwigPyObject),                 /* tp_basicsize */
       0,                                    /* tp_itemsize */
       (destructor)SwigPyObject_dealloc,     /* tp_dealloc */
-      0,                                    /* tp_print */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                         /*tp_print*/
+#else
+      (Py_ssize_t)0,                        /*tp_vectorcall_offset*/
+#endif
       (getattrfunc)0,                       /* tp_getattr */
       (setattrfunc)0,                       /* tp_setattr */
 #if PY_VERSION_HEX >= 0x03000000
       0, /* tp_reserved in 3.0.1, tp_compare in 3.0.0 but not used */
 #else
       (cmpfunc)SwigPyObject_compare,        /* tp_compare */
 #endif
@@ -1762,29 +2046,38 @@
       0,                                    /* tp_maxalloc */
       0,                                    /* tp_prev */
       0                                     /* tp_next */
 #endif
     };
     swigpyobject_type = tmp;
     type_init = 1;
-    if (PyType_Ready(&swigpyobject_type) < 0)
+    if (PyType_Ready(&swigpyobject_type) != 0)
       return NULL;
   }
   return &swigpyobject_type;
 }
 
 SWIGRUNTIME PyObject *
 SwigPyObject_New(void *ptr, swig_type_info *ty, int own)
 {
   SwigPyObject *sobj = PyObject_NEW(SwigPyObject, SwigPyObject_type());
   if (sobj) {
     sobj->ptr  = ptr;
     sobj->ty   = ty;
     sobj->own  = own;
     sobj->next = 0;
+#ifdef SWIGPYTHON_BUILTIN
+    sobj->dict = 0;
+#endif
+    if (own == SWIG_POINTER_OWN) {
+      /* Obtain a reference to the Python capsule wrapping the module information, so that the
+       * module information is correctly destroyed after all SWIG python objects have been freed
+       * by the GC (and corresponding destructors invoked) */
+      Py_XINCREF(Swig_Capsule_global);
+    }
   }
   return (PyObject *)sobj;
 }
 
 /* -----------------------------------------------------------------------------
  * Implements a simple Swig Packed type, and use it instead of string
  * ----------------------------------------------------------------------------- */
@@ -1864,15 +2157,19 @@
       PyObject_HEAD_INIT(NULL)
       0,                                    /* ob_size */
 #endif
       "SwigPyPacked",                       /* tp_name */
       sizeof(SwigPyPacked),                 /* tp_basicsize */
       0,                                    /* tp_itemsize */
       (destructor)SwigPyPacked_dealloc,     /* tp_dealloc */
-      0,                                    /* tp_print */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                         /*tp_print*/
+#else
+      (Py_ssize_t)0,                        /*tp_vectorcall_offset*/
+#endif
       (getattrfunc)0,                       /* tp_getattr */
       (setattrfunc)0,                       /* tp_setattr */
 #if PY_VERSION_HEX>=0x03000000
       0, /* tp_reserved in 3.0.1 */
 #else
       (cmpfunc)SwigPyPacked_compare,        /* tp_compare */
 #endif
@@ -1929,15 +2226,15 @@
       0,                                    /* tp_maxalloc */
       0,                                    /* tp_prev */
       0                                     /* tp_next */
 #endif
     };
     swigpypacked_type = tmp;
     type_init = 1;
-    if (PyType_Ready(&swigpypacked_type) < 0)
+    if (PyType_Ready(&swigpypacked_type) != 0)
       return NULL;
   }
   return &swigpypacked_type;
 }
 
 SWIGRUNTIME PyObject *
 SwigPyPacked_New(void *ptr, size_t size, swig_type_info *ty)
@@ -2119,20 +2416,27 @@
       }
     } else {
       if (ptr) *ptr = vptr;
       break;
     }
   }
   if (sobj) {
-    if (own)
-      *own = *own | sobj->own;
-    if (flags & SWIG_POINTER_DISOWN) {
-      sobj->own = 0;
+    if (((flags & SWIG_POINTER_RELEASE) == SWIG_POINTER_RELEASE) && !sobj->own) {
+      res = SWIG_ERROR_RELEASE_NOT_OWNED;
+    } else {
+      if (own)
+        *own = *own | sobj->own;
+      if (flags & SWIG_POINTER_DISOWN) {
+        sobj->own = 0;
+      }
+      if (flags & SWIG_POINTER_CLEAR) {
+        sobj->ptr = 0;
+      }
+      res = SWIG_OK;
     }
-    res = SWIG_OK;
   } else {
     if (implicit_conv) {
       SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
       if (data && !data->implicitconv) {
         PyObject *klass = data->klass;
         if (klass) {
           PyObject *impconv;
@@ -2237,20 +2541,25 @@
   PyObject *newraw = data->newraw;
   if (newraw) {
     inst = PyObject_Call(newraw, data->newargs, NULL);
     if (inst) {
 #if !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
       PyObject **dictptr = _PyObject_GetDictPtr(inst);
       if (dictptr != NULL) {
-	PyObject *dict = *dictptr;
-	if (dict == NULL) {
-	  dict = PyDict_New();
-	  *dictptr = dict;
-	  PyDict_SetItem(dict, SWIG_This(), swig_this);
-	}
+        PyObject *dict = *dictptr;
+        if (dict == NULL) {
+          dict = PyDict_New();
+          *dictptr = dict;
+        }
+        if (dict) {
+          PyDict_SetItem(dict, SWIG_This(), swig_this);
+        } else{
+          Py_DECREF(inst);
+          inst = 0;
+        }
       }
 #else
       if (PyObject_SetAttr(inst, SWIG_This(), swig_this) == -1) {
         Py_DECREF(inst);
         inst = 0;
       }
 #endif
@@ -2264,15 +2573,15 @@
         inst = ((PyTypeObject *)data->newargs)->tp_new((PyTypeObject *)data->newargs, empty_args, empty_kwargs);
         Py_DECREF(empty_kwargs);
         if (inst) {
           if (PyObject_SetAttr(inst, SWIG_This(), swig_this) == -1) {
             Py_DECREF(inst);
             inst = 0;
           } else {
-            Py_TYPE(inst)->tp_flags &= ~Py_TPFLAGS_VALID_VERSION_TAG;
+            PyType_Modified(Py_TYPE(inst));
           }
         }
       }
       Py_DECREF(empty_args);
     }
 #else
     PyObject *dict = PyDict_New();
@@ -2293,30 +2602,34 @@
   PyObject **dictptr = _PyObject_GetDictPtr(inst);
   if (dictptr != NULL) {
     PyObject *dict = *dictptr;
     if (dict == NULL) {
       dict = PyDict_New();
       *dictptr = dict;
     }
-    return PyDict_SetItem(dict, SWIG_This(), swig_this);
+    if (dict) {
+      return PyDict_SetItem(dict, SWIG_This(), swig_this);
+    } else{
+      return -1;
+    }
   }
 #endif
   return PyObject_SetAttr(inst, SWIG_This(), swig_this);
 } 
 
 
 SWIGINTERN PyObject *
 SWIG_Python_InitShadowInstance(PyObject *args) {
   PyObject *obj[2];
   if (!SWIG_Python_UnpackTuple(args, "swiginit", 2, 2, obj)) {
     return NULL;
   } else {
     SwigPyObject *sthis = SWIG_Python_GetSwigThis(obj[0]);
     if (sthis) {
-      SwigPyObject_append((PyObject*) sthis, obj[1]);
+      Py_DECREF(SwigPyObject_append((PyObject*) sthis, obj[1]));
     } else {
       if (SWIG_Python_SetSwigThis(obj[0], obj[1]) != 0)
         return NULL;
     }
     return SWIG_Py_Void();
   }
 }
@@ -2347,15 +2660,17 @@
 #ifdef SWIGPYTHON_BUILTIN
         newobj->dict = 0;
 #endif
       }
     } else {
       newobj = PyObject_New(SwigPyObject, clientdata->pytype);
 #ifdef SWIGPYTHON_BUILTIN
-      newobj->dict = 0;
+      if (newobj) {
+        newobj->dict = 0;
+      }
 #endif
     }
     if (newobj) {
       newobj->ptr = ptr;
       newobj->ty = type;
       newobj->own = own;
       newobj->next = 0;
@@ -2386,89 +2701,111 @@
  *  Get type list 
  * -----------------------------------------------------------------------------*/
 
 #ifdef SWIG_LINK_RUNTIME
 void *SWIG_ReturnGlobalTypeList(void *);
 #endif
 
+static PyObject *Swig_TypeCache_global = NULL;
+
+/* The python cached type query */
+SWIGRUNTIME PyObject *
+SWIG_Python_TypeCache(void) {
+  if (Swig_TypeCache_global == NULL) {
+    Swig_TypeCache_global = PyDict_New();
+  }
+  return Swig_TypeCache_global;
+}
+
 SWIGRUNTIME swig_module_info *
 SWIG_Python_GetModule(void *SWIGUNUSEDPARM(clientdata)) {
+#ifdef SWIG_LINK_RUNTIME
   static void *type_pointer = (void *)0;
   /* first check if module already created */
   if (!type_pointer) {
-#ifdef SWIG_LINK_RUNTIME
     type_pointer = SWIG_ReturnGlobalTypeList((void *)0);
+  }
 #else
-    type_pointer = PyCapsule_Import(SWIGPY_CAPSULE_NAME, 0);
-    if (PyErr_Occurred()) {
-      PyErr_Clear();
-      type_pointer = (void *)0;
-    }
-#endif
+  void *type_pointer = PyCapsule_Import(SWIGPY_CAPSULE_NAME, 0);
+  if (PyErr_Occurred()) {
+    PyErr_Clear();
+    type_pointer = (void *)0;
   }
+#endif
   return (swig_module_info *) type_pointer;
 }
 
+
+static int interpreter_counter = 0; // how many (sub-)interpreters are using swig_module's types
+
 SWIGRUNTIME void
 SWIG_Python_DestroyModule(PyObject *obj)
 {
   swig_module_info *swig_module = (swig_module_info *) PyCapsule_GetPointer(obj, SWIGPY_CAPSULE_NAME);
   swig_type_info **types = swig_module->types;
   size_t i;
+  if (--interpreter_counter != 0) // another sub-interpreter may still be using the swig_module's types
+    return;
   for (i =0; i < swig_module->size; ++i) {
     swig_type_info *ty = types[i];
     if (ty->owndata) {
       SwigPyClientData *data = (SwigPyClientData *) ty->clientdata;
+      ty->clientdata = 0;
       if (data) SwigPyClientData_Del(data);
     }
   }
   Py_DECREF(SWIG_This());
   Swig_This_global = NULL;
+  Py_DECREF(SWIG_globals());
+  Swig_Globals_global = NULL;
+  Py_DECREF(SWIG_Python_TypeCache());
+  Swig_TypeCache_global = NULL;
+  Swig_Capsule_global = NULL;
 }
 
 SWIGRUNTIME void
 SWIG_Python_SetModule(swig_module_info *swig_module) {
 #if PY_VERSION_HEX >= 0x03000000
  /* Add a dummy module object into sys.modules */
   PyObject *module = PyImport_AddModule("swig_runtime_data" SWIG_RUNTIME_VERSION);
 #else
   static PyMethodDef swig_empty_runtime_method_table[] = { {NULL, NULL, 0, NULL} }; /* Sentinel */
   PyObject *module = Py_InitModule("swig_runtime_data" SWIG_RUNTIME_VERSION, swig_empty_runtime_method_table);
 #endif
   PyObject *pointer = PyCapsule_New((void *) swig_module, SWIGPY_CAPSULE_NAME, SWIG_Python_DestroyModule);
   if (pointer && module) {
-    PyModule_AddObject(module, "type_pointer_capsule" SWIG_TYPE_TABLE_NAME, pointer);
+    if (PyModule_AddObject(module, SWIGPY_CAPSULE_ATTR_NAME, pointer) == 0) {
+      ++interpreter_counter;
+      Swig_Capsule_global = pointer;
+    } else {
+      Py_DECREF(pointer);
+    }
   } else {
     Py_XDECREF(pointer);
   }
 }
 
-/* The python cached type query */
-SWIGRUNTIME PyObject *
-SWIG_Python_TypeCache(void) {
-  static PyObject *SWIG_STATIC_POINTER(cache) = PyDict_New();
-  return cache;
-}
-
 SWIGRUNTIME swig_type_info *
 SWIG_Python_TypeQuery(const char *type)
 {
   PyObject *cache = SWIG_Python_TypeCache();
   PyObject *key = SWIG_Python_str_FromChar(type); 
   PyObject *obj = PyDict_GetItem(cache, key);
   swig_type_info *descriptor;
   if (obj) {
     descriptor = (swig_type_info *) PyCapsule_GetPointer(obj, NULL);
   } else {
     swig_module_info *swig_module = SWIG_GetModule(0);
     descriptor = SWIG_TypeQueryModule(swig_module, swig_module, type);
     if (descriptor) {
       obj = PyCapsule_New((void*) descriptor, NULL, NULL);
-      PyDict_SetItem(cache, key, obj);
-      Py_DECREF(obj);
+      if (obj) {
+        PyDict_SetItem(cache, key, obj);
+        Py_DECREF(obj);
+      }
     }
   }
   Py_DECREF(key);
   return descriptor;
 }
 
 /* 
@@ -2493,15 +2830,14 @@
       Py_XINCREF(type);
       PyErr_Clear();
       if (infront) {
 	PyErr_Format(type, "%s %s", mesg, errmesg);
       } else {
 	PyErr_Format(type, "%s %s", errmesg, mesg);
       }
-      SWIG_Python_str_DelForPy3(tmp);
       Py_DECREF(old_str);
     }
     return 1;
   } else {
     return 0;
   }
 }
@@ -2545,15 +2881,14 @@
       const char *otype = (obj ? obj->ob_type->tp_name : 0); 
       if (otype) {
 	PyObject *str = PyObject_Str(obj);
 	const char *cstr = str ? SWIG_Python_str_AsChar(str) : 0;
 	if (cstr) {
 	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s(%s)' is received",
 		       type, otype, cstr);
-          SWIG_Python_str_DelForPy3(cstr);
 	} else {
 	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s' is received",
 		       type, otype);
 	}
 	Py_XDECREF(str);
 	return;
       }
@@ -2567,20 +2902,14 @@
 
 /* Convert a pointer value, signal an exception on a type mismatch */
 SWIGRUNTIME void *
 SWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int SWIGUNUSEDPARM(argnum), int flags) {
   void *result;
   if (SWIG_Python_ConvertPtr(obj, &result, ty, flags) == -1) {
     PyErr_Clear();
-#if SWIG_POINTER_EXCEPTION
-    if (flags) {
-      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);
-      SWIG_Python_ArgFail(argnum);
-    }
-#endif
   }
   return result;
 }
 
 #ifdef SWIGPYTHON_BUILTIN
 SWIGRUNTIME int
 SWIG_Python_NonDynamicSetAttr(PyObject *obj, PyObject *name, PyObject *value) {
@@ -2603,30 +2932,30 @@
     PyErr_Format(PyExc_TypeError, "attribute name must be string, not '%.200s'", name->ob_type->tp_name);
     return -1;
   } else {
     Py_INCREF(name);
   }
 
   if (!tp->tp_dict) {
-    if (PyType_Ready(tp) < 0)
+    if (PyType_Ready(tp) != 0)
       goto done;
   }
 
   descr = _PyType_Lookup(tp, name);
   f = NULL;
   if (descr != NULL)
     f = descr->ob_type->tp_descr_set;
   if (!f) {
     if (PyString_Check(name)) {
       encoded_name = name;
       Py_INCREF(name);
     } else {
       encoded_name = PyUnicode_AsUTF8String(name);
       if (!encoded_name)
-        return -1;
+        goto done;
     }
     PyErr_Format(PyExc_AttributeError, "'%.100s' object has no attribute '%.200s'", tp->tp_name, PyString_AsString(encoded_name));
     Py_DECREF(encoded_name);
   } else {
     res = f(descr, obj, value);
   }
   
@@ -2645,15 +2974,19 @@
 extern "C" {
 #endif
 
 SWIGINTERN Py_hash_t
 SwigPyObject_hash(PyObject *obj) {
   SwigPyObject *sobj = (SwigPyObject *)obj;
   void *ptr = sobj->ptr;
+#if PY_VERSION_HEX < 0x03020000
+  return (Py_hash_t)(Py_ssize_t)ptr;
+#else
   return (Py_hash_t)ptr;
+#endif
 }
 
 SWIGINTERN Py_hash_t
 SWIG_PyNumber_AsPyHash(PyObject *obj) {
   Py_hash_t result = -1;
 #if PY_VERSION_HEX < 0x03020000
   if (PyInt_Check(obj))
@@ -2850,15 +3183,19 @@
       PyObject_HEAD_INIT(&PyType_Type)
       0,                                        /* ob_size */
 #endif
       "swig_static_var_getset_descriptor",      /* tp_name */
       sizeof(PyGetSetDescrObject),              /* tp_basicsize */
       0,                                        /* tp_itemsize */
       (destructor)SwigPyStaticVar_dealloc,      /* tp_dealloc */
-      0,                                        /* tp_print */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                             /* tp_print */
+#else
+      (Py_ssize_t)0,                            /* tp_vectorcall_offset */
+#endif
       0,                                        /* tp_getattr */
       0,                                        /* tp_setattr */
       0,                                        /* tp_compare */
       (reprfunc)SwigPyStaticVar_repr,           /* tp_repr */
       0,                                        /* tp_as_number */
       0,                                        /* tp_as_sequence */
       0,                                        /* tp_as_mapping */
@@ -2934,15 +3271,19 @@
       PyObject_HEAD_INIT(&PyType_Type)
       0,                                        /* ob_size */
 #endif
       "SwigPyObjectType",                       /* tp_name */
       PyType_Type.tp_basicsize,                 /* tp_basicsize */
       0,                                        /* tp_itemsize */
       0,                                        /* tp_dealloc */
-      0,                                        /* tp_print */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                             /* tp_print */
+#else
+      (Py_ssize_t)0,                            /* tp_vectorcall_offset */
+#endif
       0,                                        /* tp_getattr */
       0,                                        /* tp_setattr */
       0,                                        /* tp_compare */
       0,                                        /* tp_repr */
       0,                                        /* tp_as_number */
       0,                                        /* tp_as_sequence */
       0,                                        /* tp_as_mapping */
@@ -3053,18 +3394,18 @@
   Py_XINCREF(result);
   return result;
 }
 
 SWIGINTERN void
 SwigPyBuiltin_SetMetaType (PyTypeObject *type, PyTypeObject *metatype)
 {
-#if PY_VERSION_HEX >= 0x03000000
-    type->ob_base.ob_base.ob_type = metatype;
+#if PY_VERSION_HEX >= 0x030900a4
+    Py_SET_TYPE(type, metatype);
 #else
-    type->ob_type = metatype;
+    Py_TYPE(type) = metatype;
 #endif
 }
 
 
 /* Start of callback function macros for use in PyTypeObject */
 
 typedef PyObject *(*SwigPyWrapperFunction)(PyObject *, PyObject *);
@@ -3394,31 +3735,16 @@
 #endif
 
 
 
 
 #define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 
 
-#define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 
-
-
+#define SWIG_contract_assert(expr, msg) do { if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } } while (0) 
 
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* Method creation and docstring support functions */
-
-SWIGINTERN PyMethodDef *SWIG_PythonGetProxyDoc(const char *name);
-SWIGINTERN PyObject *SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func);
-SWIGINTERN PyObject *SWIG_PyStaticMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func);
-
-#ifdef __cplusplus
-}
-#endif
 
 
 /* -------- TYPES TABLE (BEGIN) -------- */
 
 #define SWIGTYPE_p_CameraAbilities swig_types[0]
 #define SWIGTYPE_p_CameraCaptureType swig_types[1]
 #define SWIGTYPE_p_CameraDriverStatus swig_types[2]
@@ -3493,18 +3819,14 @@
 
 #else
 #  define SWIG_init    init_version
 
 #endif
 #define SWIG_name    "_version"
 
-#define SWIGVERSION 0x040002 
-#define SWIG_VERSION SWIGVERSION
-
-
 #define SWIG_as_voidptr(a) (void *)((const void *)(a)) 
 #define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),(void**)(a)) 
 
 
 #include <stddef.h>
 
 
@@ -3681,14 +4003,15 @@
   PyObject *resultobj = 0;
   GPVersionVerbosity arg1 ;
   int val1 ;
   int ecode1 = 0 ;
   PyObject * obj0 = 0 ;
   char **result = 0 ;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_port_library_version", 1, 1, &obj0)) SWIG_fail;
   ecode1 = SWIG_AsVal_int(obj0, &val1);
   if (!SWIG_IsOK(ecode1)) {
     SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "gp_port_library_version" "', argument " "1"" of type '" "GPVersionVerbosity""'");
   } 
   arg1 = (GPVersionVerbosity)(val1);
   result = (char **)gp_port_library_version(arg1);
@@ -3713,14 +4036,15 @@
   PyObject *resultobj = 0;
   GPVersionVerbosity arg1 ;
   int val1 ;
   int ecode1 = 0 ;
   PyObject * obj0 = 0 ;
   char **result = 0 ;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_library_version", 1, 1, &obj0)) SWIG_fail;
   ecode1 = SWIG_AsVal_int(obj0, &val1);
   if (!SWIG_IsOK(ecode1)) {
     SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "gp_library_version" "', argument " "1"" of type '" "GPVersionVerbosity""'");
   } 
   arg1 = (GPVersionVerbosity)(val1);
   result = (char **)gp_library_version(arg1);
@@ -3738,38 +4062,14 @@
   return resultobj;
 fail:
   return NULL;
 }
 
 
 static PyMethodDef SwigMethods[] = {
-	 { "SWIG_PyInstanceMethod_New", SWIG_PyInstanceMethod_New, METH_O, NULL},
-	 { "SWIG_PyStaticMethod_New", SWIG_PyStaticMethod_New, METH_O, NULL},
-	 { "gp_port_library_version", _wrap_gp_port_library_version, METH_VARARGS, "\n"
-		"gp_port_library_version(verbose) -> char const **\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"verbose: GPVersionVerbosity (gphoto2.GP_VERSION_SHORT etc.)\n"
-		"\n"
-		""},
-	 { "gp_library_version", _wrap_gp_library_version, METH_VARARGS, "\n"
-		"gp_library_version(verbose) -> char const **\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"verbose: GPVersionVerbosity (gphoto2.GP_VERSION_SHORT etc.)\n"
-		"\n"
-		""},
-	 { NULL, NULL, 0, NULL }
-};
-
-static PyMethodDef SwigMethods_proxydocs[] = {
-	 { "SWIG_PyInstanceMethod_New", SWIG_PyInstanceMethod_New, METH_O, NULL},
-	 { "SWIG_PyStaticMethod_New", SWIG_PyStaticMethod_New, METH_O, NULL},
 	 { "gp_port_library_version", _wrap_gp_port_library_version, METH_VARARGS, "\n"
 		"gp_port_library_version(verbose) -> char const **\n"
 		"\n"
 		"Parameters\n"
 		"----------\n"
 		"verbose: GPVersionVerbosity (gphoto2.GP_VERSION_SHORT etc.)\n"
 		"\n"
@@ -3785,67 +4085,67 @@
 	 { NULL, NULL, 0, NULL }
 };
 
 
 /* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */
 
 static swig_type_info _swigt__p_CameraAbilities = {"_p_CameraAbilities", "CameraAbilities *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraCaptureType = {"_p_CameraCaptureType", "enum CameraCaptureType *|CameraCaptureType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraDriverStatus = {"_p_CameraDriverStatus", "enum CameraDriverStatus *|CameraDriverStatus *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraEventType = {"_p_CameraEventType", "enum CameraEventType *|CameraEventType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileAccessType = {"_p_CameraFileAccessType", "enum CameraFileAccessType *|CameraFileAccessType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileInfoFields = {"_p_CameraFileInfoFields", "enum CameraFileInfoFields *|CameraFileInfoFields *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileOperation = {"_p_CameraFileOperation", "enum CameraFileOperation *|CameraFileOperation *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraCaptureType = {"_p_CameraCaptureType", "CameraCaptureType *|enum CameraCaptureType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraDriverStatus = {"_p_CameraDriverStatus", "CameraDriverStatus *|enum CameraDriverStatus *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraEventType = {"_p_CameraEventType", "CameraEventType *|enum CameraEventType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileAccessType = {"_p_CameraFileAccessType", "CameraFileAccessType *|enum CameraFileAccessType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileInfoFields = {"_p_CameraFileInfoFields", "CameraFileInfoFields *|enum CameraFileInfoFields *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileOperation = {"_p_CameraFileOperation", "CameraFileOperation *|enum CameraFileOperation *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_CameraFilePath = {"_p_CameraFilePath", "CameraFilePath *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFilePermissions = {"_p_CameraFilePermissions", "enum CameraFilePermissions *|CameraFilePermissions *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileStatus = {"_p_CameraFileStatus", "enum CameraFileStatus *|CameraFileStatus *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileType = {"_p_CameraFileType", "enum CameraFileType *|CameraFileType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFolderOperation = {"_p_CameraFolderOperation", "enum CameraFolderOperation *|CameraFolderOperation *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraOperation = {"_p_CameraOperation", "enum CameraOperation *|CameraOperation *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraStorageAccessType = {"_p_CameraStorageAccessType", "enum CameraStorageAccessType *|CameraStorageAccessType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraStorageFilesystemType = {"_p_CameraStorageFilesystemType", "enum CameraStorageFilesystemType *|CameraStorageFilesystemType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraStorageInfoFields = {"_p_CameraStorageInfoFields", "enum CameraStorageInfoFields *|CameraStorageInfoFields *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraStorageType = {"_p_CameraStorageType", "enum CameraStorageType *|CameraStorageType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFilePermissions = {"_p_CameraFilePermissions", "CameraFilePermissions *|enum CameraFilePermissions *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileStatus = {"_p_CameraFileStatus", "CameraFileStatus *|enum CameraFileStatus *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileType = {"_p_CameraFileType", "CameraFileType *|enum CameraFileType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFolderOperation = {"_p_CameraFolderOperation", "CameraFolderOperation *|enum CameraFolderOperation *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraOperation = {"_p_CameraOperation", "CameraOperation *|enum CameraOperation *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraStorageAccessType = {"_p_CameraStorageAccessType", "CameraStorageAccessType *|enum CameraStorageAccessType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraStorageFilesystemType = {"_p_CameraStorageFilesystemType", "CameraStorageFilesystemType *|enum CameraStorageFilesystemType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraStorageInfoFields = {"_p_CameraStorageInfoFields", "CameraStorageInfoFields *|enum CameraStorageInfoFields *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraStorageType = {"_p_CameraStorageType", "CameraStorageType *|enum CameraStorageType *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_CameraText = {"_p_CameraText", "CameraText *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraWidgetType = {"_p_CameraWidgetType", "enum CameraWidgetType *|CameraWidgetType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_GPLogLevel = {"_p_GPLogLevel", "enum GPLogLevel *|GPLogLevel *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_GPPortType = {"_p_GPPortType", "enum GPPortType *|GPPortType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_GPVersionVerbosity = {"_p_GPVersionVerbosity", "enum GPVersionVerbosity *|GPVersionVerbosity *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_GphotoDeviceType = {"_p_GphotoDeviceType", "enum GphotoDeviceType *|GphotoDeviceType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraWidgetType = {"_p_CameraWidgetType", "CameraWidgetType *|enum CameraWidgetType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GPLogLevel = {"_p_GPLogLevel", "GPLogLevel *|enum GPLogLevel *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GPPortType = {"_p_GPPortType", "GPPortType *|enum GPPortType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GPVersionVerbosity = {"_p_GPVersionVerbosity", "GPVersionVerbosity *|enum GPVersionVerbosity *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GphotoDeviceType = {"_p_GphotoDeviceType", "GphotoDeviceType *|enum GphotoDeviceType *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_SwigPyObject = {"_p_SwigPyObject", "SwigPyObject *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__Camera = {"_p__Camera", "struct _Camera *|Camera *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraAbilitiesList = {"_p__CameraAbilitiesList", "struct _CameraAbilitiesList *|CameraAbilitiesList *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFile = {"_p__CameraFile", "struct _CameraFile *|CameraFile *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFileHandler = {"_p__CameraFileHandler", "struct _CameraFileHandler *|CameraFileHandler *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFileInfo = {"_p__CameraFileInfo", "struct _CameraFileInfo *|CameraFileInfo *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFileInfoAudio = {"_p__CameraFileInfoAudio", "struct _CameraFileInfoAudio *|CameraFileInfoAudio *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFileInfoFile = {"_p__CameraFileInfoFile", "struct _CameraFileInfoFile *|CameraFileInfoFile *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFileInfoPreview = {"_p__CameraFileInfoPreview", "struct _CameraFileInfoPreview *|CameraFileInfoPreview *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFilesystem = {"_p__CameraFilesystem", "struct _CameraFilesystem *|CameraFilesystem *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFilesystemFuncs = {"_p__CameraFilesystemFuncs", "struct _CameraFilesystemFuncs *|CameraFilesystemFuncs *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFunctions = {"_p__CameraFunctions", "struct _CameraFunctions *|CameraFunctions *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraList = {"_p__CameraList", "struct _CameraList *|CameraList *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraPrivateCore = {"_p__CameraPrivateCore", "struct _CameraPrivateCore *|CameraPrivateCore *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraPrivateLibrary = {"_p__CameraPrivateLibrary", "struct _CameraPrivateLibrary *|CameraPrivateLibrary *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraStorageInformation = {"_p__CameraStorageInformation", "struct _CameraStorageInformation *|CameraStorageInformation *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraWidget = {"_p__CameraWidget", "struct _CameraWidget *|CameraWidget *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__GPContext = {"_p__GPContext", "struct _GPContext *|GPContext *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__GPContextFeedback = {"_p__GPContextFeedback", "enum _GPContextFeedback *|GPContextFeedback *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__Camera = {"_p__Camera", "Camera *|struct _Camera *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraAbilitiesList = {"_p__CameraAbilitiesList", "CameraAbilitiesList *|struct _CameraAbilitiesList *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFile = {"_p__CameraFile", "CameraFile *|struct _CameraFile *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFileHandler = {"_p__CameraFileHandler", "CameraFileHandler *|struct _CameraFileHandler *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFileInfo = {"_p__CameraFileInfo", "CameraFileInfo *|struct _CameraFileInfo *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFileInfoAudio = {"_p__CameraFileInfoAudio", "CameraFileInfoAudio *|struct _CameraFileInfoAudio *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFileInfoFile = {"_p__CameraFileInfoFile", "CameraFileInfoFile *|struct _CameraFileInfoFile *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFileInfoPreview = {"_p__CameraFileInfoPreview", "CameraFileInfoPreview *|struct _CameraFileInfoPreview *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFilesystem = {"_p__CameraFilesystem", "CameraFilesystem *|struct _CameraFilesystem *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFilesystemFuncs = {"_p__CameraFilesystemFuncs", "CameraFilesystemFuncs *|struct _CameraFilesystemFuncs *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFunctions = {"_p__CameraFunctions", "CameraFunctions *|struct _CameraFunctions *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraList = {"_p__CameraList", "CameraList *|struct _CameraList *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraPrivateCore = {"_p__CameraPrivateCore", "CameraPrivateCore *|struct _CameraPrivateCore *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraPrivateLibrary = {"_p__CameraPrivateLibrary", "CameraPrivateLibrary *|struct _CameraPrivateLibrary *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraStorageInformation = {"_p__CameraStorageInformation", "CameraStorageInformation *|struct _CameraStorageInformation *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraWidget = {"_p__CameraWidget", "CameraWidget *|struct _CameraWidget *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__GPContext = {"_p__GPContext", "GPContext *|struct _GPContext *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__GPContextFeedback = {"_p__GPContextFeedback", "GPContextFeedback *|enum _GPContextFeedback *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p__GPPortInfo = {"_p__GPPortInfo", "_GPPortInfo *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__GPPortInfoList = {"_p__GPPortInfoList", "struct _GPPortInfoList *|GPPortInfoList *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__GPPortInfoList = {"_p__GPPortInfoList", "GPPortInfoList *|struct _GPPortInfoList *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_int = {"_p_int", "intptr_t *|int *|int_least32_t *|int_fast32_t *|int32_t *|int_fast16_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_long = {"_p_long", "long *|time_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_long_long = {"_p_long_long", "int_least64_t *|int_fast64_t *|int64_t *|long long *|intmax_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_short = {"_p_short", "short *|int_least16_t *|int16_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_signed_char = {"_p_signed_char", "signed char *|int_least8_t *|int_fast8_t *|int8_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_unsigned_char = {"_p_unsigned_char", "unsigned char *|uint_least8_t *|uint_fast8_t *|uint8_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_unsigned_int = {"_p_unsigned_int", "uintptr_t *|uint_least32_t *|uint_fast32_t *|uint32_t *|unsigned int *|uint_fast16_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_unsigned_long_long = {"_p_unsigned_long_long", "uint_least64_t *|uint_fast64_t *|uint64_t *|unsigned long long *|uintmax_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_unsigned_short = {"_p_unsigned_short", "unsigned short *|uint_least16_t *|uint16_t *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_int = {"_p_int", "int32_t *|int_fast16_t *|int_fast32_t *|int_least32_t *|intptr_t *|int *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_long = {"_p_long", "time_t *|long *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_long_long = {"_p_long_long", "int64_t *|int_fast64_t *|int_least64_t *|intmax_t *|long long *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_short = {"_p_short", "int16_t *|int_least16_t *|short *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_signed_char = {"_p_signed_char", "int8_t *|int_fast8_t *|int_least8_t *|signed char *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_unsigned_char = {"_p_unsigned_char", "uint8_t *|uint_fast8_t *|uint_least8_t *|unsigned char *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_unsigned_int = {"_p_unsigned_int", "uint32_t *|uint_fast16_t *|uint_fast32_t *|uint_least32_t *|uintptr_t *|unsigned int *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_unsigned_long_long = {"_p_unsigned_long_long", "uint64_t *|uint_fast64_t *|uint_least64_t *|uintmax_t *|unsigned long long *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_unsigned_short = {"_p_unsigned_short", "uint16_t *|uint_least16_t *|unsigned short *", 0, 0, (void*)0, 0};
 
 static swig_type_info *swig_type_initial[] = {
   &_swigt__p_CameraAbilities,
   &_swigt__p_CameraCaptureType,
   &_swigt__p_CameraDriverStatus,
   &_swigt__p_CameraEventType,
   &_swigt__p_CameraFileAccessType,
@@ -4069,17 +4369,20 @@
 #endif
 #endif
 
 #if 0
 #define SWIGRUNTIME_DEBUG
 #endif
 
+#ifndef SWIG_INIT_CLIENT_DATA_TYPE
+#define SWIG_INIT_CLIENT_DATA_TYPE void *
+#endif
 
 SWIGRUNTIME void
-SWIG_InitializeModule(void *clientdata) {
+SWIG_InitializeModule(SWIG_INIT_CLIENT_DATA_TYPE clientdata) {
   size_t i;
   swig_module_info *module_head, *iter;
   int init;
   
   /* check to see if the circular list has been setup, if not, set it up */
   if (swig_module.next==0) {
     /* Initialize the swig_module */
@@ -4254,228 +4557,14 @@
 
 
 
 #ifdef __cplusplus
 extern "C" {
 #endif
   
-  /* Python-specific SWIG API */
-#define SWIG_newvarlink()                             SWIG_Python_newvarlink()
-#define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
-#define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)
-  
-  /* -----------------------------------------------------------------------------
-   * global variable support code.
-   * ----------------------------------------------------------------------------- */
-  
-  typedef struct swig_globalvar {
-    char       *name;                  /* Name of global variable */
-    PyObject *(*get_attr)(void);       /* Return the current value */
-    int       (*set_attr)(PyObject *); /* Set the value */
-    struct swig_globalvar *next;
-  } swig_globalvar;
-  
-  typedef struct swig_varlinkobject {
-    PyObject_HEAD
-    swig_globalvar *vars;
-  } swig_varlinkobject;
-  
-  SWIGINTERN PyObject *
-  swig_varlink_repr(swig_varlinkobject *SWIGUNUSEDPARM(v)) {
-#if PY_VERSION_HEX >= 0x03000000
-    return PyUnicode_InternFromString("<Swig global variables>");
-#else
-    return PyString_FromString("<Swig global variables>");
-#endif
-  }
-  
-  SWIGINTERN PyObject *
-  swig_varlink_str(swig_varlinkobject *v) {
-#if PY_VERSION_HEX >= 0x03000000
-    PyObject *str = PyUnicode_InternFromString("(");
-    PyObject *tail;
-    PyObject *joined;
-    swig_globalvar *var;
-    for (var = v->vars; var; var=var->next) {
-      tail = PyUnicode_FromString(var->name);
-      joined = PyUnicode_Concat(str, tail);
-      Py_DecRef(str);
-      Py_DecRef(tail);
-      str = joined;
-      if (var->next) {
-        tail = PyUnicode_InternFromString(", ");
-        joined = PyUnicode_Concat(str, tail);
-        Py_DecRef(str);
-        Py_DecRef(tail);
-        str = joined;
-      }
-    }
-    tail = PyUnicode_InternFromString(")");
-    joined = PyUnicode_Concat(str, tail);
-    Py_DecRef(str);
-    Py_DecRef(tail);
-    str = joined;
-#else
-    PyObject *str = PyString_FromString("(");
-    swig_globalvar *var;
-    for (var = v->vars; var; var=var->next) {
-      PyString_ConcatAndDel(&str,PyString_FromString(var->name));
-      if (var->next) PyString_ConcatAndDel(&str,PyString_FromString(", "));
-    }
-    PyString_ConcatAndDel(&str,PyString_FromString(")"));
-#endif
-    return str;
-  }
-  
-  SWIGINTERN void
-  swig_varlink_dealloc(swig_varlinkobject *v) {
-    swig_globalvar *var = v->vars;
-    while (var) {
-      swig_globalvar *n = var->next;
-      free(var->name);
-      free(var);
-      var = n;
-    }
-  }
-  
-  SWIGINTERN PyObject *
-  swig_varlink_getattr(swig_varlinkobject *v, char *n) {
-    PyObject *res = NULL;
-    swig_globalvar *var = v->vars;
-    while (var) {
-      if (strcmp(var->name,n) == 0) {
-        res = (*var->get_attr)();
-        break;
-      }
-      var = var->next;
-    }
-    if (res == NULL && !PyErr_Occurred()) {
-      PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
-    }
-    return res;
-  }
-  
-  SWIGINTERN int
-  swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
-    int res = 1;
-    swig_globalvar *var = v->vars;
-    while (var) {
-      if (strcmp(var->name,n) == 0) {
-        res = (*var->set_attr)(p);
-        break;
-      }
-      var = var->next;
-    }
-    if (res == 1 && !PyErr_Occurred()) {
-      PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
-    }
-    return res;
-  }
-  
-  SWIGINTERN PyTypeObject*
-  swig_varlink_type(void) {
-    static char varlink__doc__[] = "Swig var link object";
-    static PyTypeObject varlink_type;
-    static int type_init = 0;
-    if (!type_init) {
-      const PyTypeObject tmp = {
-#if PY_VERSION_HEX >= 0x03000000
-        PyVarObject_HEAD_INIT(NULL, 0)
-#else
-        PyObject_HEAD_INIT(NULL)
-        0,                                  /* ob_size */
-#endif
-        "swigvarlink",                      /* tp_name */
-        sizeof(swig_varlinkobject),         /* tp_basicsize */
-        0,                                  /* tp_itemsize */
-        (destructor) swig_varlink_dealloc,  /* tp_dealloc */
-        0,                                  /* tp_print */
-        (getattrfunc) swig_varlink_getattr, /* tp_getattr */
-        (setattrfunc) swig_varlink_setattr, /* tp_setattr */
-        0,                                  /* tp_compare */
-        (reprfunc) swig_varlink_repr,       /* tp_repr */
-        0,                                  /* tp_as_number */
-        0,                                  /* tp_as_sequence */
-        0,                                  /* tp_as_mapping */
-        0,                                  /* tp_hash */
-        0,                                  /* tp_call */
-        (reprfunc) swig_varlink_str,        /* tp_str */
-        0,                                  /* tp_getattro */
-        0,                                  /* tp_setattro */
-        0,                                  /* tp_as_buffer */
-        0,                                  /* tp_flags */
-        varlink__doc__,                     /* tp_doc */
-        0,                                  /* tp_traverse */
-        0,                                  /* tp_clear */
-        0,                                  /* tp_richcompare */
-        0,                                  /* tp_weaklistoffset */
-        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
-        0,                                  /* tp_del */
-        0,                                  /* tp_version_tag */
-#if PY_VERSION_HEX >= 0x03040000
-        0,                                  /* tp_finalize */
-#endif
-#if PY_VERSION_HEX >= 0x03080000
-        0,                                  /* tp_vectorcall */
-#endif
-#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
-        0,                                  /* tp_print */
-#endif
-#ifdef COUNT_ALLOCS
-        0,                                  /* tp_allocs */
-        0,                                  /* tp_frees */
-        0,                                  /* tp_maxalloc */
-        0,                                  /* tp_prev */
-        0                                   /* tp_next */
-#endif
-      };
-      varlink_type = tmp;
-      type_init = 1;
-      if (PyType_Ready(&varlink_type) < 0)
-      return NULL;
-    }
-    return &varlink_type;
-  }
-  
-  /* Create a variable linking object for use later */
-  SWIGINTERN PyObject *
-  SWIG_Python_newvarlink(void) {
-    swig_varlinkobject *result = PyObject_NEW(swig_varlinkobject, swig_varlink_type());
-    if (result) {
-      result->vars = 0;
-    }
-    return ((PyObject*) result);
-  }
-  
-  SWIGINTERN void 
-  SWIG_Python_addvarlink(PyObject *p, const char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
-    swig_varlinkobject *v = (swig_varlinkobject *) p;
-    swig_globalvar *gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
-    if (gv) {
-      size_t size = strlen(name)+1;
-      gv->name = (char *)malloc(size);
-      if (gv->name) {
-        memcpy(gv->name, name, size);
-        gv->get_attr = get_attr;
-        gv->set_attr = set_attr;
-        gv->next = v->vars;
-      }
-    }
-    v->vars = gv;
-  }
-  
-  SWIGINTERN PyObject *
-  SWIG_globals(void) {
-    static PyObject *globals = 0;
-    if (!globals) {
-      globals = SWIG_newvarlink();
-    }
-    return globals;
-  }
-  
   /* -----------------------------------------------------------------------------
    * constants/methods manipulation
    * ----------------------------------------------------------------------------- */
   
   /* Install Constants */
   SWIGINTERN void
   SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
@@ -4496,31 +4585,28 @@
       if (obj) {
         PyDict_SetItemString(d, constants[i].name, obj);
         Py_DECREF(obj);
       }
     }
   }
   
-  /* -----------------------------------------------------------------------------*/
-  /* Fix SwigMethods to carry the callback ptrs when needed */
-  /* -----------------------------------------------------------------------------*/
+  /* -----------------------------------------------------------------------------
+   * Patch %callback methods' docstrings to hold the callback ptrs
+   * -----------------------------------------------------------------------------*/
   
   SWIGINTERN void
-  SWIG_Python_FixMethods(PyMethodDef *methods,
-    swig_const_info *const_table,
-    swig_type_info **types,
-    swig_type_info **types_initial) {
+  SWIG_Python_FixMethods(PyMethodDef *methods, const swig_const_info *const_table, swig_type_info **types, swig_type_info **types_initial) {
     size_t i;
     for (i = 0; methods[i].ml_name; ++i) {
       const char *c = methods[i].ml_doc;
       if (!c) continue;
       c = strstr(c, "swig_ptr: ");
       if (c) {
         int j;
-        swig_const_info *ci = 0;
+        const swig_const_info *ci = 0;
         const char *name = c + 10;
         for (j = 0; const_table[j].type; ++j) {
           if (strncmp(const_table[j].name, name, 
               strlen(const_table[j].name)) == 0) {
             ci = &(const_table[j]);
             break;
           }
@@ -4544,76 +4630,21 @@
             }
           }
         }
       }
     }
   } 
   
-  /* -----------------------------------------------------------------------------
-   * Method creation and docstring support functions
-   * ----------------------------------------------------------------------------- */
-  
-  /* -----------------------------------------------------------------------------
-   * Function to find the method definition with the correct docstring for the
-   * proxy module as opposed to the low-level API
-   * ----------------------------------------------------------------------------- */
-  
-  SWIGINTERN PyMethodDef *SWIG_PythonGetProxyDoc(const char *name) {
-    /* Find the function in the modified method table */
-    size_t offset = 0;
-    int found = 0;
-    while (SwigMethods_proxydocs[offset].ml_meth != NULL) {
-      if (strcmp(SwigMethods_proxydocs[offset].ml_name, name) == 0) {
-        found = 1;
-        break;
-      }
-      offset++;
-    }
-    /* Use the copy with the modified docstring if available */
-    return found ? &SwigMethods_proxydocs[offset] : NULL;
-  }
-  
-  /* -----------------------------------------------------------------------------
-   * Wrapper of PyInstanceMethod_New() used in Python 3
-   * It is exported to the generated module, used for -fastproxy
-   * ----------------------------------------------------------------------------- */
-  
-  SWIGINTERN PyObject *SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func) {
-    if (PyCFunction_Check(func)) {
-      PyCFunctionObject *funcobj = (PyCFunctionObject *)func;
-      PyMethodDef *ml = SWIG_PythonGetProxyDoc(funcobj->m_ml->ml_name);
-      if (ml)
-      func = PyCFunction_NewEx(ml, funcobj->m_self, funcobj->m_module);
-    }
-#if PY_VERSION_HEX >= 0x03000000
-    return PyInstanceMethod_New(func);
-#else
-    return PyMethod_New(func, NULL, NULL);
-#endif
-  }
-  
-  /* -----------------------------------------------------------------------------
-   * Wrapper of PyStaticMethod_New()
-   * It is exported to the generated module, used for -fastproxy
-   * ----------------------------------------------------------------------------- */
-  
-  SWIGINTERN PyObject *SWIG_PyStaticMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func) {
-    if (PyCFunction_Check(func)) {
-      PyCFunctionObject *funcobj = (PyCFunctionObject *)func;
-      PyMethodDef *ml = SWIG_PythonGetProxyDoc(funcobj->m_ml->ml_name);
-      if (ml)
-      func = PyCFunction_NewEx(ml, funcobj->m_self, funcobj->m_module);
-    }
-    return PyStaticMethod_New(func);
-  }
-  
 #ifdef __cplusplus
 }
 #endif
 
+
+
+
 /* -----------------------------------------------------------------------------*
  *  Partial Init method
  * -----------------------------------------------------------------------------*/
 
 #ifdef __cplusplus
 extern "C"
 #endif
```

### Comparing `gphoto2-2.3.4/src/swig-gp2.5.30/widget_wrap.c` & `gphoto2-2.3.5/src/swig-gp2_5_30/widget_wrap.c`

 * *Files 3% similar despite different names*

```diff
@@ -1,24 +1,21 @@
 /* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 4.0.2
+ * This file was automatically generated by SWIG (https://www.swig.org).
+ * Version 4.1.1
  *
- * This file is not intended to be easily readable and contains a number of
- * coding conventions designed to improve portability and efficiency. Do not make
- * changes to this file unless you know what you are doing--modify the SWIG
- * interface file instead.
+ * Do not make changes to this file unless you know what you are doing - modify
+ * the SWIG interface file instead.
  * ----------------------------------------------------------------------------- */
 
 
-#ifndef SWIGPYTHON
+#define SWIG_VERSION 0x040101
 #define SWIGPYTHON
-#endif
-
 #define SWIG_PYTHON_DIRECTOR_NO_VTABLE
 #define SWIGPYTHON_BUILTIN
+#define SWIGPYTHON_FASTPROXY
 
 /* -----------------------------------------------------------------------------
  *  This section contains generic SWIG labels for method/variable
  *  declarations/attributes, and other compiler dependent labels.
  * ----------------------------------------------------------------------------- */
 
 /* template workaround for compilers that cannot correctly implement the C++ standard */
@@ -142,23 +139,45 @@
 
 
 #if defined(__GNUC__) && defined(_WIN32) && !defined(SWIG_PYTHON_NO_HYPOT_WORKAROUND)
 /* Workaround for '::hypot' has not been declared', see https://bugs.python.org/issue11566 */
 # include <math.h>
 #endif
 
+#if !defined(PY_SSIZE_T_CLEAN) && !defined(SWIG_NO_PY_SSIZE_T_CLEAN)
+#define PY_SSIZE_T_CLEAN
+#endif
+
+#if __GNUC__ >= 7
+#pragma GCC diagnostic push
+#if defined(__cplusplus) && __cplusplus >=201703L
+#pragma GCC diagnostic ignored "-Wregister" /* For python-2.7 headers that use register */
+#endif
+#endif
+
 #if defined(_DEBUG) && defined(SWIG_PYTHON_INTERPRETER_NO_DEBUG)
 /* Use debug wrappers with the Python release dll */
+
+#if defined(_MSC_VER) && _MSC_VER >= 1929
+/* Workaround compilation errors when redefining _DEBUG in MSVC 2019 version 16.10 and later
+ * See https://github.com/swig/swig/issues/2090 */
+# include <corecrt.h>
+#endif
+
 # undef _DEBUG
 # include <Python.h>
 # define _DEBUG 1
 #else
 # include <Python.h>
 #endif
 
+#if __GNUC__ >= 7
+#pragma GCC diagnostic pop
+#endif
+
 /* -----------------------------------------------------------------------------
  * swigrun.swg
  *
  * This file contains generic C API SWIG runtime support for pointer
  * type checking.
  * ----------------------------------------------------------------------------- */
 
@@ -197,14 +216,16 @@
 # define SWIG_BUFFER_SIZE 1024
 #endif
 
 /* Flags for pointer conversions */
 #define SWIG_POINTER_DISOWN        0x1
 #define SWIG_CAST_NEW_MEMORY       0x2
 #define SWIG_POINTER_NO_NULL       0x4
+#define SWIG_POINTER_CLEAR         0x8
+#define SWIG_POINTER_RELEASE       (SWIG_POINTER_CLEAR | SWIG_POINTER_DISOWN)
 
 /* Flags for new pointer objects */
 #define SWIG_POINTER_OWN           0x1
 
 
 /*
    Flags/methods for returning states.
@@ -268,44 +289,50 @@
       }
 
    Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
    more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
    SWIG errors code.
 
    Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
-   allows to return the 'cast rank', for example, if you have this
+   allows returning the 'cast rank', for example, if you have this
 
        int food(double)
        int fooi(int);
 
    and you call
 
       food(1)   // cast rank '1'  (1 -> 1.0)
       fooi(1)   // cast rank '0'
 
    just use the SWIG_AddCast()/SWIG_CheckState()
 */
 
 #define SWIG_OK                    (0)
+/* Runtime errors are < 0 */
 #define SWIG_ERROR                 (-1)
+/* Errors in range -1 to -99 are in swigerrors.swg (errors for all languages including those not using the runtime) */
+/* Errors in range -100 to -199 are language specific errors defined in *errors.swg */
+/* Errors < -200 are generic runtime specific errors */
+#define SWIG_ERROR_RELEASE_NOT_OWNED (-200)
+
 #define SWIG_IsOK(r)               (r >= 0)
 #define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)
 
 /* The CastRankLimit says how many bits are used for the cast rank */
 #define SWIG_CASTRANKLIMIT         (1 << 8)
 /* The NewMask denotes the object was created (using new/malloc) */
 #define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
 /* The TmpMask is for in/out typemaps that use temporal objects */
 #define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
 /* Simple returning values */
 #define SWIG_BADOBJ                (SWIG_ERROR)
 #define SWIG_OLDOBJ                (SWIG_OK)
 #define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
 #define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
-/* Check, add and del mask methods */
+/* Check, add and del object mask methods */
 #define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
 #define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
 #define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
 #define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
 #define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
 #define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))
 
@@ -443,15 +470,15 @@
   return 0;
 }
 
 /*
   Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
 */
 SWIGRUNTIME swig_cast_info *
-SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty) {
+SWIG_TypeCheckStruct(const swig_type_info *from, swig_type_info *ty) {
   if (ty) {
     swig_cast_info *iter = ty->cast;
     while (iter) {
       if (iter->type == from) {
         if (iter == ty->cast)
           return iter;
         /* Move iter to the top of the linked list */
@@ -503,17 +530,17 @@
 /*
   Return the pretty name associated with this type,
   that is an unmangled type name in a form presentable to the user.
 */
 SWIGRUNTIME const char *
 SWIG_TypePrettyName(const swig_type_info *type) {
   /* The "str" field contains the equivalent pretty names of the
-     type, separated by vertical-bar characters.  We choose
-     to print the last name, as it is often (?) the most
-     specific. */
+     type, separated by vertical-bar characters.  Choose the last
+     name. It should be the most specific; a fully resolved name
+     but not necessarily with default template parameters expanded. */
   if (!type) return NULL;
   if (type->str != NULL) {
     const char *last_name = type->str;
     const char *s;
     for (s = type->str; *s; s++)
       if (*s == '|') last_name = s+1;
     return last_name;
@@ -725,15 +752,15 @@
   return SWIG_UnpackData(++c,ptr,sz);
 }
 
 #ifdef __cplusplus
 }
 #endif
 
-/*  Errors in SWIG */
+/* SWIG Errors applicable to all language modules, values are reserved from -1 to -99 */
 #define  SWIG_UnknownError    	   -1
 #define  SWIG_IOError        	   -2
 #define  SWIG_RuntimeError   	   -3
 #define  SWIG_IndexError     	   -4
 #define  SWIG_TypeError      	   -5
 #define  SWIG_DivisionByZero 	   -6
 #define  SWIG_OverflowError  	   -7
@@ -741,15 +768,14 @@
 #define  SWIG_ValueError     	   -9
 #define  SWIG_SystemError    	   -10
 #define  SWIG_AttributeError 	   -11
 #define  SWIG_MemoryError    	   -12
 #define  SWIG_NullReferenceError   -13
 
 
-
 /* Compatibility macros for Python 3 */
 #if PY_VERSION_HEX >= 0x03000000
 
 #define PyClass_Check(obj) PyObject_IsInstance(obj, (PyObject *)&PyType_Type)
 #define PyInt_Check(x) PyLong_Check(x)
 #define PyInt_AsLong(x) PyLong_AsLong(x)
 #define PyInt_FromLong(x) PyLong_FromLong(x)
@@ -757,15 +783,14 @@
 #define PyString_Check(name) PyBytes_Check(name)
 #define PyString_FromString(x) PyUnicode_FromString(x)
 #define PyString_Format(fmt, args)  PyUnicode_Format(fmt, args)
 #define PyString_AsString(str) PyBytes_AsString(str)
 #define PyString_Size(str) PyBytes_Size(str)	
 #define PyString_InternFromString(key) PyUnicode_InternFromString(key)
 #define Py_TPFLAGS_HAVE_CLASS Py_TPFLAGS_BASETYPE
-#define PyString_AS_STRING(x) PyUnicode_AS_STRING(x)
 #define _PyLong_FromSsize_t(x) PyLong_FromSsize_t(x)
 
 #endif
 
 #ifndef Py_TYPE
 #  define Py_TYPE(op) ((op)->ob_type)
 #endif
@@ -775,46 +800,27 @@
 #if PY_VERSION_HEX >= 0x03000000
 #  define SWIG_Python_str_FromFormat PyUnicode_FromFormat
 #else
 #  define SWIG_Python_str_FromFormat PyString_FromFormat
 #endif
 
 
-/* Warning: This function will allocate a new string in Python 3,
- * so please call SWIG_Python_str_DelForPy3(x) to free the space.
- */
 SWIGINTERN char*
 SWIG_Python_str_AsChar(PyObject *str)
 {
 #if PY_VERSION_HEX >= 0x03030000
   return (char *)PyUnicode_AsUTF8(str);
-#elif PY_VERSION_HEX >= 0x03000000
-  char *newstr = 0;
-  str = PyUnicode_AsUTF8String(str);
-  if (str) {
-    char *cstr;
-    Py_ssize_t len;
-    if (PyBytes_AsStringAndSize(str, &cstr, &len) != -1) {
-      newstr = (char *) malloc(len+1);
-      if (newstr)
-        memcpy(newstr, cstr, len+1);
-    }
-    Py_XDECREF(str);
-  }
-  return newstr;
 #else
   return PyString_AsString(str);
 #endif
 }
 
-#if PY_VERSION_HEX >= 0x03030000 || PY_VERSION_HEX < 0x03000000
-#  define SWIG_Python_str_DelForPy3(x)
-#else
-#  define SWIG_Python_str_DelForPy3(x) free( (void*) (x) )
-#endif
+/* Was useful for Python 3.0.x-3.2.x - now provided only for compatibility
+ * with any uses in user interface files. */
+#define SWIG_Python_str_DelForPy3(x)
 
 
 SWIGINTERN PyObject*
 SWIG_Python_str_FromChar(const char *c)
 {
 #if PY_VERSION_HEX >= 0x03000000
   return PyUnicode_FromString(c); 
@@ -823,18 +829,22 @@
 #endif
 }
 
 #ifndef PyObject_DEL
 # define PyObject_DEL PyObject_Del
 #endif
 
-// SWIGPY_USE_CAPSULE is no longer used within SWIG itself, but some user
-// interface files check for it.
+/* SWIGPY_USE_CAPSULE is no longer used within SWIG itself, but some user interface files check for it. */
 # define SWIGPY_USE_CAPSULE
-# define SWIGPY_CAPSULE_NAME ("swig_runtime_data" SWIG_RUNTIME_VERSION ".type_pointer_capsule" SWIG_TYPE_TABLE_NAME)
+#ifdef SWIGPYTHON_BUILTIN
+# define SWIGPY_CAPSULE_ATTR_NAME "type_pointer_capsule_builtin" SWIG_TYPE_TABLE_NAME
+#else
+# define SWIGPY_CAPSULE_ATTR_NAME "type_pointer_capsule" SWIG_TYPE_TABLE_NAME
+#endif
+# define SWIGPY_CAPSULE_NAME ("swig_runtime_data" SWIG_RUNTIME_VERSION "." SWIGPY_CAPSULE_ATTR_NAME)
 
 #if PY_VERSION_HEX < 0x03020000
 #define PyDescr_TYPE(x) (((PyDescrObject *)(x))->d_type)
 #define PyDescr_NAME(x) (((PyDescrObject *)(x))->d_name)
 #define Py_hash_t long
 #endif
 
@@ -900,15 +910,14 @@
     const char *tmp = SWIG_Python_str_AsChar(old_str);
     PyErr_Clear();
     Py_XINCREF(type);
     if (tmp)
       PyErr_Format(type, "%s %s", tmp, mesg);
     else
       PyErr_Format(type, "%s", mesg);
-    SWIG_Python_str_DelForPy3(tmp);
     Py_DECREF(old_str);
     Py_DECREF(value);
   } else {
     PyErr_SetString(PyExc_RuntimeError, mesg);
   }
 }
 
@@ -931,16 +940,20 @@
     PyObject *type = NULL, *value = NULL, *traceback = NULL;
     PyErr_Fetch(&type, &value, &traceback);
 #if PY_VERSION_HEX >= 0x03000000
     newvalue = PyUnicode_FromFormat("%S\nAdditional information:\n%s", value, message);
 #else
     newvalue = PyString_FromFormat("%s\nAdditional information:\n%s", PyString_AsString(value), message);
 #endif
-    Py_XDECREF(value);
-    PyErr_Restore(type, newvalue, traceback);
+    if (newvalue) {
+      Py_XDECREF(value);
+      PyErr_Restore(type, newvalue, traceback);
+    } else {
+      PyErr_Restore(type, value, traceback);
+    }
   } else {
     /* Raise TypeError using given message */
     PyErr_SetString(PyExc_TypeError, message);
   }
 }
 
 #if defined(SWIG_PYTHON_NO_THREADS)
@@ -949,16 +962,20 @@
 #  endif
 #endif
 #if defined(SWIG_PYTHON_THREADS) /* Threading support is enabled */
 #  if !defined(SWIG_PYTHON_USE_GIL) && !defined(SWIG_PYTHON_NO_USE_GIL)
 #    define SWIG_PYTHON_USE_GIL
 #  endif
 #  if defined(SWIG_PYTHON_USE_GIL) /* Use PyGILState threads calls */
-#    ifndef SWIG_PYTHON_INITIALIZE_THREADS
-#     define SWIG_PYTHON_INITIALIZE_THREADS  PyEval_InitThreads() 
+#    if !defined(SWIG_PYTHON_INITIALIZE_THREADS)
+#      if PY_VERSION_HEX < 0x03070000
+#        define SWIG_PYTHON_INITIALIZE_THREADS PyEval_InitThreads()
+#      else
+#        define SWIG_PYTHON_INITIALIZE_THREADS
+#      endif
 #    endif
 #    ifdef __cplusplus /* C++ code */
        class SWIG_Python_Thread_Block {
          bool status;
          PyGILState_STATE state;
        public:
          void end() { if (status) { PyGILState_Release(state); status = false;} }
@@ -1048,16 +1065,16 @@
  *
  * ----------------------------------------------------------------------------- */
 
 #if PY_VERSION_HEX < 0x02070000 /* 2.7.0 */
 # error "This version of SWIG only supports Python >= 2.7"
 #endif
 
-#if PY_VERSION_HEX >= 0x03000000 && PY_VERSION_HEX < 0x03020000
-# error "This version of SWIG only supports Python 3 >= 3.2"
+#if PY_VERSION_HEX >= 0x03000000 && PY_VERSION_HEX < 0x03030000
+# error "This version of SWIG only supports Python 3 >= 3.3"
 #endif
 
 /* Common SWIG API */
 
 /* for raw pointers */
 #define SWIG_Python_ConvertPtr(obj, pptr, type, flags)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, 0)
 #define SWIG_ConvertPtr(obj, pptr, type, flags)         SWIG_Python_ConvertPtr(obj, pptr, type, flags)
@@ -1164,15 +1181,20 @@
   } else if (result == Py_None) {
     Py_DECREF(result);
     result = obj;
   } else {
     if (!PyList_Check(result)) {
       PyObject *o2 = result;
       result = PyList_New(1);
-      PyList_SetItem(result, 0, o2);
+      if (result) {
+        PyList_SET_ITEM(result, 0, o2);
+      } else {
+        Py_DECREF(obj);
+        return o2;
+      }
     }
     PyList_Append(result,obj);
     Py_DECREF(obj);
   }
   return result;
 }
 
@@ -1246,14 +1268,246 @@
 */
 #ifdef __cplusplus
 #define SWIG_STATIC_POINTER(var)  var
 #else
 #define SWIG_STATIC_POINTER(var)  var = 0; if (!var) var
 #endif
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Python-specific SWIG API */
+#define SWIG_newvarlink()                             SWIG_Python_newvarlink()
+#define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
+#define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)
+ 
+/* -----------------------------------------------------------------------------
+ * global variable support code.
+ * ----------------------------------------------------------------------------- */
+ 
+typedef struct swig_globalvar {   
+  char       *name;                  /* Name of global variable */
+  PyObject *(*get_attr)(void);       /* Return the current value */
+  int       (*set_attr)(PyObject *); /* Set the value */
+  struct swig_globalvar *next;
+} swig_globalvar;
+
+typedef struct swig_varlinkobject {
+  PyObject_HEAD
+  swig_globalvar *vars;
+} swig_varlinkobject;
+
+SWIGINTERN PyObject *
+swig_varlink_repr(PyObject *SWIGUNUSEDPARM(v)) {
+#if PY_VERSION_HEX >= 0x03000000
+  return PyUnicode_InternFromString("<Swig global variables>");
+#else
+  return PyString_FromString("<Swig global variables>");
+#endif
+}
+
+SWIGINTERN PyObject *
+swig_varlink_str(PyObject *o) {
+  swig_varlinkobject *v = (swig_varlinkobject *) o;
+#if PY_VERSION_HEX >= 0x03000000
+  PyObject *str = PyUnicode_InternFromString("(");
+  PyObject *tail;
+  PyObject *joined;
+  swig_globalvar *var;
+  for (var = v->vars; var; var=var->next) {
+    tail = PyUnicode_FromString(var->name);
+    joined = PyUnicode_Concat(str, tail);
+    Py_DecRef(str);
+    Py_DecRef(tail);
+    str = joined;
+    if (var->next) {
+        tail = PyUnicode_InternFromString(", ");
+        joined = PyUnicode_Concat(str, tail);
+        Py_DecRef(str);
+        Py_DecRef(tail);
+        str = joined;
+    }
+  }
+  tail = PyUnicode_InternFromString(")");
+  joined = PyUnicode_Concat(str, tail);
+  Py_DecRef(str);
+  Py_DecRef(tail);
+  str = joined;
+#else
+  PyObject *str = PyString_FromString("(");
+  swig_globalvar *var;
+  for (var = v->vars; var; var=var->next) {
+    PyString_ConcatAndDel(&str,PyString_FromString(var->name));
+    if (var->next) PyString_ConcatAndDel(&str,PyString_FromString(", "));
+  }
+  PyString_ConcatAndDel(&str,PyString_FromString(")"));
+#endif
+  return str;
+}
+
+SWIGINTERN void
+swig_varlink_dealloc(PyObject *o) {
+  swig_varlinkobject *v = (swig_varlinkobject *) o;
+  swig_globalvar *var = v->vars;
+  while (var) {
+    swig_globalvar *n = var->next;
+    free(var->name);
+    free(var);
+    var = n;
+  }
+}
+
+SWIGINTERN PyObject *
+swig_varlink_getattr(PyObject *o, char *n) {
+  swig_varlinkobject *v = (swig_varlinkobject *) o;
+  PyObject *res = NULL;
+  swig_globalvar *var = v->vars;
+  while (var) {
+    if (strcmp(var->name,n) == 0) {
+      res = (*var->get_attr)();
+      break;
+    }
+    var = var->next;
+  }
+  if (res == NULL && !PyErr_Occurred()) {
+    PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
+  }
+  return res;
+}
+
+SWIGINTERN int
+swig_varlink_setattr(PyObject *o, char *n, PyObject *p) {
+  swig_varlinkobject *v = (swig_varlinkobject *) o;
+  int res = 1;
+  swig_globalvar *var = v->vars;
+  while (var) {
+    if (strcmp(var->name,n) == 0) {
+      res = (*var->set_attr)(p);
+      break;
+    }
+    var = var->next;
+  }
+  if (res == 1 && !PyErr_Occurred()) {
+    PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
+  }
+  return res;
+}
+
+SWIGINTERN PyTypeObject*
+swig_varlink_type(void) {
+  static char varlink__doc__[] = "Swig var link object";
+  static PyTypeObject varlink_type;
+  static int type_init = 0;
+  if (!type_init) {
+    const PyTypeObject tmp = {
+#if PY_VERSION_HEX >= 0x03000000
+      PyVarObject_HEAD_INIT(NULL, 0)
+#else
+      PyObject_HEAD_INIT(NULL)
+      0,                                  /* ob_size */
+#endif
+      "swigvarlink",                      /* tp_name */
+      sizeof(swig_varlinkobject),         /* tp_basicsize */
+      0,                                  /* tp_itemsize */
+      (destructor) swig_varlink_dealloc,  /* tp_dealloc */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                       /*tp_print*/
+#else
+      (Py_ssize_t)0,                      /*tp_vectorcall_offset*/
+#endif
+      (getattrfunc) swig_varlink_getattr, /* tp_getattr */
+      (setattrfunc) swig_varlink_setattr, /* tp_setattr */
+      0,                                  /* tp_compare */
+      (reprfunc) swig_varlink_repr,       /* tp_repr */
+      0,                                  /* tp_as_number */
+      0,                                  /* tp_as_sequence */
+      0,                                  /* tp_as_mapping */
+      0,                                  /* tp_hash */
+      0,                                  /* tp_call */
+      (reprfunc) swig_varlink_str,        /* tp_str */
+      0,                                  /* tp_getattro */
+      0,                                  /* tp_setattro */
+      0,                                  /* tp_as_buffer */
+      0,                                  /* tp_flags */
+      varlink__doc__,                     /* tp_doc */
+      0,                                  /* tp_traverse */
+      0,                                  /* tp_clear */
+      0,                                  /* tp_richcompare */
+      0,                                  /* tp_weaklistoffset */
+      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
+      0,                                  /* tp_del */
+      0,                                  /* tp_version_tag */
+#if PY_VERSION_HEX >= 0x03040000
+      0,                                  /* tp_finalize */
+#endif
+#if PY_VERSION_HEX >= 0x03080000
+      0,                                  /* tp_vectorcall */
+#endif
+#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
+      0,                                  /* tp_print */
+#endif
+#ifdef COUNT_ALLOCS
+      0,                                  /* tp_allocs */
+      0,                                  /* tp_frees */
+      0,                                  /* tp_maxalloc */
+      0,                                  /* tp_prev */
+      0                                   /* tp_next */
+#endif
+    };
+    varlink_type = tmp;
+    type_init = 1;
+    if (PyType_Ready(&varlink_type) < 0)
+      return NULL;
+  }
+  return &varlink_type;
+}
+
+/* Create a variable linking object for use later */
+SWIGINTERN PyObject *
+SWIG_Python_newvarlink(void) {
+  swig_varlinkobject *result = PyObject_NEW(swig_varlinkobject, swig_varlink_type());
+  if (result) {
+    result->vars = 0;
+  }
+  return ((PyObject*) result);
+}
+
+SWIGINTERN void 
+SWIG_Python_addvarlink(PyObject *p, const char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
+  swig_varlinkobject *v = (swig_varlinkobject *) p;
+  swig_globalvar *gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
+  if (gv) {
+    size_t size = strlen(name)+1;
+    gv->name = (char *)malloc(size);
+    if (gv->name) {
+      memcpy(gv->name, name, size);
+      gv->get_attr = get_attr;
+      gv->set_attr = set_attr;
+      gv->next = v->vars;
+    }
+  }
+  v->vars = gv;
+}
+
+
+static PyObject *Swig_Globals_global = NULL;
+  
+SWIGINTERN PyObject *
+SWIG_globals(void) {
+  if (Swig_Globals_global == NULL) {
+    Swig_Globals_global = SWIG_newvarlink();
+  }
+  return Swig_Globals_global;
+}
+
+#ifdef __cplusplus
+}
+#endif
+
 /* -----------------------------------------------------------------------------
  * Pointer declarations
  * ----------------------------------------------------------------------------- */
 
 /* Flags for new pointer objects */
 #define SWIG_POINTER_NOSHADOW       (SWIG_POINTER_OWN      << 1)
 #define SWIG_POINTER_NEW            (SWIG_POINTER_NOSHADOW | SWIG_POINTER_OWN)
@@ -1316,52 +1570,59 @@
     SwigPyClientData *data = (SwigPyClientData *)malloc(sizeof(SwigPyClientData));
     /* the klass element */
     data->klass = obj;
     Py_INCREF(data->klass);
     /* the newraw method and newargs arguments used to create a new raw instance */
     if (PyClass_Check(obj)) {
       data->newraw = 0;
-      data->newargs = obj;
       Py_INCREF(obj);
+      data->newargs = obj;
     } else {
       data->newraw = PyObject_GetAttrString(data->klass, "__new__");
       if (data->newraw) {
-	Py_INCREF(data->newraw);
-	data->newargs = PyTuple_New(1);
-	PyTuple_SetItem(data->newargs, 0, obj);
+        data->newargs = PyTuple_New(1);
+        if (data->newargs) {
+          Py_INCREF(obj);
+          PyTuple_SET_ITEM(data->newargs, 0, obj);
+        } else {
+          Py_DECREF(data->newraw);
+          Py_DECREF(data->klass);
+          free(data);
+          return 0;
+        }
       } else {
-	data->newargs = obj;
+        Py_INCREF(obj);
+        data->newargs = obj;
       }
-      Py_INCREF(data->newargs);
     }
     /* the destroy method, aka as the C++ delete method */
     data->destroy = PyObject_GetAttrString(data->klass, "__swig_destroy__");
     if (PyErr_Occurred()) {
       PyErr_Clear();
       data->destroy = 0;
     }
     if (data->destroy) {
-      int flags;
-      Py_INCREF(data->destroy);
-      flags = PyCFunction_GET_FLAGS(data->destroy);
-      data->delargs = !(flags & (METH_O));
+      data->delargs = !(PyCFunction_GET_FLAGS(data->destroy) & METH_O);
     } else {
       data->delargs = 0;
     }
     data->implicitconv = 0;
     data->pytype = 0;
     return data;
   }
 }
 
 SWIGRUNTIME void 
-SwigPyClientData_Del(SwigPyClientData *data) {
+SwigPyClientData_Del(SwigPyClientData *data)
+{
+  Py_XDECREF(data->klass);
   Py_XDECREF(data->newraw);
   Py_XDECREF(data->newargs);
   Py_XDECREF(data->destroy);
+  free(data);
 }
 
 /* =============== SwigPyObject =====================*/
 
 typedef struct {
   PyObject_HEAD
   void *ptr;
@@ -1380,15 +1641,15 @@
 SwigPyObject_get___dict__(PyObject *v, PyObject *SWIGUNUSEDPARM(args))
 {
   SwigPyObject *sobj = (SwigPyObject *)v;
 
   if (!sobj->dict)
     sobj->dict = PyDict_New();
 
-  Py_INCREF(sobj->dict);
+  Py_XINCREF(sobj->dict);
   return sobj->dict;
 }
 
 #endif
 
 SWIGRUNTIME PyObject *
 SwigPyObject_long(SwigPyObject *v)
@@ -1398,26 +1659,29 @@
 
 SWIGRUNTIME PyObject *
 SwigPyObject_format(const char* fmt, SwigPyObject *v)
 {
   PyObject *res = NULL;
   PyObject *args = PyTuple_New(1);
   if (args) {
-    if (PyTuple_SetItem(args, 0, SwigPyObject_long(v)) == 0) {
-      PyObject *ofmt = SWIG_Python_str_FromChar(fmt);
+    PyObject *val = SwigPyObject_long(v);
+    if (val) {
+      PyObject *ofmt;
+      PyTuple_SET_ITEM(args, 0, val);
+      ofmt = SWIG_Python_str_FromChar(fmt);
       if (ofmt) {
 #if PY_VERSION_HEX >= 0x03000000
-	res = PyUnicode_Format(ofmt,args);
+        res = PyUnicode_Format(ofmt,args);
 #else
-	res = PyString_Format(ofmt,args);
+        res = PyString_Format(ofmt,args);
 #endif
-	Py_DECREF(ofmt);
+        Py_DECREF(ofmt);
       }
-      Py_DECREF(args);
     }
+    Py_DECREF(args);
   }
   return res;
 }
 
 SWIGRUNTIME PyObject *
 SwigPyObject_oct(SwigPyObject *v)
 {
@@ -1431,26 +1695,31 @@
 }
 
 SWIGRUNTIME PyObject *
 SwigPyObject_repr(SwigPyObject *v)
 {
   const char *name = SWIG_TypePrettyName(v->ty);
   PyObject *repr = SWIG_Python_str_FromFormat("<Swig Object of type '%s' at %p>", (name ? name : "unknown"), (void *)v);
-  if (v->next) {
+  if (repr && v->next) {
     PyObject *nrep = SwigPyObject_repr((SwigPyObject *)v->next);
+    if (nrep) {
 # if PY_VERSION_HEX >= 0x03000000
-    PyObject *joined = PyUnicode_Concat(repr, nrep);
-    Py_DecRef(repr);
-    Py_DecRef(nrep);
-    repr = joined;
+      PyObject *joined = PyUnicode_Concat(repr, nrep);
+      Py_DecRef(repr);
+      Py_DecRef(nrep);
+      repr = joined;
 # else
-    PyString_ConcatAndDel(&repr,nrep);
+      PyString_ConcatAndDel(&repr,nrep);
 # endif
+    } else {
+      Py_DecRef(repr);
+      repr = NULL;
+    }
   }
-  return repr;  
+  return repr;
 }
 
 /* We need a version taking two PyObject* parameters so it's a valid
  * PyCFunction to use in swigobject_methods[]. */
 SWIGRUNTIME PyObject *
 SwigPyObject_repr2(PyObject *v, PyObject *SWIGUNUSEDPARM(args))
 {
@@ -1512,14 +1781,16 @@
     || (strcmp(Py_TYPE(op)->tp_name,"SwigPyObject") == 0);
 #endif
 }
 
 SWIGRUNTIME PyObject *
 SwigPyObject_New(void *ptr, swig_type_info *ty, int own);
 
+static PyObject* Swig_Capsule_global = NULL;
+
 SWIGRUNTIME void
 SwigPyObject_dealloc(PyObject *v)
 {
   SwigPyObject *sobj = (SwigPyObject *) v;
   PyObject *next = sobj->next;
   if (sobj->own == SWIG_POINTER_OWN) {
     swig_type_info *ty = sobj->ty;
@@ -1538,16 +1809,20 @@
       
       PyObject *type = NULL, *value = NULL, *traceback = NULL;
       PyErr_Fetch(&type, &value, &traceback);
 
       if (data->delargs) {
         /* we need to create a temporary object to carry the destroy operation */
         PyObject *tmp = SwigPyObject_New(sobj->ptr, ty, 0);
-        res = SWIG_Python_CallFunctor(destroy, tmp);
-        Py_DECREF(tmp);
+        if (tmp) {
+          res = SWIG_Python_CallFunctor(destroy, tmp);
+        } else {
+          res = 0;
+        }
+        Py_XDECREF(tmp);
       } else {
         PyCFunction meth = PyCFunction_GET_FUNCTION(destroy);
         PyObject *mself = PyCFunction_GET_SELF(destroy);
         res = ((*meth)(mself, v));
       }
       if (!res)
         PyErr_WriteUnraisable(destroy);
@@ -1558,27 +1833,32 @@
     } 
 #if !defined(SWIG_PYTHON_SILENT_MEMLEAK)
     else {
       const char *name = SWIG_TypePrettyName(ty);
       printf("swig/python detected a memory leak of type '%s', no destructor found.\n", (name ? name : "unknown"));
     }
 #endif
-  } 
+    Py_XDECREF(Swig_Capsule_global);
+  }
   Py_XDECREF(next);
+#ifdef SWIGPYTHON_BUILTIN
+  Py_XDECREF(sobj->dict);
+#endif
   PyObject_DEL(v);
 }
 
 SWIGRUNTIME PyObject* 
 SwigPyObject_append(PyObject* v, PyObject* next)
 {
   SwigPyObject *sobj = (SwigPyObject *) v;
   if (!SwigPyObject_Check(next)) {
     PyErr_SetString(PyExc_TypeError, "Attempt to append a non SwigPyObject");
     return NULL;
   }
+  ((SwigPyObject *)next)->next = sobj->next;
   sobj->next = next;
   Py_INCREF(next);
   return SWIG_Py_Void();
 }
 
 SWIGRUNTIME PyObject* 
 SwigPyObject_next(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
@@ -1615,17 +1895,17 @@
   if (!PyArg_UnpackTuple(args, "own", 0, 1, &val)) {
     return NULL;
   } else {
     SwigPyObject *sobj = (SwigPyObject *)v;
     PyObject *obj = PyBool_FromLong(sobj->own);
     if (val) {
       if (PyObject_IsTrue(val)) {
-        SwigPyObject_acquire(v,args);
+        Py_DECREF(SwigPyObject_acquire(v,args));
       } else {
-        SwigPyObject_disown(v,args);
+        Py_DECREF(SwigPyObject_disown(v,args));
       }
     } 
     return obj;
   }
 }
 
 static PyMethodDef
@@ -1697,15 +1977,19 @@
       PyObject_HEAD_INIT(NULL)
       0,                                    /* ob_size */
 #endif
       "SwigPyObject",                       /* tp_name */
       sizeof(SwigPyObject),                 /* tp_basicsize */
       0,                                    /* tp_itemsize */
       (destructor)SwigPyObject_dealloc,     /* tp_dealloc */
-      0,                                    /* tp_print */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                         /*tp_print*/
+#else
+      (Py_ssize_t)0,                        /*tp_vectorcall_offset*/
+#endif
       (getattrfunc)0,                       /* tp_getattr */
       (setattrfunc)0,                       /* tp_setattr */
 #if PY_VERSION_HEX >= 0x03000000
       0, /* tp_reserved in 3.0.1, tp_compare in 3.0.0 but not used */
 #else
       (cmpfunc)SwigPyObject_compare,        /* tp_compare */
 #endif
@@ -1762,29 +2046,38 @@
       0,                                    /* tp_maxalloc */
       0,                                    /* tp_prev */
       0                                     /* tp_next */
 #endif
     };
     swigpyobject_type = tmp;
     type_init = 1;
-    if (PyType_Ready(&swigpyobject_type) < 0)
+    if (PyType_Ready(&swigpyobject_type) != 0)
       return NULL;
   }
   return &swigpyobject_type;
 }
 
 SWIGRUNTIME PyObject *
 SwigPyObject_New(void *ptr, swig_type_info *ty, int own)
 {
   SwigPyObject *sobj = PyObject_NEW(SwigPyObject, SwigPyObject_type());
   if (sobj) {
     sobj->ptr  = ptr;
     sobj->ty   = ty;
     sobj->own  = own;
     sobj->next = 0;
+#ifdef SWIGPYTHON_BUILTIN
+    sobj->dict = 0;
+#endif
+    if (own == SWIG_POINTER_OWN) {
+      /* Obtain a reference to the Python capsule wrapping the module information, so that the
+       * module information is correctly destroyed after all SWIG python objects have been freed
+       * by the GC (and corresponding destructors invoked) */
+      Py_XINCREF(Swig_Capsule_global);
+    }
   }
   return (PyObject *)sobj;
 }
 
 /* -----------------------------------------------------------------------------
  * Implements a simple Swig Packed type, and use it instead of string
  * ----------------------------------------------------------------------------- */
@@ -1864,15 +2157,19 @@
       PyObject_HEAD_INIT(NULL)
       0,                                    /* ob_size */
 #endif
       "SwigPyPacked",                       /* tp_name */
       sizeof(SwigPyPacked),                 /* tp_basicsize */
       0,                                    /* tp_itemsize */
       (destructor)SwigPyPacked_dealloc,     /* tp_dealloc */
-      0,                                    /* tp_print */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                         /*tp_print*/
+#else
+      (Py_ssize_t)0,                        /*tp_vectorcall_offset*/
+#endif
       (getattrfunc)0,                       /* tp_getattr */
       (setattrfunc)0,                       /* tp_setattr */
 #if PY_VERSION_HEX>=0x03000000
       0, /* tp_reserved in 3.0.1 */
 #else
       (cmpfunc)SwigPyPacked_compare,        /* tp_compare */
 #endif
@@ -1929,15 +2226,15 @@
       0,                                    /* tp_maxalloc */
       0,                                    /* tp_prev */
       0                                     /* tp_next */
 #endif
     };
     swigpypacked_type = tmp;
     type_init = 1;
-    if (PyType_Ready(&swigpypacked_type) < 0)
+    if (PyType_Ready(&swigpypacked_type) != 0)
       return NULL;
   }
   return &swigpypacked_type;
 }
 
 SWIGRUNTIME PyObject *
 SwigPyPacked_New(void *ptr, size_t size, swig_type_info *ty)
@@ -2119,20 +2416,27 @@
       }
     } else {
       if (ptr) *ptr = vptr;
       break;
     }
   }
   if (sobj) {
-    if (own)
-      *own = *own | sobj->own;
-    if (flags & SWIG_POINTER_DISOWN) {
-      sobj->own = 0;
+    if (((flags & SWIG_POINTER_RELEASE) == SWIG_POINTER_RELEASE) && !sobj->own) {
+      res = SWIG_ERROR_RELEASE_NOT_OWNED;
+    } else {
+      if (own)
+        *own = *own | sobj->own;
+      if (flags & SWIG_POINTER_DISOWN) {
+        sobj->own = 0;
+      }
+      if (flags & SWIG_POINTER_CLEAR) {
+        sobj->ptr = 0;
+      }
+      res = SWIG_OK;
     }
-    res = SWIG_OK;
   } else {
     if (implicit_conv) {
       SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
       if (data && !data->implicitconv) {
         PyObject *klass = data->klass;
         if (klass) {
           PyObject *impconv;
@@ -2237,20 +2541,25 @@
   PyObject *newraw = data->newraw;
   if (newraw) {
     inst = PyObject_Call(newraw, data->newargs, NULL);
     if (inst) {
 #if !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
       PyObject **dictptr = _PyObject_GetDictPtr(inst);
       if (dictptr != NULL) {
-	PyObject *dict = *dictptr;
-	if (dict == NULL) {
-	  dict = PyDict_New();
-	  *dictptr = dict;
-	  PyDict_SetItem(dict, SWIG_This(), swig_this);
-	}
+        PyObject *dict = *dictptr;
+        if (dict == NULL) {
+          dict = PyDict_New();
+          *dictptr = dict;
+        }
+        if (dict) {
+          PyDict_SetItem(dict, SWIG_This(), swig_this);
+        } else{
+          Py_DECREF(inst);
+          inst = 0;
+        }
       }
 #else
       if (PyObject_SetAttr(inst, SWIG_This(), swig_this) == -1) {
         Py_DECREF(inst);
         inst = 0;
       }
 #endif
@@ -2264,15 +2573,15 @@
         inst = ((PyTypeObject *)data->newargs)->tp_new((PyTypeObject *)data->newargs, empty_args, empty_kwargs);
         Py_DECREF(empty_kwargs);
         if (inst) {
           if (PyObject_SetAttr(inst, SWIG_This(), swig_this) == -1) {
             Py_DECREF(inst);
             inst = 0;
           } else {
-            Py_TYPE(inst)->tp_flags &= ~Py_TPFLAGS_VALID_VERSION_TAG;
+            PyType_Modified(Py_TYPE(inst));
           }
         }
       }
       Py_DECREF(empty_args);
     }
 #else
     PyObject *dict = PyDict_New();
@@ -2293,30 +2602,34 @@
   PyObject **dictptr = _PyObject_GetDictPtr(inst);
   if (dictptr != NULL) {
     PyObject *dict = *dictptr;
     if (dict == NULL) {
       dict = PyDict_New();
       *dictptr = dict;
     }
-    return PyDict_SetItem(dict, SWIG_This(), swig_this);
+    if (dict) {
+      return PyDict_SetItem(dict, SWIG_This(), swig_this);
+    } else{
+      return -1;
+    }
   }
 #endif
   return PyObject_SetAttr(inst, SWIG_This(), swig_this);
 } 
 
 
 SWIGINTERN PyObject *
 SWIG_Python_InitShadowInstance(PyObject *args) {
   PyObject *obj[2];
   if (!SWIG_Python_UnpackTuple(args, "swiginit", 2, 2, obj)) {
     return NULL;
   } else {
     SwigPyObject *sthis = SWIG_Python_GetSwigThis(obj[0]);
     if (sthis) {
-      SwigPyObject_append((PyObject*) sthis, obj[1]);
+      Py_DECREF(SwigPyObject_append((PyObject*) sthis, obj[1]));
     } else {
       if (SWIG_Python_SetSwigThis(obj[0], obj[1]) != 0)
         return NULL;
     }
     return SWIG_Py_Void();
   }
 }
@@ -2347,15 +2660,17 @@
 #ifdef SWIGPYTHON_BUILTIN
         newobj->dict = 0;
 #endif
       }
     } else {
       newobj = PyObject_New(SwigPyObject, clientdata->pytype);
 #ifdef SWIGPYTHON_BUILTIN
-      newobj->dict = 0;
+      if (newobj) {
+        newobj->dict = 0;
+      }
 #endif
     }
     if (newobj) {
       newobj->ptr = ptr;
       newobj->ty = type;
       newobj->own = own;
       newobj->next = 0;
@@ -2386,89 +2701,111 @@
  *  Get type list 
  * -----------------------------------------------------------------------------*/
 
 #ifdef SWIG_LINK_RUNTIME
 void *SWIG_ReturnGlobalTypeList(void *);
 #endif
 
+static PyObject *Swig_TypeCache_global = NULL;
+
+/* The python cached type query */
+SWIGRUNTIME PyObject *
+SWIG_Python_TypeCache(void) {
+  if (Swig_TypeCache_global == NULL) {
+    Swig_TypeCache_global = PyDict_New();
+  }
+  return Swig_TypeCache_global;
+}
+
 SWIGRUNTIME swig_module_info *
 SWIG_Python_GetModule(void *SWIGUNUSEDPARM(clientdata)) {
+#ifdef SWIG_LINK_RUNTIME
   static void *type_pointer = (void *)0;
   /* first check if module already created */
   if (!type_pointer) {
-#ifdef SWIG_LINK_RUNTIME
     type_pointer = SWIG_ReturnGlobalTypeList((void *)0);
+  }
 #else
-    type_pointer = PyCapsule_Import(SWIGPY_CAPSULE_NAME, 0);
-    if (PyErr_Occurred()) {
-      PyErr_Clear();
-      type_pointer = (void *)0;
-    }
-#endif
+  void *type_pointer = PyCapsule_Import(SWIGPY_CAPSULE_NAME, 0);
+  if (PyErr_Occurred()) {
+    PyErr_Clear();
+    type_pointer = (void *)0;
   }
+#endif
   return (swig_module_info *) type_pointer;
 }
 
+
+static int interpreter_counter = 0; // how many (sub-)interpreters are using swig_module's types
+
 SWIGRUNTIME void
 SWIG_Python_DestroyModule(PyObject *obj)
 {
   swig_module_info *swig_module = (swig_module_info *) PyCapsule_GetPointer(obj, SWIGPY_CAPSULE_NAME);
   swig_type_info **types = swig_module->types;
   size_t i;
+  if (--interpreter_counter != 0) // another sub-interpreter may still be using the swig_module's types
+    return;
   for (i =0; i < swig_module->size; ++i) {
     swig_type_info *ty = types[i];
     if (ty->owndata) {
       SwigPyClientData *data = (SwigPyClientData *) ty->clientdata;
+      ty->clientdata = 0;
       if (data) SwigPyClientData_Del(data);
     }
   }
   Py_DECREF(SWIG_This());
   Swig_This_global = NULL;
+  Py_DECREF(SWIG_globals());
+  Swig_Globals_global = NULL;
+  Py_DECREF(SWIG_Python_TypeCache());
+  Swig_TypeCache_global = NULL;
+  Swig_Capsule_global = NULL;
 }
 
 SWIGRUNTIME void
 SWIG_Python_SetModule(swig_module_info *swig_module) {
 #if PY_VERSION_HEX >= 0x03000000
  /* Add a dummy module object into sys.modules */
   PyObject *module = PyImport_AddModule("swig_runtime_data" SWIG_RUNTIME_VERSION);
 #else
   static PyMethodDef swig_empty_runtime_method_table[] = { {NULL, NULL, 0, NULL} }; /* Sentinel */
   PyObject *module = Py_InitModule("swig_runtime_data" SWIG_RUNTIME_VERSION, swig_empty_runtime_method_table);
 #endif
   PyObject *pointer = PyCapsule_New((void *) swig_module, SWIGPY_CAPSULE_NAME, SWIG_Python_DestroyModule);
   if (pointer && module) {
-    PyModule_AddObject(module, "type_pointer_capsule" SWIG_TYPE_TABLE_NAME, pointer);
+    if (PyModule_AddObject(module, SWIGPY_CAPSULE_ATTR_NAME, pointer) == 0) {
+      ++interpreter_counter;
+      Swig_Capsule_global = pointer;
+    } else {
+      Py_DECREF(pointer);
+    }
   } else {
     Py_XDECREF(pointer);
   }
 }
 
-/* The python cached type query */
-SWIGRUNTIME PyObject *
-SWIG_Python_TypeCache(void) {
-  static PyObject *SWIG_STATIC_POINTER(cache) = PyDict_New();
-  return cache;
-}
-
 SWIGRUNTIME swig_type_info *
 SWIG_Python_TypeQuery(const char *type)
 {
   PyObject *cache = SWIG_Python_TypeCache();
   PyObject *key = SWIG_Python_str_FromChar(type); 
   PyObject *obj = PyDict_GetItem(cache, key);
   swig_type_info *descriptor;
   if (obj) {
     descriptor = (swig_type_info *) PyCapsule_GetPointer(obj, NULL);
   } else {
     swig_module_info *swig_module = SWIG_GetModule(0);
     descriptor = SWIG_TypeQueryModule(swig_module, swig_module, type);
     if (descriptor) {
       obj = PyCapsule_New((void*) descriptor, NULL, NULL);
-      PyDict_SetItem(cache, key, obj);
-      Py_DECREF(obj);
+      if (obj) {
+        PyDict_SetItem(cache, key, obj);
+        Py_DECREF(obj);
+      }
     }
   }
   Py_DECREF(key);
   return descriptor;
 }
 
 /* 
@@ -2493,15 +2830,14 @@
       Py_XINCREF(type);
       PyErr_Clear();
       if (infront) {
 	PyErr_Format(type, "%s %s", mesg, errmesg);
       } else {
 	PyErr_Format(type, "%s %s", errmesg, mesg);
       }
-      SWIG_Python_str_DelForPy3(tmp);
       Py_DECREF(old_str);
     }
     return 1;
   } else {
     return 0;
   }
 }
@@ -2545,15 +2881,14 @@
       const char *otype = (obj ? obj->ob_type->tp_name : 0); 
       if (otype) {
 	PyObject *str = PyObject_Str(obj);
 	const char *cstr = str ? SWIG_Python_str_AsChar(str) : 0;
 	if (cstr) {
 	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s(%s)' is received",
 		       type, otype, cstr);
-          SWIG_Python_str_DelForPy3(cstr);
 	} else {
 	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s' is received",
 		       type, otype);
 	}
 	Py_XDECREF(str);
 	return;
       }
@@ -2567,20 +2902,14 @@
 
 /* Convert a pointer value, signal an exception on a type mismatch */
 SWIGRUNTIME void *
 SWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int SWIGUNUSEDPARM(argnum), int flags) {
   void *result;
   if (SWIG_Python_ConvertPtr(obj, &result, ty, flags) == -1) {
     PyErr_Clear();
-#if SWIG_POINTER_EXCEPTION
-    if (flags) {
-      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);
-      SWIG_Python_ArgFail(argnum);
-    }
-#endif
   }
   return result;
 }
 
 #ifdef SWIGPYTHON_BUILTIN
 SWIGRUNTIME int
 SWIG_Python_NonDynamicSetAttr(PyObject *obj, PyObject *name, PyObject *value) {
@@ -2603,30 +2932,30 @@
     PyErr_Format(PyExc_TypeError, "attribute name must be string, not '%.200s'", name->ob_type->tp_name);
     return -1;
   } else {
     Py_INCREF(name);
   }
 
   if (!tp->tp_dict) {
-    if (PyType_Ready(tp) < 0)
+    if (PyType_Ready(tp) != 0)
       goto done;
   }
 
   descr = _PyType_Lookup(tp, name);
   f = NULL;
   if (descr != NULL)
     f = descr->ob_type->tp_descr_set;
   if (!f) {
     if (PyString_Check(name)) {
       encoded_name = name;
       Py_INCREF(name);
     } else {
       encoded_name = PyUnicode_AsUTF8String(name);
       if (!encoded_name)
-        return -1;
+        goto done;
     }
     PyErr_Format(PyExc_AttributeError, "'%.100s' object has no attribute '%.200s'", tp->tp_name, PyString_AsString(encoded_name));
     Py_DECREF(encoded_name);
   } else {
     res = f(descr, obj, value);
   }
   
@@ -2645,15 +2974,19 @@
 extern "C" {
 #endif
 
 SWIGINTERN Py_hash_t
 SwigPyObject_hash(PyObject *obj) {
   SwigPyObject *sobj = (SwigPyObject *)obj;
   void *ptr = sobj->ptr;
+#if PY_VERSION_HEX < 0x03020000
+  return (Py_hash_t)(Py_ssize_t)ptr;
+#else
   return (Py_hash_t)ptr;
+#endif
 }
 
 SWIGINTERN Py_hash_t
 SWIG_PyNumber_AsPyHash(PyObject *obj) {
   Py_hash_t result = -1;
 #if PY_VERSION_HEX < 0x03020000
   if (PyInt_Check(obj))
@@ -2850,15 +3183,19 @@
       PyObject_HEAD_INIT(&PyType_Type)
       0,                                        /* ob_size */
 #endif
       "swig_static_var_getset_descriptor",      /* tp_name */
       sizeof(PyGetSetDescrObject),              /* tp_basicsize */
       0,                                        /* tp_itemsize */
       (destructor)SwigPyStaticVar_dealloc,      /* tp_dealloc */
-      0,                                        /* tp_print */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                             /* tp_print */
+#else
+      (Py_ssize_t)0,                            /* tp_vectorcall_offset */
+#endif
       0,                                        /* tp_getattr */
       0,                                        /* tp_setattr */
       0,                                        /* tp_compare */
       (reprfunc)SwigPyStaticVar_repr,           /* tp_repr */
       0,                                        /* tp_as_number */
       0,                                        /* tp_as_sequence */
       0,                                        /* tp_as_mapping */
@@ -2934,15 +3271,19 @@
       PyObject_HEAD_INIT(&PyType_Type)
       0,                                        /* ob_size */
 #endif
       "SwigPyObjectType",                       /* tp_name */
       PyType_Type.tp_basicsize,                 /* tp_basicsize */
       0,                                        /* tp_itemsize */
       0,                                        /* tp_dealloc */
-      0,                                        /* tp_print */
+#if PY_VERSION_HEX < 0x030800b4
+      (printfunc)0,                             /* tp_print */
+#else
+      (Py_ssize_t)0,                            /* tp_vectorcall_offset */
+#endif
       0,                                        /* tp_getattr */
       0,                                        /* tp_setattr */
       0,                                        /* tp_compare */
       0,                                        /* tp_repr */
       0,                                        /* tp_as_number */
       0,                                        /* tp_as_sequence */
       0,                                        /* tp_as_mapping */
@@ -3053,18 +3394,18 @@
   Py_XINCREF(result);
   return result;
 }
 
 SWIGINTERN void
 SwigPyBuiltin_SetMetaType (PyTypeObject *type, PyTypeObject *metatype)
 {
-#if PY_VERSION_HEX >= 0x03000000
-    type->ob_base.ob_base.ob_type = metatype;
+#if PY_VERSION_HEX >= 0x030900a4
+    Py_SET_TYPE(type, metatype);
 #else
-    type->ob_type = metatype;
+    Py_TYPE(type) = metatype;
 #endif
 }
 
 
 /* Start of callback function macros for use in PyTypeObject */
 
 typedef PyObject *(*SwigPyWrapperFunction)(PyObject *, PyObject *);
@@ -3394,33 +3735,18 @@
 #endif
 
 
 
 
 #define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 
 
-#define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 
+#define SWIG_contract_assert(expr, msg) do { if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } } while (0) 
 
 
 
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* Method creation and docstring support functions */
-
-SWIGINTERN PyMethodDef *SWIG_PythonGetProxyDoc(const char *name);
-SWIGINTERN PyObject *SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func);
-SWIGINTERN PyObject *SWIG_PyStaticMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func);
-
-#ifdef __cplusplus
-}
-#endif
-
-
 /* -------- TYPES TABLE (BEGIN) -------- */
 
 #define SWIGTYPE_p_CameraAbilities swig_types[0]
 #define SWIGTYPE_p_CameraCaptureType swig_types[1]
 #define SWIGTYPE_p_CameraDriverStatus swig_types[2]
 #define SWIGTYPE_p_CameraEventType swig_types[3]
 #define SWIGTYPE_p_CameraFileAccessType swig_types[4]
@@ -3498,18 +3824,14 @@
 
 #else
 #  define SWIG_init    init_widget
 
 #endif
 #define SWIG_name    "_widget"
 
-#define SWIGVERSION 0x040002 
-#define SWIG_VERSION SWIGVERSION
-
-
 #define SWIG_as_voidptr(a) (void *)((const void *)(a)) 
 #define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),(void**)(a)) 
 
 
 #include <stddef.h>
 
 
@@ -4213,18 +4535,14 @@
 inline int SWIG_isfinite_func(T x) {
   using namespace std;
   return isfinite(x);
 }
 #  define SWIG_isfinite(X) (SWIG_isfinite_func(X))
 # elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 2))
 #  define SWIG_isfinite(X) (__builtin_isfinite(X))
-# elif defined(__clang__) && defined(__has_builtin)
-#  if __has_builtin(__builtin_isfinite)
-#   define SWIG_isfinite(X) (__builtin_isfinite(X))
-#  endif
 # elif defined(_MSC_VER)
 #  define SWIG_isfinite(X) (_finite(X))
 # elif defined(__sun) && defined(__SVR4)
 #  include <ieeefp.h>
 #  define SWIG_isfinite(X) (finite(X))
 # endif
 #endif
@@ -4426,14 +4744,15 @@
   PyObject * obj0 = 0 ;
   int result;
   
   {
     temp2.str_val = NULL;
     arg2 = &temp2;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_widget_get_value", 1, 1, &obj0)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_widget_get_value" "', argument " "1"" of type '" "CameraWidget *""'"); 
   }
   arg1 = (CameraWidget *)(argp1);
   result = (int)gp_widget_get_value(arg1,arg2);
@@ -4482,14 +4801,15 @@
 SWIGINTERN PyObject *_wrap_CameraWidgetChildIter___next__(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct CameraWidgetChildIter *arg1 = (struct CameraWidgetChildIter *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   CameraWidget *result = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraWidgetChildIter___next__ takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CameraWidgetChildIter, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraWidgetChildIter___next__" "', argument " "1"" of type '" "struct CameraWidgetChildIter *""'"); 
   }
   arg1 = (struct CameraWidgetChildIter *)(argp1);
   {
@@ -4505,14 +4825,15 @@
 
 SWIGINTERN PyObject *_wrap_delete_CameraWidgetChildIter(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct CameraWidgetChildIter *arg1 = (struct CameraWidgetChildIter *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_CameraWidgetChildIter takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CameraWidgetChildIter, SWIG_POINTER_DISOWN |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CameraWidgetChildIter" "', argument " "1"" of type '" "struct CameraWidgetChildIter *""'"); 
   }
   arg1 = (struct CameraWidgetChildIter *)(argp1);
   free((char *) arg1);
@@ -4539,14 +4860,15 @@
   {
     arg2 = (CameraWidgetChildIter *)calloc(1, sizeof(CameraWidgetChildIter));
     if (arg2 == NULL) {
       PyErr_SetString(PyExc_MemoryError, "Cannot allocate " "CameraWidgetChildIter");
       SWIG_fail;
     }
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_widget_get_children", 1, 1, &obj0)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_widget_get_children" "', argument " "1"" of type '" "CameraWidget *""'"); 
   }
   arg1 = (CameraWidget *)(argp1);
   result = (int)gp_widget_get_children(arg1,arg2);
@@ -4571,14 +4893,15 @@
 SWIGINTERN PyObject *_wrap_CameraWidgetChoiceIter___next__(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct CameraWidgetChoiceIter *arg1 = (struct CameraWidgetChoiceIter *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   char *result = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraWidgetChoiceIter___next__ takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CameraWidgetChoiceIter, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraWidgetChoiceIter___next__" "', argument " "1"" of type '" "struct CameraWidgetChoiceIter *""'"); 
   }
   arg1 = (struct CameraWidgetChoiceIter *)(argp1);
   {
@@ -4594,14 +4917,15 @@
 
 SWIGINTERN PyObject *_wrap_delete_CameraWidgetChoiceIter(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct CameraWidgetChoiceIter *arg1 = (struct CameraWidgetChoiceIter *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_CameraWidgetChoiceIter takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CameraWidgetChoiceIter, SWIG_POINTER_DISOWN |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CameraWidgetChoiceIter" "', argument " "1"" of type '" "struct CameraWidgetChoiceIter *""'"); 
   }
   arg1 = (struct CameraWidgetChoiceIter *)(argp1);
   free((char *) arg1);
@@ -4628,14 +4952,15 @@
   {
     arg2 = (CameraWidgetChoiceIter *)calloc(1, sizeof(CameraWidgetChoiceIter));
     if (arg2 == NULL) {
       PyErr_SetString(PyExc_MemoryError, "Cannot allocate " "CameraWidgetChoiceIter");
       SWIG_fail;
     }
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_widget_get_choices", 1, 1, &obj0)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_widget_get_choices" "', argument " "1"" of type '" "CameraWidget *""'"); 
   }
   arg1 = (CameraWidget *)(argp1);
   result = (int)gp_widget_get_choices(arg1,arg2);
@@ -4659,14 +4984,15 @@
 
 SWIGINTERN PyObject *_wrap_delete_CameraWidget(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraWidget *arg1 = (struct _CameraWidget *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_CameraWidget takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraWidget, SWIG_POINTER_DISOWN |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CameraWidget" "', argument " "1"" of type '" "struct _CameraWidget *""'"); 
   }
   arg1 = (struct _CameraWidget *)(argp1);
   {
@@ -4683,14 +5009,15 @@
 SWIGINTERN PyObject *_wrap_CameraWidget_count_children(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraWidget *arg1 = (struct _CameraWidget *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   int result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraWidget_count_children takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraWidget_count_children" "', argument " "1"" of type '" "struct _CameraWidget *""'"); 
   }
   arg1 = (struct _CameraWidget *)(argp1);
   {
@@ -4716,14 +5043,15 @@
   CameraWidget *temp3 ;
   PyObject * obj1 = 0 ;
   
   {
     temp3 = NULL;
     arg3 = &temp3;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "CameraWidget_get_child", 1, 1, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraWidget_get_child" "', argument " "1"" of type '" "struct _CameraWidget *""'"); 
   }
   arg1 = (struct _CameraWidget *)(argp1);
   ecode2 = SWIG_AsVal_int(obj1, &val2);
@@ -4775,14 +5103,15 @@
   {
     arg2 = (CameraWidgetChildIter *)calloc(1, sizeof(CameraWidgetChildIter));
     if (arg2 == NULL) {
       PyErr_SetString(PyExc_MemoryError, "Cannot allocate " "CameraWidgetChildIter");
       SWIG_fail;
     }
   }
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraWidget_get_children takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraWidget_get_children" "', argument " "1"" of type '" "struct _CameraWidget *""'"); 
   }
   arg1 = (struct _CameraWidget *)(argp1);
   {
@@ -4820,14 +5149,15 @@
   CameraWidget *temp3 ;
   PyObject * obj1 = 0 ;
   
   {
     temp3 = NULL;
     arg3 = &temp3;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "CameraWidget_get_child_by_label", 1, 1, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraWidget_get_child_by_label" "', argument " "1"" of type '" "struct _CameraWidget *""'"); 
   }
   arg1 = (struct _CameraWidget *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -4883,14 +5213,15 @@
   CameraWidget *temp3 ;
   PyObject * obj1 = 0 ;
   
   {
     temp3 = NULL;
     arg3 = &temp3;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "CameraWidget_get_child_by_id", 1, 1, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraWidget_get_child_by_id" "', argument " "1"" of type '" "struct _CameraWidget *""'"); 
   }
   arg1 = (struct _CameraWidget *)(argp1);
   ecode2 = SWIG_AsVal_int(obj1, &val2);
@@ -4945,14 +5276,15 @@
   CameraWidget *temp3 ;
   PyObject * obj1 = 0 ;
   
   {
     temp3 = NULL;
     arg3 = &temp3;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "CameraWidget_get_child_by_name", 1, 1, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraWidget_get_child_by_name" "', argument " "1"" of type '" "struct _CameraWidget *""'"); 
   }
   arg1 = (struct _CameraWidget *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -5004,14 +5336,15 @@
   int res1 = 0 ;
   CameraWidget *temp2 ;
   
   {
     temp2 = NULL;
     arg2 = &temp2;
   }
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraWidget_get_root takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraWidget_get_root" "', argument " "1"" of type '" "struct _CameraWidget *""'"); 
   }
   arg1 = (struct _CameraWidget *)(argp1);
   {
@@ -5056,14 +5389,15 @@
   int res1 = 0 ;
   CameraWidget *temp2 ;
   
   {
     temp2 = NULL;
     arg2 = &temp2;
   }
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraWidget_get_parent takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraWidget_get_parent" "', argument " "1"" of type '" "struct _CameraWidget *""'"); 
   }
   arg1 = (struct _CameraWidget *)(argp1);
   {
@@ -5108,14 +5442,15 @@
   int res1 = 0 ;
   VoidValue value2 ;
   int alloc2 = 0 ;
   int res2 = 0 ;
   CameraWidgetType type2 ;
   PyObject * obj1 = 0 ;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "CameraWidget_set_value", 1, 1, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraWidget_set_value" "', argument " "1"" of type '" "struct _CameraWidget *""'"); 
   }
   arg1 = (struct _CameraWidget *)(argp1);
   // Camera widget is stored in arg1 as it's definitely the first argument to gp_widget_set_value
@@ -5181,14 +5516,15 @@
   int res1 = 0 ;
   VoidValue temp2 ;
   
   {
     temp2.str_val = NULL;
     arg2 = &temp2;
   }
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraWidget_get_value takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraWidget_get_value" "', argument " "1"" of type '" "struct _CameraWidget *""'"); 
   }
   arg1 = (struct _CameraWidget *)(argp1);
   {
@@ -5244,14 +5580,15 @@
   void *argp1 = 0 ;
   int res1 = 0 ;
   int res2 ;
   char *buf2 = 0 ;
   int alloc2 = 0 ;
   PyObject * obj1 = 0 ;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "CameraWidget_set_name", 1, 1, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraWidget_set_name" "', argument " "1"" of type '" "struct _CameraWidget *""'"); 
   }
   arg1 = (struct _CameraWidget *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -5280,14 +5617,15 @@
   int res1 = 0 ;
   char *temp2 ;
   
   {
     temp2 = NULL;
     arg2 = &temp2;
   }
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraWidget_get_name takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraWidget_get_name" "', argument " "1"" of type '" "struct _CameraWidget *""'"); 
   }
   arg1 = (struct _CameraWidget *)(argp1);
   {
@@ -5317,14 +5655,15 @@
   void *argp1 = 0 ;
   int res1 = 0 ;
   int res2 ;
   char *buf2 = 0 ;
   int alloc2 = 0 ;
   PyObject * obj1 = 0 ;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "CameraWidget_set_info", 1, 1, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraWidget_set_info" "', argument " "1"" of type '" "struct _CameraWidget *""'"); 
   }
   arg1 = (struct _CameraWidget *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -5353,14 +5692,15 @@
   int res1 = 0 ;
   char *temp2 ;
   
   {
     temp2 = NULL;
     arg2 = &temp2;
   }
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraWidget_get_info takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraWidget_get_info" "', argument " "1"" of type '" "struct _CameraWidget *""'"); 
   }
   arg1 = (struct _CameraWidget *)(argp1);
   {
@@ -5389,14 +5729,15 @@
   int *arg2 = (int *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   int temp2 ;
   int res2 = SWIG_TMPOBJ ;
   
   arg2 = &temp2;
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraWidget_get_id takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraWidget_get_id" "', argument " "1"" of type '" "struct _CameraWidget *""'"); 
   }
   arg1 = (struct _CameraWidget *)(argp1);
   {
@@ -5422,14 +5763,15 @@
   CameraWidgetType *arg2 = (CameraWidgetType *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   CameraWidgetType temp2 ;
   int res2 = SWIG_TMPOBJ ;
   
   arg2 = &temp2;
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraWidget_get_type takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraWidget_get_type" "', argument " "1"" of type '" "struct _CameraWidget *""'"); 
   }
   arg1 = (struct _CameraWidget *)(argp1);
   {
@@ -5457,14 +5799,15 @@
   int res1 = 0 ;
   char *temp2 ;
   
   {
     temp2 = NULL;
     arg2 = &temp2;
   }
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraWidget_get_label takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraWidget_get_label" "', argument " "1"" of type '" "struct _CameraWidget *""'"); 
   }
   arg1 = (struct _CameraWidget *)(argp1);
   {
@@ -5501,14 +5844,15 @@
   int ecode3 = 0 ;
   float val4 ;
   int ecode4 = 0 ;
   PyObject * obj1 = 0 ;
   PyObject * obj2 = 0 ;
   PyObject * obj3 = 0 ;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "CameraWidget_set_range", 3, 3, &obj1, &obj2, &obj3)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraWidget_set_range" "', argument " "1"" of type '" "struct _CameraWidget *""'"); 
   }
   arg1 = (struct _CameraWidget *)(argp1);
   ecode2 = SWIG_AsVal_float(obj1, &val2);
@@ -5551,14 +5895,15 @@
   int res3 = SWIG_TMPOBJ ;
   float temp4 ;
   int res4 = SWIG_TMPOBJ ;
   
   arg2 = &temp2;
   arg3 = &temp3;
   arg4 = &temp4;
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraWidget_get_range takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraWidget_get_range" "', argument " "1"" of type '" "struct _CameraWidget *""'"); 
   }
   arg1 = (struct _CameraWidget *)(argp1);
   {
@@ -5597,14 +5942,15 @@
   void *argp1 = 0 ;
   int res1 = 0 ;
   int res2 ;
   char *buf2 = 0 ;
   int alloc2 = 0 ;
   PyObject * obj1 = 0 ;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "CameraWidget_add_choice", 1, 1, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraWidget_add_choice" "', argument " "1"" of type '" "struct _CameraWidget *""'"); 
   }
   arg1 = (struct _CameraWidget *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -5628,14 +5974,15 @@
 SWIGINTERN PyObject *_wrap_CameraWidget_count_choices(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraWidget *arg1 = (struct _CameraWidget *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   int result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraWidget_count_choices takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraWidget_count_choices" "', argument " "1"" of type '" "struct _CameraWidget *""'"); 
   }
   arg1 = (struct _CameraWidget *)(argp1);
   {
@@ -5659,14 +6006,15 @@
   {
     arg2 = (CameraWidgetChoiceIter *)calloc(1, sizeof(CameraWidgetChoiceIter));
     if (arg2 == NULL) {
       PyErr_SetString(PyExc_MemoryError, "Cannot allocate " "CameraWidgetChoiceIter");
       SWIG_fail;
     }
   }
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraWidget_get_choices takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraWidget_get_choices" "', argument " "1"" of type '" "struct _CameraWidget *""'"); 
   }
   arg1 = (struct _CameraWidget *)(argp1);
   {
@@ -5703,14 +6051,15 @@
   char *temp3 ;
   PyObject * obj1 = 0 ;
   
   {
     temp3 = NULL;
     arg3 = &temp3;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "CameraWidget_get_choice", 1, 1, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraWidget_get_choice" "', argument " "1"" of type '" "struct _CameraWidget *""'"); 
   }
   arg1 = (struct _CameraWidget *)(argp1);
   ecode2 = SWIG_AsVal_int(obj1, &val2);
@@ -5741,14 +6090,15 @@
 SWIGINTERN PyObject *_wrap_CameraWidget_changed(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct _CameraWidget *arg1 = (struct _CameraWidget *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   int result;
   
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraWidget_changed takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraWidget_changed" "', argument " "1"" of type '" "struct _CameraWidget *""'"); 
   }
   arg1 = (struct _CameraWidget *)(argp1);
   {
@@ -5768,14 +6118,15 @@
   int arg2 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   int val2 ;
   int ecode2 = 0 ;
   PyObject * obj1 = 0 ;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "CameraWidget_set_changed", 1, 1, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraWidget_set_changed" "', argument " "1"" of type '" "struct _CameraWidget *""'"); 
   }
   arg1 = (struct _CameraWidget *)(argp1);
   ecode2 = SWIG_AsVal_int(obj1, &val2);
@@ -5800,14 +6151,15 @@
   int arg2 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   int val2 ;
   int ecode2 = 0 ;
   PyObject * obj1 = 0 ;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "CameraWidget_set_readonly", 1, 1, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraWidget_set_readonly" "', argument " "1"" of type '" "struct _CameraWidget *""'"); 
   }
   arg1 = (struct _CameraWidget *)(argp1);
   ecode2 = SWIG_AsVal_int(obj1, &val2);
@@ -5832,14 +6184,15 @@
   int *arg2 = (int *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   int temp2 ;
   int res2 = SWIG_TMPOBJ ;
   
   arg2 = &temp2;
+  (void)self;
   if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "CameraWidget_get_readonly takes no arguments");
   res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CameraWidget_get_readonly" "', argument " "1"" of type '" "struct _CameraWidget *""'"); 
   }
   arg1 = (struct _CameraWidget *)(argp1);
   {
@@ -5869,14 +6222,15 @@
   int res1 = 0 ;
   void *argp2 = 0 ;
   int res2 = 0 ;
   PyObject * obj0 = 0 ;
   PyObject * obj1 = 0 ;
   int result;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_widget_append", 2, 2, &obj0, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_widget_append" "', argument " "1"" of type '" "CameraWidget *""'"); 
   }
   arg1 = (CameraWidget *)(argp1);
   res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p__CameraWidget, 0 |  0 );
@@ -5900,14 +6254,15 @@
   int res1 = 0 ;
   void *argp2 = 0 ;
   int res2 = 0 ;
   PyObject * obj0 = 0 ;
   PyObject * obj1 = 0 ;
   int result;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_widget_prepend", 2, 2, &obj0, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_widget_prepend" "', argument " "1"" of type '" "CameraWidget *""'"); 
   }
   arg1 = (CameraWidget *)(argp1);
   res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p__CameraWidget, 0 |  0 );
@@ -5927,14 +6282,15 @@
   PyObject *resultobj = 0;
   CameraWidget *arg1 = (CameraWidget *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   PyObject * obj0 = 0 ;
   int result;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_widget_count_children", 1, 1, &obj0)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_widget_count_children" "', argument " "1"" of type '" "CameraWidget *""'"); 
   }
   arg1 = (CameraWidget *)(argp1);
   result = (int)gp_widget_count_children(arg1);
@@ -5959,14 +6315,15 @@
   PyObject * obj1 = 0 ;
   int result;
   
   {
     temp3 = NULL;
     arg3 = &temp3;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_widget_get_child", 2, 2, &obj0, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_widget_get_child" "', argument " "1"" of type '" "CameraWidget *""'"); 
   }
   arg1 = (CameraWidget *)(argp1);
   ecode2 = SWIG_AsVal_int(obj1, &val2);
@@ -6020,14 +6377,15 @@
   PyObject * obj1 = 0 ;
   int result;
   
   {
     temp3 = NULL;
     arg3 = &temp3;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_widget_get_child_by_label", 2, 2, &obj0, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_widget_get_child_by_label" "', argument " "1"" of type '" "CameraWidget *""'"); 
   }
   arg1 = (CameraWidget *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -6082,14 +6440,15 @@
   PyObject * obj1 = 0 ;
   int result;
   
   {
     temp3 = NULL;
     arg3 = &temp3;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_widget_get_child_by_id", 2, 2, &obj0, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_widget_get_child_by_id" "', argument " "1"" of type '" "CameraWidget *""'"); 
   }
   arg1 = (CameraWidget *)(argp1);
   ecode2 = SWIG_AsVal_int(obj1, &val2);
@@ -6143,14 +6502,15 @@
   PyObject * obj1 = 0 ;
   int result;
   
   {
     temp3 = NULL;
     arg3 = &temp3;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_widget_get_child_by_name", 2, 2, &obj0, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_widget_get_child_by_name" "', argument " "1"" of type '" "CameraWidget *""'"); 
   }
   arg1 = (CameraWidget *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -6201,14 +6561,15 @@
   PyObject * obj0 = 0 ;
   int result;
   
   {
     temp2 = NULL;
     arg2 = &temp2;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_widget_get_root", 1, 1, &obj0)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_widget_get_root" "', argument " "1"" of type '" "CameraWidget *""'"); 
   }
   arg1 = (CameraWidget *)(argp1);
   result = (int)gp_widget_get_root(arg1,arg2);
@@ -6252,14 +6613,15 @@
   PyObject * obj0 = 0 ;
   int result;
   
   {
     temp2 = NULL;
     arg2 = &temp2;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_widget_get_parent", 1, 1, &obj0)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_widget_get_parent" "', argument " "1"" of type '" "CameraWidget *""'"); 
   }
   arg1 = (CameraWidget *)(argp1);
   result = (int)gp_widget_get_parent(arg1,arg2);
@@ -6303,14 +6665,15 @@
   int alloc2 = 0 ;
   int res2 = 0 ;
   CameraWidgetType type2 ;
   PyObject * obj0 = 0 ;
   PyObject * obj1 = 0 ;
   int result;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_widget_set_value", 2, 2, &obj0, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_widget_set_value" "', argument " "1"" of type '" "CameraWidget *""'"); 
   }
   arg1 = (CameraWidget *)(argp1);
   // Camera widget is stored in arg1 as it's definitely the first argument to gp_widget_set_value
@@ -6374,14 +6737,15 @@
   int res2 ;
   char *buf2 = 0 ;
   int alloc2 = 0 ;
   PyObject * obj0 = 0 ;
   PyObject * obj1 = 0 ;
   int result;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_widget_set_name", 2, 2, &obj0, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_widget_set_name" "', argument " "1"" of type '" "CameraWidget *""'"); 
   }
   arg1 = (CameraWidget *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -6409,14 +6773,15 @@
   PyObject * obj0 = 0 ;
   int result;
   
   {
     temp2 = NULL;
     arg2 = &temp2;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_widget_get_name", 1, 1, &obj0)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_widget_get_name" "', argument " "1"" of type '" "CameraWidget *""'"); 
   }
   arg1 = (CameraWidget *)(argp1);
   result = (int)gp_widget_get_name(arg1,(char const **)arg2);
@@ -6445,14 +6810,15 @@
   int res2 ;
   char *buf2 = 0 ;
   int alloc2 = 0 ;
   PyObject * obj0 = 0 ;
   PyObject * obj1 = 0 ;
   int result;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_widget_set_info", 2, 2, &obj0, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_widget_set_info" "', argument " "1"" of type '" "CameraWidget *""'"); 
   }
   arg1 = (CameraWidget *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -6480,14 +6846,15 @@
   PyObject * obj0 = 0 ;
   int result;
   
   {
     temp2 = NULL;
     arg2 = &temp2;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_widget_get_info", 1, 1, &obj0)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_widget_get_info" "', argument " "1"" of type '" "CameraWidget *""'"); 
   }
   arg1 = (CameraWidget *)(argp1);
   result = (int)gp_widget_get_info(arg1,(char const **)arg2);
@@ -6515,14 +6882,15 @@
   int res1 = 0 ;
   int temp2 ;
   int res2 = SWIG_TMPOBJ ;
   PyObject * obj0 = 0 ;
   int result;
   
   arg2 = &temp2;
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_widget_get_id", 1, 1, &obj0)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_widget_get_id" "', argument " "1"" of type '" "CameraWidget *""'"); 
   }
   arg1 = (CameraWidget *)(argp1);
   result = (int)gp_widget_get_id(arg1,arg2);
@@ -6547,14 +6915,15 @@
   int res1 = 0 ;
   CameraWidgetType temp2 ;
   int res2 = SWIG_TMPOBJ ;
   PyObject * obj0 = 0 ;
   int result;
   
   arg2 = &temp2;
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_widget_get_type", 1, 1, &obj0)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_widget_get_type" "', argument " "1"" of type '" "CameraWidget *""'"); 
   }
   arg1 = (CameraWidget *)(argp1);
   result = (int)gp_widget_get_type(arg1,arg2);
@@ -6581,14 +6950,15 @@
   PyObject * obj0 = 0 ;
   int result;
   
   {
     temp2 = NULL;
     arg2 = &temp2;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_widget_get_label", 1, 1, &obj0)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_widget_get_label" "', argument " "1"" of type '" "CameraWidget *""'"); 
   }
   arg1 = (CameraWidget *)(argp1);
   result = (int)gp_widget_get_label(arg1,(char const **)arg2);
@@ -6624,14 +6994,15 @@
   int ecode4 = 0 ;
   PyObject * obj0 = 0 ;
   PyObject * obj1 = 0 ;
   PyObject * obj2 = 0 ;
   PyObject * obj3 = 0 ;
   int result;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_widget_set_range", 4, 4, &obj0, &obj1, &obj2, &obj3)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_widget_set_range" "', argument " "1"" of type '" "CameraWidget *""'"); 
   }
   arg1 = (CameraWidget *)(argp1);
   ecode2 = SWIG_AsVal_float(obj1, &val2);
@@ -6673,14 +7044,15 @@
   int res4 = SWIG_TMPOBJ ;
   PyObject * obj0 = 0 ;
   int result;
   
   arg2 = &temp2;
   arg3 = &temp3;
   arg4 = &temp4;
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_widget_get_range", 1, 1, &obj0)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_widget_get_range" "', argument " "1"" of type '" "CameraWidget *""'"); 
   }
   arg1 = (CameraWidget *)(argp1);
   result = (int)gp_widget_get_range(arg1,arg2,arg3,arg4);
@@ -6718,14 +7090,15 @@
   int res2 ;
   char *buf2 = 0 ;
   int alloc2 = 0 ;
   PyObject * obj0 = 0 ;
   PyObject * obj1 = 0 ;
   int result;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_widget_add_choice", 2, 2, &obj0, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_widget_add_choice" "', argument " "1"" of type '" "CameraWidget *""'"); 
   }
   arg1 = (CameraWidget *)(argp1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
@@ -6747,14 +7120,15 @@
   PyObject *resultobj = 0;
   CameraWidget *arg1 = (CameraWidget *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   PyObject * obj0 = 0 ;
   int result;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_widget_count_choices", 1, 1, &obj0)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_widget_count_choices" "', argument " "1"" of type '" "CameraWidget *""'"); 
   }
   arg1 = (CameraWidget *)(argp1);
   result = (int)gp_widget_count_choices(arg1);
@@ -6779,14 +7153,15 @@
   PyObject * obj1 = 0 ;
   int result;
   
   {
     temp3 = NULL;
     arg3 = &temp3;
   }
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_widget_get_choice", 2, 2, &obj0, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_widget_get_choice" "', argument " "1"" of type '" "CameraWidget *""'"); 
   }
   arg1 = (CameraWidget *)(argp1);
   ecode2 = SWIG_AsVal_int(obj1, &val2);
@@ -6815,14 +7190,15 @@
   PyObject *resultobj = 0;
   CameraWidget *arg1 = (CameraWidget *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   PyObject * obj0 = 0 ;
   int result;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_widget_changed", 1, 1, &obj0)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_widget_changed" "', argument " "1"" of type '" "CameraWidget *""'"); 
   }
   arg1 = (CameraWidget *)(argp1);
   result = (int)gp_widget_changed(arg1);
@@ -6841,14 +7217,15 @@
   int res1 = 0 ;
   int val2 ;
   int ecode2 = 0 ;
   PyObject * obj0 = 0 ;
   PyObject * obj1 = 0 ;
   int result;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_widget_set_changed", 2, 2, &obj0, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_widget_set_changed" "', argument " "1"" of type '" "CameraWidget *""'"); 
   }
   arg1 = (CameraWidget *)(argp1);
   ecode2 = SWIG_AsVal_int(obj1, &val2);
@@ -6872,14 +7249,15 @@
   int res1 = 0 ;
   int val2 ;
   int ecode2 = 0 ;
   PyObject * obj0 = 0 ;
   PyObject * obj1 = 0 ;
   int result;
   
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_widget_set_readonly", 2, 2, &obj0, &obj1)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_widget_set_readonly" "', argument " "1"" of type '" "CameraWidget *""'"); 
   }
   arg1 = (CameraWidget *)(argp1);
   ecode2 = SWIG_AsVal_int(obj1, &val2);
@@ -6903,14 +7281,15 @@
   int res1 = 0 ;
   int temp2 ;
   int res2 = SWIG_TMPOBJ ;
   PyObject * obj0 = 0 ;
   int result;
   
   arg2 = &temp2;
+  (void)self;
   if (!PyArg_UnpackTuple(args, "gp_widget_get_readonly", 1, 1, &obj0)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__CameraWidget, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gp_widget_get_readonly" "', argument " "1"" of type '" "CameraWidget *""'"); 
   }
   arg1 = (CameraWidget *)(argp1);
   result = (int)gp_widget_get_readonly(arg1,arg2);
@@ -6924,682 +7303,14 @@
   return resultobj;
 fail:
   return NULL;
 }
 
 
 static PyMethodDef SwigMethods[] = {
-	 { "SWIG_PyInstanceMethod_New", SWIG_PyInstanceMethod_New, METH_O, NULL},
-	 { "SWIG_PyStaticMethod_New", SWIG_PyStaticMethod_New, METH_O, NULL},
-	 { "gp_widget_get_value", _wrap_gp_widget_get_value, METH_VARARGS, "\n"
-		"gp_widget_get_value(widget) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"widget: gphoto2.CameraWidget\n"
-		"\n"
-		"Retrieves the value of the CameraWidget.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `widget` :  \n"
-		"    a CameraWidget  \n"
-		"* `value` :  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		"\n"
-		"See also gphoto2.CameraWidget.get_value\n"
-		""},
-	 { "gp_widget_get_children", _wrap_gp_widget_get_children, METH_VARARGS, "\n"
-		"gp_widget_get_children(widget) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"widget: gphoto2.CameraWidget\n"
-		"\n"
-		"Gets all the child widgets of a CameraWidget. The return value is a list\n"
-		"containing a gphoto2 error code and a Python iterator. The iterator can\n"
-		"be used to get each child in sequence.\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `widget` :\n"
-		"    a CameraWidget\n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code and a Python iterator.\n"
-		"\n"
-		"See also gphoto2.CameraWidget.get_children\n"
-		""},
-	 { "gp_widget_get_choices", _wrap_gp_widget_get_choices, METH_VARARGS, "\n"
-		"gp_widget_get_choices(widget) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"widget: gphoto2.CameraWidget\n"
-		"\n"
-		"Gets all the choice values of a CameraWidget. The return value is a list\n"
-		"containing a gphoto2 error code and a Python iterator. The iterator can\n"
-		"be used to get each choice in sequence.\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `widget` :\n"
-		"    a CameraWidget\n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code and a Python iterator.\n"
-		"\n"
-		"See also gphoto2.CameraWidget.get_choices\n"
-		""},
-	 { "gp_widget_append", _wrap_gp_widget_append, METH_VARARGS, "\n"
-		"gp_widget_append(widget, child) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"widget: gphoto2.CameraWidget\n"
-		"child: gphoto2.CameraWidget\n"
-		"\n"
-		"Appends a CameraWidget to a CameraWidget.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `widget` :  \n"
-		"    a CameraWidget  \n"
-		"* `child` :  \n"
-		"    the CameraWidget you would like to append to above  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		"\n"
-		"See also gphoto2.CameraWidget.append\n"
-		""},
-	 { "gp_widget_prepend", _wrap_gp_widget_prepend, METH_VARARGS, "\n"
-		"gp_widget_prepend(widget, child) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"widget: gphoto2.CameraWidget\n"
-		"child: gphoto2.CameraWidget\n"
-		"\n"
-		"Prepends a CameraWidget to a CameraWidget.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `widget` :  \n"
-		"    a CameraWidget  \n"
-		"* `child` :  \n"
-		"    the CameraWidget you would like to prepend to above  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		"\n"
-		"See also gphoto2.CameraWidget.prepend\n"
-		""},
-	 { "gp_widget_count_children", _wrap_gp_widget_count_children, METH_VARARGS, "\n"
-		"gp_widget_count_children(widget) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"widget: gphoto2.CameraWidget\n"
-		"\n"
-		"Counts the children of the CameraWidget.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `widget` :  \n"
-		"    a CameraWidget  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code or number of children\n"
-		"\n"
-		"See also gphoto2.CameraWidget.count_children\n"
-		""},
-	 { "gp_widget_get_child", _wrap_gp_widget_get_child, METH_VARARGS, "\n"
-		"gp_widget_get_child(widget, child_number) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"widget: gphoto2.CameraWidget\n"
-		"child_number: int\n"
-		"\n"
-		"Retrieves the child number `child_number` of the parent.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `widget` :  \n"
-		"    a CameraWidget  \n"
-		"* `child_number` :  \n"
-		"    the number of the child  \n"
-		"* `child` :  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		"\n"
-		"See also gphoto2.CameraWidget.get_child\n"
-		""},
-	 { "gp_widget_get_child_by_label", _wrap_gp_widget_get_child_by_label, METH_VARARGS, "\n"
-		"gp_widget_get_child_by_label(widget, label) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"widget: gphoto2.CameraWidget\n"
-		"label: str\n"
-		"\n"
-		"Retrieves the child with label `label` of the CameraWidget.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `widget` :  \n"
-		"    a CameraWidget  \n"
-		"* `label` :  \n"
-		"    the label of the child  \n"
-		"* `child` :  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		"\n"
-		"See also gphoto2.CameraWidget.get_child_by_label\n"
-		""},
-	 { "gp_widget_get_child_by_id", _wrap_gp_widget_get_child_by_id, METH_VARARGS, "\n"
-		"gp_widget_get_child_by_id(widget, id) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"widget: gphoto2.CameraWidget\n"
-		"id: int\n"
-		"\n"
-		"Retrieves the child with id `id` of the widget.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `widget` :  \n"
-		"    a CameraWidget  \n"
-		"* `id` :  \n"
-		"    the id of the child  \n"
-		"* `child` :  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		"\n"
-		"See also gphoto2.CameraWidget.get_child_by_id\n"
-		""},
-	 { "gp_widget_get_child_by_name", _wrap_gp_widget_get_child_by_name, METH_VARARGS, "\n"
-		"gp_widget_get_child_by_name(widget, name) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"widget: gphoto2.CameraWidget\n"
-		"name: str\n"
-		"\n"
-		"Retrieves the child with name `name` of the widget.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `widget` :  \n"
-		"    a CameraWidget  \n"
-		"* `name` :  \n"
-		"    the name of the child  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		"\n"
-		"See also gphoto2.CameraWidget.get_child_by_name\n"
-		""},
-	 { "gp_widget_get_root", _wrap_gp_widget_get_root, METH_VARARGS, "\n"
-		"gp_widget_get_root(widget) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"widget: gphoto2.CameraWidget\n"
-		"\n"
-		"Retrieves the root of the CameraWidget.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `widget` :  \n"
-		"    a CameraWidget  \n"
-		"* `root` :  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		"\n"
-		"See also gphoto2.CameraWidget.get_root\n"
-		""},
-	 { "gp_widget_get_parent", _wrap_gp_widget_get_parent, METH_VARARGS, "\n"
-		"gp_widget_get_parent(widget) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"widget: gphoto2.CameraWidget\n"
-		"\n"
-		"Retrieves the parent of a CameraWidget.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `widget` :  \n"
-		"    a CameraWidget  \n"
-		"* `parent` :  \n"
-		"    the pointer to the parent to return  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		"\n"
-		"See also gphoto2.CameraWidget.get_parent\n"
-		""},
-	 { "gp_widget_set_value", _wrap_gp_widget_set_value, METH_VARARGS, "\n"
-		"gp_widget_set_value(widget, value) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"widget: gphoto2.CameraWidget\n"
-		"value: int/float/str\n"
-		"\n"
-		"Sets the value of the widget.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `widget` :  \n"
-		"    a CameraWidget  \n"
-		"* `value` :  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.  \n"
-		"\n"
-		"Please pass (char*) for GP_WIDGET_MENU, GP_WIDGET_TEXT, GP_WIDGET_RADIO,\n"
-		"(float) for GP_WIDGET_RANGE, (int) for GP_WIDGET_DATE, GP_WIDGET_TOGGLE,\n"
-		"and (CameraWidgetCallback) for GP_WIDGET_BUTTON.\n"
-		"\n"
-		"See also gphoto2.CameraWidget.set_value\n"
-		""},
-	 { "gp_widget_set_name", _wrap_gp_widget_set_name, METH_VARARGS, "\n"
-		"gp_widget_set_name(widget, name) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"widget: gphoto2.CameraWidget\n"
-		"name: str\n"
-		"\n"
-		"Sets the name of the widget.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `widget` :  \n"
-		"    a CameraWidget  \n"
-		"* `name` :  \n"
-		"    Name of above widget  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		"\n"
-		"See also gphoto2.CameraWidget.set_name\n"
-		""},
-	 { "gp_widget_get_name", _wrap_gp_widget_get_name, METH_VARARGS, "\n"
-		"gp_widget_get_name(widget) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"widget: gphoto2.CameraWidget\n"
-		"\n"
-		"Gets the name of the widget.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `widget` :  \n"
-		"    a CameraWidget  \n"
-		"* `name` :  \n"
-		"    Name of above widget  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		"\n"
-		"See also gphoto2.CameraWidget.get_name\n"
-		""},
-	 { "gp_widget_set_info", _wrap_gp_widget_set_info, METH_VARARGS, "\n"
-		"gp_widget_set_info(widget, info) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"widget: gphoto2.CameraWidget\n"
-		"info: str\n"
-		"\n"
-		"Sets the information about the widget.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `widget` :  \n"
-		"    a CameraWidget  \n"
-		"* `info` :  \n"
-		"    Information about above widget  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		"\n"
-		"See also gphoto2.CameraWidget.set_info\n"
-		""},
-	 { "gp_widget_get_info", _wrap_gp_widget_get_info, METH_VARARGS, "\n"
-		"gp_widget_get_info(widget) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"widget: gphoto2.CameraWidget\n"
-		"\n"
-		"Retrieves the information about the widget.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `widget` :  \n"
-		"    a CameraWidget  \n"
-		"* `info` :  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		"\n"
-		"See also gphoto2.CameraWidget.get_info\n"
-		""},
-	 { "gp_widget_get_id", _wrap_gp_widget_get_id, METH_VARARGS, "\n"
-		"gp_widget_get_id(widget) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"widget: gphoto2.CameraWidget\n"
-		"\n"
-		"Retrieves the unique id of the CameraWidget.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `widget` :  \n"
-		"    a CameraWidget  \n"
-		"* `id` :  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		"\n"
-		"See also gphoto2.CameraWidget.get_id\n"
-		""},
-	 { "gp_widget_get_type", _wrap_gp_widget_get_type, METH_VARARGS, "\n"
-		"gp_widget_get_type(widget) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"widget: gphoto2.CameraWidget\n"
-		"\n"
-		"Retrieves the type of the CameraWidget.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `widget` :  \n"
-		"    a CameraWidget  \n"
-		"* `type` :  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		"\n"
-		"See also gphoto2.CameraWidget.get_type\n"
-		""},
-	 { "gp_widget_get_label", _wrap_gp_widget_get_label, METH_VARARGS, "\n"
-		"gp_widget_get_label(widget) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"widget: gphoto2.CameraWidget\n"
-		"\n"
-		"Retrieves the label of the CameraWidget.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `widget` :  \n"
-		"    a CameraWidget  \n"
-		"* `label` :  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		"\n"
-		"See also gphoto2.CameraWidget.get_label\n"
-		""},
-	 { "gp_widget_set_range", _wrap_gp_widget_set_range, METH_VARARGS, "\n"
-		"gp_widget_set_range(range, low, high, increment) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"range: gphoto2.CameraWidget\n"
-		"low: float\n"
-		"high: float\n"
-		"increment: float\n"
-		"\n"
-		"Sets some range parameters of the CameraWidget.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `range` :  \n"
-		"    a CameraWidget of type GP_WIDGET_RANGE  \n"
-		"* `min` :  \n"
-		"* `max` :  \n"
-		"* `increment` :  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		"\n"
-		"See also gphoto2.CameraWidget.set_range\n"
-		""},
-	 { "gp_widget_get_range", _wrap_gp_widget_get_range, METH_VARARGS, "\n"
-		"gp_widget_get_range(range) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"range: gphoto2.CameraWidget\n"
-		"\n"
-		"Retrieves some range parameters of the CameraWidget.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `range` :  \n"
-		"    a CameraWidget of type GP_WIDGET_RANGE  \n"
-		"* `min` :  \n"
-		"* `max` :  \n"
-		"* `increment` :  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		"\n"
-		"See also gphoto2.CameraWidget.get_range\n"
-		""},
-	 { "gp_widget_add_choice", _wrap_gp_widget_add_choice, METH_VARARGS, "\n"
-		"gp_widget_add_choice(widget, choice) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"widget: gphoto2.CameraWidget\n"
-		"choice: str\n"
-		"\n"
-		"Adds a choice to the CameraWidget.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `widget` :  \n"
-		"    a CameraWidget of type GP_WIDGET_RADIO or GP_WIDGET_MENU  \n"
-		"* `choice` :  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		"\n"
-		"See also gphoto2.CameraWidget.add_choice\n"
-		""},
-	 { "gp_widget_count_choices", _wrap_gp_widget_count_choices, METH_VARARGS, "\n"
-		"gp_widget_count_choices(widget) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"widget: gphoto2.CameraWidget\n"
-		"\n"
-		"Counts the choices of the CameraWidget.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `widget` :  \n"
-		"    a CameraWidget of type GP_WIDGET_RADIO or GP_WIDGET_MENU  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code or number of choices.\n"
-		"\n"
-		"See also gphoto2.CameraWidget.count_choices\n"
-		""},
-	 { "gp_widget_get_choice", _wrap_gp_widget_get_choice, METH_VARARGS, "\n"
-		"gp_widget_get_choice(widget, choice_number) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"widget: gphoto2.CameraWidget\n"
-		"choice_number: int\n"
-		"\n"
-		"Retrieves the choice number `choice_number`.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `widget` :  \n"
-		"    a CameraWidget of type GP_WIDGET_RADIO or GP_WIDGET_MENU  \n"
-		"* `choice_number` :  \n"
-		"* `choice` :  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code\n"
-		"\n"
-		"See also gphoto2.CameraWidget.get_choice\n"
-		""},
-	 { "gp_widget_changed", _wrap_gp_widget_changed, METH_VARARGS, "\n"
-		"gp_widget_changed(widget) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"widget: gphoto2.CameraWidget\n"
-		"\n"
-		"Tells if the widget has been changed.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `widget` :  \n"
-		"    a CameraWidget  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code or changed flag.  \n"
-		"\n"
-		"Returns 1 if the state of the CameraWidget has been changed or 0 if not.  \n"
-		"\n"
-		"Note: this formerly cleared the changed state. It no longer does with\n"
-		"2.5.11.\n"
-		"\n"
-		"See also gphoto2.CameraWidget.changed\n"
-		""},
-	 { "gp_widget_set_changed", _wrap_gp_widget_set_changed, METH_VARARGS, "\n"
-		"gp_widget_set_changed(widget, changed) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"widget: gphoto2.CameraWidget\n"
-		"changed: int\n"
-		"\n"
-		"Tells that the widget has been changed.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `widget` :  \n"
-		"    a CameraWidget  \n"
-		"* `changed` :  \n"
-		"    a boolean whether we changed or not  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code  \n"
-		"\n"
-		"Sets the changed of the CameraWidget depending on the changed parameter.\n"
-		"\n"
-		"See also gphoto2.CameraWidget.set_changed\n"
-		""},
-	 { "gp_widget_set_readonly", _wrap_gp_widget_set_readonly, METH_VARARGS, "\n"
-		"gp_widget_set_readonly(widget, readonly) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"widget: gphoto2.CameraWidget\n"
-		"readonly: int\n"
-		"\n"
-		"Tells that the widget is readonly.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `widget` :  \n"
-		"    a CameraWidget  \n"
-		"* `changed` :  \n"
-		"    a boolean whether we are readonly or not  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code  \n"
-		"\n"
-		"Sets the readonly of the CameraWidget depending on the changed\n"
-		"parameter.  \n"
-		"\n"
-		"Only useful when called from the camera driver.\n"
-		"\n"
-		"See also gphoto2.CameraWidget.set_readonly\n"
-		""},
-	 { "gp_widget_get_readonly", _wrap_gp_widget_get_readonly, METH_VARARGS, "\n"
-		"gp_widget_get_readonly(widget) -> int\n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"widget: gphoto2.CameraWidget\n"
-		"\n"
-		"Retrieves the readonly state of the CameraWidget.  \n"
-		"\n"
-		"Parameters\n"
-		"----------\n"
-		"* `widget` :  \n"
-		"    a CameraWidget  \n"
-		"* `readonly` :  \n"
-		"\n"
-		"Returns\n"
-		"-------\n"
-		"a gphoto2 error code.\n"
-		"\n"
-		"See also gphoto2.CameraWidget.get_readonly\n"
-		""},
-	 { NULL, NULL, 0, NULL }
-};
-
-static PyMethodDef SwigMethods_proxydocs[] = {
-	 { "SWIG_PyInstanceMethod_New", SWIG_PyInstanceMethod_New, METH_O, NULL},
-	 { "SWIG_PyStaticMethod_New", SWIG_PyStaticMethod_New, METH_O, NULL},
 	 { "gp_widget_get_value", _wrap_gp_widget_get_value, METH_VARARGS, "\n"
 		"gp_widget_get_value(widget) -> int\n"
 		"\n"
 		"Parameters\n"
 		"----------\n"
 		"widget: gphoto2.CameraWidget\n"
 		"\n"
@@ -8312,15 +8023,19 @@
     PyObject_HEAD_INIT(NULL)
     0,                                        /* ob_size */
 #endif
     "gphoto2.widget.CameraWidgetChildIter",   /* tp_name */
     sizeof(SwigPyObject),                     /* tp_basicsize */
     0,                                        /* tp_itemsize */
     _wrap_delete_CameraWidgetChildIter_destructor_closure,        /* tp_dealloc */
+#if PY_VERSION_HEX < 0x030800b4
     (printfunc) 0,                            /* tp_print */
+#else
+    (Py_ssize_t) 0,                           /* tp_vectorcall_offset */
+#endif
     (getattrfunc) 0,                          /* tp_getattr */
     (setattrfunc) 0,                          /* tp_setattr */
 #if PY_VERSION_HEX >= 0x03000000
     0,                                        /* tp_compare */
 #else
     (cmpfunc) 0,                              /* tp_compare */
 #endif
@@ -8384,14 +8099,17 @@
 #endif
   },
 #if PY_VERSION_HEX >= 0x03050000
   {
     (unaryfunc) 0,                            /* am_await */
     (unaryfunc) 0,                            /* am_aiter */
     (unaryfunc) 0,                            /* am_anext */
+# if PY_VERSION_HEX >= 0x030a0000
+    (sendfunc) 0,                             /* am_send */
+# endif
   },
 #endif
   {
     (binaryfunc) 0,                           /* nb_add */
     (binaryfunc) 0,                           /* nb_subtract */
     (binaryfunc) 0,                           /* nb_multiply */
 #if PY_VERSION_HEX < 0x03000000
@@ -8484,14 +8202,23 @@
   },
     (PyObject *) 0,                           /* ht_name */
     (PyObject *) 0,                           /* ht_slots */
 #if PY_VERSION_HEX >= 0x03030000
     (PyObject *) 0,                           /* ht_qualname */
     0,                                        /* ht_cached_keys */
 #endif
+#if PY_VERSION_HEX >= 0x03090000
+    (PyObject *) 0,                           /* ht_module */
+#endif
+#if PY_VERSION_HEX >= 0x030b0000
+    (char *) 0,                               /* _ht_tpname */
+  {
+    (PyObject *) 0,                           /* getitem */
+  }
+#endif
 };
 
 SWIGINTERN SwigPyClientData SwigPyBuiltin__CameraWidgetChildIter_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__CameraWidgetChildIter_type};
 
 static SwigPyGetSet CameraWidgetChoiceIter___dict___getset = { SwigPyObject_get___dict__, 0 };
 SWIGINTERN PyGetSetDef SwigPyBuiltin__CameraWidgetChoiceIter_getset[] = {
     { (char *)"__dict__", SwigPyBuiltin_GetterClosure, 0, (char *)"\n"
@@ -8546,15 +8273,19 @@
     PyObject_HEAD_INIT(NULL)
     0,                                        /* ob_size */
 #endif
     "gphoto2.widget.CameraWidgetChoiceIter",  /* tp_name */
     sizeof(SwigPyObject),                     /* tp_basicsize */
     0,                                        /* tp_itemsize */
     _wrap_delete_CameraWidgetChoiceIter_destructor_closure,       /* tp_dealloc */
+#if PY_VERSION_HEX < 0x030800b4
     (printfunc) 0,                            /* tp_print */
+#else
+    (Py_ssize_t) 0,                           /* tp_vectorcall_offset */
+#endif
     (getattrfunc) 0,                          /* tp_getattr */
     (setattrfunc) 0,                          /* tp_setattr */
 #if PY_VERSION_HEX >= 0x03000000
     0,                                        /* tp_compare */
 #else
     (cmpfunc) 0,                              /* tp_compare */
 #endif
@@ -8618,14 +8349,17 @@
 #endif
   },
 #if PY_VERSION_HEX >= 0x03050000
   {
     (unaryfunc) 0,                            /* am_await */
     (unaryfunc) 0,                            /* am_aiter */
     (unaryfunc) 0,                            /* am_anext */
+# if PY_VERSION_HEX >= 0x030a0000
+    (sendfunc) 0,                             /* am_send */
+# endif
   },
 #endif
   {
     (binaryfunc) 0,                           /* nb_add */
     (binaryfunc) 0,                           /* nb_subtract */
     (binaryfunc) 0,                           /* nb_multiply */
 #if PY_VERSION_HEX < 0x03000000
@@ -8718,14 +8452,23 @@
   },
     (PyObject *) 0,                           /* ht_name */
     (PyObject *) 0,                           /* ht_slots */
 #if PY_VERSION_HEX >= 0x03030000
     (PyObject *) 0,                           /* ht_qualname */
     0,                                        /* ht_cached_keys */
 #endif
+#if PY_VERSION_HEX >= 0x03090000
+    (PyObject *) 0,                           /* ht_module */
+#endif
+#if PY_VERSION_HEX >= 0x030b0000
+    (char *) 0,                               /* _ht_tpname */
+  {
+    (PyObject *) 0,                           /* getitem */
+  }
+#endif
 };
 
 SWIGINTERN SwigPyClientData SwigPyBuiltin__CameraWidgetChoiceIter_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__CameraWidgetChoiceIter_type};
 
 static SwigPyGetSet CameraWidget___dict___getset = { SwigPyObject_get___dict__, 0 };
 SWIGINTERN PyGetSetDef SwigPyBuiltin___CameraWidget_getset[] = {
     { (char *)"__dict__", SwigPyBuiltin_GetterClosure, 0, (char *)"\n"
@@ -9294,15 +9037,19 @@
     PyObject_HEAD_INIT(NULL)
     0,                                        /* ob_size */
 #endif
     "gphoto2.widget.CameraWidget",            /* tp_name */
     sizeof(SwigPyObject),                     /* tp_basicsize */
     0,                                        /* tp_itemsize */
     _wrap_delete_CameraWidget_destructor_closure,                 /* tp_dealloc */
+#if PY_VERSION_HEX < 0x030800b4
     (printfunc) 0,                            /* tp_print */
+#else
+    (Py_ssize_t) 0,                           /* tp_vectorcall_offset */
+#endif
     (getattrfunc) 0,                          /* tp_getattr */
     (setattrfunc) 0,                          /* tp_setattr */
 #if PY_VERSION_HEX >= 0x03000000
     0,                                        /* tp_compare */
 #else
     (cmpfunc) 0,                              /* tp_compare */
 #endif
@@ -9371,14 +9118,17 @@
 #endif
   },
 #if PY_VERSION_HEX >= 0x03050000
   {
     (unaryfunc) 0,                            /* am_await */
     (unaryfunc) 0,                            /* am_aiter */
     (unaryfunc) 0,                            /* am_anext */
+# if PY_VERSION_HEX >= 0x030a0000
+    (sendfunc) 0,                             /* am_send */
+# endif
   },
 #endif
   {
     (binaryfunc) 0,                           /* nb_add */
     (binaryfunc) 0,                           /* nb_subtract */
     (binaryfunc) 0,                           /* nb_multiply */
 #if PY_VERSION_HEX < 0x03000000
@@ -9471,80 +9221,89 @@
   },
     (PyObject *) 0,                           /* ht_name */
     (PyObject *) 0,                           /* ht_slots */
 #if PY_VERSION_HEX >= 0x03030000
     (PyObject *) 0,                           /* ht_qualname */
     0,                                        /* ht_cached_keys */
 #endif
+#if PY_VERSION_HEX >= 0x03090000
+    (PyObject *) 0,                           /* ht_module */
+#endif
+#if PY_VERSION_HEX >= 0x030b0000
+    (char *) 0,                               /* _ht_tpname */
+  {
+    (PyObject *) 0,                           /* getitem */
+  }
+#endif
 };
 
 SWIGINTERN SwigPyClientData SwigPyBuiltin___CameraWidget_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin___CameraWidget_type};
 
 
 /* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */
 
 static swig_type_info _swigt__p_CameraAbilities = {"_p_CameraAbilities", "CameraAbilities *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraCaptureType = {"_p_CameraCaptureType", "enum CameraCaptureType *|CameraCaptureType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraDriverStatus = {"_p_CameraDriverStatus", "enum CameraDriverStatus *|CameraDriverStatus *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraEventType = {"_p_CameraEventType", "enum CameraEventType *|CameraEventType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileAccessType = {"_p_CameraFileAccessType", "enum CameraFileAccessType *|CameraFileAccessType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileInfoFields = {"_p_CameraFileInfoFields", "enum CameraFileInfoFields *|CameraFileInfoFields *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileOperation = {"_p_CameraFileOperation", "enum CameraFileOperation *|CameraFileOperation *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraCaptureType = {"_p_CameraCaptureType", "CameraCaptureType *|enum CameraCaptureType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraDriverStatus = {"_p_CameraDriverStatus", "CameraDriverStatus *|enum CameraDriverStatus *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraEventType = {"_p_CameraEventType", "CameraEventType *|enum CameraEventType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileAccessType = {"_p_CameraFileAccessType", "CameraFileAccessType *|enum CameraFileAccessType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileInfoFields = {"_p_CameraFileInfoFields", "CameraFileInfoFields *|enum CameraFileInfoFields *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileOperation = {"_p_CameraFileOperation", "CameraFileOperation *|enum CameraFileOperation *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_CameraFilePath = {"_p_CameraFilePath", "CameraFilePath *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFilePermissions = {"_p_CameraFilePermissions", "enum CameraFilePermissions *|CameraFilePermissions *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileStatus = {"_p_CameraFileStatus", "enum CameraFileStatus *|CameraFileStatus *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFileType = {"_p_CameraFileType", "enum CameraFileType *|CameraFileType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraFolderOperation = {"_p_CameraFolderOperation", "enum CameraFolderOperation *|CameraFolderOperation *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraOperation = {"_p_CameraOperation", "enum CameraOperation *|CameraOperation *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraStorageAccessType = {"_p_CameraStorageAccessType", "enum CameraStorageAccessType *|CameraStorageAccessType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraStorageFilesystemType = {"_p_CameraStorageFilesystemType", "enum CameraStorageFilesystemType *|CameraStorageFilesystemType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraStorageInfoFields = {"_p_CameraStorageInfoFields", "enum CameraStorageInfoFields *|CameraStorageInfoFields *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraStorageType = {"_p_CameraStorageType", "enum CameraStorageType *|CameraStorageType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFilePermissions = {"_p_CameraFilePermissions", "CameraFilePermissions *|enum CameraFilePermissions *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileStatus = {"_p_CameraFileStatus", "CameraFileStatus *|enum CameraFileStatus *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFileType = {"_p_CameraFileType", "CameraFileType *|enum CameraFileType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraFolderOperation = {"_p_CameraFolderOperation", "CameraFolderOperation *|enum CameraFolderOperation *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraOperation = {"_p_CameraOperation", "CameraOperation *|enum CameraOperation *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraStorageAccessType = {"_p_CameraStorageAccessType", "CameraStorageAccessType *|enum CameraStorageAccessType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraStorageFilesystemType = {"_p_CameraStorageFilesystemType", "CameraStorageFilesystemType *|enum CameraStorageFilesystemType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraStorageInfoFields = {"_p_CameraStorageInfoFields", "CameraStorageInfoFields *|enum CameraStorageInfoFields *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraStorageType = {"_p_CameraStorageType", "CameraStorageType *|enum CameraStorageType *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_CameraText = {"_p_CameraText", "CameraText *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_CameraWidgetChildIter = {"_p_CameraWidgetChildIter", "struct CameraWidgetChildIter *|CameraWidgetChildIter *", 0, 0, (void*)&SwigPyBuiltin__CameraWidgetChildIter_clientdata, 0};
-static swig_type_info _swigt__p_CameraWidgetChoiceIter = {"_p_CameraWidgetChoiceIter", "struct CameraWidgetChoiceIter *|CameraWidgetChoiceIter *", 0, 0, (void*)&SwigPyBuiltin__CameraWidgetChoiceIter_clientdata, 0};
-static swig_type_info _swigt__p_CameraWidgetType = {"_p_CameraWidgetType", "enum CameraWidgetType *|CameraWidgetType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_GPLogLevel = {"_p_GPLogLevel", "enum GPLogLevel *|GPLogLevel *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_GPPortType = {"_p_GPPortType", "enum GPPortType *|GPPortType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_GPVersionVerbosity = {"_p_GPVersionVerbosity", "enum GPVersionVerbosity *|GPVersionVerbosity *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_GphotoDeviceType = {"_p_GphotoDeviceType", "enum GphotoDeviceType *|GphotoDeviceType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_CameraWidgetChildIter = {"_p_CameraWidgetChildIter", "CameraWidgetChildIter *|struct CameraWidgetChildIter *", 0, 0, (void*)&SwigPyBuiltin__CameraWidgetChildIter_clientdata, 0};
+static swig_type_info _swigt__p_CameraWidgetChoiceIter = {"_p_CameraWidgetChoiceIter", "CameraWidgetChoiceIter *|struct CameraWidgetChoiceIter *", 0, 0, (void*)&SwigPyBuiltin__CameraWidgetChoiceIter_clientdata, 0};
+static swig_type_info _swigt__p_CameraWidgetType = {"_p_CameraWidgetType", "CameraWidgetType *|enum CameraWidgetType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GPLogLevel = {"_p_GPLogLevel", "GPLogLevel *|enum GPLogLevel *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GPPortType = {"_p_GPPortType", "GPPortType *|enum GPPortType *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GPVersionVerbosity = {"_p_GPVersionVerbosity", "GPVersionVerbosity *|enum GPVersionVerbosity *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GphotoDeviceType = {"_p_GphotoDeviceType", "GphotoDeviceType *|enum GphotoDeviceType *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_SwigPyObject = {"_p_SwigPyObject", "SwigPyObject *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__Camera = {"_p__Camera", "struct _Camera *|Camera *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraAbilitiesList = {"_p__CameraAbilitiesList", "struct _CameraAbilitiesList *|CameraAbilitiesList *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFile = {"_p__CameraFile", "struct _CameraFile *|CameraFile *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFileHandler = {"_p__CameraFileHandler", "struct _CameraFileHandler *|CameraFileHandler *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFileInfo = {"_p__CameraFileInfo", "struct _CameraFileInfo *|CameraFileInfo *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFileInfoAudio = {"_p__CameraFileInfoAudio", "struct _CameraFileInfoAudio *|CameraFileInfoAudio *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFileInfoFile = {"_p__CameraFileInfoFile", "struct _CameraFileInfoFile *|CameraFileInfoFile *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFileInfoPreview = {"_p__CameraFileInfoPreview", "struct _CameraFileInfoPreview *|CameraFileInfoPreview *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFilesystem = {"_p__CameraFilesystem", "struct _CameraFilesystem *|CameraFilesystem *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFilesystemFuncs = {"_p__CameraFilesystemFuncs", "struct _CameraFilesystemFuncs *|CameraFilesystemFuncs *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraFunctions = {"_p__CameraFunctions", "struct _CameraFunctions *|CameraFunctions *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraList = {"_p__CameraList", "struct _CameraList *|CameraList *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraPrivateCore = {"_p__CameraPrivateCore", "struct _CameraPrivateCore *|CameraPrivateCore *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraPrivateLibrary = {"_p__CameraPrivateLibrary", "struct _CameraPrivateLibrary *|CameraPrivateLibrary *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraStorageInformation = {"_p__CameraStorageInformation", "struct _CameraStorageInformation *|CameraStorageInformation *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__CameraWidget = {"_p__CameraWidget", "struct _CameraWidget *|CameraWidget *|_CameraWidget *", 0, 0, (void*)&SwigPyBuiltin___CameraWidget_clientdata, 0};
-static swig_type_info _swigt__p__GPContext = {"_p__GPContext", "struct _GPContext *|GPContext *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__GPContextFeedback = {"_p__GPContextFeedback", "enum _GPContextFeedback *|GPContextFeedback *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__Camera = {"_p__Camera", "Camera *|struct _Camera *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraAbilitiesList = {"_p__CameraAbilitiesList", "CameraAbilitiesList *|struct _CameraAbilitiesList *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFile = {"_p__CameraFile", "CameraFile *|struct _CameraFile *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFileHandler = {"_p__CameraFileHandler", "CameraFileHandler *|struct _CameraFileHandler *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFileInfo = {"_p__CameraFileInfo", "CameraFileInfo *|struct _CameraFileInfo *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFileInfoAudio = {"_p__CameraFileInfoAudio", "CameraFileInfoAudio *|struct _CameraFileInfoAudio *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFileInfoFile = {"_p__CameraFileInfoFile", "CameraFileInfoFile *|struct _CameraFileInfoFile *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFileInfoPreview = {"_p__CameraFileInfoPreview", "CameraFileInfoPreview *|struct _CameraFileInfoPreview *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFilesystem = {"_p__CameraFilesystem", "CameraFilesystem *|struct _CameraFilesystem *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFilesystemFuncs = {"_p__CameraFilesystemFuncs", "CameraFilesystemFuncs *|struct _CameraFilesystemFuncs *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraFunctions = {"_p__CameraFunctions", "CameraFunctions *|struct _CameraFunctions *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraList = {"_p__CameraList", "CameraList *|struct _CameraList *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraPrivateCore = {"_p__CameraPrivateCore", "CameraPrivateCore *|struct _CameraPrivateCore *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraPrivateLibrary = {"_p__CameraPrivateLibrary", "CameraPrivateLibrary *|struct _CameraPrivateLibrary *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraStorageInformation = {"_p__CameraStorageInformation", "CameraStorageInformation *|struct _CameraStorageInformation *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__CameraWidget = {"_p__CameraWidget", "CameraWidget *|struct _CameraWidget *|_CameraWidget *", 0, 0, (void*)&SwigPyBuiltin___CameraWidget_clientdata, 0};
+static swig_type_info _swigt__p__GPContext = {"_p__GPContext", "GPContext *|struct _GPContext *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__GPContextFeedback = {"_p__GPContextFeedback", "GPContextFeedback *|enum _GPContextFeedback *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p__GPPortInfo = {"_p__GPPortInfo", "_GPPortInfo *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__GPPortInfoList = {"_p__GPPortInfoList", "struct _GPPortInfoList *|GPPortInfoList *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p__GPPortInfoList = {"_p__GPPortInfoList", "GPPortInfoList *|struct _GPPortInfoList *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_float = {"_p_float", "float *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_int = {"_p_int", "intptr_t *|int *|int_least32_t *|int_fast32_t *|int32_t *|int_fast16_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_long = {"_p_long", "long *|time_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_long_long = {"_p_long_long", "int_least64_t *|int_fast64_t *|int64_t *|long long *|intmax_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_p__CameraWidget = {"_p_p__CameraWidget", "struct _CameraWidget **|CameraWidget **", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_int = {"_p_int", "int32_t *|int_fast16_t *|int_fast32_t *|int_least32_t *|intptr_t *|int *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_long = {"_p_long", "time_t *|long *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_long_long = {"_p_long_long", "int64_t *|int_fast64_t *|int_least64_t *|intmax_t *|long long *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_p__CameraWidget = {"_p_p__CameraWidget", "CameraWidget **|struct _CameraWidget **", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_p_char = {"_p_p_char", "char **", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_short = {"_p_short", "short *|int_least16_t *|int16_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_signed_char = {"_p_signed_char", "signed char *|int_least8_t *|int_fast8_t *|int8_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_unsigned_char = {"_p_unsigned_char", "unsigned char *|uint_least8_t *|uint_fast8_t *|uint8_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_unsigned_int = {"_p_unsigned_int", "uintptr_t *|uint_least32_t *|uint_fast32_t *|uint32_t *|unsigned int *|uint_fast16_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_unsigned_long_long = {"_p_unsigned_long_long", "uint_least64_t *|uint_fast64_t *|uint64_t *|unsigned long long *|uintmax_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_unsigned_short = {"_p_unsigned_short", "unsigned short *|uint_least16_t *|uint16_t *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_short = {"_p_short", "int16_t *|int_least16_t *|short *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_signed_char = {"_p_signed_char", "int8_t *|int_fast8_t *|int_least8_t *|signed char *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_unsigned_char = {"_p_unsigned_char", "uint8_t *|uint_fast8_t *|uint_least8_t *|unsigned char *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_unsigned_int = {"_p_unsigned_int", "uint32_t *|uint_fast16_t *|uint_fast32_t *|uint_least32_t *|uintptr_t *|unsigned int *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_unsigned_long_long = {"_p_unsigned_long_long", "uint64_t *|uint_fast64_t *|uint_least64_t *|uintmax_t *|unsigned long long *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_unsigned_short = {"_p_unsigned_short", "uint16_t *|uint_least16_t *|unsigned short *", 0, 0, (void*)0, 0};
 
 static swig_type_info *swig_type_initial[] = {
   &_swigt__p_CameraAbilities,
   &_swigt__p_CameraCaptureType,
   &_swigt__p_CameraDriverStatus,
   &_swigt__p_CameraEventType,
   &_swigt__p_CameraFileAccessType,
@@ -9785,17 +9544,20 @@
 #endif
 #endif
 
 #if 0
 #define SWIGRUNTIME_DEBUG
 #endif
 
+#ifndef SWIG_INIT_CLIENT_DATA_TYPE
+#define SWIG_INIT_CLIENT_DATA_TYPE void *
+#endif
 
 SWIGRUNTIME void
-SWIG_InitializeModule(void *clientdata) {
+SWIG_InitializeModule(SWIG_INIT_CLIENT_DATA_TYPE clientdata) {
   size_t i;
   swig_module_info *module_head, *iter;
   int init;
   
   /* check to see if the circular list has been setup, if not, set it up */
   if (swig_module.next==0) {
     /* Initialize the swig_module */
@@ -9970,228 +9732,14 @@
 
 
 
 #ifdef __cplusplus
 extern "C" {
 #endif
   
-  /* Python-specific SWIG API */
-#define SWIG_newvarlink()                             SWIG_Python_newvarlink()
-#define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
-#define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)
-  
-  /* -----------------------------------------------------------------------------
-   * global variable support code.
-   * ----------------------------------------------------------------------------- */
-  
-  typedef struct swig_globalvar {
-    char       *name;                  /* Name of global variable */
-    PyObject *(*get_attr)(void);       /* Return the current value */
-    int       (*set_attr)(PyObject *); /* Set the value */
-    struct swig_globalvar *next;
-  } swig_globalvar;
-  
-  typedef struct swig_varlinkobject {
-    PyObject_HEAD
-    swig_globalvar *vars;
-  } swig_varlinkobject;
-  
-  SWIGINTERN PyObject *
-  swig_varlink_repr(swig_varlinkobject *SWIGUNUSEDPARM(v)) {
-#if PY_VERSION_HEX >= 0x03000000
-    return PyUnicode_InternFromString("<Swig global variables>");
-#else
-    return PyString_FromString("<Swig global variables>");
-#endif
-  }
-  
-  SWIGINTERN PyObject *
-  swig_varlink_str(swig_varlinkobject *v) {
-#if PY_VERSION_HEX >= 0x03000000
-    PyObject *str = PyUnicode_InternFromString("(");
-    PyObject *tail;
-    PyObject *joined;
-    swig_globalvar *var;
-    for (var = v->vars; var; var=var->next) {
-      tail = PyUnicode_FromString(var->name);
-      joined = PyUnicode_Concat(str, tail);
-      Py_DecRef(str);
-      Py_DecRef(tail);
-      str = joined;
-      if (var->next) {
-        tail = PyUnicode_InternFromString(", ");
-        joined = PyUnicode_Concat(str, tail);
-        Py_DecRef(str);
-        Py_DecRef(tail);
-        str = joined;
-      }
-    }
-    tail = PyUnicode_InternFromString(")");
-    joined = PyUnicode_Concat(str, tail);
-    Py_DecRef(str);
-    Py_DecRef(tail);
-    str = joined;
-#else
-    PyObject *str = PyString_FromString("(");
-    swig_globalvar *var;
-    for (var = v->vars; var; var=var->next) {
-      PyString_ConcatAndDel(&str,PyString_FromString(var->name));
-      if (var->next) PyString_ConcatAndDel(&str,PyString_FromString(", "));
-    }
-    PyString_ConcatAndDel(&str,PyString_FromString(")"));
-#endif
-    return str;
-  }
-  
-  SWIGINTERN void
-  swig_varlink_dealloc(swig_varlinkobject *v) {
-    swig_globalvar *var = v->vars;
-    while (var) {
-      swig_globalvar *n = var->next;
-      free(var->name);
-      free(var);
-      var = n;
-    }
-  }
-  
-  SWIGINTERN PyObject *
-  swig_varlink_getattr(swig_varlinkobject *v, char *n) {
-    PyObject *res = NULL;
-    swig_globalvar *var = v->vars;
-    while (var) {
-      if (strcmp(var->name,n) == 0) {
-        res = (*var->get_attr)();
-        break;
-      }
-      var = var->next;
-    }
-    if (res == NULL && !PyErr_Occurred()) {
-      PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
-    }
-    return res;
-  }
-  
-  SWIGINTERN int
-  swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
-    int res = 1;
-    swig_globalvar *var = v->vars;
-    while (var) {
-      if (strcmp(var->name,n) == 0) {
-        res = (*var->set_attr)(p);
-        break;
-      }
-      var = var->next;
-    }
-    if (res == 1 && !PyErr_Occurred()) {
-      PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
-    }
-    return res;
-  }
-  
-  SWIGINTERN PyTypeObject*
-  swig_varlink_type(void) {
-    static char varlink__doc__[] = "Swig var link object";
-    static PyTypeObject varlink_type;
-    static int type_init = 0;
-    if (!type_init) {
-      const PyTypeObject tmp = {
-#if PY_VERSION_HEX >= 0x03000000
-        PyVarObject_HEAD_INIT(NULL, 0)
-#else
-        PyObject_HEAD_INIT(NULL)
-        0,                                  /* ob_size */
-#endif
-        "swigvarlink",                      /* tp_name */
-        sizeof(swig_varlinkobject),         /* tp_basicsize */
-        0,                                  /* tp_itemsize */
-        (destructor) swig_varlink_dealloc,  /* tp_dealloc */
-        0,                                  /* tp_print */
-        (getattrfunc) swig_varlink_getattr, /* tp_getattr */
-        (setattrfunc) swig_varlink_setattr, /* tp_setattr */
-        0,                                  /* tp_compare */
-        (reprfunc) swig_varlink_repr,       /* tp_repr */
-        0,                                  /* tp_as_number */
-        0,                                  /* tp_as_sequence */
-        0,                                  /* tp_as_mapping */
-        0,                                  /* tp_hash */
-        0,                                  /* tp_call */
-        (reprfunc) swig_varlink_str,        /* tp_str */
-        0,                                  /* tp_getattro */
-        0,                                  /* tp_setattro */
-        0,                                  /* tp_as_buffer */
-        0,                                  /* tp_flags */
-        varlink__doc__,                     /* tp_doc */
-        0,                                  /* tp_traverse */
-        0,                                  /* tp_clear */
-        0,                                  /* tp_richcompare */
-        0,                                  /* tp_weaklistoffset */
-        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
-        0,                                  /* tp_del */
-        0,                                  /* tp_version_tag */
-#if PY_VERSION_HEX >= 0x03040000
-        0,                                  /* tp_finalize */
-#endif
-#if PY_VERSION_HEX >= 0x03080000
-        0,                                  /* tp_vectorcall */
-#endif
-#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
-        0,                                  /* tp_print */
-#endif
-#ifdef COUNT_ALLOCS
-        0,                                  /* tp_allocs */
-        0,                                  /* tp_frees */
-        0,                                  /* tp_maxalloc */
-        0,                                  /* tp_prev */
-        0                                   /* tp_next */
-#endif
-      };
-      varlink_type = tmp;
-      type_init = 1;
-      if (PyType_Ready(&varlink_type) < 0)
-      return NULL;
-    }
-    return &varlink_type;
-  }
-  
-  /* Create a variable linking object for use later */
-  SWIGINTERN PyObject *
-  SWIG_Python_newvarlink(void) {
-    swig_varlinkobject *result = PyObject_NEW(swig_varlinkobject, swig_varlink_type());
-    if (result) {
-      result->vars = 0;
-    }
-    return ((PyObject*) result);
-  }
-  
-  SWIGINTERN void 
-  SWIG_Python_addvarlink(PyObject *p, const char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
-    swig_varlinkobject *v = (swig_varlinkobject *) p;
-    swig_globalvar *gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
-    if (gv) {
-      size_t size = strlen(name)+1;
-      gv->name = (char *)malloc(size);
-      if (gv->name) {
-        memcpy(gv->name, name, size);
-        gv->get_attr = get_attr;
-        gv->set_attr = set_attr;
-        gv->next = v->vars;
-      }
-    }
-    v->vars = gv;
-  }
-  
-  SWIGINTERN PyObject *
-  SWIG_globals(void) {
-    static PyObject *globals = 0;
-    if (!globals) {
-      globals = SWIG_newvarlink();
-    }
-    return globals;
-  }
-  
   /* -----------------------------------------------------------------------------
    * constants/methods manipulation
    * ----------------------------------------------------------------------------- */
   
   /* Install Constants */
   SWIGINTERN void
   SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
@@ -10212,31 +9760,28 @@
       if (obj) {
         PyDict_SetItemString(d, constants[i].name, obj);
         Py_DECREF(obj);
       }
     }
   }
   
-  /* -----------------------------------------------------------------------------*/
-  /* Fix SwigMethods to carry the callback ptrs when needed */
-  /* -----------------------------------------------------------------------------*/
+  /* -----------------------------------------------------------------------------
+   * Patch %callback methods' docstrings to hold the callback ptrs
+   * -----------------------------------------------------------------------------*/
   
   SWIGINTERN void
-  SWIG_Python_FixMethods(PyMethodDef *methods,
-    swig_const_info *const_table,
-    swig_type_info **types,
-    swig_type_info **types_initial) {
+  SWIG_Python_FixMethods(PyMethodDef *methods, const swig_const_info *const_table, swig_type_info **types, swig_type_info **types_initial) {
     size_t i;
     for (i = 0; methods[i].ml_name; ++i) {
       const char *c = methods[i].ml_doc;
       if (!c) continue;
       c = strstr(c, "swig_ptr: ");
       if (c) {
         int j;
-        swig_const_info *ci = 0;
+        const swig_const_info *ci = 0;
         const char *name = c + 10;
         for (j = 0; const_table[j].type; ++j) {
           if (strncmp(const_table[j].name, name, 
               strlen(const_table[j].name)) == 0) {
             ci = &(const_table[j]);
             break;
           }
@@ -10260,76 +9805,21 @@
             }
           }
         }
       }
     }
   } 
   
-  /* -----------------------------------------------------------------------------
-   * Method creation and docstring support functions
-   * ----------------------------------------------------------------------------- */
-  
-  /* -----------------------------------------------------------------------------
-   * Function to find the method definition with the correct docstring for the
-   * proxy module as opposed to the low-level API
-   * ----------------------------------------------------------------------------- */
-  
-  SWIGINTERN PyMethodDef *SWIG_PythonGetProxyDoc(const char *name) {
-    /* Find the function in the modified method table */
-    size_t offset = 0;
-    int found = 0;
-    while (SwigMethods_proxydocs[offset].ml_meth != NULL) {
-      if (strcmp(SwigMethods_proxydocs[offset].ml_name, name) == 0) {
-        found = 1;
-        break;
-      }
-      offset++;
-    }
-    /* Use the copy with the modified docstring if available */
-    return found ? &SwigMethods_proxydocs[offset] : NULL;
-  }
-  
-  /* -----------------------------------------------------------------------------
-   * Wrapper of PyInstanceMethod_New() used in Python 3
-   * It is exported to the generated module, used for -fastproxy
-   * ----------------------------------------------------------------------------- */
-  
-  SWIGINTERN PyObject *SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func) {
-    if (PyCFunction_Check(func)) {
-      PyCFunctionObject *funcobj = (PyCFunctionObject *)func;
-      PyMethodDef *ml = SWIG_PythonGetProxyDoc(funcobj->m_ml->ml_name);
-      if (ml)
-      func = PyCFunction_NewEx(ml, funcobj->m_self, funcobj->m_module);
-    }
-#if PY_VERSION_HEX >= 0x03000000
-    return PyInstanceMethod_New(func);
-#else
-    return PyMethod_New(func, NULL, NULL);
-#endif
-  }
-  
-  /* -----------------------------------------------------------------------------
-   * Wrapper of PyStaticMethod_New()
-   * It is exported to the generated module, used for -fastproxy
-   * ----------------------------------------------------------------------------- */
-  
-  SWIGINTERN PyObject *SWIG_PyStaticMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func) {
-    if (PyCFunction_Check(func)) {
-      PyCFunctionObject *funcobj = (PyCFunctionObject *)func;
-      PyMethodDef *ml = SWIG_PythonGetProxyDoc(funcobj->m_ml->ml_name);
-      if (ml)
-      func = PyCFunction_NewEx(ml, funcobj->m_self, funcobj->m_module);
-    }
-    return PyStaticMethod_New(func);
-  }
-  
 #ifdef __cplusplus
 }
 #endif
 
+
+
+
 /* -----------------------------------------------------------------------------*
  *  Partial Init method
  * -----------------------------------------------------------------------------*/
 
 #ifdef __cplusplus
 extern "C"
 #endif
```

