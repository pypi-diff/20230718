# Comparing `tmp/learnware-0.1.0.99-py3-none-any.whl.zip` & `tmp/learnware-0.1.0.dev0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,29 +1,28 @@
-Zip file size: 36577 bytes, number of entries: 27
--rw-r--r--  2.0 unx      854 b- defN 23-Apr-25 08:52 learnware/__init__.py
--rw-r--r--  2.0 unx     3706 b- defN 23-Apr-25 08:52 learnware/config.py
--rw-r--r--  2.0 unx     1212 b- defN 23-Apr-25 08:52 learnware/logger.py
--rw-r--r--  2.0 unx     1393 b- defN 23-Apr-25 08:52 learnware/utils.py
--rw-r--r--  2.0 unx     2860 b- defN 23-Apr-25 08:52 learnware/learnware/__init__.py
--rw-r--r--  2.0 unx     3746 b- defN 23-Apr-25 08:52 learnware/learnware/base.py
--rw-r--r--  2.0 unx    11996 b- defN 23-Apr-25 08:52 learnware/learnware/reuse.py
--rw-r--r--  2.0 unx     1785 b- defN 23-Apr-25 08:52 learnware/learnware/utils.py
--rw-r--r--  2.0 unx      270 b- defN 23-Apr-25 08:52 learnware/market/__init__.py
--rw-r--r--  2.0 unx     4492 b- defN 23-Apr-25 08:52 learnware/market/anchor.py
--rw-r--r--  2.0 unx     5985 b- defN 23-Apr-25 08:52 learnware/market/base.py
--rw-r--r--  2.0 unx     2940 b- defN 23-Apr-25 08:52 learnware/market/database_ops.py
--rw-r--r--  2.0 unx    31403 b- defN 23-Apr-25 08:52 learnware/market/easy.py
--rw-r--r--  2.0 unx     1063 b- defN 23-Apr-25 08:52 learnware/market/evolve.py
--rw-r--r--  2.0 unx     1175 b- defN 23-Apr-25 08:52 learnware/market/evolve_anchor.py
--rw-r--r--  2.0 unx     2885 b- defN 23-Apr-25 08:52 learnware/market/heterogeneous_feature.py
--rw-r--r--  2.0 unx       28 b- defN 23-Apr-25 08:52 learnware/model/__init__.py
--rw-r--r--  2.0 unx     1661 b- defN 23-Apr-25 08:52 learnware/model/base.py
--rw-r--r--  2.0 unx      133 b- defN 23-Apr-25 08:52 learnware/specification/__init__.py
--rw-r--r--  2.0 unx     2925 b- defN 23-Apr-25 08:52 learnware/specification/base.py
--rw-r--r--  2.0 unx    15787 b- defN 23-Apr-25 08:52 learnware/specification/rkme.py
--rw-r--r--  2.0 unx     2308 b- defN 23-Apr-25 08:52 learnware/specification/utils.py
--rw-r--r--  2.0 unx     1062 b- defN 23-Apr-25 08:53 learnware-0.1.0.99.dist-info/LICENSE
--rw-r--r--  2.0 unx    13476 b- defN 23-Apr-25 08:53 learnware-0.1.0.99.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Apr-25 08:53 learnware-0.1.0.99.dist-info/WHEEL
--rw-r--r--  2.0 unx       10 b- defN 23-Apr-25 08:53 learnware-0.1.0.99.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     2268 b- defN 23-Apr-25 08:53 learnware-0.1.0.99.dist-info/RECORD
-27 files, 117515 bytes uncompressed, 32927 bytes compressed:  72.0%
+Zip file size: 37260 bytes, number of entries: 26
+-rw-r--r--  2.0 unx      855 b- defN 23-Jul-18 07:32 learnware/__init__.py
+-rw-r--r--  2.0 unx     3981 b- defN 23-Jul-18 05:41 learnware/config.py
+-rw-r--r--  2.0 unx     1212 b- defN 23-Jul-18 05:41 learnware/logger.py
+-rw-r--r--  2.0 unx     1393 b- defN 23-Jul-18 05:41 learnware/utils.py
+-rw-r--r--  2.0 unx     2860 b- defN 23-Jul-18 05:41 learnware/learnware/__init__.py
+-rw-r--r--  2.0 unx     3746 b- defN 23-Jul-18 05:41 learnware/learnware/base.py
+-rw-r--r--  2.0 unx    11996 b- defN 23-Jul-18 07:24 learnware/learnware/reuse.py
+-rw-r--r--  2.0 unx     1785 b- defN 23-Jul-18 06:06 learnware/learnware/utils.py
+-rw-r--r--  2.0 unx      270 b- defN 23-Jul-18 05:41 learnware/market/__init__.py
+-rw-r--r--  2.0 unx     4492 b- defN 23-Jul-18 05:41 learnware/market/anchor.py
+-rw-r--r--  2.0 unx     5985 b- defN 23-Jul-18 05:41 learnware/market/base.py
+-rw-r--r--  2.0 unx     4866 b- defN 23-Jul-18 05:41 learnware/market/database_ops.py
+-rw-r--r--  2.0 unx    31698 b- defN 23-Jul-18 05:41 learnware/market/easy.py
+-rw-r--r--  2.0 unx     1063 b- defN 23-Jul-18 05:41 learnware/market/evolve.py
+-rw-r--r--  2.0 unx     1175 b- defN 23-Jul-18 05:41 learnware/market/evolve_anchor.py
+-rw-r--r--  2.0 unx     2885 b- defN 23-Jul-18 05:41 learnware/market/heterogeneous_feature.py
+-rw-r--r--  2.0 unx       28 b- defN 23-Jul-18 05:41 learnware/model/__init__.py
+-rw-r--r--  2.0 unx     1661 b- defN 23-Jul-18 05:41 learnware/model/base.py
+-rw-r--r--  2.0 unx      133 b- defN 23-Jul-18 05:41 learnware/specification/__init__.py
+-rw-r--r--  2.0 unx     3005 b- defN 23-Jul-18 05:41 learnware/specification/base.py
+-rw-r--r--  2.0 unx    16110 b- defN 23-Jul-18 07:32 learnware/specification/rkme.py
+-rw-r--r--  2.0 unx     3905 b- defN 23-Jul-18 07:32 learnware/specification/utils.py
+-rw-r--r--  2.0 unx    14192 b- defN 23-Jul-18 07:32 learnware-0.1.0.dev0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jul-18 07:32 learnware-0.1.0.dev0.dist-info/WHEEL
+-rw-r--r--  2.0 unx       10 b- defN 23-Jul-18 07:32 learnware-0.1.0.dev0.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     2183 b- defN 23-Jul-18 07:32 learnware-0.1.0.dev0.dist-info/RECORD
+26 files, 121581 bytes uncompressed, 33742 bytes compressed:  72.2%
```

## zipnote {}

```diff
@@ -60,23 +60,20 @@
 
 Filename: learnware/specification/rkme.py
 Comment: 
 
 Filename: learnware/specification/utils.py
 Comment: 
 
-Filename: learnware-0.1.0.99.dist-info/LICENSE
+Filename: learnware-0.1.0.dev0.dist-info/METADATA
 Comment: 
 
-Filename: learnware-0.1.0.99.dist-info/METADATA
+Filename: learnware-0.1.0.dev0.dist-info/WHEEL
 Comment: 
 
-Filename: learnware-0.1.0.99.dist-info/WHEEL
+Filename: learnware-0.1.0.dev0.dist-info/top_level.txt
 Comment: 
 
-Filename: learnware-0.1.0.99.dist-info/top_level.txt
-Comment: 
-
-Filename: learnware-0.1.0.99.dist-info/RECORD
+Filename: learnware-0.1.0.dev0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## learnware/__init__.py

```diff
@@ -1,8 +1,8 @@
-__version__ = "0.1.0.99"
+__version__ = "0.1.0.dev"
 
 import os
 from .logger import get_module_logger
 
 
 def init(make_dir: bool = False, tf_loglevel: str = "2", **kwargs):
     from .config import C
```

## learnware/config.py

```diff
@@ -1,17 +1,25 @@
 import os
 import copy
 import logging
+import json
 
 
 class Config:
     def __init__(self, default_conf):
         self.__dict__["_default_config"] = copy.deepcopy(default_conf)  # avoiding conflictions with __getattr__
         self.reset()
 
+        config_file = os.path.join(self.root_path, "config.json")
+        if os.path.exists(config_file):
+           with open(config_file, "r") as f:
+               self.__dict__["_config"].update(json.load(f))
+               pass
+           pass
+
     def __getitem__(self, key):
         return self.__dict__["_config"][key]
 
     def __getattr__(self, attr):
         if attr in self.__dict__["_config"]:
             return self.__dict__["_config"][attr]
 
@@ -126,12 +134,12 @@
     "learnware_pool_path": LEARNWARE_POOL_PATH,
     "learnware_zip_pool_path": LEARNWARE_ZIP_POOL_PATH,
     "learnware_folder_pool_path": LEARNWARE_FOLDER_POOL_PATH,
     "learnware_folder_config": {
         "yaml_file": "learnware.yaml",
         "module_file": "__init__.py",
     },
-    "database_path": DATABASE_PATH,
+    "database_url": f"sqlite:///{DATABASE_PATH}",
     "max_reduced_set_size": 1310720,
 }
 
 C = Config(_DEFAULT_CONFIG)
```

## learnware/market/database_ops.py

```diff
@@ -1,89 +1,151 @@
+from sqlalchemy.ext.declarative import declarative_base
+from sqlalchemy import create_engine, text
+from sqlalchemy import (
+    Column, Integer, Text, DateTime, String
+)
 import os
 import json
-import sqlite3
-from copy import deepcopy
-
-from ..logger import get_module_logger
 from ..learnware import get_learnware_from_dirpath
-from ..config import C
 
-logger = get_module_logger("database_ops")
 
+DeclarativeBase = declarative_base()
+
+
+class Learnware(DeclarativeBase):
+    __tablename__ = 'tb_learnware'
 
-def init_empty_db(func):
-    def wrapper(market_id, *args, **kwargs):
-        conn = sqlite3.connect(os.path.join(C.database_path, f"market_{market_id}.db"))
-        cur = conn.cursor()
-        listOfTables = cur.execute(
-            """SELECT name FROM sqlite_master WHERE type='table' AND name='LEARNWARE'; """
-        ).fetchall()
-        if len(listOfTables) == 0:
-            logger.info("Initializing Database in %s..." % (os.path.join(C.database_path, f"market_{market_id}.db")))
-            cur.execute(
-                """CREATE TABLE LEARNWARE
-            (ID CHAR(10) PRIMARY KEY     NOT NULL,
-            SEMANTIC_SPEC            TEXT     NOT NULL,
-            ZIP_PATH     TEXT NOT NULL,
-            FOLDER_PATH         TEXT NOT NULL,
-            USE_FLAG         TEXT NOT NULL);"""
+    id = Column(String(10), primary_key=True, nullable=False)
+    semantic_spec = Column(Text, nullable=False)
+    zip_path = Column(Text, nullable=False)
+    folder_path = Column(Text, nullable=False)
+    use_flag = Column(Text, nullable=False)
+
+    pass
+
+
+class DatabaseOperations(object):
+
+    def __init__(self, url: str, database_name: str):
+        if url.startswith("sqlite"):
+            url = os.path.join(url, f"{database_name}.db")
+        else:
+            url = f"{url}/{database_name}"
+            pass
+
+        self.url = url
+        self.create_database_if_not_exists(url)
+
+        pass
+
+    
+    def create_database_if_not_exists(self, url):
+        database_exists = True
+
+        if url.startswith("sqlite"):
+            # it is sqlite
+            start = url.find(":///")
+            path = url[start+4:]
+            if os.path.exists(path):
+                database_exists = True
+                pass
+            else:
+                database_exists = False
+                os.makedirs(os.path.dirname(path), exist_ok=True)
+                pass
+            pass
+        elif self.url.startswith("postgresql"):
+            # it is postgresql
+            dbname_start = url.rfind("/")
+            dbname = url[dbname_start+1:]
+            url_no_dbname = url[:dbname_start]
+            engine = create_engine(url_no_dbname)
+
+            with engine.connect() as conn:
+                result = conn.execute(text("SELECT datname FROM pg_database;"))
+                db_list = set()
+
+                for row in  result.fetchall():
+                    db_list.add(row[0].lower())
+                    pass
+
+                if dbname.lower() not in db_list:
+                    database_exists = False
+                    conn.execution_options(isolation_level="AUTOCOMMIT").execute(
+                    text("CREATE DATABASE {0};".format(dbname)))
+                    pass
+                else:
+                    database_exists = True
+                    pass
+                pass
+            engine.dispose()
+            pass
+        else:
+            raise Exception(f"Unsupported database url: {self.url}")
+            pass
+        
+        self.engine = create_engine(url, future=True)
+
+        if not database_exists:
+            DeclarativeBase.metadata.create_all(self.engine)
+            pass
+        pass
+
+    def clear_learnware_table(self):
+        with self.engine.connect() as conn:
+            conn.execute(text("DELETE FROM tb_learnware;"))
+            conn.commit()
+            pass
+        pass
+
+    def add_learnware(self, id: str, semantic_spec: dict, zip_path, folder_path, use_flag: str):
+        with self.engine.connect() as conn:
+            semantic_spec_str = json.dumps(semantic_spec)
+            conn.execute(
+                text(
+                ("INSERT INTO tb_learnware (id, semantic_spec, zip_path, folder_path, use_flag)"
+                 "VALUES (:id, :semantic_spec, :zip_path, :folder_path, :use_flag);")
+                ),
+                dict(id=id, semantic_spec=semantic_spec_str, zip_path=zip_path,
+                folder_path=folder_path, use_flag=use_flag)
             )
-            logger.info("Database Built!")
-        kwargs["cur"] = cur
-        item = func(*args, **kwargs)
-        conn.commit()
-        conn.close()
-        return item
-
-    return wrapper
-
-
-# Clear Learnware Database
-# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-# !!!!!                                    !!!!!
-# !!!!! Do NOT use unless highly necessary !!!!!
-# !!!!!                                    !!!!!
-# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-@init_empty_db
-def clear_learnware_table(cur):
-    logger.warning("!!! Drop Learnware Table !!!")
-    cur.execute("DROP TABLE LEARNWARE")
-
-
-@init_empty_db
-def add_learnware_to_db(id: str, semantic_spec: dict, zip_path: str, folder_path: str, use_flag: str, cur):
-    semantic_spec_str = json.dumps(semantic_spec)
-    cur.execute(
-        "INSERT INTO LEARNWARE (ID,SEMANTIC_SPEC,ZIP_PATH,FOLDER_PATH,USE_FLAG) \
-      VALUES ('%s', '%s', '%s', '%s', '%s')"
-        % (id, semantic_spec_str, zip_path, folder_path, use_flag)
-    )
-
-
-@init_empty_db
-def delete_learnware_from_db(id: str, cur):
-    cur.execute("DELETE from LEARNWARE where ID='%s';" % (id))
-
-
-@init_empty_db
-def load_market_from_db(cur):
-    logger.info("Reload from Database")
-    cursor = cur.execute("SELECT id, semantic_spec, zip_path, FOLDER_PATH from LEARNWARE")
-
-    learnware_list = {}
-    zip_list = {}
-    folder_list = {}
-    max_count = 0
-
-    for id, semantic_spec, zip_path, folder_path in cursor:
-        semantic_spec_dict = json.loads(semantic_spec)
-        new_learnware = get_learnware_from_dirpath(
-            id=id, semantic_spec=semantic_spec_dict, learnware_dirpath=folder_path
-        )
-
-        learnware_list[id] = new_learnware
-        zip_list[id] = zip_path
-        folder_list[id] = folder_path
-        max_count = max(max_count, int(id))
+            conn.commit()
+            pass
+        pass
+    
+    def delete_learnware(self, id: str):
+        with self.engine.connect() as conn:
+            conn.execute(
+                text("DELETE FROM tb_learnware WHERE id=:id;"),
+                dict(id=id)
+            )
+            conn.commit()
+            pass
+        pass
+
+    def load_market(self):
+        with self.engine.connect() as conn:
+            cursor = conn.execute(text("SELECT id, semantic_spec, zip_path, folder_path, use_flag FROM tb_learnware;"))
+
+            learnware_list = {}
+            zip_list = {}
+            folder_list = {}
+            max_count = 0
+
+            for id, semantic_spec, zip_path, folder_path, use_flag in cursor:
+                id = id.strip()
+                semantic_spec_dict = json.loads(semantic_spec)
+                new_learnware = get_learnware_from_dirpath(
+                    id=id, semantic_spec=semantic_spec_dict, learnware_dirpath=folder_path
+                )
+                print(f'load learnware: {id}')
+                learnware_list[id] = new_learnware
+                # assert new_learnware is not None
+                zip_list[id] = zip_path
+                folder_list[id] = folder_path
+                max_count = max(max_count, int(id))
+            pass
+
+        return learnware_list, zip_list, folder_list, max_count + 1
+        pass
 
-    logger.info("Market Reloaded from DB.")
-    return learnware_list, zip_list, folder_list, max_count + 1
+    pass
```

## learnware/market/easy.py

```diff
@@ -5,15 +5,15 @@
 import torch
 import numpy as np
 import pandas as pd
 from cvxopt import solvers, matrix
 from typing import Tuple, Any, List, Union, Dict
 
 from .base import BaseMarket, BaseUserInfo
-from .database_ops import load_market_from_db, add_learnware_to_db, delete_learnware_from_db, clear_learnware_table
+from .database_ops import DatabaseOperations
 
 from ..learnware import Learnware, get_learnware_from_dirpath
 from ..specification import RKMEStatSpecification, Specification
 from ..logger import get_module_logger
 from ..config import C as conf
 
 logger = get_module_logger("market", "INFO")
@@ -50,32 +50,31 @@
         self.learnware_zip_pool_path = os.path.join(self.learnware_pool_path, "zips")
         self.learnware_folder_pool_path = os.path.join(self.learnware_pool_path, "unzipped_learnwares")
         self.learnware_list = {}  # id: Learnware
         self.learnware_zip_list = {}
         self.learnware_folder_list = {}
         self.count = 0
         self.semantic_spec_list = conf.semantic_specs
+        self.dbops = DatabaseOperations(conf.database_url, 'market_' + self.market_id)
         self.reload_market(rebuild=rebuild)  # Automatically reload the market
         logger.info("Market Initialized!")
 
     def reload_market(self, rebuild: bool = False) -> bool:
         if rebuild:
             logger.warning("Warning! You are trying to clear current database!")
             try:
-                clear_learnware_table(market_id=self.market_id)
+                self.dbops.clear_learnware_table()
                 rmtree(self.learnware_pool_path)
             except:
                 pass
 
         os.makedirs(self.learnware_pool_path, exist_ok=True)
         os.makedirs(self.learnware_zip_pool_path, exist_ok=True)
         os.makedirs(self.learnware_folder_pool_path, exist_ok=True)
-        self.learnware_list, self.learnware_zip_list, self.learnware_folder_list, self.count = load_market_from_db(
-            market_id=self.market_id
-        )
+        self.learnware_list, self.learnware_zip_list, self.learnware_folder_list, self.count = self.dbops.load_market()
 
     @classmethod
     def check_learnware(cls, learnware: Learnware) -> int:
         """Check the utility of a learnware
 
         Parameters
         ----------
@@ -199,18 +198,20 @@
             try:
                 os.remove(target_zip_dir)
                 rmtree(target_folder_dir)
             except:
                 pass
             return None, self.INVALID_LEARNWARE
 
+        if new_learnware is None:
+            return None, self.INVALID_LEARNWARE
+        
         check_flag = self.check_learnware(new_learnware)
 
-        add_learnware_to_db(
-            market_id=self.market_id,
+        self.dbops.add_learnware(
             id=id,
             semantic_spec=semantic_spec,
             zip_path=target_zip_dir,
             folder_path=target_folder_dir,
             use_flag=check_flag,
         )
 
@@ -649,14 +650,15 @@
         if "RKMEStatSpecification" not in user_info.stat_info:
             return None, learnware_list, 0.0, None
         elif len(learnware_list) == 0:
             return [], [], 0.0, []
         else:
             user_rkme = user_info.stat_info["RKMEStatSpecification"]
             learnware_list = self._filter_by_rkme_spec_dimension(learnware_list, user_rkme)
+            print('after filter by rkme dimension, learnware_list length is %d' % len(learnware_list))
 
             sorted_dist_list, single_learnware_list = self._search_by_rkme_spec_single(learnware_list, user_rkme)
             if search_method == "auto":
                 mixture_dist, weight_list, mixture_learnware_list = self._search_by_rkme_spec_mixture_auto(
                     learnware_list, user_rkme, max_search_num
                 )
             elif search_method == "greedy":
@@ -673,18 +675,21 @@
                 sorted_score_list = self._convert_dist_to_score(sorted_dist_list)
                 mixture_score = None
             else:
                 merge_score_list = self._convert_dist_to_score(sorted_dist_list + [mixture_dist])
                 sorted_score_list = merge_score_list[:-1]
                 mixture_score = merge_score_list[-1]
 
+            print('after search by rkme spec, learnware_list length is %d' % len(learnware_list))
             # filter learnware with low score
             sorted_score_list, single_learnware_list = self._filter_by_rkme_spec_single(
                 sorted_score_list, single_learnware_list
             )
+
+            print('after filter by rkme spec, learnware_list length is %d' % len(learnware_list))
             return sorted_score_list, single_learnware_list, mixture_score, mixture_learnware_list
 
     def delete_learnware(self, id: str) -> bool:
         """Delete Learnware from market
 
         Parameters
         ----------
@@ -704,15 +709,15 @@
         zip_dir = self.learnware_zip_list[id]
         os.remove(zip_dir)
         folder_dir = self.learnware_folder_list[id]
         rmtree(folder_dir)
         self.learnware_list.pop(id)
         self.learnware_zip_list.pop(id)
         self.learnware_folder_list.pop(id)
-        delete_learnware_from_db(market_id=self.market_id, id=id)
+        self.dbops.delete_learnware(id=id)
 
         return True
 
     def get_semantic_spec_list(self) -> dict:
         return self.semantic_spec_list
 
     def get_learnware_by_ids(self, ids: Union[str, List[str]]) -> Union[Learnware, List[Learnware]]:
```

## learnware/specification/base.py

```diff
@@ -1,9 +1,10 @@
 import copy
 import numpy as np
+from typing import Dict
 
 
 class BaseStatSpecification:
     """The Statistical Specification Interface, which provide save and load method"""
 
     def generate_stat_spec_from_data(self, **kwargs):
         """Construct statistical specification from raw dataset
@@ -33,22 +34,22 @@
         """
         raise NotImplementedError("load is not implemented")
 
 
 class Specification:
     """The specification interface, which manages the semantic specifications and statistical specifications"""
 
-    def __init__(self, semantic_spec: dict = None, stat_spec: dict = None):
+    def __init__(self, semantic_spec: dict = None, stat_spec: Dict[str, BaseStatSpecification] = None):
         """The initialization method
 
         Parameters
         ----------
         semantic_spec : dict, optional
             The initiailzed semantic specification, by default None
-        stat_spec : dict, optional
+        stat_spec : Dict[str, BaseStatSpecification], optional
             The initiailzaed statistical specification, by default None
         """
         self.semantic_spec = semantic_spec
         self.stat_spec = {} if stat_spec is None else stat_spec
 
     def __repr__(self) -> str:
         return "{}(Semantic Specification: {}, Statistical Specification: {})".format(
```

## learnware/specification/rkme.py

```diff
@@ -100,20 +100,25 @@
         """
         alpha = None
         self.num_points = X.shape[0]
         X_shape = X.shape
         Z_shape = tuple([K] + list(X_shape)[1:])
         X = X.reshape(self.num_points, -1)
 
-        # fill np.nan
-        X_nan = np.isnan(X)
-        if X_nan.max() == 1:
+        # Check data values
+        X[np.isinf(X) | np.isneginf(X) | np.isposinf(X) | np.isneginf(X)] = np.nan
+        if np.any(np.isnan(X)):
             for col in range(X.shape[1]):
-                col_mean = np.nanmean(X[:, col])
-                X[:, col] = np.where(X_nan[:, col], col_mean, X[:, col])
+                is_nan = np.isnan(X[:, col])
+                if np.any(is_nan):
+                    if np.all(is_nan):
+                        raise ValueError(f"All values in column {col} are exceptional, e.g., NaN and Inf.")
+                    # Fill np.nan with np.nanmean
+                    col_mean = np.nanmean(X[:, col])
+                    X[:, col] = np.where(is_nan, col_mean, X[:, col])
 
         if not reduce:
             self.z = X.reshape(X_shape)
             self.beta = 1 / self.num_points * np.ones(self.num_points)
             self.z = torch.from_numpy(self.z).double().to(self.device)
             self.beta = torch.from_numpy(self.beta).double().to(self.device)
             return
@@ -384,15 +389,16 @@
         -------
         bool
             True if the RKME is loaded successfully.
         """
         # Load JSON file:
         load_path = filepath
         if os.path.exists(load_path):
-            obj_text = codecs.open(load_path, "r", encoding="utf-8").read()
+            with codecs.open(load_path, "r", encoding="utf-8") as fin:
+                obj_text = fin.read()
             rkme_load = json.loads(obj_text)
             rkme_load["device"] = choose_device(rkme_load["cuda_idx"])
             rkme_load["z"] = torch.from_numpy(np.array(rkme_load["z"]))
             rkme_load["beta"] = torch.from_numpy(np.array(rkme_load["beta"]))
 
             for d in self.__dir__():
                 if d in rkme_load.keys():
@@ -428,15 +434,14 @@
     Returns
     -------
     torch.device
             A torch.device object
     """
     if cuda_idx != -1:
         device = torch.device(f"cuda:{cuda_idx}" if torch.cuda.is_available() else "cpu")
-        # device = torch.device(f"cuda:{cuda_idx}")
     else:
         device = torch.device("cpu")
     return device
 
 
 def torch_rbf_kernel(x1, x2, gamma) -> torch.Tensor:
     """Use pytorch to compute rbf_kernel function at faster speed.
```

## learnware/specification/utils.py

```diff
@@ -1,74 +1,116 @@
+import torch
 import numpy as np
+import pandas as pd
+from typing import Union
 
 from .base import BaseStatSpecification
 from .rkme import RKMEStatSpecification
 from ..config import C
 
 
+def convert_to_numpy(data: Union[np.ndarray, pd.DataFrame, torch.Tensor]):
+    """Convert data to np.ndarray
+
+    Parameters
+    ----------
+    data : np.ndarray, pd.DataFrame, or torch.Tensor
+        The input data that needs to be converted to a NumPy array.
+
+    Returns
+    -------
+    np.ndarray
+        The data converted to a NumPy array.
+    """
+    if isinstance(data, np.ndarray):
+        return data
+    elif isinstance(data, pd.DataFrame):
+        return data.to_numpy()
+    elif isinstance(data, torch.Tensor):
+        return data.detach().cpu().numpy()
+    else:
+        raise TypeError("Unsupported data format. Please provide a NumPy array, a Pandas DataFrame, or a PyTorch Tensor.")
+
+
 def generate_rkme_spec(
-    X: np.ndarray,
+    X: Union[np.ndarray, pd.DataFrame, torch.Tensor],
     gamma: float = 0.1,
-    K: int = 100,
+    reduced_set_size: int = 100,
     step_size: float = 0.1,
     steps: int = 3,
     nonnegative_beta: bool = True,
     reduce: bool = True,
-    cuda_idx: int = -1,
+    cuda_idx: int = None,
 ) -> RKMEStatSpecification:
     """
-            Interface for users to generate Reduced Kernel Mean Embedding (RKME) specification.
-            Return a RKMEStatSpecification object, use .save() method to save as json file.
-
+        Interface for users to generate Reduced Kernel Mean Embedding (RKME) specification.
+        Return a RKMEStatSpecification object, use .save() method to save as json file.
 
     Parameters
     ----------
-    X : np.ndarray
-            Raw data in np.ndarray format.
-            Size of array: (n*d)
+    X : np.ndarray, pd.DataFrame, or torch.Tensor
+        Raw data in np.ndarray, pd.DataFrame, or torch.Tensor format.
+        The shape of X:
+            First dimension represents the number of samples (data points).
+            The remaining dimensions represent the dimensions (features) of each sample.
+            For example, if X has shape (100, 3), it means there are 100 samples, and each sample has 3 features.
     gamma : float
-    Bandwidth in gaussian kernel, by default 0.1.
-    K : int
-            Size of the construced reduced set.
+        Bandwidth in gaussian kernel, by default 0.1.
+    reduced_set_size : int
+        Size of the construced reduced set.
     step_size : float
-            Step size for gradient descent in the iterative optimization.
+        Step size for gradient descent in the iterative optimization.
     steps : int
-            Total rounds in the iterative optimization.
+        Total rounds in the iterative optimization.
     nonnegative_beta : bool, optional
-            True if weights for the reduced set are intended to be kept non-negative, by default False.
+        True if weights for the reduced set are intended to be kept non-negative, by default False.
     reduce : bool, optional
-            Whether shrink original data to a smaller set, by default True
+        Whether shrink original data to a smaller set, by default True
     cuda_idx : int
-            A flag indicating whether use CUDA during RKME computation. -1 indicates CUDA not used.
+        A flag indicating whether use CUDA during RKME computation. -1 indicates CUDA not used.
+        None indicates that CUDA is automatically selected.
 
     Returns
     -------
     RKMEStatSpecification
-            A RKMEStatSpecification object
+        A RKMEStatSpecification object
     """
+    # Convert data type
+    X = convert_to_numpy(X)
     X = np.ascontiguousarray(X).astype(np.float32)
+    
+    # Check reduced_set_size
     max_reduced_set_size = C.max_reduced_set_size
-    if K * X[0].size > max_reduced_set_size:
-        K = max(1, max_reduced_set_size // X[0].size)
+    if reduced_set_size * X[0].size > max_reduced_set_size:
+        reduced_set_size = max(1, max_reduced_set_size // X[0].size)
+    
+    # Check cuda_idx
+    if not torch.cuda.is_available() or cuda_idx == -1:
+        cuda_idx = -1
+    else:
+        num_cuda_devices = torch.cuda.device_count()
+        if cuda_idx is None or not (cuda_idx >= 0 and cuda_idx < num_cuda_devices):
+            cuda_idx = 0
+    
+    # Generate rkme spec
     rkme_spec = RKMEStatSpecification(gamma=gamma, cuda_idx=cuda_idx)
-    rkme_spec.generate_stat_spec_from_data(X, K, step_size, steps, nonnegative_beta, reduce)
+    rkme_spec.generate_stat_spec_from_data(X, reduced_set_size, step_size, steps, nonnegative_beta, reduce)
     return rkme_spec
 
 
 def generate_stat_spec(X: np.ndarray) -> BaseStatSpecification:
     """
-            Interface for users to generate statistical specification.
-            Return a StatSpecification object, use .save() method to save as npy file.
-
+        Interface for users to generate statistical specification.
+        Return a StatSpecification object, use .save() method to save as npy file.
 
     Parameters
     ----------
     X : np.ndarray
-            Raw data in np.ndarray format.
-            Size of array: (n*d)
+        Raw data in np.ndarray format.
+        Size of array: (n*d)
 
     Returns
     -------
     StatSpecification
-            A StatSpecification object
+        A StatSpecification object
     """
-    return None
+    return None
```

## Comparing `learnware-0.1.0.99.dist-info/METADATA` & `learnware-0.1.0.dev0.dist-info/METADATA`

 * *Files 4% similar despite different names*

```diff
@@ -1,27 +1,27 @@
 Metadata-Version: 2.1
 Name: learnware
-Version: 0.1.0.99
+Version: 0.1.0.dev0
 Summary: learnware market project
 Home-page: https://git.nju.edu.cn/learnware/learnware-market
 License: MIT Licence
+Platform: UNKNOWN
 Classifier: Intended Audience :: Science/Research
 Classifier: Intended Audience :: Developers
 Classifier: Programming Language :: Python
 Classifier: Topic :: Software Development
 Classifier: Topic :: Scientific/Engineering
 Classifier: Operating System :: POSIX :: Linux
 Classifier: Operating System :: Microsoft :: Windows
 Classifier: Operating System :: MacOS
 Classifier: Programming Language :: Python :: 3.6
 Classifier: Programming Language :: Python :: 3.7
 Classifier: Programming Language :: Python :: 3.8
 Requires-Python: >=3.6.0
 Description-Content-Type: text/markdown
-License-File: LICENSE
 Requires-Dist: numpy (<1.24,>=1.20.0)
 Requires-Dist: pandas (>=0.25.1)
 Requires-Dist: scipy (>=1.0.0)
 Requires-Dist: matplotlib (>=3.1.3)
 Requires-Dist: torch (>=1.11.0)
 Requires-Dist: cvxopt (>=1.3.0)
 Requires-Dist: tqdm (>=4.65.0)
@@ -37,25 +37,37 @@
 [![Python Versions](https://img.shields.io/pypi/pyversions/learnware.svg?logo=python&logoColor=white)](https://pypi.org/project/learnware/#files)
 [![Platform](https://img.shields.io/badge/platform-linux%20%7C%20windows%20%7C%20macos-lightgrey)](https://pypi.org/project/learnware/#files)
 [![PypI Versions](https://img.shields.io/pypi/v/learnware)](https://pypi.org/project/learnware/#history)
 [![Documentation Status](https://readthedocs.org/projects/learnware/badge/?version=latest)](https://learnware.readthedocs.io/en/latest/?badge=latest)
 [![License](https://img.shields.io/pypi/l/learnware)](LICENSE)
 
 
-<p align="center">
-  <img src="./docs/_static/img/logo/logo1.png" />
-</p>
 
-``Learnware Market`` is a model sharing platform, which give a basic implementation of the learnware paradigm. A learnware is a well-performed trained machine learning model with a specification that enables it to be adequately identified to reuse according to the requirement of future users who may know nothing about the learnware in advance. The learnware paradigm can solve entangled problems in the current machine learning paradigm, like continual learning and catastrophic forgetting. It also reduces resources for training a well-performed model.
+<div align=center>
+  <img src="./docs/_static/img/logo/logo1.png"  width="50%"/>
+</div>
+
+
+``Learnware`` is a model sharing platform, which give a basic implementation of the learnware paradigm. A learnware is a well-performed trained machine learning model with a specification that enables it to be adequately identified to reuse according to the requirement of future users who may know nothing about the learnware in advance. The learnware paradigm can solve entangled problems in the current machine learning paradigm, like continual learning and catastrophic forgetting. It also reduces resources for training a well-performed model.
 
 
 # Introduction
 
 ## Framework 
 
+<div align="center">
+  <img src="./docs/_static/img/learnware_paradigm.jpg" width="70%"/>
+</div>
+
+Machine learning, especially the prevailing big model paradigm, has achieved great success in natural language processing and computer vision applications. However, it still faces challenges such as the requirement of a large amount of labeled training data, difficulty in adapting to changing environments, and catastrophic forgetting when refining trained models incrementally. These big models, while useful in their targeted tasks, often fail to address the above issues and struggle to generalize beyond their specific purposes.
+
+<div align="center">
+  <img src="./docs/_static/img/learnware_market.jpg" width="70%" />
+</div>
+
 The learnware paradigm introduces the concept of a well-performed, trained machine learning model with a specification that allows future users, who have no prior knowledge of the learnware, to reuse it based on their requirements.
 
 Developers or owners of trained machine learning models can submit their models to a learnware market. If accepted, the market assigns a specification to the model and accommodates it. The learnware market could host thousands or millions of well-performed models from different developers, for various tasks, using diverse data, and optimizing different objectives.
 
 Instead of building a model from scratch, users can submit their requirements to the learnware market, which then identifies and deploys helpful learnware(s) based on the specifications. Users can apply the learnware directly, adapt it using their data, or exploit it in other ways to improve their model. This process is more efficient and less expensive than building a model from scratch.
 
 ## Benefits of the Learnware Paradigm
@@ -70,15 +82,15 @@
 | Unplanned tasks | Open to all legal developers, the learnware market can accommodate helpful learnwares for various tasks. |
 | Carbon emission | Assembling small models may offer good-enough performance, reducing interest in training large models and the carbon footprint. |
 
 # Quick Start
 
 ## Installation
 
-Learnware is currently hosted on [PyPI](https://pypi.org/). You can easily intsall ``Learnware Market`` according to the following steps:
+Learnware is currently hosted on [PyPI](https://pypi.org/). You can easily intsall ``Learnware`` according to the following steps:
 
 - For Windows and Linux users:
 
     ```bash
     pip install learnware
     ```
 
@@ -99,57 +111,57 @@
     A python file offering interfaces for your model's fitting, predicting and fine-tuning.
 
 - ``rkme.json``
 
     A json file containing the statistical specification of your data. 
 
 - ``learnware.yaml``
-    
+
     A config file describing your model class name, type of statistical specification(e.g. Reduced Kernel Mean Embedding, ``RKMEStatSpecification``), and 
     the file name of your statistical specification file.
 
 - ``environment.yaml``
 
     A Conda environment configuration file for running the model (if the model environment is incompatible, you can rely on this for manual configuration). 
     You can generate this file according to the following steps:
 
     - Create env config for conda:
 
         ```bash
         conda env export | grep -v "^prefix: " > environment.yaml
         ```
-        
+
     - Recover env from config:
 
         ```bash
         conda env create -f environment.yaml
         ```
 
 We also demonstrate the detail format of learnware zipfile in [DOC link], and also please refer to [Examples](./examples/workflow_by_code/learnware_example) for concrete learnware zipfile example.
 
 ## Learnware Market Workflow
 
-Users can start an ``Learnware Market`` workflow according to the following steps:
+Users can start an ``Learnware`` workflow according to the following steps:
 
 ### Initialize a Learware Market
 
-The ``EasyMarket`` class implements the most basic set of functions in a ``Learnware Market``. 
-You can use the following code snippet to initialize a basic ``Learnware Market`` named "demo":
+The ``EasyMarket`` class implements the most basic set of functions in a ``Learnware``. 
+You can use the following code snippet to initialize a basic ``Learnware`` named "demo":
 
 ```python
 import learnware
 from learnware.market import EasyMarket
 
 learnware.init()
 easy_market = EasyMarket(market_id="demo", rebuild=True)
 ```
 
 ### Upload Leanwares
 
-Before uploading your learnware into the ``Learnware Market``,
+Before uploading your learnware into the ``Learnware``,
 create a semantic specification ``semantic_spec`` by selecting or filling in values for the predefined semantic tags 
 to describe the features of your task and model.
 
 For example, the following code snippet demonstrates the semantic specification 
 of a Scikit-Learn type model, which is designed for business scenario and performs classification on tabular data:
 
 ```python
@@ -161,26 +173,26 @@
     "Description": {"Values": "", "Type": "String"},
     "Name": {"Values": "demo_learnware", "Type": "String"},
 }
 ```
 
 Once the semantic specification is defined, 
 you can easily upload your learnware with a single line of code:
-    
+
 ```python
 easy_market.add_learnware(zip_path, semantic_spec) 
 ```
 
 Here, ``zip_path`` is the directory of your learnware zipfile.
 
 ### Semantic Specification Search
 
 To search for learnwares that fit your task purpose, 
 you should also provide a semantic specification ``user_semantic`` that describes the characteristics of your task.
-The ``Learnware Market`` will perform a first-stage search based on ``user_semantic``,
+The ``Learnware`` will perform a first-stage search based on ``user_semantic``,
 identifying potentially helpful leranwares whose models solve tasks similar to your requirements. 
 
 ```python
 # construct user_info which includes semantic specification for searching learnware
 user_info = BaseUserInfo(id="user", semantic_spec=semantic_spec)
 
 # search_learnware performs semantic specification search if user_info doesn't include a statistical specification
@@ -189,15 +201,15 @@
 # single_learnware_list is the learnware list by semantic specification searching
 print(single_learnware_list)
 ```
 
 ### Statistical Specification Search
 
 If you choose to porvide your own statistical specification file ``stat.json``, 
-the ``Learnware Market`` can perform a more accurate leanware selection from 
+the ``Learnware`` can perform a more accurate leanware selection from 
 the learnwares returned by the previous step. This second-stage search is based on statistical information 
 and returns one or more learnwares that are most likely to be helpful for your task. 
 
 For example, the following code is designed to work with Reduced Set Kernel Embedding as a statistical specification:
 
 ```python
 import learnware.specification as specification
@@ -238,15 +250,15 @@
 # using averaging ensemble reuser to reuse the searched learnwares to make prediction
 reuse_ensemble = AveragingReuser(learnware_list=mixture_learnware_list)
 ensemble_predict_y = reuse_ensemble.predict(user_data=test_x)
 ```
 
 ## Auto Workflow Example
 
-``Learnware Market`` also provides an auto workflow example, which includes preparing learnwares, upload and delete learnware from markets, search learnware with semantic specifications and statistical specifications. The users can run ``examples/workflow_by_code.py`` to try the basic workflow of ``Learnware Market``.
+``Learnware`` also provides an auto workflow example, which includes preparing learnwares, upload and delete learnware from markets, search learnware with semantic specifications and statistical specifications. The users can run ``examples/workflow_by_code.py`` to try the basic workflow of ``Learnware``.
 
 
 # Experiments and Examples
 
 ## Environment
 
 For all experiments, we used a single linux server. Details on the specifications are listed in the table below. All processors were used for training and evaluating.
@@ -265,32 +277,34 @@
 
 ## Results
 
 The time-consuming specification generation is shown in the table below:
 
 | Dataset | Data Dimensions | Specification Generation Time (s) |
 |  ----  | ----  | ----  |
-|  PFS  | NAN  | NAN  |
-|  M5  | NAN | 9~15  |
-|  CIFAR 10 | 9000*3*32*32 | 7~10  |
+|  PFS  | 8714274*31  | < 1.5  |
+|  M5  | 46027957*82 | 9~15  |
+|  CIFAR 10 | 9000\*3\*32\*32 | 7~10  |
 
 
 The accuracy of search and reuse is shown in the table below:
 
 | Dataset | Top-1 Performance | Job Selector Reuse | Average Ensemble Reuse |
 |  ----  | ----  | ----  | ----  |
-|  PFS  | NAN  | NAN  |  NAN  |
+|  PFS  | 1.955 +/- 2.866  | 2.175 +/- 2.847  |  1.950 +/- 2.888  |
 |  M5  | 2.066 +/- 0.424 | 2.116 +/- 0.472  |  2.512 +/- 0.573  |
 |  CIFAR 10 | 0.619 +/- 0.138 | 0.585 +/- 0.056  |  .715 +/- 0.075  |
 
 # About
 
 ## Contributor
 We appreciate all contributions and thank all the contributors!
 
 TODO: Here paste the github API after publishing:
 
 [Pic after publish]()
 
 ## About us
 
-Visit [LAMDA's official website](http://www.lamda.nju.edu.cn/MainPage.ashx),
+Visit [LAMDA's official website](http://www.lamda.nju.edu.cn/MainPage.ashx).
+
+
```

## Comparing `learnware-0.1.0.99.dist-info/RECORD` & `learnware-0.1.0.dev0.dist-info/RECORD`

 * *Files 11% similar despite different names*

```diff
@@ -1,27 +1,26 @@
-learnware/__init__.py,sha256=J-e5k__9g2niIzSVNv5TX0EMI17oK1PyggYlAlWSNKA,854
-learnware/config.py,sha256=K_dtlufvPAsE9BgkO2iISCNRc8Np18klVKMAGDvwm-8,3706
+learnware/__init__.py,sha256=1oD0NjfM_gK1DL9A84EbchOSZEg1XDg3hpJrRpmIvcg,855
+learnware/config.py,sha256=e6Jwgiz4TWtKUUMDoaRkMTyx2LythpVsbhsz1zjbFBY,3981
 learnware/logger.py,sha256=8aFrf115fnZOyqqcLN_nLzA3FMWGO2AaVqGQXPabag4,1212
 learnware/utils.py,sha256=02FP3JF263Cn9rPbKtrdSuIBrtY7yGyzWGxYuloQTk4,1393
 learnware/learnware/__init__.py,sha256=gtEv1KuDDGw54bsuO7QUJWgBynouAfQUgKQ74ty5dXg,2860
 learnware/learnware/base.py,sha256=uDDOymE5GNqhdCaPt6QoWmz7crBLGns5eXAVZx1uJkA,3746
 learnware/learnware/reuse.py,sha256=BrpfXbYhAHtIV9FsN4s-5E89eAqTNgEbWytBwUBKDlU,11996
 learnware/learnware/utils.py,sha256=JNDTTiuLtMILDwu2SRTFPG5ro2cNwnRACxIhCx3ixAk,1785
 learnware/market/__init__.py,sha256=ko1rUsXG4fXG27EtxiN-Ndt20kEkXh3yQAbGqGUvGiE,270
 learnware/market/anchor.py,sha256=sp7dmKmPCnvzF6Aont-gAIFATB5N6qzDCjFZxLm_rLc,4492
 learnware/market/base.py,sha256=EAoM8mb9Tru2h1yiVwqqGSZwU5uOH84-zVrmUZ1yeyM,5985
-learnware/market/database_ops.py,sha256=SHwsUbcWxpnhNfbxLvhc5JAD0PhqQPlcW2VDa6SIz_U,2940
-learnware/market/easy.py,sha256=annzRuFcbD51kj_MU_6JYPnuXoSXEpE_Cur3DtRQ5XY,31403
+learnware/market/database_ops.py,sha256=Ksiawa8wtVp6C9fm3_3zgkSKOsDoYRbMkoEqAHc1GYQ,4866
+learnware/market/easy.py,sha256=0u9TXWR7KmQRIIYiV1xnYNQOMW2T1YO1Hybm_jVfoj0,31698
 learnware/market/evolve.py,sha256=j2g1K6WOfH6HVz_dgDDhkYlRFe3DEnIm7dK3WKyUZXw,1063
 learnware/market/evolve_anchor.py,sha256=ufWA5v8cCHF4CmSYpGQakBT02_jIAzwkO0nvyp2EipM,1175
 learnware/market/heterogeneous_feature.py,sha256=TbgsocW4Ivx6xY667-E69q0f1cLLe2Chdwyn-oOwxGo,2885
 learnware/model/__init__.py,sha256=CJmh144hGLh6OBlI45txWNqWROP5LGAF1ZpWkDc4cQA,28
 learnware/model/base.py,sha256=lF_8xYT6fM_pMapizyCLNPZV70jQeAk8LgesvH3ZGFk,1661
 learnware/specification/__init__.py,sha256=xdvvo1G6uX_ZS31EunQ_8WPvq0m-OnXvo7Strx73CU4,133
-learnware/specification/base.py,sha256=aEXUMNMxYpFqlDEqAMFhtqKsk12bzITT13U6TfKZvXI,2925
-learnware/specification/rkme.py,sha256=YsCsJJcF9LnXvKum4iDknkrYnSsOFpExzRU-GklU8P0,15787
-learnware/specification/utils.py,sha256=DqA6BNydYGyGMTH3vj-kkcMRGEo0RwqyYD8TypSCbF4,2308
-learnware-0.1.0.99.dist-info/LICENSE,sha256=kIk6vGE4CLnMblbcDAwb7NDJ2KVVLNE-qv4B9ZPbaPk,1062
-learnware-0.1.0.99.dist-info/METADATA,sha256=s7zBL0NxehVBf22f06OsLaA9bQqenNBn-0K26HwfxbU,13476
-learnware-0.1.0.99.dist-info/WHEEL,sha256=2wepM1nk4DS4eFpYrW1TTqPcoGNfHhhO_i5m4cOimbo,92
-learnware-0.1.0.99.dist-info/top_level.txt,sha256=9L2y-P7clIzwLZUrASK2FUvwrxH_uSW9hm0zNgf_fUQ,10
-learnware-0.1.0.99.dist-info/RECORD,,
+learnware/specification/base.py,sha256=pUKmbxXRAHUGsIs3npBfScuNlZi6yh84_wMI3btP0H4,3005
+learnware/specification/rkme.py,sha256=llxI7msZJMQKIiZAY0OZBMTpAsQmk3V278KFmFeMCt0,16110
+learnware/specification/utils.py,sha256=PjdNL5w9D7CgXIJTsN7c94S6l-4tto-YYz9AyJPPZ4Q,3905
+learnware-0.1.0.dev0.dist-info/METADATA,sha256=Dpz2ZZSkDbCG5MuoGlatd3tvkYNjKskXyOac0mzejx8,14192
+learnware-0.1.0.dev0.dist-info/WHEEL,sha256=OqRkF0eY5GHssMorFjlbTIq072vpHpF60fIQA6lS9xA,92
+learnware-0.1.0.dev0.dist-info/top_level.txt,sha256=9L2y-P7clIzwLZUrASK2FUvwrxH_uSW9hm0zNgf_fUQ,10
+learnware-0.1.0.dev0.dist-info/RECORD,,
```

