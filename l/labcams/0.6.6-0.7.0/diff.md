# Comparing `tmp/labcams-0.6.6-py3-none-any.whl.zip` & `tmp/labcams-0.7.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,25 +1,25 @@
-Zip file size: 95886 bytes, number of entries: 23
+Zip file size: 92476 bytes, number of entries: 23
 -rw-rw-r--  2.0 unx      832 b- defN 22-Jun-16 04:03 labcams/__init__.py
 -rw-rw-r--  2.0 unx    13689 b- defN 23-Jul-12 17:13 labcams/avt.py
 -rw-rw-r--  2.0 unx     6684 b- defN 23-Jul-12 17:13 labcams/basler.py
 -rw-rw-r--  2.0 unx     8117 b- defN 22-Jun-16 04:03 labcams/cam_stim_trigger.py
--rw-rw-r--  2.0 unx    35453 b- defN 23-Jul-12 17:13 labcams/cams.py
--rw-rw-r--  2.0 unx    23464 b- defN 23-Jul-12 17:13 labcams/gui.py
--rw-rw-r--  2.0 unx    49342 b- defN 23-Jul-12 17:13 labcams/io.py
+-rw-rw-r--  2.0 unx    35578 b- defN 23-Jul-18 01:12 labcams/cams.py
+-rw-rw-r--  2.0 unx    23524 b- defN 23-Jul-18 01:12 labcams/gui.py
+-rw-rw-r--  2.0 unx    49319 b- defN 23-Jul-18 01:12 labcams/io.py
 -rw-rw-r--  2.0 unx    11492 b- defN 23-Jul-12 17:13 labcams/nidaq_acq.py
--rw-rw-r--  2.0 unx    24851 b- defN 23-Jul-12 17:13 labcams/pco.py
+-rw-rw-r--  2.0 unx     6979 b- defN 23-Jul-18 01:12 labcams/pco.py
 -rw-rw-r--  2.0 unx     1216 b- defN 23-Jul-12 17:13 labcams/plugins.py
 -rw-rw-r--  2.0 unx    30459 b- defN 23-Jul-12 17:13 labcams/pointgreycam.py
 -rw-rw-r--  2.0 unx     6310 b- defN 23-Jul-12 17:13 labcams/pvcam.py
 -rw-rw-r--  2.0 unx     6872 b- defN 23-Jul-12 17:13 labcams/qimaging.py
 -rw-rw-r--  2.0 unx    62774 b- defN 22-Apr-23 23:36 labcams/qimaging_dll.py
 -rw-rw-r--  2.0 unx    10107 b- defN 23-Jul-12 17:13 labcams/utils.py
--rw-rw-r--  2.0 unx    47519 b- defN 23-Jul-12 17:13 labcams/widgets.py
+-rw-rw-r--  2.0 unx    47564 b- defN 23-Jul-18 01:12 labcams/widgets.py
 -rw-rw-r--  2.0 unx     5561 b- defN 23-Jul-12 17:13 labcams/ximeacam.py
--rw-rw-r--  2.0 unx    35149 b- defN 23-Jul-12 17:17 labcams-0.6.6.dist-info/LICENSE.txt
--rw-rw-r--  2.0 unx     1975 b- defN 23-Jul-12 17:17 labcams-0.6.6.dist-info/METADATA
--rw-rw-r--  2.0 unx       92 b- defN 23-Jul-12 17:17 labcams-0.6.6.dist-info/WHEEL
--rw-rw-r--  2.0 unx       46 b- defN 23-Jul-12 17:17 labcams-0.6.6.dist-info/entry_points.txt
--rw-rw-r--  2.0 unx        8 b- defN 23-Jul-12 17:17 labcams-0.6.6.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     1768 b- defN 23-Jul-12 17:17 labcams-0.6.6.dist-info/RECORD
-23 files, 383780 bytes uncompressed, 93100 bytes compressed:  75.7%
+-rw-rw-r--  2.0 unx    35149 b- defN 23-Jul-18 01:14 labcams-0.7.0.dist-info/LICENSE.txt
+-rw-rw-r--  2.0 unx     2285 b- defN 23-Jul-18 01:14 labcams-0.7.0.dist-info/METADATA
+-rw-rw-r--  2.0 unx       92 b- defN 23-Jul-18 01:14 labcams-0.7.0.dist-info/WHEEL
+-rw-rw-r--  2.0 unx       46 b- defN 23-Jul-18 01:14 labcams-0.7.0.dist-info/entry_points.txt
+-rw-rw-r--  2.0 unx        8 b- defN 23-Jul-18 01:14 labcams-0.7.0.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     1767 b- defN 23-Jul-18 01:14 labcams-0.7.0.dist-info/RECORD
+23 files, 366424 bytes uncompressed, 89690 bytes compressed:  75.5%
```

## zipnote {}

```diff
@@ -45,26 +45,26 @@
 
 Filename: labcams/widgets.py
 Comment: 
 
 Filename: labcams/ximeacam.py
 Comment: 
 
-Filename: labcams-0.6.6.dist-info/LICENSE.txt
+Filename: labcams-0.7.0.dist-info/LICENSE.txt
 Comment: 
 
-Filename: labcams-0.6.6.dist-info/METADATA
+Filename: labcams-0.7.0.dist-info/METADATA
 Comment: 
 
-Filename: labcams-0.6.6.dist-info/WHEEL
+Filename: labcams-0.7.0.dist-info/WHEEL
 Comment: 
 
-Filename: labcams-0.6.6.dist-info/entry_points.txt
+Filename: labcams-0.7.0.dist-info/entry_points.txt
 Comment: 
 
-Filename: labcams-0.6.6.dist-info/top_level.txt
+Filename: labcams-0.7.0.dist-info/top_level.txt
 Comment: 
 
-Filename: labcams-0.6.6.dist-info/RECORD
+Filename: labcams-0.7.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## labcams/cams.py

```diff
@@ -262,14 +262,15 @@
             return
         idx = frameID % self.nbuffers.value
         if len(frame.shape) == 2:
             self.imgs[idx,:,:,0] = frame[:]
         else:
             self.imgs[idx] = frame[:]
         self.nframes.value = frameID
+        self.lastframeid = int(frameID)
         self.membuffer_lock.release()
 
     def _parse_command_queue(self):
         if not self.eventsQ.empty():
             cmd = self.eventsQ.get()
             if '=' in cmd:
                 cmd = cmd.split('=')
@@ -317,14 +318,15 @@
 
     def _cam_loop(self):
         '''get a frame and move on, returns frame,(frameID,timestamp)'''
         pass
     
     def _cam_waitsoftwaretrigger(self):
         '''wait for software trigger'''
+        self.lastframeid = -1
         while (not self.start_trigger.is_set()):
             # limits resolution to 1 ms 
             time.sleep(0.001)
             if self.close_event.is_set() or self.stop_trigger.is_set():
                 break
             self._handle_frame(None,(None,None)) # to stop saving while waiting for triggers
         if self.close_event.is_set() or self.stop_trigger.is_set():
@@ -671,15 +673,18 @@
             from .pco import PCOCam
         except Exception as err:
             print(err)
             print(''' 
             
                     Could not load the PCO driver. 
 
-    If you want to record from PCO cameras install the PCO.sdk driver.
+    If you want to record from PCO cameras install the PCO driver.
+            
+            pip install pco>2.0.1
+           
     If not you have the wrong config file.
 
             Edit the file in USERHME/labcams/default.json and delete the PCO cam or use the -c option
 
 ''')
         
         self.cam = PCOCam(cam_id=self.cam_id,
```

## labcams/gui.py

```diff
@@ -152,14 +152,16 @@
                                     hardware_trigger_event = self.hardware_trigger_event))
             if hasattr(self.cams[-1],'excitation_trigger'):
                 self.excitation_trigger = self.cams[-1].excitation_trigger
                 self.excitation_trigger_widget = CamStimTriggerWidget(
                     ino = self.cams[-1].excitation_trigger,
                     cam = self.cams[-1].cam)
                 self.camstim_tab = QDockWidget("Camera excitation control",self)
+                self.camstim_tab.setObjectName("Cam stim")
+
                 self.camstim_tab.setWidget(self.excitation_trigger_widget)
                 self.addDockWidget(
                     Qt.LeftDockWidgetArea,
                     self.camstim_tab)
             # Print parameters
             display('\t Camera: {0}'.format(cam['name']))
             for k in np.sort(list(cam.keys())):
```

## labcams/io.py

```diff
@@ -316,20 +316,20 @@
     def _write(self,frame,frameid,timestamp):
         pass
     
     def get_from_queue_and_save(self):
         buff = self.inQ.get()
         qsize = self.inQ.qsize()
         if qsize > 1000:
-            display('[{0} - frame:{1}] Queue size: {2}'.format(
-                self.dataname,frameid,qsize))
+            display('[{0}] Queue size: {1}'.format(
+                self.dataname,qsize))
             while not self.inQ.empty():
                 self.inQ.get()
             display('######################################## ISSUE RECORDING. FRAME COUNT ON QUEUE TOO HIGH. DROPPING FRAMES. #########################')
-            display('########################################          THIS IS NOT NORMAL, CHECK THE INSTALATION.              #########################')
+            display('########################################          THIS IS NOT NORMAL, CHECK THE SETTINGS.              #########################')
             if not self.logfile is None:
                 self.logfile.write('# ISSUE RECORDING. FRAME COUNT ON QUEUE TOO HIGH. DROPPING FRAMES.')
                 self.logfile.write('# THIS IS NOT NORMAL, CHECK THE INSTALATION.')
         buf = None
         if not buff[0] is None:
             if len(buff) > 1:
                 buf = self.get_frame(buff[0])
```

## labcams/pco.py

```diff
@@ -11,79 +11,56 @@
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 from .cams import *
+import pco
 from datetime import datetime
 class PCOCam(GenericCam):
-    time_modes = {0:"ns", 1: "us", 2: "ms"}
     def __init__(self,
                  cam_id = None,
                  name = '',
                  start_trigger = None,
                  stop_trigger = None,
                  save_trigger = None,                 
                  out_q = None,
                  binning = None,
                  exposure = 100,
                  dtype = np.uint16,
-                 use_camera_parameters = True,
                  trigger_source = np.uint16(2),
                  hardware_trigger = None,
-                 dllpath = None,
+                 roi = None,
                  recorderpar = None,
+                 acquire_mode = 'auto', # external
+                 debuglevel = 'off', # verbose
                  **kwargs):
         super(PCOCam,self).__init__(cam_id = cam_id,
                                     name = name,
                                     out_q = out_q,
                                     start_trigger = start_trigger,
                                     stop_trigger = stop_trigger,
                                     save_trigger = save_trigger,
-                                    recorderpar=recorderpar)
+                                    recorderpar = recorderpar)
         self.armed = False
         self.drivername = 'PCO'
-        if dllpath is None:
-            userpath = os.path.expanduser('~')
-            dllpath = ['C:\\Program Files (x86)\\pco\\pco.sdk\\bin64\\SC2_Cam.dll',
-                       'C:\\Program Files (x86)\\Digital Camera Toolbox\\pco.sdk\\bin64\\SC2_Cam.dll',
-                       'C:\\Program Files (x86)\\PCO Digital Camera Toolbox\\pco.sdk\\bin64\\SC2_Cam.dll',
-                       pjoin(userpath,'AppData\\Roaming\\PCO Digital Camera Toolbox\\pco.sdkbin64\\SC2_Cam.dll')]
-        self._dll = None
-        for path in dllpath:
-            if os.path.isfile(path):
-                self._dll = ctypes.WinDLL(path)
-                self.dllpath = path
-                break
-        if self._dll is None:
-            print('Please install PCO.sdk in one of these locations:')
-            print(dllpath)
-            raise OSError
-        self.poll_timeout=1
-        self.trigerMode = 0
         self.exposure = exposure
         self.binning = binning
         self.dtype = dtype
-        ret = self.camopen(self.cam_id)
-        assert ret == 0, "PCO: Could not open camera {0}".format(cam_id)
-        self.use_camera_parameters = use_camera_parameters
-        if self.use_camera_parameters:
-            if not self.binning is None:
-                ret = self.set_binning(self.binning,self.binning)
-                display('PCO - Binning: {0}'.format(ret))
-        ret = self.set_exposure_time(self.exposure)
-        display('PCO - Exposure: {0} {1}'.format(*ret))
-        self.set_trigger_mode(0)
-        display('PCO - Trigger mode: {0}'.format(self.get_trigger_mode()))
-        frame = self.get_one()
-        self.disarm()
-        self.camclose()
-        self.hCam = None
-        self._prepared = []
+        self.roi = roi
+        self.acquire_mode = acquire_mode
+        self.debuglevel = debuglevel
+        self._cam_init()
+        
+        self.cam.record(1)
+        frame,info = self.cam.image()
+
+        self.cam.close()
+        self.cam = None
         self.h.value = frame.shape[0]
         self.w.value = frame.shape[1]
         display('PCO - size: {0} x {1}'.format(self.h.value,self.w.value))
 
         if len(frame.shape) == 2:
             self.nchan.value = 1
         else:
@@ -94,16 +71,14 @@
         self.hardware_trigger = hardware_trigger
         if self.hardware_trigger is None:
             self.hardware_trigger = Event()
 
         self.trigger_source = trigger_source
         self.frame_rate = 1000.0/float(self.exposure)
         self.fs.value = self.frame_rate
-
-        self._dll = None
         display("[PCO {0}] Got info from camera".format(
              self.cam_id))
 
     def _init_controls(self):
         self.ctrevents = dict(
             exposure=dict(
                 function = 'set_exposure_time',
@@ -111,478 +86,101 @@
                 variable = 'exposure',
                 units = 'ms',
                 type = 'float',
                 min = 0.001,
                 max = 100000,
                 step = 10))
 
-    def camopen(self,camid,reset = False):
-        '''Open PCO camera'''
-        opencamera = self._dll.PCO_OpenCamera
-        # PCO_OpenCamera(HANDLE *hCam, int board_num), return int
-        opencamera.argtypes = (ctypes.POINTER(ctypes.c_void_p), ctypes.c_uint16)
-        opencamera.restype = ctypes.c_int
-        self.hCam = ctypes.c_void_p()
-        ret = opencamera(self.hCam, camid)
-        if ret == 0 and reset:
-            self._dll.PCO_ResetSettingsToDefault(self.hCam)
-        return ret
-    
-    def camclose(self):
-        ''' Close PCO camera'''
-        return self._dll.PCO_CloseCamera(self.hCam)
-    
-    def acquisitionstart(self):
-        """
-        Start recording
-        :return: message from recording status
-        """
-        return self._dll.PCO_SetRecordingState(self.hCam, ctypes.c_uint16(1))
+    def set_exposure_time(self,exposure):
+        self.exposure = exposure
+        self.cam.exposure_time = self.exposure/1000.
+        
     
     def acquisitionstop(self):
         """
         Start recording
         :return: message from recording status
         """
         display('[PCO {0}] - Stopping acquisition.'.format(self.cam_id))
-        return self._dll.PCO_SetRecordingState(self.hCam, ctypes.c_uint16(0))
+        return self.cam.stop()
     
-    def get_health_state(self):
-        cameraWarning, cameraError, cameraStatus = (ctypes.c_uint16(),
-                                                    ctypes.c_uint16(),
-                                                    ctypes.c_uint16())
-        iRet = self._dll.PCO_GetCameraHealthStatus(self.hCam,
-                                                   ctypes.byref(cameraWarning),
-                                                   ctypes.byref(cameraError),
-                                                   ctypes.byref(cameraStatus))
-        if cameraError.value !=0:
-            display("PCO - Camera has ErrorStatus");
-            return -1
-        return 0
-    def _prepare_to_mem(self):
-        """
-        Prepares memory for recording
-        :return:
-        """
-        dw1stImage, dwLastImage = ctypes.c_uint32(0), ctypes.c_uint32(0)
-        wBitsPerPixel = ctypes.c_uint16(16)
-        dwStatusDll, dwStatusDrv = ctypes.c_uint32(), ctypes.c_uint32()
-        bytes_per_pixel = ctypes.c_uint32(2)
-        pixels_per_image = ctypes.c_uint32(self.wXResAct.value *
-                                           self.wYResAct.value)
-        added_buffers = []
-        for which_buf in range(len(self.buffer_numbers)):
-            self._dll.PCO_AddBufferEx(
-                self.hCam, dw1stImage, dwLastImage,
-                self.buffer_numbers[which_buf], self.wXResAct,
-                self.wYResAct, wBitsPerPixel)
-            added_buffers.append(which_buf)
-
-        # prepare Python data types for receiving data
-        # http://stackoverflow.com/questions/7543675/how-to-convert-pointer-to-c-array-to-python-array
-        ArrayType = ctypes.c_uint16*pixels_per_image.value
-        self._prepared = (dw1stImage, dwLastImage,
-                          wBitsPerPixel,
-                          dwStatusDll, dwStatusDrv,
-                          bytes_per_pixel, pixels_per_image,
-                          added_buffers, ArrayType)
-
-    def set_transfer_parameters_auto(self):
-        buffer = (ctypes.c_uint8 * 80)(0)
-        self._dll.PCO_SetTransferParametersAuto.argtypes = [ctypes.c_void_p,
-                                                            ctypes.c_void_p,
-                                                            ctypes.c_int]
-
-        p_buffer = ctypes.cast(buffer, ctypes.POINTER(ctypes.c_void_p))
-        ilen = ctypes.c_int(len(buffer))
-
-        error = self._dll.PCO_SetTransferParametersAuto(self.hCam,
-                                                        p_buffer,
-                                                        ilen)
 
-    def allocate_buffers(self, num_buffers=15):
-        """
-        Allocate buffers for image grabbing
-        :param num_buffers:
-        :return:
-        """
-        # Get the actual image resolution-needed for buffers
-        self.wXResAct=ctypes.c_uint16()
-        self.wYResAct=ctypes.c_uint16()
-        wXResMax=ctypes.c_uint16()
-        wYResMax = ctypes.c_uint16()
-        self._dll.PCO_GetSizes(self.hCam, ctypes.byref(self.wXResAct),
-                               ctypes.byref(self.wYResAct), ctypes.byref(wXResMax),
-                               ctypes.byref(wYResMax))
-        self.w.value,self.h.value = [self.wXResAct.value,
-                         self.wYResAct.value]
-        self.wXResAct.value = int(self.wXResAct.value)
-        self.wYResAct.value = int(self.wYResAct.value)
-
-        
-        dwSize = ctypes.c_uint32(self.wXResAct.value*self.wYResAct.value*2)  # 2 bytes per pixel
-        # set buffer variable to []
-        self.buffer_numbers, self.buffer_pointers, self.buffer_events = ([], [], [])
-        # now set buffer variables to correct value and pass them to the API
-        for i in range(num_buffers):
-            self.buffer_numbers.append(ctypes.c_int16(-1))
-            self.buffer_pointers.append(ctypes.c_void_p(0))
-            self.buffer_events.append(ctypes.c_void_p(0))
-            self._dll.PCO_AllocateBuffer(self.hCam,
-                                         ctypes.byref(self.buffer_numbers[i]),
-                                         dwSize,
-                                         ctypes.byref(self.buffer_pointers[i]),
-                                         ctypes.byref(self.buffer_events[i]))
-
-        # Tell camera link what actual resolution to expect
-        #print('Setting size - {0}, {1}'.format(self.wXResAct,self.wYResAct))
-        self._dll.PCO_SetImageParameters(self.hCam,
-                                         self.wXResAct,
-                                         self.wYResAct)
+    def _cam_init(self):
+        self.cam = pco.Camera()
+        self.cam.sdk.set_hot_pixel_correction_mode('on')
+        self.cam.sdk.set_pixel_rate(max(self.cam.sdk.get_camera_description()['pixel rate']))
         try:
-            self._dll.PCO_CamLinkSetImageParameters(self.hCam,
-                                                    self.wXResAct,
-                                                    self.wYResAct)
+            self.cam.sdk.set_hwio_signal(index = 3,
+                                         enabled = 'on',
+                                         signal_type = 'TTL',
+                                         filter_type = 'off',
+                                         polarity='high level',
+                                         selected = 0,
+                                         parameter = [2,0,0,0])
+            # this is not doing what I want yet..
         except:
-            display('CameraLink SetImageParameters failed.')
-        self.set_transfer_parameters_auto()
-    
-    #def get_one(self, poll_timeout=5e7):
-    #    iRet = PCO_GetImageEx(cam, 1, 0, 0, BufNum, XResAct, YResAct, 16)
-    
-    def get_trigger_mode(self):
-        wTrigMod = ctypes.c_uint16()
-        self._dll.PCO_GetTriggerMode(self.hCam, ctypes.byref(wTrigMod))
-        return wTrigMod.value
-    
-    def set_trigger_mode(self,tmode = 0):
-        '''
-        0x0000 = [auto sequence]
-        0x0001 = [software trigger]
-        0x0002 = [external exposure start & software trigger]
-        0x0003 = [external exposure control]
-        0x0004 = [external synchronized]
-        0x0005 = [fast external exposure control]
-        0x0006 = [external CDS control]
-        0x0007 = [slow external exposure control]
-        0x0102 = [external synchronized HDSDI]
-        '''
-        wTrigMod = ctypes.c_uint16(tmode)
-        return self._dll.PCO_SetTriggerMode(self.hCam, wTrigMod)
+            print('Could not set HWIO for line 4.')
+        self.cam.set_acquire_mode = self.acquire_mode
+        if not self.binning is None:
+            self.cam.sdk.set_binning(self.binning,self.binning)
+        sizes = self.cam.sdk.get_sizes()
+        binning = self.cam.sdk.get_binning()
+        if self.roi is None:
+            self.roi = [1,1,int(sizes['x max']/binning['binning x']),
+                        int(sizes['y max']/binning['binning y'])]
+        self.cam.sdk.set_roi(*self.roi)
 
-    def set_binning(self, h_bin, v_bin):
-        """
-        binning allows for Binning pixels in h_bin x v_bin
-        Allowed values in {1,2,4,8,16,32}
-        :param h_bin: binning in horizontal direction
-        :param v_bin:
-        :return: None
-        """
-        allowed = [1, 2, 4]
-
-        self._dll.PCO_SetBinning.argtypes = [ctypes.c_void_p,
-                                             ctypes.c_uint16,
-                                             ctypes.c_uint16]
-
-        wBinHorz = ctypes.c_uint16(np.uint16(h_bin))
-        wBinVert = ctypes.c_uint16(np.uint16(v_bin))
-        if (h_bin in allowed) and (v_bin in allowed):
-            self._dll.PCO_SetBinning(self.hCam, wBinHorz, wBinVert)
-            self._dll.PCO_GetBinning(self.hCam, ctypes.byref(wBinHorz),
-                                          ctypes.byref(wBinVert))
-            wXResAct=ctypes.c_uint16()
-            wYResAct=ctypes.c_uint16()
-            wXResMax=ctypes.c_uint16()
-            wYResMax = ctypes.c_uint16()
-            self._dll.PCO_GetSizes(self.hCam,
-                                   ctypes.byref(wXResAct),
-                                   ctypes.byref(wYResAct),
-                                   ctypes.byref(wXResMax),
-                                   ctypes.byref(wYResMax))
-            
-            wRoiX0 = ctypes.c_uint16(0)
-            wRoiY0 = ctypes.c_uint16(0)
-            wRoiX1 = ctypes.c_uint16(int(100))
-            wRoiY1 = ctypes.c_uint16(int(100))
-            self._dll.PCO_SetROI(self.hCam,
-                                    wRoiX0,
-                                    wRoiY0,
-                                    wRoiX1,
-                                    wRoiY1)
-
-            return [wBinHorz.value, wBinVert.value]
-        else:
-            raise ValueError("Not allowed binning value pair " + str(h_bin)
-                              + "x" + str(v_bin))
-            return None
-    
-    def set_exposure_time(self, exp_time=100, base_exposure=2):
-        """
-        Sets delay and exposure time allowing to choose a base for each parameter
-        0x0000 timebase=[ns]=[10^-9 seconds]
-        0x0001 timebase=[us]=[10^-6 seconds]
-        0x0002 timebase=[ms]=[10^-3 seconds]
-        Note: Does not require armed camera to set exp time
-        :param exp_time: Exposure time (integer < 1000)
-        :param base_exposure: Base 10 order for exposure time in seconds-> ns/us/ms
-        :param verbose: True if process should be printed
-        :return: None
-        """
-        # check for allowed values
-        self.exposure = exp_time
-        if not(base_exposure in [1, 2]):
-            raise UserWarning("PCO - Not accepted time base mode (has to be 1 or 2).")
-
-        # pass values to ctypes variables
-        dwDelay = ctypes.c_uint32(0)
-        dwExposure = ctypes.c_uint32(np.uint32(exp_time))
-        wTimeBaseDelay = ctypes.c_uint16(0)
-        wTimeBaseExposure = ctypes.c_uint16(np.uint16(base_exposure))
-
-        # set exposure time and delay time
-        self._dll.PCO_SetDelayExposureTime(self.hCam,
-                                           dwDelay, dwExposure,
-                                           wTimeBaseDelay, wTimeBaseExposure)
-        self._dll.PCO_GetDelayExposureTime(self.hCam, ctypes.byref(dwDelay),
-                                           ctypes.byref(dwExposure),
-                                           ctypes.byref(wTimeBaseDelay),
-                                           ctypes.byref(wTimeBaseExposure))
-
-        return [dwExposure.value, self.time_modes[wTimeBaseExposure.value]]
-
-    def get_exposure_time(self):
-        """
-        Get exposure time of the camera.
-        :return: exposure time, units
-        """
-        # pass values to ctypes variables
-        dwDelay = ctypes.c_uint32(0)
-        dwExposure = ctypes.c_uint32(0)
-        wTimeBaseDelay = ctypes.c_uint16(0)
-        wTimeBaseExposure = ctypes.c_uint16(0)
-
-        # get exposure time
-        self._dll.PCO_GetDelayExposureTime(self.hCam, ctypes.byref(dwDelay),
-                                           ctypes.byref(dwExposure),
-                                           ctypes.byref(wTimeBaseDelay),
-                                           ctypes.byref(wTimeBaseExposure))
-
-        return [dwExposure.value, self.time_modes[wTimeBaseExposure.value]]
-
-    def arm(self):
-        """
-        Arms camera and allocates buffers for image recording
-        :return:
-        """
-        if self.armed:
-            raise UserWarning("PCO - Camera already armed?")
-        # Arm camera
-        self._dll.PCO_ArmCamera(self.hCam)
-        
-        self.armed = True
-        self.allocate_buffers()
-        return self.armed
-    
-    def disarm(self):
-        """
-        Disarm camera, free allocated buffers and set
-        recording to 0
-        :return:
-        """
-        # set recording state to 0
-        wRecState = ctypes.c_uint16(0)
-        self._dll.PCO_SetRecordingState(self.hCam, wRecState)
-        # free all allocated buffers
-        self._dll.PCO_RemoveBuffer(self.hCam)
-        for buf in self.buffer_numbers:
-            self._dll.PCO_FreeBuffer(self.hCam, buf)
-        self.buffer_numbers, self.buffer_pointers, self.buffer_events = (
-            [], [], [])
-        self.armed = False
-
-        
-    def get_one(self, poll_timeout=5e7):
-        """
-        Records a single image
-        :return:
-        """
-        self.arm()
-        self.acquisitionstart()
-        self._prepare_to_mem()
-        message = 0
-        (dw1stImage, dwLastImage, wBitsPerPixel, dwStatusDll,
-         dwStatusDrv, bytes_per_pixel,
-         pixels_per_image, added_buffers, ArrayType) = self._prepared
-
-        assert bytes_per_pixel.value == 2
-        out = np.zeros((self.wYResAct.value, self.wXResAct.value),
-                       dtype=np.uint16)
-        num_acquired = 0
-        num_images = 1
-        for which_im in range(num_images):
-            num_polls = 0
-            polling = True
-            while polling:
-                num_polls += 1
-                message = self._dll.PCO_GetBufferStatus(
-                    self.hCam, self.buffer_numbers[added_buffers[0]],
-                    ctypes.byref(dwStatusDll), ctypes.byref(dwStatusDrv))
-                #print(hex(dwStatusDll.value))
-                if dwStatusDll.value == 0xc0008000:
-                    which_buf = added_buffers.pop(0)  # Buffer exits the queue
-                    #print("After", num_polls, "polls, buffer")
-                    #print(self.buffer_numbers[which_buf].value)
-                    #print("is ready.")
-                    polling = False
-                    break
-                else:
-                    time.sleep(0.00005)  # Wait 50 microseconds
-                if num_polls > poll_timeout:
-                    #print("After %i polls, no buffer."%(poll_timeout))
-                    return None
-            try:
-                if dwStatusDrv.value == 0x00000000:
-                    pass
-                elif dwStatusDrv.value == 0x80332028:
-                    print('DMA error during record_to_memory')
-                    break
-                    raise MemoryError('DMA error during record_to_memory')
-                else:
-                    print("dwStatusDrv:", dwStatusDrv.value)
-                    print("Buffer status error")
-                    break
-                buffer_ptr = ctypes.cast(self.buffer_pointers[which_buf], ctypes.POINTER(ArrayType))
-                out[:, :] = np.frombuffer(buffer_ptr.contents, dtype=self.dtype).reshape(out.shape)
-                num_acquired += 1
-            finally:
-                self._dll.PCO_AddBufferEx(  # Put the buffer back in the queue
-                    self.hCam,
-                    dw1stImage,
-                    dwLastImage,
-                    self.buffer_numbers[which_buf],
-                    self.wXResAct,
-                    self.wYResAct,
-                    wBitsPerPixel)
-                added_buffers.append(which_buf)
-        
-        self.acquisitionstop()
-        self.disarm()
-        return out
-
-    def _cam_init(self):
-        if self._dll is None:
-            self._dll = ctypes.WinDLL(self.dllpath)
-        self.nframes.value = 0
-        self.lastframeid = -1
-        ret = self.camopen(self.cam_id)
-        if self.use_camera_parameters:
-            if not self.binning is None:
-                ret = self.set_binning(self.binning,self.binning)
-                display('PCO - Binning: {0}'.format(ret))
-            ret = self.set_exposure_time(self.exposure)
-            display('PCO - Exposure: {0} {1}'.format(*ret))
-        if self.hardware_trigger.is_set():
-            display('PCO - Trigger mode settting to: {0}'.format(self.trigger_source))
-            display('\t\t\tPCO - {0}'.format(self.set_trigger_mode(self.trigger_source)))
-        else:
-            self.set_trigger_mode(0)
-        display('PCO - Trigger mode: {0}'.format(self.get_trigger_mode()))
-        display('PCO - size: {0} x {1}'.format(self.h.value,self.w.value))
-        # need to handle cams that don't support this?
-        self._dll.PCO_SetTimestampMode(self.hCam,ctypes.c_uint16(1))
+        self.cam.exposure_time = self.exposure/1000.
+        self.cam.sdk.set_timestamp_mode('binary')
         self.camera_ready.set()
         self.nframes.value = 0
+        self.lastframeid = -1
         self.datestart = datetime.now()
         
     def _cam_startacquisition(self):
         display('PCO [{0}] - Started acquisition.'.format(self.cam_id))
-        self.arm()        
-        self._prepare_to_mem()
-        (self.dw1stImage, self.dwLastImage, self.wBitsPerPixel, self.dwStatusDll,
-         self.dwStatusDrv, bytes_per_pixel,
-         pixels_per_image, self.added_buffers, self.ArrayType) = self._prepared
-        assert bytes_per_pixel.value == 2 # uint16
-        self.out = np.zeros((self.wYResAct.value, self.wXResAct.value),
-                            dtype=self.dtype)
-        self.acquisitionstart()
+        self.cam.record(500, mode='ring buffer')
                 
     def _cam_stopacquisition(self, clean_buffers = True):
-        self.acquisitionstop()
-        i=0
+        self.cam.sdk.set_recording_state('off')
+        self.cam.stop()
+        i = 0
         while clean_buffers:
             # check if there are any frame buffers missing.
             frame,metadata = self._cam_loop()
             if frame is None:
                 break
             self._handle_frame(frame,metadata)
             i+=1
         display('[PCO {0}] - cleared {0} buffers.'.format(self.cam_id,i))
-
-        self.disarm()
         
-    def _cam_loop(self,poll_timeout=5e7):
         
+    def _cam_loop(self,poll_timeout=5e7):
         timestamp = 0
         message = 0
         num_acquired = 0
-        num_polls = 0
-        polling = True
-        while polling:
-            which_buf = None
-            num_polls += 1
-            message = self._dll.PCO_GetBufferStatus(
-                self.hCam, self.buffer_numbers[self.added_buffers[0]],
-                ctypes.byref(self.dwStatusDll), ctypes.byref(self.dwStatusDrv))
-            if self.dwStatusDll.value == 0xc0008000:
-                which_buf = self.added_buffers.pop(0)  # Buffer exits the queue
-                #print("After", num_polls, "polls, buffer")
-                #print(self.buffer_numbers[which_buf].value)
-                #print("is ready.")
-                polling = False
-                break
-            else:
-                time.sleep(0.0005)  # Wait 500 microseconds
-                if num_polls > self.poll_timeout:
-                    break
-        if not which_buf is None:
-            try:
-                if self.dwStatusDrv.value == 0x00000000:
-                    pass
-                elif self.dwStatusDrv.value == 0x80332028:
-                    print('DMA error during record_to_memory')
-                else:
-                    print("dwStatusDrv:", self.dwStatusDrv.value)
-                    print("Buffer status error")
-                buffer_ptr = ctypes.cast(self.buffer_pointers[which_buf], ctypes.POINTER(self.ArrayType))
-                self.out[:, :] = np.frombuffer(buffer_ptr.contents, dtype=np.uint16).reshape(self.out.shape)
-                num_acquired += 1
-            finally:
-                self._dll.PCO_AddBufferEx(  # Put the buffer back in the queue
-                    self.hCam, self.dw1stImage, self.dwLastImage,
-                    self.buffer_numbers[which_buf], self.wXResAct, self.wYResAct,
-                    self.wBitsPerPixel)
-                self.added_buffers.append(which_buf)
-            frameID = 0
-            timestamp = 0
-            frameID = int(''.join([hex(((a >> 8*0) & 0xFF))[-2:] for a in self.out[0,:4]]).replace('x','0'))
-            try:
-                datestr = ('{0}{1}-{2}-{3} {4}:{5}:{6}.{7}{8}{9}'.format(
-                    *[hex(((a >> 8*0) & 0xFF)
-                          )[-2:] for a in self.out[0,4:14]]).replace('x','0'))
-                timestam = datetime.strptime(datestr,'%Y-%m-%d %H:%M:%S.%f')
-            except:
-                timestam = datetime.now()
-            timestamp = (timestam - self.datestart).total_seconds()
-            # Handle failed string decoding.
-            return self.out.copy(),(frameID,timestamp)
-        return None,(None,None)
+        status = self.cam.rec.get_status()
+        #if not status['is running']:
+        #    return None,(None,None)
+        if status['dwProcImgCount'] == 0 or status['dwProcImgCount'] <= (self.lastframeid):
+            return None,(None,None)
+
+        frame,info = self.cam.image(-1)
+        frameID = info['timestamp']['image counter']
+        t = info['timestamp']
+        ms,s = np.modf(t['second'])
+        timestamp = datetime(year = t['year'],
+                             month=t['month'],
+                             day = t['day'],
+                             hour=t['hour'],
+                             minute = t['minute'],
+                             second = int(s),
+                             microsecond = int(ms*1e6))
+        return frame,(frameID,timestamp)
     
     def _cam_close(self):
-        display('PCO [{0}] - Closing camera.'.format(self.cam_id))
-        self.acquisitionstop()
-        self.disarm()
-        ret = self.camclose()
+        ret = self.cam.close()
         display('PCO - returned {0} on close'.format(ret))
         self.save_trigger.clear()
         if self.was_saving:
             self.was_saving = False
             self.queue.put(['STOP'])
```

## labcams/widgets.py

```diff
@@ -878,14 +878,15 @@
     def __init__(self,port = None,ino=None, outQ = None, cam = None):
         super(CamStimTriggerWidget,self).__init__()
         if (ino is None) and (not port is None):
             from .cam_stim_trigger import CamStimInterface
             ino = CamStimInterface(port = port,outQ = outQ)
         self.ino = ino
         self.cam = cam
+        self.setObjectName("CamStimTrigger")
         form = QFormLayout()
         if not ino is None:
             def disarm():
                 ino.disarm()
             disarmButton = QPushButton('Disarm')
             disarmButton.clicked.connect(disarm)
             form.addRow(disarmButton)
```

## Comparing `labcams-0.6.6.dist-info/LICENSE.txt` & `labcams-0.7.0.dist-info/LICENSE.txt`

 * *Files identical despite different names*

## Comparing `labcams-0.6.6.dist-info/RECORD` & `labcams-0.7.0.dist-info/RECORD`

 * *Files 12% similar despite different names*

```diff
@@ -1,23 +1,23 @@
 labcams/__init__.py,sha256=mCXlJn7AXCFSvtWKT5RYkCFbE18vCKFCbBttqQUrddk,832
 labcams/avt.py,sha256=P8_tC87XPLJJTc1hWKkKK0sRwVgYtYNfGDCHat9l5-A,13689
 labcams/basler.py,sha256=KnrBjd9hO0A18jte_9G4wa-zDQWa_cgjOZnSJqigSu0,6684
 labcams/cam_stim_trigger.py,sha256=8_iyElKvSzWk_jHSZa-16WA25TdOvJizuRC92Gyxx7U,8117
-labcams/cams.py,sha256=_UNULiPU9DpaQCGc24nC89B5y7-n6PfmAK6_82jiiCI,35453
-labcams/gui.py,sha256=cOCEpMstY_uNnxBZq3ZGmEk-a0_j77Hc2s4590fBXUI,23464
-labcams/io.py,sha256=PyT2fxiURnwOoqI12IN9PxgILhsvuVkdGchOfSkifi8,49342
+labcams/cams.py,sha256=6p9SCKtCF6QbhSFdUnvZQT1dOgJGdopNnSwqnzRgsKs,35578
+labcams/gui.py,sha256=iefiiVUUAXqOgt22JaiEBVzVESLxxv3sKyYQsLghUpY,23524
+labcams/io.py,sha256=y1eJfDhIcEKR5QgtwLtYAi_BHh-uMq65F7CxYst7g7k,49319
 labcams/nidaq_acq.py,sha256=j1lmT28EjkCjjg4zlRE1AFsvwN6BKEsvxXVMmeTPNGQ,11492
-labcams/pco.py,sha256=Cu7nDMe8eHabkjmNhWCJSZbxwSNUMgjzZoTtoRdFvs0,24851
+labcams/pco.py,sha256=Jdbj0UZAf9pm7HYuOuzglBPklx0LW69wzB1GFj1s3cQ,6979
 labcams/plugins.py,sha256=zthQlqJFrAEHy7gdbZoFluHWiGVtZiIJE9uPc87YNos,1216
 labcams/pointgreycam.py,sha256=9F7UESNw0MxCRyO79dN8VoDzgmtw9PdIVmbMP3WShKM,30459
 labcams/pvcam.py,sha256=uJ8DWERqYAjDlFmiJTYdv8XIEMnsl4qfofJP2VGuPp0,6310
 labcams/qimaging.py,sha256=1Dwlg76AfOyeHyEndYfZ7AnnrYwnvflDW95QDpzp5HA,6872
 labcams/qimaging_dll.py,sha256=pGqfRq15BWLTMLe9pv-JcObz1yPwocnj-FdqXcw-T1A,62774
 labcams/utils.py,sha256=xpOb8joXHoMfUdhpOyT2nwVt7U3mxVnVlYEhi3JIbmU,10107
-labcams/widgets.py,sha256=Rkhx0IBhaJygm20xCUoaTYIf_F9VAag5-1nejAVcmx0,47519
+labcams/widgets.py,sha256=5GSlMwVz8eBbnMjcR5DG67i525q69DX24s3ERh06m_w,47564
 labcams/ximeacam.py,sha256=hq9l2logmtrvFWRqaMVZmZ1zvOA_NRsxKsQrcopspU4,5561
-labcams-0.6.6.dist-info/LICENSE.txt,sha256=OXLcl0T2SZ8Pmy2_dmlvKuetivmyPd5m1q-Gyd-zaYY,35149
-labcams-0.6.6.dist-info/METADATA,sha256=2RcFdHpO3ei7Ag68zngyNio-eWKFIJxv_j7a-emp_kM,1975
-labcams-0.6.6.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
-labcams-0.6.6.dist-info/entry_points.txt,sha256=IXmap1X2QfMmEsUpJi0Z9V-zvkG0urpX9I3Ct_jwfKM,46
-labcams-0.6.6.dist-info/top_level.txt,sha256=id3KInKuvCHG2ofzEp-zvMNc843ixQ407p4RP89IsZ8,8
-labcams-0.6.6.dist-info/RECORD,,
+labcams-0.7.0.dist-info/LICENSE.txt,sha256=OXLcl0T2SZ8Pmy2_dmlvKuetivmyPd5m1q-Gyd-zaYY,35149
+labcams-0.7.0.dist-info/METADATA,sha256=Gw7hyoX91RSwFzwOfs8z_7gdfRI2HIYwjeS1Cb0v8mA,2285
+labcams-0.7.0.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
+labcams-0.7.0.dist-info/entry_points.txt,sha256=IXmap1X2QfMmEsUpJi0Z9V-zvkG0urpX9I3Ct_jwfKM,46
+labcams-0.7.0.dist-info/top_level.txt,sha256=id3KInKuvCHG2ofzEp-zvMNc843ixQ407p4RP89IsZ8,8
+labcams-0.7.0.dist-info/RECORD,,
```

