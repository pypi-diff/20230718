# Comparing `tmp/cartagen4py-0.2.0-py3-none-any.whl.zip` & `tmp/cartagen4py-0.2.1-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,17 +1,17 @@
-Zip file size: 42565 bytes, number of entries: 40
+Zip file size: 43665 bytes, number of entries: 40
 -rw-r--r--  2.0 unx      183 b- defN 23-May-16 13:17 cartagen4py/__init__.py
 -rw-r--r--  2.0 unx      134 b- defN 23-May-15 08:34 cartagen4py/algorithms/__init__.py
 -rw-r--r--  2.0 unx      244 b- defN 23-May-15 08:34 cartagen4py/algorithms/buildings/__init__.py
 -rw-r--r--  2.0 unx     4500 b- defN 23-Jul-10 07:34 cartagen4py/algorithms/buildings/amalgamation.py
--rw-r--r--  2.0 unx     7441 b- defN 23-May-15 08:35 cartagen4py/algorithms/buildings/random_displacement.py
+-rw-r--r--  2.0 unx     7791 b- defN 23-Jul-18 08:14 cartagen4py/algorithms/buildings/random_displacement.py
 -rw-r--r--  2.0 unx     8144 b- defN 23-May-24 14:53 cartagen4py/algorithms/buildings/simplification.py
 -rw-r--r--  2.0 unx    15705 b- defN 23-Jul-10 07:34 cartagen4py/algorithms/buildings/squaring.py
 -rw-r--r--  2.0 unx       55 b- defN 23-May-12 12:21 cartagen4py/algorithms/general/__init__.py
--rw-r--r--  2.0 unx    35580 b- defN 23-Jul-10 08:51 cartagen4py/algorithms/general/constraint.py
+-rw-r--r--  2.0 unx    41211 b- defN 23-Jul-17 13:23 cartagen4py/algorithms/general/constraint.py
 -rw-r--r--  2.0 unx      120 b- defN 23-May-12 12:23 cartagen4py/algorithms/lines/__init__.py
 -rw-r--r--  2.0 unx     5307 b- defN 23-Jun-21 09:43 cartagen4py/algorithms/lines/line_simplification.py
 -rw-r--r--  2.0 unx     3095 b- defN 23-May-24 14:53 cartagen4py/algorithms/lines/line_smoothing.py
 -rw-r--r--  2.0 unx      162 b- defN 23-May-16 08:50 cartagen4py/data_enrichment/__init__.py
 -rw-r--r--  2.0 unx     7219 b- defN 23-Jul-05 09:28 cartagen4py/data_enrichment/building_measures.py
 -rw-r--r--  2.0 unx    14259 b- defN 23-Jul-10 07:34 cartagen4py/data_enrichment/stroke.py
 -rw-r--r--  2.0 unx     1018 b- defN 23-May-12 11:58 cartagen4py/data_enrichment/urban_areas.py
@@ -27,16 +27,16 @@
 -rw-r--r--  2.0 unx     1327 b- defN 23-Mar-21 13:10 cartagen4py/utils/geometry/extent.py
 -rw-r--r--  2.0 unx     3329 b- defN 23-Jun-21 15:05 cartagen4py/utils/geometry/line.py
 -rw-r--r--  2.0 unx     3167 b- defN 23-May-12 11:54 cartagen4py/utils/geometry/segment.py
 -rw-r--r--  2.0 unx       91 b- defN 23-May-15 08:51 cartagen4py/utils/math/__init__.py
 -rw-r--r--  2.0 unx     4693 b- defN 23-Jul-10 07:34 cartagen4py/utils/math/morphology.py
 -rw-r--r--  2.0 unx      474 b- defN 23-May-12 11:28 cartagen4py/utils/math/vector.py
 -rw-r--r--  2.0 unx      106 b- defN 23-May-15 08:50 cartagen4py/utils/partitioning/__init__.py
--rw-r--r--  2.0 unx     2183 b- defN 23-May-12 11:55 cartagen4py/utils/partitioning/network.py
+-rw-r--r--  2.0 unx     2183 b- defN 23-Jul-18 07:39 cartagen4py/utils/partitioning/network.py
 -rw-r--r--  2.0 unx      334 b- defN 23-May-15 09:06 cartagen4py/utils/partitioning/quadtree.py
 -rw-r--r--  2.0 unx       54 b- defN 23-May-16 08:51 cartagen4py/utils/tessellation/__init__.py
 -rw-r--r--  2.0 unx     3721 b- defN 23-May-16 07:42 cartagen4py/utils/tessellation/hexagonal.py
--rw-r--r--  2.0 unx      914 b- defN 23-Jul-10 11:57 cartagen4py-0.2.0.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Jul-10 11:57 cartagen4py-0.2.0.dist-info/WHEEL
--rw-r--r--  2.0 unx       12 b- defN 23-Jul-10 11:57 cartagen4py-0.2.0.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     3772 b- defN 23-Jul-10 11:57 cartagen4py-0.2.0.dist-info/RECORD
-40 files, 132502 bytes uncompressed, 36349 bytes compressed:  72.6%
+-rw-r--r--  2.0 unx      914 b- defN 23-Jul-18 08:28 cartagen4py-0.2.1.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jul-18 08:28 cartagen4py-0.2.1.dist-info/WHEEL
+-rw-r--r--  2.0 unx       12 b- defN 23-Jul-18 08:28 cartagen4py-0.2.1.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     3772 b- defN 23-Jul-18 08:28 cartagen4py-0.2.1.dist-info/RECORD
+40 files, 138483 bytes uncompressed, 37449 bytes compressed:  73.0%
```

## zipnote {}

```diff
@@ -102,20 +102,20 @@
 
 Filename: cartagen4py/utils/tessellation/__init__.py
 Comment: 
 
 Filename: cartagen4py/utils/tessellation/hexagonal.py
 Comment: 
 
-Filename: cartagen4py-0.2.0.dist-info/METADATA
+Filename: cartagen4py-0.2.1.dist-info/METADATA
 Comment: 
 
-Filename: cartagen4py-0.2.0.dist-info/WHEEL
+Filename: cartagen4py-0.2.1.dist-info/WHEEL
 Comment: 
 
-Filename: cartagen4py-0.2.0.dist-info/top_level.txt
+Filename: cartagen4py-0.2.1.dist-info/top_level.txt
 Comment: 
 
-Filename: cartagen4py-0.2.0.dist-info/RECORD
+Filename: cartagen4py-0.2.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## cartagen4py/algorithms/buildings/random_displacement.py

```diff
@@ -1,20 +1,20 @@
 # This is an implementation of the random building displacement algorithm
 
-import random, math
+import random, math, numpy
 
 import shapely
 
 from cartagen4py.utils.partitioning.network import network_partition
 
 class BuildingDisplacementRandom:
     """
     Initialize random displacement object, with default length displacement factor and number of iterations per building
     """
-    def __init__(self, max_trials=25, max_displacement=10, network_partitioning=True, verbose=False):
+    def __init__(self, max_trials=25, max_displacement=10, network_partitioning=False, verbose=False):
         self.MAX_TRIALS = max_trials
         self.MAX_DISPLACEMENT = max_displacement
         self.NETWORK_PARTITIONING = network_partitioning
         self.VERBOSE = verbose
 
     def displace(self, buildings, roads, rivers, *networks):
         """
@@ -47,15 +47,18 @@
                         partition_roads.append(shapely.intersection(road, partitions[1][i]))
                 partition_rivers = []
                 for river in rivers.geometry:
                     if river.intersects(partitions[1][i]):
                         partition_rivers.append(shapely.intersection(river, partitions[1][i]))
                 self.__random_displacement(partition, partition_roads, partition_rivers)
         else:
-            self.__random_displacement(buildings, roads, rivers)
+            building_index = numpy.ndarray(len(buildings), dtype='int16')
+            for i, b in buildings.iterrows():
+                building_index[i] = i
+            self.__random_displacement(building_index, self.__gdf_to_geomlist(roads), self.__gdf_to_geomlist(rivers))
 
         return self.__BUILDINGS
 
     def __random_displacement(self, buildings, roads, rivers):
         """
         Launch a loop to iteratively displace buildings randomly and checks the congestion before validating
         """
@@ -162,7 +165,13 @@
             if geometry is None:
                 return intersection
             # Else, returning the union between the intersection and the existing geometry
             else:
                 return geometry.union(intersection)
         else:
             return geometry
+
+    def __gdf_to_geomlist(self, gdf):
+        l = []
+        for geom in gdf.geometry:
+            l.append(geom)
+        return l
```

## cartagen4py/algorithms/general/constraint.py

```diff
@@ -3,46 +3,57 @@
 import shapely, pprint, geopandas
 import numpy as np
 from cartagen4py.utils.partitioning.network import network_partition
 np.set_printoptions(suppress=True)
 
 class ConstraintMethod:
     """
-    Initialize constraint method object, with default constraints
+    Initialize constraint method object
     Parameters
     ----------
-    default_distance : int optional
-        This is the default distance for the detection of spatial conflicts.        
+    max_iteration : int optional
+        This is the maximum number of iteration before breaking the loop. If constraints and weights are correctly set, the norm tolerance threshold should be reached before the maximum number of iteration.
+        Default value is set to 1000.
+    norm_tolerance : float optional
+        The threshold below which the norm of the resulting point matrix is acceptable enough to break the iteration loop.
+        The default value is set to 0.05.
+    verbose : boolean optional
+        For debugging purposes, choose to print some key values while the constraint method is calculated.
+        Default set to False.
     """
-    def __init__(self, max_iteration=1000, default_distance=5, default_conflict_weight=15, norm_tolerance=0.05, verbose=False):
+    def __init__(self, max_iteration=1000, norm_tolerance=0.05, verbose=False):
         self.MAX_ITER = max_iteration
-        self.DEFAULT_DISTANCE = default_distance
-        self.DEFAULT_CONFLICT_WEIGHT = default_conflict_weight
         self.NORM_TOLERANCE = norm_tolerance
         self.VERBOSE = verbose
 
-        self.__ALLOWED_WEIGHTS = {
+        self.__ALLOWED_CONSTRAINTS = {
             'Point': ['movement'],
             'LineString': ['movement', 'stiffness', 'curvature'],
             'Polygon': ['movement', 'stiffness', 'curvature']
         }
 
+        # Create dummy arrays for distances and conflicts weights
         self.__DISTANCES = np.ndarray((0, 0))
         self.__CONFLICTS = np.ndarray((0, 0))
         
+        # List of future objects added to the generalization
         self.__OBJECTS = []
+        # The same list of objects once the generalization has been made
         self.__RESULTS = []
+        # Stores weights as entered by the user with the add() method
         self.__WEIGHTS = []
-        #Â self.__DISTANCES = []
+        # Stores the number of different shapes
         self.__SHAPE_COUNT = 0
         
+        # Stores all points of all objects
         self.__points = []
+        # Stores all points of all objects in nested lists of shapes
         self.__shapes = []
 
-        # Following contains all the object level constraints
+        # Stores points influenced by specific constraints
         self.__constraints = {
             'movement': [],
             'stiffness': [],
             'curvature': []
         }
 
         # Nodes and links will be respectively populated with node to node and node to link spatial conflicts
@@ -59,17 +70,17 @@
             One or multiple GeoSerie of geographic objects, can be points, lines or polygons (if multigeometry are provided, they will be exploded).
             If multiple objects are provided, they must be the same geometry type because the same constraints will be applied.
         weights : **int**, *optional*.
             Specify a weight value for a specific constraint. Possible weights:
             movement : **int**.
                 If an object is able to move, specify the weight of the movement constraint.
             stiffness : **int**.
-                If a polygon is able to move but is not flexible, specify the weight of the stiffness constraint. A point cannot have a stiffness constraint.
+                If a polygon or a line is able to move but is not flexible, specify the weight of the stiffness constraint. A point cannot have a stiffness constraint.
             curvature : **int**.
-                If a line or polygon is flexible, specify the weight of the curvature constraint. A point cannot have a curvature constraint.
+                If a polygon or line is flexible, specify the weight of the curvature constraint. A point cannot have a curvature constraint.
         """
 
         geometry = None
         for i, obj in enumerate(objects):
             # Explode geometries to avoid multigeometries
             o = obj.explode(ignore_index=True)
             
@@ -95,24 +106,20 @@
             # Add the object for safe keeping
             self.__OBJECTS.append(o)
             # Add the object for generalization
             self.__RESULTS.append(o)
 
     def __reconstruct_weights(self, geomtype, **weights):
         """
-        Reconstruct weights as a dict. Check whether weights are correcty set and/or apply default weights when needed
+        Reconstruct weights as a dict. Check whether weights are correcty set
         """
         w = {}
 
-        # Check if movement weight is provided and raise an error if not
-        if 'movement' not in w.keys():
-            raise Exception('You must provide a movement weight.')
-
         # Retrieve allowed weights for the given geometry type
-        allowed = self.__ALLOWED_WEIGHTS[geomtype]
+        allowed = self.__ALLOWED_CONSTRAINTS[geomtype]
         for name, value in weights.items():
             # If weight is not allowed, raise an error
             if name not in allowed:
                 raise Exception('{0} weight does not exists or cannot be applied to {1}.\n'.format(name, geomtype) +
                     'Available weights for {0}: {1}'.format(geomtype, ', '.join(allowed)))
             # Check if the weight is an integer
             if isinstance(value, int):
@@ -122,70 +129,73 @@
             # Raise an error if the weight is not an integer
             else:
                 raise Exception('Provided weight ({0}) is not an integer.'.format(value))
 
             # Add the weight to the dict
             w[name] = value
 
+        # Check if movement weight is provided and raise an error if not
+        if 'movement' not in w.keys():
+            raise Exception('You must provide a movement weight.')
+
         return w
 
     def add_spatial_conflicts(self, distances, spatial_weights):
         """
         Defines spatial conflict between pairs of geographic objects previously added.
         Parameters
         ----------
         distances : **Numpy**, *ndarray*.
             A numpy ndarray of dimension (x, x) where x is the number of objects added to the constraint method object before generalization.
             Value at index (i, j) must be the same as the value at index (j, i) and represents the distance between geographic objects added
             in the order they were added. 
         spatial_weights : **Numpy**, *ndarray*.
             Same as the distances matrix but the values represent the weight of the spatial conflict of the two considered objects.
         """
+
+        # Retrieve the number of objects
         nb_obj = len(self.__OBJECTS)
+
+        # Retrieve both array dimensions
         sd = distances.shape
         sw = spatial_weights.shape
+
+        # Retrieve the number of row and colums of each array
         xd, yd, xw, yw = sd[0], sd[1], sw[0], sw[1]
 
+        # Checks if both array have the same dimension
         if xd != xw or yd != yw:
             raise Exception("The distances matrix and the spatial weights matrix must have the same dimensions.")
         else:
+            # Checks if matrices are square
             if xd != yd:
                 raise Exception("The spatial conflict matrix must be square.")
             else:
                 dimension_error = False
+                # Checks if the dimensions of the matrices are the same as the number of objects
                 if xd != nb_obj:
                     dimension_error = True
                 if yd != nb_obj:
                     dimension_error = True
                 if dimension_error:
-                    raise Exception("The provided matrix must have both dimensions equal to the number of provided objects.")
+                    raise Exception("The provided matrix must have both dimensions equal to the number of provided objects." + \
+                        "Please follow the documentation to set up spatial conflicts.")
 
+        # If nothing has failed, stores both matrices
         self.__DISTANCES = distances
         self.__CONFLICTS = spatial_weights
 
-    def __set_default_spatial_conflicts(self):
-        dimension = self.__DISTANCES.shape[0]
-        for i in range(dimension):
-            for j in range(dimension):
-                if i != j:
-                    if self.__DISTANCES[i][j] == 0:
-                        self.__DISTANCES[i][j] = self.DEFAULT_DISTANCE
-                    if self.__CONFLICTS[i][j] == 0:
-                        self.__CONFLICTS[i][j] = self.DEFAULT_CONFLICT_WEIGHT
-
 
     def generalize(self, network_partitioning=False):
         """
         Launch the constraint generalization on the added objects.
         """
         # Checks if objects are present
         if len(self.__OBJECTS) < 1:
             raise Exception('No objects provided, cannot generalize.')
-
-        self.__set_default_spatial_conflicts()
         
         # Prepare points and shapes using their index
         points = self.__generate_point_list()
 
         # Flag spatially conflicting points depending on the distance parameter
         self.__calculate_spatial_conflicts(points)
 
@@ -230,56 +240,52 @@
         stiffness = self.__constraints['stiffness']
         curvature = self.__constraints['curvature']
         nodes = self.__nodes
         links = self.__links
 
         # Define the size of the vector
         size = 2 * len(points) +  2 * len(stiffness) + 3 * len(curvature) + len(nodes) + len(links)
+    
         # Create a zero filled np array of the wanted shape
         Y = np.zeros(size)
 
         # Add x and y value to the begining of the vector representing the movement constraint
         for i, p in enumerate(points):
             Y[2 * i] = p[0]
             Y[2 * i + 1] = p[1]
 
         offset = 2 * len(points)
         for i, p in enumerate(stiffness):
             current_id = p[0]
+            # Retrieve the next point in the shape
             apply, next_id = self.__get_next_point_in_shape(current_id, points)
+            # The apply boolean is set to False if the current point is the last of the shape in a LineString
             if apply:
                 dx, dy = self.__calculate_stiffness(current_id, next_id, points)
+                # Difference between the current and the following along the x axis (x - x+1)
                 Y[offset + 2 * i] = dx
+                # Difference between the current and the following along the y axis (y - y+1)
                 Y[offset + 2 * i + 1] = dy
         
         offset += 2 * len(stiffness)
         for i, p in enumerate(curvature):
             current_id = p[0]
+            # Retrieve the previous and the next point in the shape
             apply, previous_id, next_id = self.__get_surrounding_points_in_shape(current_id, points)
+            # The apply boolean is set to False if the current point is the first or the last of the shape in a LineString
             if apply:
-                normp, normn, alpha = self.__calculate_curvature(previous_id, current_id, next_id, points)
+                alpha, normp, normn = self.__calculate_curvature(previous_id, current_id, next_id, points)
+                # First value of the constraint is the angle formed by the previous, the current and the next point
                 Y[offset + i] = alpha
+                # Second value is the norm of the vector formed by the previous and the current point
                 Y[offset + i + 1] = normp
+                # Third value is the norm of the vector formed by the current and the next point
                 Y[offset + i + 2] = normn
 
-        offset += 3 * len(curvature)
-        # Add minimum distance between close nodes
-        for i, n in enumerate(nodes):
-            if n[3] > n[2]:
-                Y[offset + i] = n[3]
-            else:
-                Y[offset + i] = n[2]
-
-        # Add minimum distance between close nodes and links
-        offset += len(nodes)
-        for i, l in enumerate(links):
-            if l[4] > l[3]:
-                Y[offset + i] = l[4]
-            else:
-                Y[offset + i] = l[3]
+        # Keep 0 for the spatial conflicts (nodes and links)
 
         self.__Y = Y
 
     def __build_B(self, points):
         """
         Build the matrix B -> Y - S(X).
         """
@@ -293,37 +299,56 @@
         for i, p in enumerate(points):
             S[2 * i] = p[0]
             S[2 * i + 1] = p[1]
 
         offset = 2 * len(points)
         for i, p in enumerate(stiffness):
             current_id = p[0]
+            # Retrieve the next point in the shape
             apply, next_id = self.__get_next_point_in_shape(current_id, points)
+            # The apply boolean is set to False if the current point is the last of the shape in a LineString
             if apply:
                 dx, dy = self.__calculate_stiffness(current_id, next_id, points)
+                # Difference between the current and the following along the x axis (x - x+1)
                 S[offset + 2 * i] = dx
+                # Difference between the current and the following along the y axis (y - y+1)
                 S[offset + 2 * i + 1] = dy
 
         offset += 2 * len(stiffness)
         for i, p in enumerate(curvature):
             current_id = p[0]
+            # Retrieve the previous and the next point in the shape
             apply, previous_id, next_id = self.__get_surrounding_points_in_shape(current_id, points)
+            # The apply boolean is set to False if the current point is the first or the last of the shape in a LineString
             if apply:
-                normp, normn, alpha = self.__calculate_curvature(previous_id, current_id, next_id, points)
+                alpha, normp, normn = self.__calculate_curvature(previous_id, current_id, next_id, points)
+                # First value of the constraint is the angle formed by the previous, the current and the next point
                 S[offset + i] = alpha
+                # Second value is the norm of the vector formed by the previous and the current point
                 S[offset + i + 1] = normp
+                # Third value is the norm of the vector formed by the current and the next point
                 S[offset + i + 2] = normn
 
         offset += 3 * len(curvature)
         for i, n in enumerate(nodes):
-            S[offset + i] = n[3]
+            if n[3] > n[2]:
+                # Add 0 if the actual distance is higher than the minimum distance
+                S[offset + i] = 0
+            else:
+                # Add dist_min - dist if the actual distance is below the minimum distance
+                S[offset + i] = n[2] - n[3]
 
         offset += len(nodes)
         for i, l in enumerate(links):
-            S[offset + i] = l[4]
+            if l[4] > l[3]:
+                # Same as nodes
+                S[offset + i] = 0
+            else:
+                # Same as nodes
+                S[offset + i] = l[3] - l[4]
 
         return self.__Y - S
 
     def __build_W(self, points):
         """
         Build the weighting matrix.
         """
@@ -365,117 +390,138 @@
         # Create the diagonal weighting matrix by concatenating all constraints matrices
         self.__W = np.diag(np.concatenate((constraints)))
 
     def __compute_dx(self, points):
         """
         Apply the least square method to the model.
         """
+        # Build the jacobian matrix A
         A = self.__build_A(points)
+        # Build the matrix B which is S - Y
         B = self.__build_B(points)
 
         atp = A.T @ self.__W
         atpa = atp @ A
         atpb = atp @ B
 
+        # Solves the equation
         dx = np.linalg.solve(atpa, atpb)
+
         return dx
 
     def __build_A(self, points):
         """
         Build the jacobian matrix of the model.
         """
+        # Build an identity matrix for the movement constraint
         identity = np.identity(2 * len(points))
+
+        # Calulcate the stiffness matrix and stacking it on A
         stiffness = self.__build_stiffness(points)
         A = np.vstack((identity, stiffness))
+
+        # Calulcate the stiffness matrix and stacking it on A
         curvature = self.__build_curvature(points)
         A = np.vstack((A, curvature))
+
+        # Calulcate the spatial conflicts matrix and stacking it on A
         spatial = self.__build_spatial(points)
         A = np.vstack((A, spatial))
 
         return A
 
     def __build_stiffness(self, points):
         """
         Create a matrix for the stiffness constraint.
         """
         stiffness = self.__constraints['stiffness']
         m = np.zeros((2 * len(stiffness), 2 * len(points)))
 
         for i, p in enumerate(stiffness):
             current_id = p[0]
+            # Retrieve the next point in the shape
             apply, next_id = self.__get_next_point_in_shape(current_id, points)
+            # The apply boolean is set to False if the current point is the first or the last of the shape in a LineString
             if apply:
+                # x for the current point
                 m[2 * i][2 * current_id] = 1
+                # x for the next point
                 m[2 * i][2 * next_id] = -1
+                # y for the current point
                 m[2 * i + 1][2 * current_id + 1] = 1
+                # y for the next point
                 m[2 * i + 1][2 * next_id + 1] = -1
 
         return m
 
     def __build_curvature(self, points):
         """
         Create a matrix for the curvature constraint.
         """
         curvature = self.__constraints['curvature']
         m = np.zeros((3 * len(curvature), 2 * len(points)))
 
         for i, p in enumerate(curvature):
-            p0 = p[0]
-            apply, pp, pn = self.__get_surrounding_points_in_shape(p0, points)
+            p = p[0]
+            # Retrieve the previous and the next point in the shape
+            apply, pp, pn = self.__get_surrounding_points_in_shape(p, points)
+            # The apply boolean is set to False if the current point is the first or the last of the shape in a LineString
             if apply:
                 xp, yp = points[pp][0], points[pp][1]
-                x0, y0 = points[p0][0], points[p0][1]
+                x, y = points[p][0], points[p][1]
                 xn, yn = points[pn][0], points[pn][1]
-                x0xp = x0 - xp
-                y0yp = y0 - yp
-                x0xn = x0 - xn
-                y0yn = y0 - yn
-                b = ((x0xp)**2 + (y0yp)**2)
-                d = ((x0xn)**2 + (y0yn)**2)
-                c = ((x0xp) * (y0yn) - (x0xn) * (y0yp))
-                bd = b * d
-                a = (bd)**(-0.5)
 
-                lp = ((x0 - xp)**2 + (y0 - yp)**2) ** 0.5
-                ln = ((xn - x0)**2 + (yn - y0)**2) ** 0.5
-
-                m[3 * i][2 * pp] = a * (-x0xp * c + y0yn * b) / b
-                m[3 * i][2 * pp + 1] = a * (-x0xn * b - y0yp * c) / b
-                m[3 * i][2 * p0] = a * ((-yp + yn) * bd + c * ((y0yp) * d + (x0xn) * b)) / bd
-                m[3 * i][2 * p0 + 1] = a * ((xp - xn) * bd + c * ((y0yp) * d + (y0yn) * b)) / bd
-                m[3 * i][2 * pn] = a * (-x0xn * c - y0yp * d) / d
-                m[3 * i][2 * pn + 1] = a * (x0xp * d - y0yn * c) / d
-                m[3 * i + 1][2 * pp] = (x0 - xp) / lp
-                m[3 * i + 1][2 * pp + 1] = (y0 - yp) / lp
-                m[3 * i + 1][2 * p0] = -(x0 - xp) / lp
-                m[3 * i + 1][2 * p0 + 1] = -(y0 - yp) / lp
-                m[3 * i + 2][2 * pn] = (xn - x0) / ln
-                m[3 * i + 2][2 * pn + 1] = (yn - y0) / ln
-                m[3 * i + 2][2 * p0] = -(xn - x0) / ln
-                m[3 * i + 2][2 * p0 + 1] = -(yn - y0) / ln
-
-                # # Calculate equation factors for angles
-                # normU = np.sqrt((x0 - xp) * (x0 - xp) + (y0 - yp) * (y0 - yp))
-                # normW = np.sqrt((xn - x0) * (xn - x0) + (yn - y0) * (yn - y0))
-                # a = (y0 - yn) / (normU * normW)
-                # b = (-x0 + xn) / (normU * normW)
-                # c = (-yp + yn) / (normU * normW)
-                # d = (xp - xn) / (normU * normW)
-                # e = (yp - y0) / (normU * normW)
-                # f = (-xp + x0) / (normU * normW)
-
-                # # Calculate equation factors for lengths
-                # a1 = (xp - x0) / normU
-                # b1 = (yp - y0) / normU
-                # c1 = (x0 - xp) / normU
-                # d1 = (y0 - yp) / normU
-                # a2 = (xn - x0) / normW
-                # b2 = (yn - y0) / normW
-                # c2 = (x0 - xn) / normW
-                # d2 = (y0 - yn) / normW
+                x_xp = x - xp
+                y_yp = y - yp
+                x_xn = x - xn
+                y_yn = y - yn
+                b = ((x_xp) * (x_xp) + (y_yp) * (y_yp))
+                d = ((x_xn) * (x_xn) + (y_yn) * (y_yn))
+                c = ((x_xp) * (y_yn) - (x_xn) * (y_yp))
+                bd = b * d
+                a = (bd) ** (-0.5)
+                
+                # df/dxi-1
+                m[3 * i][2 * pp] = a * (-x_xp * c + y_yn * b) / b
+                # df/dyi-1
+                m[3 * i][2 * pp + 1] = a * (-x_xn * b - y_yp * c) / b
+                # df/dxi
+                m[3 * i][2 * p] = a * ((-yp + yn) * bd + c * ((x_xp) * d + (x_xn) * b)) / bd
+                # df/dyi
+                m[3 * i][2 * p + 1] = a * ((xp - xn) * bd + c * ((y_yp) * d + (y_yn) * b)) / bd
+                # df/dxi+1
+                m[3 * i][2 * pn] = a * (-x_xn * c - y_yp * d) / d
+                # df/dyi+1
+                m[3 * i][2 * pn + 1] = a * (x_xp * d - y_yn * c) / d
+
+                # Calculate length of the previous and next segment
+                lp = np.sqrt((x - xp) * (x - xp) + (y - yp) * (y - yp))
+                ln = np.sqrt((xn - x) * (xn - x) + (yn - y) * (yn - y))
+
+                # Influence of the length of previous segment on the current point
+                # x
+                m[3 * i + 1][2 * p] = (x - xp) / lp
+                # y
+                m[3 * i + 1][2 * p + 1] = (y - yp) / lp
+                # Influence of the length of previous segment on the previous point (p)
+                # xp
+                m[3 * i + 1][2 * pp] = -((x - xp) / lp)
+                # yp
+                m[3 * i + 1][2 * pp + 1] = -((y - yp) / lp)
+
+                # Influence of the length of following segment on the next point (n)
+                # xn
+                m[3 * i + 2][2 * pn] = (xn - x) / ln
+                # yn
+                m[3 * i + 2][2 * pn + 1] = (yn - y) / ln
+                # Influence of the length of following segment on the current point
+                # x
+                m[3 * i + 2][2 * p] = -((xn - x) / ln)
+                # y
+                m[3 * i + 2][2 * p + 1] = -((yn - y) / ln)
 
         return m
 
     def __build_spatial(self, points):
         """
         Create a matrix for the spatial conflicts constraint.
         """
@@ -492,18 +538,18 @@
             x1, x2, y1, y2 = n1[0], n2[0], n1[1], n2[1]
             # Calculate the vector formed by those two points
             v = np.array([x2 - x1, y2 - y1])
             # Calculate the vector norm
             norm = np.linalg.norm(v)
 
             # Calculate equations factors
-            a = (x1 - x2) / norm
-            b = (y1 - y2) / norm
-            c = (x2 - x1) / norm
-            d = (y2 - y1) / norm
+            a = - ((x1 - x2) / norm)
+            b = - ((y1 - y2) / norm)
+            c = - ((x2 - x1) / norm)
+            d = - ((y2 - y1) / norm)
 
             # Filling the matrix
             m[i][2 * n[0]] = a
             m[i][2 * n[0] + 1] = b
             m[i][2 * n[1]] = c
             m[i][2 * n[1] + 1] = d
 
@@ -519,100 +565,117 @@
             # Calculate the line formed by n1 and n2
             a = (y2 - y1) / (x1 - x2)
             b = 1.0
             c = x1 * (y1 - y2) / (x1 - x2) - y1
 
             # Calculate the equation factors
             h = 0.001
-            u = (np.abs(a * (x0 + h) + b * y0 + c) - np.abs(a * (x0 - h) + b * y0 + c)) \
-                / np.sqrt(a * a + b * b) * 2 * h
-            v = (np.abs(a * x0 + b * (y0 + h) + c) - np.abs(a * x0 + b * (y0 - h) + c)) \
-                / np.sqrt(a * a + b * b) * 2 * h
+            u = - ((np.abs(a * (x0 + h) + b * y0 + c) - np.abs(a * (x0 - h) + b * y0 + c)) \
+                / np.sqrt(a * a + b * b) * 2 * h)
+            v = - ((np.abs(a * x0 + b * (y0 + h) + c) - np.abs(a * x0 + b * (y0 - h) + c)) \
+                / np.sqrt(a * a + b * b) * 2 * h)
 
-            w = 1 / (2 * h) * (
+            w = - (1 / (2 * h) * (
                 np.abs(y0 + x0 * (y2 - y1) / (x1 + h - x2) - y1 + (x1 + h) * (y1 - y2) / (x1 + h - x2)) \
                 / np.sqrt((y2 - y1) * (y2 - y1) / ((x1 + h - x2) * (x1 + h - x2)) + 1) \
                 - np.abs(y0 + x0 * (y2 - y1) / (x1 - h - x2) - y1 + (x1 - h) * (y1 - y2) / (x1 - h - x2)) \
                 / np.sqrt((y2 - y1) * (y2 - y1) / ((x1 - h - x2) * (x1 - h - x2)) + 1)
-            )
+            ))
 
-            d = 1 / (2 * h) * (
+            d = - (1 / (2 * h) * (
                 np.abs(y0 + x0 * (y2 - (y1 + h)) / (x1 - x2) - y1 - h + x1 * (y1 + h - y2) / (x1 - x2)) \
                 / np.sqrt((y2 - (y1 + h)) * (y2 - (y1 + h)) / ((x1 - x2) * (x1 - x2)) + 1) \
                 - np.abs(y0 + x0 * (y2 - (y1 - h)) / (x1 - x2) - y1 + h + x1 * (y1 - h - y2) / (x1 - x2)) \
                 / np.sqrt((y2 - (y1 - h)) * (y2  - (y1 - h)) / ((x1 - x2) * (x1 - x2)) + 1)
-            )
+            ))
 
-            e = 1 / (2 * h) * (
+            e = - (1 / (2 * h) * (
                 np.abs(y0 + x0 * (y2 - y1) / (x1 - (x2 + h))- y1 + x1 * (y1 - y2) / (x1 - (x2 + h))) \
                 / np.sqrt((y2 - y1)* (y2 - y1) / ((x1 - (x2 + h)) * (x1 - (x2 + h))) + 1) \
                 - np.abs(y0 + x0 * (y2 - y1) / (x1 - (x2 - h)) - y1 + x1 * (y1 - y2) / (x1 - (x2 - h))) \
-                / np.sqrt((y2 - y1) * (y2 - y1) / ((x1 - (x2 - h)) * (x1 - (x2 - h))) + 1))
+                / np.sqrt((y2 - y1) * (y2 - y1) / ((x1 - (x2 - h)) * (x1 - (x2 - h))) + 1)))
 
-            f = 1 / (2 * h) * (
+            f = - (1 / (2 * h) * (
                 np.abs(y0 + x0 * (y2 + h - y1) / (x1 - x2) - y1 + x1 * (y1 - (y2 + h)) / (x1 - x2)) \
                 / np.sqrt((y2 + h - y1) * (y2 + h - y1) / ((x1 - x2) * (x1 - x2)) + 1) \
                 - np.abs(y0 + x0 * (y2 - h - y1) / (x1 - x2) - y1 + x1 * (y1 - (y2 - h)) / (x1 - x2)) \
-                / np.sqrt((y2 - h - y1) * (y2 - y1 - h) / ((x1 - x2) * (x1 - x2)) + 1))
+                / np.sqrt((y2 - h - y1) * (y2 - y1 - h) / ((x1 - x2) * (x1 - x2)) + 1)))
 
             # Filling the matrix with the partial derivatives
+            # For point 0, the node in the node-to-link conflict
+            # x0
             m[offset + i][2 * n[0]] = u
+            # y0
             m[offset + i][2 * n[0] + 1] = v
+            # For point 1 of the line (1, 2)
+            # x1
             m[offset + i][2 * n[1]] = w
+            # y1
             m[offset + i][2 * n[1] + 1] = d
+            # For point 2 of the line (1, 2)
+            # x2
             m[offset + i][2 * n[2]] = e
+            # y2
             m[offset + i][2 * n[2] + 1] = f
 
         return m
 
-    def __generate_point_list(self):
+    def __calculate_stiffness(self, current_id, next_id, points):
         """
-        Generate a list of points composed by a tuple of coordinates (x, y), the id of the object, the id of the shape of the object, and the id of the point inside the shape.
-        Generate a nested list of objects composed of all points it is made of, sorted by shapes.
-        Generate lists of points that will accept constraints
+        Estimate the stiffness by calculating the amount of movement between following point on a shape.
         """
+        x0, y0 = points[current_id][0], points[current_id][1]
+        x1, y1 = points[next_id][0], points[next_id][1]
+        return x0 - x1, y0 - y1
 
-        def add_point_constraint(pid, weights):
-            for cname, clist in self.__constraints.items():
-                if cname in weights.keys():
-                    w = np.inf if weights[cname] == -1 else weights[cname]
-                    self.__constraints[cname].append((pid, w))
+    def __calculate_curvature(self, previous_id, current_id, next_id, points):
+        """
+        Estimate the curvature by calculating the angle formed by the point, its previous and its following point.
+        """
+        pp = np.array((points[previous_id][0], points[previous_id][1]))
+        pc = np.array((points[current_id][0], points[current_id][1]))
+        pn = np.array((points[next_id][0], points[next_id][1]))
 
-        unique_points = []
-        point_id = 0
-        for oid, shapes in enumerate(self.__OBJECTS):
-            weights = self.__WEIGHTS[oid]
-            o = []
-            for sid, shape in shapes.iterrows():
-                s = []
-                geomtype = shape.geometry.geom_type
-                points = self.__get_coordinates(shape.geometry)
-                for pid, p in enumerate(points):
-                    if geomtype == 'Polygon' and pid >= (len(points) - 1):
-                        continue
-                    else:
-                        unique_points.append(p)
-                        self.__points.append((oid, sid, pid))
-                        s.append(point_id)
-                        add_point_constraint(point_id, weights)
-                        point_id += 1
-                o.append(s)
-            self.__shapes.append(o)
+        u = (pc - pp)
+        normu = np.linalg.norm(u)
+        v = (pn - pc)
+        normv = np.linalg.norm(v)
 
-        return np.array(unique_points)
+        return np.cross(u / normu, v / normv), normu, normv
 
     def __calculate_spatial_conflicts(self, points):
         """
         Retrieve conflicting pairs of nodes and nodes, or nodes and links.
         """
 
+        # Check if the node to link conflict concern segments of different objects crossing themselves
+        def line_crossing(p, point, line, points):
+            # Retrieve previous and following points of the shape
+            a, previous_id, next_id = self.__get_surrounding_points_in_shape(p, points)
+            # Loop through both points
+            for i in [previous_id, next_id]:
+                # If point exists
+                if i is not None:
+                    # Create the geometry
+                    ip = shapely.Point(points[i])
+                    # Create the line formed with the current point
+                    crossline = shapely.LineString([point, ip])
+                    # If that line crosses the concerned line, return True
+                    if shapely.crosses(line, crossline):
+                        return True
+            # If none of the two lines cross the concerned line, return False
+            return False
+
+        # Check if a node to node conflict already exists before adding one
         def add_node_to_node(c):
             add = True
             for n in self.__nodes:
-                if (c[0] == n[0] and c[1] == n[1]) or (c[0] == n[1] and c[1] == n[0]):
+                if (c[0] == n[0] and c[1] == n[1]):
+                    add = False
+                if (c[0] == n[1] and c[1] == n[0]):
                     add = False
             if add:
                 self.__nodes.append(c)
 
         def retrieve_nodes_links(shape, geomtype, p, conflict_dist, min_dist, weight):
             point = shapely.Point(points[p])
             # Loop through all the points of the LineString or Polygon shape
@@ -635,15 +698,16 @@
                 pdist1 = shapely.distance(point, point1)
                 pdist2 = shapely.distance(point, point2)
                 ldist = shapely.distance(point, line)
                 # First, re-checks if one of the three distance is below the minimum distance threshold
                 if pdist1 < conflict_dist or pdist2 < conflict_dist or ldist < conflict_dist:
                     # If the line distance is the smallest, insert a node to link spatial conflict
                     if ldist < pdist1 and ldist < pdist2:
-                        self.__links.append([p, p1, p2, min_dist, ldist, weight])
+                        if line_crossing(p, point, line, points) == False:
+                            self.__links.append([p, p1, p2, min_dist, ldist, weight]) 
                     else:
                         # Determine which node is the closest
                         if pdist1 < pdist2:
                             add_node_to_node([p, p1, min_dist, pdist1, weight])
                         else:
                             if notlast:
                                 add_node_to_node([p, p2, min_dist, pdist2, weight])
@@ -661,39 +725,90 @@
                         continue
                     else:
                         # Getting the weight of the spatial conflict constraint from the matrix
                         weight = self.__CONFLICTS[oid][oid1]
                         # Getting the distance value from the distances matrix
                         min_dist = self.__DISTANCES[oid][oid1]
                         # Setting a distance equal to 1.5 times the min distance to retrieve conflicting objects
+                        # Setting conflict_dist = min_dist doesn't take the 1.5 time conflicting entities
                         conflict_dist = 1.5 * min_dist
                         
                         # Retrieve the geometry of the shape
                         shape = self.__OBJECTS[oid1].geometry[sid1]
                         # Checks if that shape is within the minimum distance before retrieving pairs of nodes and links
                         if shapely.dwithin(point, shape, conflict_dist):
                             # Stores the geometry type
                             geomtype = shape.geom_type
                             # Checks if the shape is a point
                             if geomtype == 'Point':
                                 distance = shapely.distance(point, shape)
-                                self.__nodes.append([p, s[0], min_dist, distance, weight])
+                                add_node_to_node([p, s[0], min_dist, distance, weight])
                             # If it's not, checking if it's closer to a node or a segment
                             else:
                                 retrieve_nodes_links(s, geomtype, p, conflict_dist, min_dist, weight)
 
         # Loop through all objects
         for o in self.__shapes:
             # Loop through all shapes
             for s in o:
                 # Loop through all points
                 for p in s:
                     # Check conflicts with other points
                     check_conflicts(p)
 
+    def __generate_point_list(self):
+        """
+        Generate a list of points composed by a tuple of coordinates (x, y), the id of the object, the id of the shape of the object, and the id of the point inside the shape.
+        Generate a nested list of objects composed of all points it is made of, sorted by shapes.
+        Generate lists of points that will accept constraints
+        """
+
+        def add_point_constraint(pid, weights):
+            for cname, clist in self.__constraints.items():
+                if cname in weights.keys():
+                    w = np.inf if weights[cname] == -1 else weights[cname]
+                    self.__constraints[cname].append((pid, w))
+
+        unique_points = []
+        point_id = 0
+        # Loop through each objects
+        for oid, shapes in enumerate(self.__OBJECTS):
+            # retrieve the weights of the concerned object
+            weights = self.__WEIGHTS[oid]
+            o = []
+            # Loop through each shape of the object
+            for sid, shape in shapes.iterrows():
+                s = []
+                # Retrieve the geometry type
+                geomtype = shape.geometry.geom_type
+                # Retrieve x, y of the points of the shape
+                points = self.__get_coordinates(shape.geometry)
+                # Loop through each points in the shape
+                for pid, p in enumerate(points):
+                    # Skipping the last point of a polygon as it is the same as the first one
+                    if geomtype == 'Polygon' and pid >= (len(points) - 1):
+                        continue
+                    else:
+                        # Append point to the full list of points
+                        unique_points.append(p)
+                        # Append the position of the point within its object and shape
+                        self.__points.append((oid, sid, pid))
+                        # Append the point to its shape
+                        s.append(point_id)
+                        # Add the constraint associated with the point
+                        add_point_constraint(point_id, weights)
+                        point_id += 1
+                # Add the list of shapes to the object
+                o.append(s)
+            # Add the list of objects to the list
+            self.__shapes.append(o)
+
+        # Return an array of unique points
+        return np.array(unique_points)
+
     def __get_next_point_in_shape(self, current_id, points):
         position = self.__points[current_id]
         oid, sid, pid = position[0], position[1], position[2]
         shape = self.__shapes[oid][sid]
         geomtype = self.__OBJECTS[oid].geometry[0].geom_type
         
         pid1 = pid + 1
@@ -705,22 +820,14 @@
             if geomtype == 'Polygon':
                 next_id = shape[0]
             else:
                 apply = False
         
         return apply, next_id
 
-    def __calculate_stiffness(self, current_id, next_id, points):
-        """
-        Estimate the stiffness by calculating the amount of movement between following point on a shape.
-        """
-        x0, y0 = points[current_id][0], points[current_id][1]
-        x1, y1 = points[next_id][0], points[next_id][1]
-        return x0 - x1, y0 - y1
-
     def __get_surrounding_points_in_shape(self, current_id, points):
         position = self.__points[current_id]
         oid, sid, pid = position[0], position[1], position[2]
         shape = self.__shapes[oid][sid]
         geomtype = self.__OBJECTS[oid].geometry[0].geom_type
         
         pid1 = pid + 1
@@ -740,27 +847,14 @@
                     previous_id = shape[pid - 1]
                     next_id = shape[0]
             else:
                 apply = False
         
         return apply, previous_id, next_id
 
-    def __calculate_curvature(self, previous_id, current_id, next_id, points):
-        """
-        Estimate the curvature by calculating the angle formed by the point, its previous and its following point.
-        """
-        pp = np.array((points[previous_id][0], points[previous_id][1]))
-        pc = np.array((points[current_id][0], points[current_id][1]))
-        pn = np.array((points[next_id][0], points[next_id][1]))
-        u = (pc - pp)
-        normu = np.linalg.norm(u)
-        v = (pn - pc)
-        normv = np.linalg.norm(v)
-        return np.cross(u / normu, v / normv), normu, normv
-
     def __update_distances(self, points):
         """
         Update the distance between pairs of nodes and pairs of nodes and links
         """
         for i, n in enumerate(self.__nodes):
             n1, n2 = points[n[0]], points[n[1]]
             x1, x2, y1, y2 = n1[0], n2[0], n1[1], n2[1]
@@ -858,8 +952,9 @@
 
         if len(links) > 0:
             links_gdf = geopandas.GeoDataFrame(links, crs=3857)
             links_gdf.to_file("cartagen4py/data/data_bourbonnaise/links.geojson", driver="GeoJSON")
         
         points_gdf.to_file("cartagen4py/data/data_bourbonnaise/points_nodes.geojson", driver="GeoJSON")
         
-        
+    def get_objects_number(self):
+        return len(self.__OBJECTS)
```

### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

## Comparing `cartagen4py-0.2.0.dist-info/METADATA` & `cartagen4py-0.2.1.dist-info/METADATA`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: cartagen4py
-Version: 0.2.0
+Version: 0.2.1
 Summary: Python package to generalise geographic objects for cartographic purposes
 Home-page: https://github.com/LostInZoom/cartagen4py
 Author: Guillaume Touya, Justin Berli
 Author-email: guillaume.touya@ign.fr
 License: CeCILL-C
 Keywords: Generalization,Cartography,cartographic generalization
 Platform: Linux
```

## Comparing `cartagen4py-0.2.0.dist-info/RECORD` & `cartagen4py-0.2.1.dist-info/RECORD`

 * *Files 10% similar despite different names*

```diff
@@ -1,16 +1,16 @@
 cartagen4py/__init__.py,sha256=YdkVGqmL0XKX79SDwQU9sglqjKQ4fx3M-1BhguIYnJk,183
 cartagen4py/algorithms/__init__.py,sha256=m7IvuFWRVVytv5Drr9_qbWVLkycJGx9jv_EF-IgrYr0,134
 cartagen4py/algorithms/buildings/__init__.py,sha256=n8nINf2pCHNcBpEyg6Jrfh7pdEx5P4UoXEC7jjwzUf4,244
 cartagen4py/algorithms/buildings/amalgamation.py,sha256=jJ3RT5KT6cYprqnr69vqnMBzHD63hkSY1zpm22CuLW4,4500
-cartagen4py/algorithms/buildings/random_displacement.py,sha256=ajzEN5tNzpO8sDMkRnTqQ8XoXoXMDkZUEhJhovlgrOE,7441
+cartagen4py/algorithms/buildings/random_displacement.py,sha256=omaxGlgrDagHf0cyO_WuwG-x2QNesf_SMtPObrLr6AM,7791
 cartagen4py/algorithms/buildings/simplification.py,sha256=sO6-FOcas80fcn7Ty811NTh7494EmSIdEmCjAMhE0Hk,8144
 cartagen4py/algorithms/buildings/squaring.py,sha256=P_ZoN8BURGnZQaEJSWaeMjJaMBAHtKoaDTXmdSL9If8,15705
 cartagen4py/algorithms/general/__init__.py,sha256=LeXQ0-n_k-Q5lFs-2W_7ob71Im2ATryygJ2FnImjaIE,55
-cartagen4py/algorithms/general/constraint.py,sha256=8C_az8VXMaNS93SpsTXYZ3Bg94FRBXBrOplBnO87bqk,35580
+cartagen4py/algorithms/general/constraint.py,sha256=iqjLgpo-koxB4FfFRPE1RRptcOM-mtNw-FWtQ_OcP-s,41211
 cartagen4py/algorithms/lines/__init__.py,sha256=RVqQrBO-WwRlVgqVVq_6zj-9bUaAIurZBOSreCjrKWk,120
 cartagen4py/algorithms/lines/line_simplification.py,sha256=BP509Vu_xHvFVd709oBO2B1aA-gmuySgcarYHRVMNCQ,5307
 cartagen4py/algorithms/lines/line_smoothing.py,sha256=ggbQDdVRzTeMftlf8cO8G_uRDOoOqPZkgHoNR3QMm3Q,3095
 cartagen4py/data_enrichment/__init__.py,sha256=3Oo9EYF2JWSGIRiUSCrem52ilpeW5tVVhXB8lfBGtd8,162
 cartagen4py/data_enrichment/building_measures.py,sha256=tRMjYuAZPBgSpOsLLPl_21Z9g-5VRQz05aS8vlCkCnw,7219
 cartagen4py/data_enrichment/stroke.py,sha256=wfK-5kgH2E0n0Jzmytjqio-RGQC4Baejsme5biItg9U,14259
 cartagen4py/data_enrichment/urban_areas.py,sha256=CeeeM2EZfg7acDvq_n20KFJ6zzTmNeTpIcFp1bwOgNI,1018
@@ -30,11 +30,11 @@
 cartagen4py/utils/math/morphology.py,sha256=9SmuqZE2pj4EHUTnGuneNHAlcGmC-5Uoid1Bn8yhnuM,4693
 cartagen4py/utils/math/vector.py,sha256=P8XnNtifAUt36VqZNs27B5AYxOZtaq4B1kiDKQ91k6M,474
 cartagen4py/utils/partitioning/__init__.py,sha256=wYY4dcoZwO1bGr6UJvSeWWuTX6freF82hpQLEEZIADE,106
 cartagen4py/utils/partitioning/network.py,sha256=NlMGNc6I2nqBW0_s-YJMHWiO7PlQlhWLEs7dqdo-ZTQ,2183
 cartagen4py/utils/partitioning/quadtree.py,sha256=8UFlbKGqJGMRPKq_XY65rQ7LZDCrAde8-34OM9wv6UA,334
 cartagen4py/utils/tessellation/__init__.py,sha256=2GwkglcYNQ017m3mI1w2Ge_pcfn280ucAm7fCDKeEjw,54
 cartagen4py/utils/tessellation/hexagonal.py,sha256=StiXgRQ2-mosM9g9Y2_o0hs5t8iai6zwcwDJFF3iEBo,3721
-cartagen4py-0.2.0.dist-info/METADATA,sha256=R00Smh_IzUrMUPWhbAk3P_ZPBGIdFlRdWzzOU3eeYS8,914
-cartagen4py-0.2.0.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-cartagen4py-0.2.0.dist-info/top_level.txt,sha256=6aS8ZPdHwWPED3ELy_ijz8nBO9mSuD6vqCoaMn5ML3Q,12
-cartagen4py-0.2.0.dist-info/RECORD,,
+cartagen4py-0.2.1.dist-info/METADATA,sha256=uiCn-mmRBzEZwUIW9hl7QEV3Y9yGmO_AvL0EaqjuUnA,914
+cartagen4py-0.2.1.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+cartagen4py-0.2.1.dist-info/top_level.txt,sha256=6aS8ZPdHwWPED3ELy_ijz8nBO9mSuD6vqCoaMn5ML3Q,12
+cartagen4py-0.2.1.dist-info/RECORD,,
```

