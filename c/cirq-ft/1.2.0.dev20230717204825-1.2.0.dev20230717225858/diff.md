# Comparing `tmp/cirq_ft-1.2.0.dev20230717204825-py3-none-any.whl.zip` & `tmp/cirq_ft-1.2.0.dev20230717225858-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,72 +1,72 @@
-Zip file size: 143199 bytes, number of entries: 70
--rw-r--r--  2.0 unx     1546 b- defN 23-Jul-17 20:48 cirq_ft/__init__.py
--rw-r--r--  2.0 unx       40 b- defN 23-Jul-17 20:48 cirq_ft/_version.py
--rw-r--r--  2.0 unx     1978 b- defN 23-Jul-17 20:48 cirq_ft/algos/__init__.py
--rw-r--r--  2.0 unx     6416 b- defN 23-Jul-17 20:48 cirq_ft/algos/and_gate.py
--rw-r--r--  2.0 unx     9436 b- defN 23-Jul-17 20:48 cirq_ft/algos/and_gate_test.py
--rw-r--r--  2.0 unx     3938 b- defN 23-Jul-17 20:48 cirq_ft/algos/apply_gate_to_lth_target.py
--rw-r--r--  2.0 unx     4100 b- defN 23-Jul-17 20:48 cirq_ft/algos/apply_gate_to_lth_target_test.py
--rw-r--r--  2.0 unx    27215 b- defN 23-Jul-17 20:48 cirq_ft/algos/arithmetic_gates.py
--rw-r--r--  2.0 unx    17717 b- defN 23-Jul-17 20:48 cirq_ft/algos/arithmetic_gates_test.py
--rw-r--r--  2.0 unx     5775 b- defN 23-Jul-17 20:48 cirq_ft/algos/generic_select.py
--rw-r--r--  2.0 unx    11576 b- defN 23-Jul-17 20:48 cirq_ft/algos/generic_select_test.py
--rw-r--r--  2.0 unx    15417 b- defN 23-Jul-17 20:48 cirq_ft/algos/hubbard_model.py
--rw-r--r--  2.0 unx     2984 b- defN 23-Jul-17 20:48 cirq_ft/algos/hubbard_model_test.py
--rw-r--r--  2.0 unx     4411 b- defN 23-Jul-17 20:48 cirq_ft/algos/multi_control_multi_target_pauli.py
--rw-r--r--  2.0 unx     1584 b- defN 23-Jul-17 20:48 cirq_ft/algos/multi_control_multi_target_pauli_test.py
--rw-r--r--  2.0 unx     4103 b- defN 23-Jul-17 20:48 cirq_ft/algos/prepare_uniform_superposition.py
--rw-r--r--  2.0 unx     3403 b- defN 23-Jul-17 20:48 cirq_ft/algos/prepare_uniform_superposition_test.py
--rw-r--r--  2.0 unx     9368 b- defN 23-Jul-17 20:48 cirq_ft/algos/programmable_rotation_gate_array.py
--rw-r--r--  2.0 unx     6014 b- defN 23-Jul-17 20:48 cirq_ft/algos/programmable_rotation_gate_array_test.py
--rw-r--r--  2.0 unx     7606 b- defN 23-Jul-17 20:48 cirq_ft/algos/qrom.py
--rw-r--r--  2.0 unx     7214 b- defN 23-Jul-17 20:48 cirq_ft/algos/qrom_test.py
--rw-r--r--  2.0 unx     6427 b- defN 23-Jul-17 20:48 cirq_ft/algos/qubitization_walk_operator.py
--rw-r--r--  2.0 unx    13620 b- defN 23-Jul-17 20:48 cirq_ft/algos/qubitization_walk_operator_test.py
--rw-r--r--  2.0 unx     5476 b- defN 23-Jul-17 20:48 cirq_ft/algos/reflection_using_prepare.py
--rw-r--r--  2.0 unx    14779 b- defN 23-Jul-17 20:48 cirq_ft/algos/reflection_using_prepare_test.py
--rw-r--r--  2.0 unx     2827 b- defN 23-Jul-17 20:48 cirq_ft/algos/select_and_prepare.py
--rw-r--r--  2.0 unx    10999 b- defN 23-Jul-17 20:48 cirq_ft/algos/select_swap_qrom.py
--rw-r--r--  2.0 unx     3976 b- defN 23-Jul-17 20:48 cirq_ft/algos/select_swap_qrom_test.py
--rw-r--r--  2.0 unx     4485 b- defN 23-Jul-17 20:48 cirq_ft/algos/selected_majorana_fermion.py
--rw-r--r--  2.0 unx     7642 b- defN 23-Jul-17 20:48 cirq_ft/algos/selected_majorana_fermion_test.py
--rw-r--r--  2.0 unx     6972 b- defN 23-Jul-17 20:48 cirq_ft/algos/state_preparation.py
--rw-r--r--  2.0 unx     6673 b- defN 23-Jul-17 20:48 cirq_ft/algos/state_preparation_test.py
--rw-r--r--  2.0 unx     8789 b- defN 23-Jul-17 20:48 cirq_ft/algos/swap_network.py
--rw-r--r--  2.0 unx     6463 b- defN 23-Jul-17 20:48 cirq_ft/algos/swap_network_test.py
--rw-r--r--  2.0 unx    17538 b- defN 23-Jul-17 20:48 cirq_ft/algos/unary_iteration_gate.py
--rw-r--r--  2.0 unx     8091 b- defN 23-Jul-17 20:48 cirq_ft/algos/unary_iteration_gate_test.py
--rw-r--r--  2.0 unx      849 b- defN 23-Jul-17 20:48 cirq_ft/algos/mean_estimation/__init__.py
--rw-r--r--  2.0 unx     2263 b- defN 23-Jul-17 20:48 cirq_ft/algos/mean_estimation/arctan.py
--rw-r--r--  2.0 unx     1875 b- defN 23-Jul-17 20:48 cirq_ft/algos/mean_estimation/arctan_test.py
--rw-r--r--  2.0 unx     3286 b- defN 23-Jul-17 20:48 cirq_ft/algos/mean_estimation/complex_phase_oracle.py
--rw-r--r--  2.0 unx     3388 b- defN 23-Jul-17 20:48 cirq_ft/algos/mean_estimation/complex_phase_oracle_test.py
--rw-r--r--  2.0 unx     7163 b- defN 23-Jul-17 20:48 cirq_ft/algos/mean_estimation/mean_estimation_operator.py
--rw-r--r--  2.0 unx    10473 b- defN 23-Jul-17 20:48 cirq_ft/algos/mean_estimation/mean_estimation_operator_test.py
--rw-r--r--  2.0 unx     1006 b- defN 23-Jul-17 20:48 cirq_ft/infra/__init__.py
--rw-r--r--  2.0 unx     3520 b- defN 23-Jul-17 20:48 cirq_ft/infra/bit_tools.py
--rw-r--r--  2.0 unx     2838 b- defN 23-Jul-17 20:48 cirq_ft/infra/bit_tools_test.py
--rw-r--r--  2.0 unx     3647 b- defN 23-Jul-17 20:48 cirq_ft/infra/decompose_protocol.py
--rw-r--r--  2.0 unx     1784 b- defN 23-Jul-17 20:48 cirq_ft/infra/decompose_protocol_test.py
--rw-r--r--  2.0 unx    13514 b- defN 23-Jul-17 20:48 cirq_ft/infra/gate_with_registers.py
--rw-r--r--  2.0 unx     5498 b- defN 23-Jul-17 20:48 cirq_ft/infra/gate_with_registers_test.py
--rw-r--r--  2.0 unx     3938 b- defN 23-Jul-17 20:48 cirq_ft/infra/jupyter_tools.py
--rw-r--r--  2.0 unx     1992 b- defN 23-Jul-17 20:48 cirq_ft/infra/jupyter_tools_test.py
--rw-r--r--  2.0 unx     9405 b- defN 23-Jul-17 20:48 cirq_ft/infra/qubit_management_transformers.py
--rw-r--r--  2.0 unx    13631 b- defN 23-Jul-17 20:48 cirq_ft/infra/qubit_management_transformers_test.py
--rw-r--r--  2.0 unx     3853 b- defN 23-Jul-17 20:48 cirq_ft/infra/qubit_manager.py
--rw-r--r--  2.0 unx     3126 b- defN 23-Jul-17 20:48 cirq_ft/infra/qubit_manager_test.py
--rw-r--r--  2.0 unx     6693 b- defN 23-Jul-17 20:48 cirq_ft/infra/t_complexity_protocol.py
--rw-r--r--  2.0 unx     7836 b- defN 23-Jul-17 20:48 cirq_ft/infra/t_complexity_protocol_test.py
--rw-r--r--  2.0 unx     5305 b- defN 23-Jul-17 20:48 cirq_ft/infra/testing.py
--rw-r--r--  2.0 unx     2800 b- defN 23-Jul-17 20:48 cirq_ft/infra/testing_test.py
--rw-r--r--  2.0 unx      809 b- defN 23-Jul-17 20:48 cirq_ft/infra/type_convertors.py
--rw-r--r--  2.0 unx      772 b- defN 23-Jul-17 20:48 cirq_ft/infra/type_convertors_test.py
--rw-r--r--  2.0 unx      673 b- defN 23-Jul-17 20:48 cirq_ft/linalg/__init__.py
--rw-r--r--  2.0 unx     8140 b- defN 23-Jul-17 20:48 cirq_ft/linalg/lcu_util.py
--rw-r--r--  2.0 unx     6420 b- defN 23-Jul-17 20:48 cirq_ft/linalg/lcu_util_test.py
--rw-r--r--  2.0 unx    11357 b- defN 23-Jul-17 20:48 cirq_ft-1.2.0.dev20230717204825.dist-info/LICENSE
--rw-r--r--  2.0 unx     1509 b- defN 23-Jul-17 20:48 cirq_ft-1.2.0.dev20230717204825.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Jul-17 20:48 cirq_ft-1.2.0.dev20230717204825.dist-info/WHEEL
--rw-r--r--  2.0 unx        8 b- defN 23-Jul-17 20:48 cirq_ft-1.2.0.dev20230717204825.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     6633 b- defN 23-Jul-17 20:48 cirq_ft-1.2.0.dev20230717204825.dist-info/RECORD
-70 files, 432694 bytes uncompressed, 132465 bytes compressed:  69.4%
+Zip file size: 142614 bytes, number of entries: 70
+-rw-r--r--  2.0 unx     1546 b- defN 23-Jul-17 22:58 cirq_ft/__init__.py
+-rw-r--r--  2.0 unx       40 b- defN 23-Jul-17 22:58 cirq_ft/_version.py
+-rw-r--r--  2.0 unx     1978 b- defN 23-Jul-17 22:58 cirq_ft/algos/__init__.py
+-rw-r--r--  2.0 unx     6416 b- defN 23-Jul-17 22:58 cirq_ft/algos/and_gate.py
+-rw-r--r--  2.0 unx     9436 b- defN 23-Jul-17 22:58 cirq_ft/algos/and_gate_test.py
+-rw-r--r--  2.0 unx     3938 b- defN 23-Jul-17 22:58 cirq_ft/algos/apply_gate_to_lth_target.py
+-rw-r--r--  2.0 unx     4100 b- defN 23-Jul-17 22:58 cirq_ft/algos/apply_gate_to_lth_target_test.py
+-rw-r--r--  2.0 unx    27215 b- defN 23-Jul-17 22:58 cirq_ft/algos/arithmetic_gates.py
+-rw-r--r--  2.0 unx    17717 b- defN 23-Jul-17 22:58 cirq_ft/algos/arithmetic_gates_test.py
+-rw-r--r--  2.0 unx     5775 b- defN 23-Jul-17 22:58 cirq_ft/algos/generic_select.py
+-rw-r--r--  2.0 unx    11576 b- defN 23-Jul-17 22:58 cirq_ft/algos/generic_select_test.py
+-rw-r--r--  2.0 unx    15417 b- defN 23-Jul-17 22:58 cirq_ft/algos/hubbard_model.py
+-rw-r--r--  2.0 unx     2984 b- defN 23-Jul-17 22:58 cirq_ft/algos/hubbard_model_test.py
+-rw-r--r--  2.0 unx     4411 b- defN 23-Jul-17 22:58 cirq_ft/algos/multi_control_multi_target_pauli.py
+-rw-r--r--  2.0 unx     1584 b- defN 23-Jul-17 22:58 cirq_ft/algos/multi_control_multi_target_pauli_test.py
+-rw-r--r--  2.0 unx     4103 b- defN 23-Jul-17 22:58 cirq_ft/algos/prepare_uniform_superposition.py
+-rw-r--r--  2.0 unx     3403 b- defN 23-Jul-17 22:58 cirq_ft/algos/prepare_uniform_superposition_test.py
+-rw-r--r--  2.0 unx     9368 b- defN 23-Jul-17 22:58 cirq_ft/algos/programmable_rotation_gate_array.py
+-rw-r--r--  2.0 unx     6014 b- defN 23-Jul-17 22:58 cirq_ft/algos/programmable_rotation_gate_array_test.py
+-rw-r--r--  2.0 unx     7606 b- defN 23-Jul-17 22:58 cirq_ft/algos/qrom.py
+-rw-r--r--  2.0 unx     7214 b- defN 23-Jul-17 22:58 cirq_ft/algos/qrom_test.py
+-rw-r--r--  2.0 unx     6427 b- defN 23-Jul-17 22:58 cirq_ft/algos/qubitization_walk_operator.py
+-rw-r--r--  2.0 unx    13620 b- defN 23-Jul-17 22:58 cirq_ft/algos/qubitization_walk_operator_test.py
+-rw-r--r--  2.0 unx     5476 b- defN 23-Jul-17 22:58 cirq_ft/algos/reflection_using_prepare.py
+-rw-r--r--  2.0 unx    14779 b- defN 23-Jul-17 22:58 cirq_ft/algos/reflection_using_prepare_test.py
+-rw-r--r--  2.0 unx     2827 b- defN 23-Jul-17 22:58 cirq_ft/algos/select_and_prepare.py
+-rw-r--r--  2.0 unx    10999 b- defN 23-Jul-17 22:58 cirq_ft/algos/select_swap_qrom.py
+-rw-r--r--  2.0 unx     3976 b- defN 23-Jul-17 22:58 cirq_ft/algos/select_swap_qrom_test.py
+-rw-r--r--  2.0 unx     4485 b- defN 23-Jul-17 22:58 cirq_ft/algos/selected_majorana_fermion.py
+-rw-r--r--  2.0 unx     7532 b- defN 23-Jul-17 22:58 cirq_ft/algos/selected_majorana_fermion_test.py
+-rw-r--r--  2.0 unx     6972 b- defN 23-Jul-17 22:58 cirq_ft/algos/state_preparation.py
+-rw-r--r--  2.0 unx     5150 b- defN 23-Jul-17 22:58 cirq_ft/algos/state_preparation_test.py
+-rw-r--r--  2.0 unx     8789 b- defN 23-Jul-17 22:58 cirq_ft/algos/swap_network.py
+-rw-r--r--  2.0 unx     6463 b- defN 23-Jul-17 22:58 cirq_ft/algos/swap_network_test.py
+-rw-r--r--  2.0 unx    17768 b- defN 23-Jul-17 22:58 cirq_ft/algos/unary_iteration_gate.py
+-rw-r--r--  2.0 unx     8091 b- defN 23-Jul-17 22:58 cirq_ft/algos/unary_iteration_gate_test.py
+-rw-r--r--  2.0 unx      849 b- defN 23-Jul-17 22:58 cirq_ft/algos/mean_estimation/__init__.py
+-rw-r--r--  2.0 unx     2263 b- defN 23-Jul-17 22:58 cirq_ft/algos/mean_estimation/arctan.py
+-rw-r--r--  2.0 unx     1875 b- defN 23-Jul-17 22:58 cirq_ft/algos/mean_estimation/arctan_test.py
+-rw-r--r--  2.0 unx     3286 b- defN 23-Jul-17 22:58 cirq_ft/algos/mean_estimation/complex_phase_oracle.py
+-rw-r--r--  2.0 unx     3388 b- defN 23-Jul-17 22:58 cirq_ft/algos/mean_estimation/complex_phase_oracle_test.py
+-rw-r--r--  2.0 unx     7163 b- defN 23-Jul-17 22:58 cirq_ft/algos/mean_estimation/mean_estimation_operator.py
+-rw-r--r--  2.0 unx    10473 b- defN 23-Jul-17 22:58 cirq_ft/algos/mean_estimation/mean_estimation_operator_test.py
+-rw-r--r--  2.0 unx     1006 b- defN 23-Jul-17 22:58 cirq_ft/infra/__init__.py
+-rw-r--r--  2.0 unx     3520 b- defN 23-Jul-17 22:58 cirq_ft/infra/bit_tools.py
+-rw-r--r--  2.0 unx     2838 b- defN 23-Jul-17 22:58 cirq_ft/infra/bit_tools_test.py
+-rw-r--r--  2.0 unx     3647 b- defN 23-Jul-17 22:58 cirq_ft/infra/decompose_protocol.py
+-rw-r--r--  2.0 unx     1784 b- defN 23-Jul-17 22:58 cirq_ft/infra/decompose_protocol_test.py
+-rw-r--r--  2.0 unx    13514 b- defN 23-Jul-17 22:58 cirq_ft/infra/gate_with_registers.py
+-rw-r--r--  2.0 unx     5498 b- defN 23-Jul-17 22:58 cirq_ft/infra/gate_with_registers_test.py
+-rw-r--r--  2.0 unx     3938 b- defN 23-Jul-17 22:58 cirq_ft/infra/jupyter_tools.py
+-rw-r--r--  2.0 unx     1992 b- defN 23-Jul-17 22:58 cirq_ft/infra/jupyter_tools_test.py
+-rw-r--r--  2.0 unx     9405 b- defN 23-Jul-17 22:58 cirq_ft/infra/qubit_management_transformers.py
+-rw-r--r--  2.0 unx    13631 b- defN 23-Jul-17 22:58 cirq_ft/infra/qubit_management_transformers_test.py
+-rw-r--r--  2.0 unx     3853 b- defN 23-Jul-17 22:58 cirq_ft/infra/qubit_manager.py
+-rw-r--r--  2.0 unx     3126 b- defN 23-Jul-17 22:58 cirq_ft/infra/qubit_manager_test.py
+-rw-r--r--  2.0 unx     6693 b- defN 23-Jul-17 22:58 cirq_ft/infra/t_complexity_protocol.py
+-rw-r--r--  2.0 unx     7836 b- defN 23-Jul-17 22:58 cirq_ft/infra/t_complexity_protocol_test.py
+-rw-r--r--  2.0 unx     5305 b- defN 23-Jul-17 22:58 cirq_ft/infra/testing.py
+-rw-r--r--  2.0 unx     2800 b- defN 23-Jul-17 22:58 cirq_ft/infra/testing_test.py
+-rw-r--r--  2.0 unx      809 b- defN 23-Jul-17 22:58 cirq_ft/infra/type_convertors.py
+-rw-r--r--  2.0 unx      772 b- defN 23-Jul-17 22:58 cirq_ft/infra/type_convertors_test.py
+-rw-r--r--  2.0 unx      673 b- defN 23-Jul-17 22:58 cirq_ft/linalg/__init__.py
+-rw-r--r--  2.0 unx     8140 b- defN 23-Jul-17 22:58 cirq_ft/linalg/lcu_util.py
+-rw-r--r--  2.0 unx     6420 b- defN 23-Jul-17 22:58 cirq_ft/linalg/lcu_util_test.py
+-rw-r--r--  2.0 unx    11357 b- defN 23-Jul-17 22:59 cirq_ft-1.2.0.dev20230717225858.dist-info/LICENSE
+-rw-r--r--  2.0 unx     1509 b- defN 23-Jul-17 22:59 cirq_ft-1.2.0.dev20230717225858.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jul-17 22:59 cirq_ft-1.2.0.dev20230717225858.dist-info/WHEEL
+-rw-r--r--  2.0 unx        8 b- defN 23-Jul-17 22:59 cirq_ft-1.2.0.dev20230717225858.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     6633 b- defN 23-Jul-17 22:59 cirq_ft-1.2.0.dev20230717225858.dist-info/RECORD
+70 files, 431291 bytes uncompressed, 131880 bytes compressed:  69.4%
```

## zipnote {}

```diff
@@ -189,23 +189,23 @@
 
 Filename: cirq_ft/linalg/lcu_util.py
 Comment: 
 
 Filename: cirq_ft/linalg/lcu_util_test.py
 Comment: 
 
-Filename: cirq_ft-1.2.0.dev20230717204825.dist-info/LICENSE
+Filename: cirq_ft-1.2.0.dev20230717225858.dist-info/LICENSE
 Comment: 
 
-Filename: cirq_ft-1.2.0.dev20230717204825.dist-info/METADATA
+Filename: cirq_ft-1.2.0.dev20230717225858.dist-info/METADATA
 Comment: 
 
-Filename: cirq_ft-1.2.0.dev20230717204825.dist-info/WHEEL
+Filename: cirq_ft-1.2.0.dev20230717225858.dist-info/WHEEL
 Comment: 
 
-Filename: cirq_ft-1.2.0.dev20230717204825.dist-info/top_level.txt
+Filename: cirq_ft-1.2.0.dev20230717225858.dist-info/top_level.txt
 Comment: 
 
-Filename: cirq_ft-1.2.0.dev20230717204825.dist-info/RECORD
+Filename: cirq_ft-1.2.0.dev20230717225858.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## cirq_ft/_version.py

```diff
@@ -1 +1 @@
-__version__ = "1.2.0.dev20230717204825"
+__version__ = "1.2.0.dev20230717225858"
```

## cirq_ft/algos/selected_majorana_fermion_test.py

```diff
@@ -18,42 +18,41 @@
 import pytest
 from cirq_ft.infra.bit_tools import iter_bits
 
 
 @pytest.mark.parametrize("selection_bitsize, target_bitsize", [(2, 4), (3, 8), (4, 9)])
 @pytest.mark.parametrize("target_gate", [cirq.X, cirq.Y])
 def test_selected_majorana_fermion_gate(selection_bitsize, target_bitsize, target_gate):
-    greedy_mm = cirq_ft.GreedyQubitManager(prefix="_a", maximize_reuse=True)
     gate = cirq_ft.SelectedMajoranaFermionGate(
         cirq_ft.SelectionRegisters(
             [cirq_ft.SelectionRegister('selection', selection_bitsize, target_bitsize)]
         ),
         target_gate=target_gate,
     )
-    g = cirq_ft.testing.GateHelper(gate, context=cirq.DecompositionContext(greedy_mm))
+    g = cirq_ft.testing.GateHelper(gate)
     assert len(g.all_qubits) <= gate.registers.total_bits() + selection_bitsize + 1
 
     sim = cirq.Simulator(dtype=np.complex128)
     for n in range(target_bitsize):
         # Initial qubit values
-        qubit_vals = {q: 0 for q in g.all_qubits}
+        qubit_vals = {q: 0 for q in g.operation.qubits}
         # All controls 'on' to activate circuit
         qubit_vals.update({c: 1 for c in g.quregs['control']})
         # Set selection according to `n`
         qubit_vals.update(zip(g.quregs['selection'], iter_bits(n, selection_bitsize)))
 
-        initial_state = [qubit_vals[x] for x in g.all_qubits]
+        initial_state = [qubit_vals[x] for x in g.operation.qubits]
 
         result = sim.simulate(
-            g.decomposed_circuit, initial_state=initial_state, qubit_order=g.all_qubits
+            g.circuit, initial_state=initial_state, qubit_order=g.operation.qubits
         )
 
         final_target_state = cirq.sub_state_vector(
             result.final_state_vector,
-            keep_indices=[g.all_qubits.index(q) for q in g.quregs['target']],
+            keep_indices=[g.operation.qubits.index(q) for q in g.quregs['target']],
         )
 
         expected_target_state = cirq.Circuit(
             [cirq.Z(q) for q in g.quregs['target'][:n]],
             target_gate(g.quregs['target'][n]),
             [cirq.I(q) for q in g.quregs['target'][n + 1 :]],
         ).final_state_vector(qubit_order=g.quregs['target'])
```

## cirq_ft/algos/state_preparation_test.py

```diff
@@ -8,67 +8,34 @@
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-import itertools
-
 import cirq
 import cirq_ft
 import numpy as np
 import pytest
 from cirq_ft.algos.generic_select_test import get_1d_Ising_lcu_coeffs
 from cirq_ft.infra.jupyter_tools import execute_notebook
 
 
-def construct_gate_helper_and_qubit_order(data, eps):
-    gate = cirq_ft.StatePreparationAliasSampling.from_lcu_probs(
-        lcu_probabilities=data, probability_epsilon=eps
-    )
-    g = cirq_ft.testing.GateHelper(gate)
-    context = cirq.DecompositionContext(cirq.ops.SimpleQubitManager())
-
-    def map_func(op: cirq.Operation, _):
-        gateset = cirq.Gateset(cirq_ft.And, cirq_ft.LessThanEqualGate, cirq_ft.LessThanGate)
-        return cirq.Circuit(
-            cirq.decompose(op, on_stuck_raise=None, keep=gateset.validate, context=context)
-        )
-
-    # TODO: Do not decompose {cq.And, cq.LessThanEqualGate, cq.LessThanGate} because the
-    # `cq.map_clean_and_borrowable_qubits` currently gets confused and is not able to re-map qubits
-    # optimally; which results in a higher number of ancillas thus the tests fails due to OOO.
-    decomposed_circuit = cirq.map_operations_and_unroll(
-        g.circuit, map_func, raise_if_add_qubits=False
-    )
-    greedy_mm = cirq_ft.GreedyQubitManager(prefix="_a", size=25, maximize_reuse=True)
-    decomposed_circuit = cirq_ft.map_clean_and_borrowable_qubits(decomposed_circuit, qm=greedy_mm)
-    # We are fine decomposing the `cq.And` gates once the qubit re-mapping is complete. Ideally,
-    # we shouldn't require this two step process.
-    arithmetic_gateset = cirq.Gateset(cirq_ft.LessThanEqualGate, cirq_ft.LessThanGate)
-    decomposed_circuit = cirq.Circuit(
-        cirq.decompose(decomposed_circuit, keep=arithmetic_gateset.validate, on_stuck_raise=None)
-    )
-    ordered_input = list(itertools.chain(*g.quregs.values()))
-    qubit_order = cirq.QubitOrder.explicit(ordered_input, fallback=cirq.QubitOrder.DEFAULT)
-    return g, qubit_order, decomposed_circuit
-
-
 @pytest.mark.parametrize("num_sites, epsilon", [[2, 3e-3], [3, 3.0e-3], [4, 5.0e-3], [7, 8.0e-3]])
 def test_state_preparation_via_coherent_alias_sampling(num_sites, epsilon):
     lcu_coefficients = get_1d_Ising_lcu_coeffs(num_sites)
-    g, qubit_order, decomposed_circuit = construct_gate_helper_and_qubit_order(
-        lcu_coefficients, epsilon
-    )
-    # assertion to ensure that simulating the `decomposed_circuit` doesn't run out of memory.
-    assert len(decomposed_circuit.all_qubits()) < 25
-    result = cirq.Simulator(dtype=np.complex128).simulate(
-        decomposed_circuit, qubit_order=qubit_order
+    gate = cirq_ft.StatePreparationAliasSampling.from_lcu_probs(
+        lcu_probabilities=lcu_coefficients.tolist(), probability_epsilon=epsilon
     )
+    g = cirq_ft.testing.GateHelper(gate)
+    qubit_order = g.operation.qubits
+
+    # Assertion to ensure that simulating the `decomposed_circuit` doesn't run out of memory.
+    assert len(g.circuit.all_qubits()) < 20
+    result = cirq.Simulator(dtype=np.complex128).simulate(g.circuit, qubit_order=qubit_order)
     state_vector = result.final_state_vector
     # State vector is of the form |l>|temp_{l}>. We trace out the |temp_{l}> part to
     # get the coefficients corresponding to |l>.
     L, logL = len(lcu_coefficients), len(g.quregs['selection'])
     state_vector = state_vector.reshape(2**logL, len(state_vector) // 2**logL)
     num_non_zero = (abs(state_vector) > 1e-6).sum(axis=1)
     prepared_state = state_vector.sum(axis=1)
@@ -78,15 +45,20 @@
     # Assert that the absolute square of prepared state (probabilities instead of amplitudes) is
     # same as `lcu_coefficients` upto `epsilon`.
     np.testing.assert_allclose(lcu_coefficients, abs(prepared_state) ** 2, atol=epsilon)
 
 
 def test_state_preparation_via_coherent_alias_sampling_diagram():
     data = np.asarray(range(1, 5)) / np.sum(range(1, 5))
-    g, qubit_order, _ = construct_gate_helper_and_qubit_order(data, 0.05)
+    gate = cirq_ft.StatePreparationAliasSampling.from_lcu_probs(
+        lcu_probabilities=data.tolist(), probability_epsilon=0.05
+    )
+    g = cirq_ft.testing.GateHelper(gate)
+    qubit_order = g.operation.qubits
+
     circuit = cirq.Circuit(cirq.decompose_once(g.operation))
     cirq.testing.assert_has_diagram(
         circuit,
         '''
 selection0: ────────UNIFORM(4)───In───────────────────×(y)───
                     │            │                    │
 selection1: ────────target───────In───────────────────×(y)───
```

## cirq_ft/algos/unary_iteration_gate.py

```diff
@@ -24,31 +24,33 @@
 from cirq_ft.algos import and_gate
 
 
 def _unary_iteration_segtree(
     ops: List[cirq.Operation],
     control: cirq.Qid,
     selection: Sequence[cirq.Qid],
+    ancilla: Sequence[cirq.Qid],
     sl: int,
     l: int,
     r: int,
     l_iter: int,
     r_iter: int,
-    qm: cirq.QubitManager,
 ) -> Iterator[Tuple[cirq.OP_TREE, cirq.Qid, int]]:
     """Constructs a unary iteration circuit by iterating over nodes of an implicit Segment Tree.
 
     Args:
         ops: Operations accumulated so far while traversing the implicit segment tree. The
             accumulated ops are yielded and cleared when we reach a leaf node.
         control: The control qubit that controls the execution of the entire unary iteration
             circuit represented by the current node of the segment tree.
         selection: Sequence of selection qubits. The i'th qubit in the list corresponds to the i'th
             level in the segment tree.Thus, a total of O(logN) selection qubits are required for a
             tree on range `N = (r_iter - l_iter)`.
+        ancilla: Pre-allocated ancilla qubits to be used for constructing the unary iteration
+            circuit.
         sl: Current depth of the tree. `selection[sl]` gives the selection qubit corresponding to
             the current depth.
         l: Left index of the range represented by current node of the segment tree.
         r: Right index of the range represented by current node of the segment tree.
         l_iter: Left index of iteration range over which the segment tree should be constructed.
         r_iter: Right index of iteration range over which the segment tree should be constructed.
 
@@ -72,81 +74,81 @@
         ops.clear()
         return
     assert sl < len(selection)
     m = (l + r) >> 1
     if r_iter <= m:
         # Yield only left sub-tree.
         yield from _unary_iteration_segtree(
-            ops, control, selection, sl + 1, l, m, l_iter, r_iter, qm
+            ops, control, selection, ancilla, sl + 1, l, m, l_iter, r_iter
         )
         return
     if l_iter >= m:
         # Yield only right sub-tree
         yield from _unary_iteration_segtree(
-            ops, control, selection, sl + 1, m, r, l_iter, r_iter, qm
+            ops, control, selection, ancilla, sl + 1, m, r, l_iter, r_iter
         )
         return
-    anc, sq = qm.qalloc(1)[0], selection[sl]
+    anc, sq = ancilla[sl], selection[sl]
     ops.append(and_gate.And((1, 0)).on(control, sq, anc))
-    yield from _unary_iteration_segtree(ops, anc, selection, sl + 1, l, m, l_iter, r_iter, qm)
+    yield from _unary_iteration_segtree(ops, anc, selection, ancilla, sl + 1, l, m, l_iter, r_iter)
     ops.append(cirq.CNOT(control, anc))
-    yield from _unary_iteration_segtree(ops, anc, selection, sl + 1, m, r, l_iter, r_iter, qm)
+    yield from _unary_iteration_segtree(ops, anc, selection, ancilla, sl + 1, m, r, l_iter, r_iter)
     ops.append(and_gate.And(adjoint=True).on(control, sq, anc))
-    qm.qfree([anc])
 
 
 def _unary_iteration_zero_control(
     ops: List[cirq.Operation],
     selection: Sequence[cirq.Qid],
+    ancilla: Sequence[cirq.Qid],
     l_iter: int,
     r_iter: int,
-    qm: cirq.QubitManager,
 ) -> Iterator[Tuple[cirq.OP_TREE, cirq.Qid, int]]:
     sl, l, r = 0, 0, 2 ** len(selection)
     m = (l + r) >> 1
     ops.append(cirq.X(selection[0]))
     yield from _unary_iteration_segtree(
-        ops, selection[0], selection[1:], sl, l, m, l_iter, r_iter, qm
+        ops, selection[0], selection[1:], ancilla, sl, l, m, l_iter, r_iter
     )
     ops.append(cirq.X(selection[0]))
     yield from _unary_iteration_segtree(
-        ops, selection[0], selection[1:], sl, m, r, l_iter, r_iter, qm
+        ops, selection[0], selection[1:], ancilla, sl, m, r, l_iter, r_iter
     )
 
 
 def _unary_iteration_single_control(
     ops: List[cirq.Operation],
     control: cirq.Qid,
     selection: Sequence[cirq.Qid],
+    ancilla: Sequence[cirq.Qid],
     l_iter: int,
     r_iter: int,
-    qm: cirq.QubitManager,
 ) -> Iterator[Tuple[cirq.OP_TREE, cirq.Qid, int]]:
     sl, l, r = 0, 0, 2 ** len(selection)
-    yield from _unary_iteration_segtree(ops, control, selection, sl, l, r, l_iter, r_iter, qm)
+    yield from _unary_iteration_segtree(ops, control, selection, ancilla, sl, l, r, l_iter, r_iter)
 
 
 def _unary_iteration_multi_controls(
     ops: List[cirq.Operation],
     controls: Sequence[cirq.Qid],
     selection: Sequence[cirq.Qid],
+    ancilla: Sequence[cirq.Qid],
     l_iter: int,
     r_iter: int,
-    qm: cirq.QubitManager,
 ) -> Iterator[Tuple[cirq.OP_TREE, cirq.Qid, int]]:
     num_controls = len(controls)
-    and_ancilla = qm.qalloc(num_controls - 2)
-    and_target = qm.qalloc(1)[0]
+    and_ancilla = ancilla[: num_controls - 2]
+    and_target = ancilla[num_controls - 2]
     multi_controlled_and = and_gate.And((1,) * len(controls)).on_registers(
         control=np.array(controls), ancilla=np.array(and_ancilla), target=and_target
     )
     ops.append(multi_controlled_and)
-    yield from _unary_iteration_single_control(ops, and_target, selection, l_iter, r_iter, qm)
+    yield from _unary_iteration_single_control(
+        ops, and_target, selection, ancilla[num_controls - 1 :], l_iter, r_iter
+    )
     ops.append(cirq.inverse(multi_controlled_and))
-    qm.qfree(and_ancilla + [and_target])
 
 
 def unary_iteration(
     l_iter: int,
     r_iter: int,
     flanking_ops: List[cirq.Operation],
     controls: Sequence[cirq.Qid],
@@ -199,26 +201,26 @@
         - cirq.OP_TREE: The op-tree to be inserted in the circuit to get to the current leaf.
         - cirq.Qid: Control qubit used to conditionally apply operations on the target conditioned
             on the returned integer.
         - int: The current integer in the iteration `range(l_iter, r_iter)`.
     """
     assert 2 ** len(selection) >= r_iter - l_iter
     assert len(selection) > 0
+    ancilla = qubit_manager.qalloc(max(0, len(controls) + len(selection) - 1))
     if len(controls) == 0:
-        yield from _unary_iteration_zero_control(
-            flanking_ops, selection, l_iter, r_iter, qubit_manager
-        )
+        yield from _unary_iteration_zero_control(flanking_ops, selection, ancilla, l_iter, r_iter)
     elif len(controls) == 1:
         yield from _unary_iteration_single_control(
-            flanking_ops, controls[0], selection, l_iter, r_iter, qubit_manager
+            flanking_ops, controls[0], selection, ancilla, l_iter, r_iter
         )
     else:
         yield from _unary_iteration_multi_controls(
-            flanking_ops, controls, selection, l_iter, r_iter, qubit_manager
+            flanking_ops, controls, selection, ancilla, l_iter, r_iter
         )
+    qubit_manager.qfree(ancilla)
 
 
 class UnaryIterationGate(infra.GateWithRegisters):
     """Base class for defining multiplexed gates that can execute a coherent for-loop.
 
     Unary iteration is a coherent for loop that can be used to conditionally perform a different
     operation on a target register for every integer in the `range(l_iter, r_iter)` stored in the
```

## Comparing `cirq_ft-1.2.0.dev20230717204825.dist-info/LICENSE` & `cirq_ft-1.2.0.dev20230717225858.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `cirq_ft-1.2.0.dev20230717204825.dist-info/METADATA` & `cirq_ft-1.2.0.dev20230717225858.dist-info/METADATA`

 * *Files 11% similar despite different names*

```diff
@@ -1,24 +1,24 @@
 Metadata-Version: 2.1
 Name: cirq-ft
-Version: 1.2.0.dev20230717204825
+Version: 1.2.0.dev20230717225858
 Summary: A Cirq package for fault-tolerant algorithms
 Home-page: http://github.com/quantumlib/cirq
 Author: The Cirq Developers
 Author-email: cirq-dev@googlegroups.com
 License: Apache 2
 Platform: UNKNOWN
 Requires-Python: >=3.9.0
 License-File: LICENSE
 Requires-Dist: attrs
 Requires-Dist: cachetools (>=5.3)
 Requires-Dist: ipywidgets
 Requires-Dist: nbconvert
 Requires-Dist: nbformat
-Requires-Dist: cirq-core (==1.2.0.dev20230717204825)
+Requires-Dist: cirq-core (==1.2.0.dev20230717225858)
 
 **This is a development version of Cirq-ft and may be unstable.**
 
 **For the latest stable release of Cirq-ft see**
 `here <https://pypi.org/project/cirq-ft>`__.
 
 .. image:: https://raw.githubusercontent.com/quantumlib/Cirq/master/docs/images/Cirq_logo_color.png
```

## Comparing `cirq_ft-1.2.0.dev20230717204825.dist-info/RECORD` & `cirq_ft-1.2.0.dev20230717225858.dist-info/RECORD`

 * *Files 3% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 cirq_ft/__init__.py,sha256=kjDotbiwECFjkQxV_PWQ25epHm-K3SHzVbHV9zONJbs,1546
-cirq_ft/_version.py,sha256=wzqWAuuEJhp5Th1SOsiavWXmsZr7z-QoNMrgpC_ke1Q,40
+cirq_ft/_version.py,sha256=2R1Zokq84xEwOdA9gt5xaTQiq2HzEUUayZo5qjU_G7w,40
 cirq_ft/algos/__init__.py,sha256=zwN5_e9ZvanHMI8IMVMu1Yr44vlgWMZ0O1xMjGSwZic,1978
 cirq_ft/algos/and_gate.py,sha256=wpQsKwkDLrC9px7VlXLkQeTqcFDJlaOlux9WcmAbTJ0,6416
 cirq_ft/algos/and_gate_test.py,sha256=mBUk6eizWW-im6CFDd54ucA7InrxqxM_mptxb242rQM,9436
 cirq_ft/algos/apply_gate_to_lth_target.py,sha256=P_QTiWNt-ozdfuuAnFn24ashb6WLc50I12gv3-gQHEw,3938
 cirq_ft/algos/apply_gate_to_lth_target_test.py,sha256=u0aiZ8EAWWnyeB0XkpTvhClH3g9AG09U0qePPTN27lc,4100
 cirq_ft/algos/arithmetic_gates.py,sha256=xWm6EmudUppK7DDA8_wxHDPWY_jS7e9T8g9SHbRIoo0,27215
 cirq_ft/algos/arithmetic_gates_test.py,sha256=7XTDzxzc5Eqid7nv1Q9FOMjehvTddapWmgS1_JS65wM,17717
@@ -23,20 +23,20 @@
 cirq_ft/algos/qubitization_walk_operator_test.py,sha256=LXpoWMQCV36UdKvBoqxnUtfvzybEY2KFDQ--aJY59lY,13620
 cirq_ft/algos/reflection_using_prepare.py,sha256=LlZgHgTulrwearlWVbstuy8E9OCsCNluElaoVLoUF2Q,5476
 cirq_ft/algos/reflection_using_prepare_test.py,sha256=vpV9v4FZExbozpmCD5Nb8dJPbaec-gHCI6dNbzKSlI8,14779
 cirq_ft/algos/select_and_prepare.py,sha256=oULWEZewbNzEyKWuQf139CC71GrxMkXBRoct8wkVyUM,2827
 cirq_ft/algos/select_swap_qrom.py,sha256=D17JOQA3QN_BGb_Kq5DprtLUMa9mrYN5BNFjtLV3NUg,10999
 cirq_ft/algos/select_swap_qrom_test.py,sha256=DiGxbRrk6LajqJaavOZ-CyRQ-JT4hkNpHOX99zsTaHA,3976
 cirq_ft/algos/selected_majorana_fermion.py,sha256=tfWLOIi2ZXxo9upnk3T2l9-JHNhCAzJy3lYQ1cl3goQ,4485
-cirq_ft/algos/selected_majorana_fermion_test.py,sha256=jJDhl-AfHzXdA2e832CiBN1Ul9CU51Dn39FgtbmZT-0,7642
+cirq_ft/algos/selected_majorana_fermion_test.py,sha256=BYNiaOXzkNSokUStg4GwwMTSi7XtaM5mgZxDI9jFPes,7532
 cirq_ft/algos/state_preparation.py,sha256=wBEPgKUCyFWxrevtCBxQYBJRaClvJMwgPZNnnxOYT-o,6972
-cirq_ft/algos/state_preparation_test.py,sha256=pIg1kmS5Qk9lOxaCAX4QSlCvLbtLtWgSsy72glHqh-c,6673
+cirq_ft/algos/state_preparation_test.py,sha256=-Xltfhbonzl_LE-ZM5T5COM4JkCNUe_eFvTswmqFJOQ,5150
 cirq_ft/algos/swap_network.py,sha256=Ba8htymofq8qNHntyugIV0Cw792ZFwr93L4vvQi_qAE,8789
 cirq_ft/algos/swap_network_test.py,sha256=YAboSWT25xNOH6bY_SxREMCoWgm2y4siMBgQ3sioThU,6463
-cirq_ft/algos/unary_iteration_gate.py,sha256=zM21z8gFnQZ24-023T8AsK5DVEkWh7zIvvUMovY-bgQ,17538
+cirq_ft/algos/unary_iteration_gate.py,sha256=2o0SR3fTF1ssof7m9OPUSOXdhGLT4KqRlFzGhEdo0uI,17768
 cirq_ft/algos/unary_iteration_gate_test.py,sha256=_C6fgdkd7Ea1IWJiRFYrLLtZCcB6WfFINo8idOKG3-E,8091
 cirq_ft/algos/mean_estimation/__init__.py,sha256=s2u-R5oVBxxktlcIilJ9Tf487EeqlcDYCUB4yENPhBY,849
 cirq_ft/algos/mean_estimation/arctan.py,sha256=Aegt_hvHoaIGnGEAzGU93_6HXKj7yUlGdKx6-sowSGg,2263
 cirq_ft/algos/mean_estimation/arctan_test.py,sha256=aa1wvtjeEu4GM-5Na_IDn21JfPTwCWltwVLrvuFe-Dk,1875
 cirq_ft/algos/mean_estimation/complex_phase_oracle.py,sha256=yNx5qtci7uaG9-ae2f-YohATCeIUEgbblYfYdSDQ1CQ,3286
 cirq_ft/algos/mean_estimation/complex_phase_oracle_test.py,sha256=dJAYPf-toeZY-M6Fui_mxuOAoVFxuyzzeKEWhsP7z4c,3388
 cirq_ft/algos/mean_estimation/mean_estimation_operator.py,sha256=x8QLOhKHH0UcOLVFYj4Xnpnh_e8JlphC0B_02jum8Sc,7163
@@ -59,12 +59,12 @@
 cirq_ft/infra/testing.py,sha256=gMcLzR-ww4rbYJYYoJrVmC96m_l0gpVZtjuDySE5cIk,5305
 cirq_ft/infra/testing_test.py,sha256=NgIj_S5L1BOYE8hkv3WZEcAFb7CQzSEkaPIRdU-jjoo,2800
 cirq_ft/infra/type_convertors.py,sha256=XtGCyGVkWi-iZQhIxz-CqxnHugwo2Sl_0b_a3Qglz0s,809
 cirq_ft/infra/type_convertors_test.py,sha256=FHny6Ubxbla8LRBJg2RsuEMgofRjqF82C6yMHhvLGbk,772
 cirq_ft/linalg/__init__.py,sha256=T67aZHhaDq9hZ8SwhPMDLVq-VzzOxKeqOb0m3Ofkle4,673
 cirq_ft/linalg/lcu_util.py,sha256=2RJ6SBifVXN6aJMfXqb98Ec5_8fRWWNmjn93P_bvdNc,8140
 cirq_ft/linalg/lcu_util_test.py,sha256=FejxO4ajd0t1t3TO7o677NDGjjuac3yD4uLFgVuCt14,6420
-cirq_ft-1.2.0.dev20230717204825.dist-info/LICENSE,sha256=tAkwu8-AdEyGxGoSvJ2gVmQdcicWw3j1ZZueVV74M-E,11357
-cirq_ft-1.2.0.dev20230717204825.dist-info/METADATA,sha256=dleUGjcFc7CpsPev37IYnKuDPpRY7puaQj_8WaIquIg,1509
-cirq_ft-1.2.0.dev20230717204825.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-cirq_ft-1.2.0.dev20230717204825.dist-info/top_level.txt,sha256=H8KJHkgeicc6P99pLIx51PGnLymjmgmVoKeeGGZxP_M,8
-cirq_ft-1.2.0.dev20230717204825.dist-info/RECORD,,
+cirq_ft-1.2.0.dev20230717225858.dist-info/LICENSE,sha256=tAkwu8-AdEyGxGoSvJ2gVmQdcicWw3j1ZZueVV74M-E,11357
+cirq_ft-1.2.0.dev20230717225858.dist-info/METADATA,sha256=mlAmk7n5M8Nf4VZxtl7FIZxYGCGy0bcOIMz8gaigtc4,1509
+cirq_ft-1.2.0.dev20230717225858.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+cirq_ft-1.2.0.dev20230717225858.dist-info/top_level.txt,sha256=H8KJHkgeicc6P99pLIx51PGnLymjmgmVoKeeGGZxP_M,8
+cirq_ft-1.2.0.dev20230717225858.dist-info/RECORD,,
```

